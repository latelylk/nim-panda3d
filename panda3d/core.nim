
when defined(pandaDir):
  const pandaDir {.strdefine.}: string = ""
  when len(pandaDir) < 1:
    {.error: "pandaDir must not be an empty string when defined".}

when defined(vcc):
  {.passC: "/DNOMINMAX".}

  when defined(pandaDir):
    {.passC: "/I\"" & pandaDir & "/include\"".}
    {.passL: "\"" & pandaDir & "/lib/libpandaexpress.lib\"".}
    {.passL: "\"" & pandaDir & "/lib/libpanda.lib\"".}
    {.passL: "\"" & pandaDir & "/lib/libp3dtoolconfig.lib\"".}
    {.passL: "\"" & pandaDir & "/lib/libp3dtool.lib\"".}
  else:
    {.passL: "libpandaexpress.lib libpanda.lib libp3dtoolconfig.lib libp3dtool.lib".}

else:
  {.passL: "-lpandaexpress -lpanda -lp3dtoolconfig -lp3dtool".}

const stringConversionCode = """
#include <string>

N_LIB_PRIVATE N_NIMCALL(std::string, nimStringToStdString)(struct NimStringDesc *desc);
N_LIB_PRIVATE N_NIMCALL(struct NimStringDesc*, nimStringFromStdString)(const std::string &s);
""";

type
  std_string {.importcpp: "std::string", header: "string".} = object

type
  std_string_const_ref {.importcpp: "std::string const&", header: "string".} = object

func size(this: std_string_const_ref): int {.importcpp: "size".}

func nimStringFromStdString(s: std_string_const_ref): string {.noinit, exportcpp: "nimStringFromStdString"} =
  result = newString(s.size())
  {.emit: "memcpy(result->data, s.data(), s.size());"}

func nimStringToStdString(desc: string): std_string {.noinit, exportcpp: "nimStringToStdString"} =
  {.emit: "result = std::string(desc->data, desc->len);"}

type
  NeverFreeMemory* {.importcpp: "NeverFreeMemory", pure, inheritable, header: "neverFreeMemory.h".} = object

type
  TypeHandle* {.importcpp: "TypeHandle", pure, header: "typeHandle.h".} = object

type
  TypeRegistry* {.importcpp: "TypeRegistry", pure, inheritable, header: "typeRegistry.h".} = object

type
  TypedObject* {.importcpp: "TypedObject*", bycopy, pure, inheritable, header: "typedObject.h".} = object

converter toTypedObject*(_: type(nil)): TypedObject {.importcpp: "(nullptr)".}
converter toBool*(this: TypedObject): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TypedObject, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TypedObject], obj: TypedObject): TypedObject {.importcpp: "(@)".}

type
  ios_base* {.importcpp: "ios_base", pure, inheritable, header: "ios_base.h".} = object

type
  istream* {.importcpp: "istream", pure, inheritable, header: "istream.h".} = object

type
  ostream* {.importcpp: "ostream", pure, inheritable, header: "ostream.h".} = object

type
  iostream* {.importcpp: "iostream", pure, inheritable, header: "iostream.h".} = object of istream

type
  fstream* {.importcpp: "fstream", pure, inheritable, header: "fstream.h".} = object of iostream

type
  ifstream* {.importcpp: "ifstream", pure, inheritable, header: "ifstream.h".} = object of istream

type
  ofstream* {.importcpp: "ofstream", pure, inheritable, header: "ofstream.h".} = object of ostream

type
  IFileStream* {.importcpp: "IFileStream", pure, inheritable, header: "iFileStream.h".} = object of istream

type
  OFileStream* {.importcpp: "OFileStream", pure, inheritable, header: "oFileStream.h".} = object of ostream

type
  FileStream* {.importcpp: "FileStream", pure, inheritable, header: "fileStream.h".} = object of iostream

type
  pifstream* = IFileStream

type
  pofstream* = OFileStream

type
  pfstream* = FileStream

type
  TextEncoder* {.importcpp: "TextEncoder", pure, inheritable, header: "textEncoder.h".} = object

type
  Filename* {.importcpp: "Filename", pure, inheritable, header: "filename.h".} = object

type
  PandaSystem* {.importcpp: "PandaSystem", pure, inheritable, header: "pandaSystem.h".} = object

type
  DSearchPath* {.importcpp: "DSearchPath", pure, inheritable, header: "dSearchPath.h".} = object

type
  ExecutionEnvironment* {.importcpp: "ExecutionEnvironment", pure, inheritable, header: "executionEnvironment.h".} = object

type
  GlobPattern* {.importcpp: "GlobPattern", pure, inheritable, header: "globPattern.h".} = object

type
  LineStream* {.importcpp: "LineStream", pure, inheritable, header: "lineStream.h".} = object of ostream

type
  ConfigFlags* {.importcpp: "ConfigFlags", pure, inheritable, header: "configFlags.h".} = object

type
  ConfigPage* {.importcpp: "ConfigPage", pure, inheritable, header: "configPage.h".} = object

type
  ConfigDeclaration* {.importcpp: "ConfigDeclaration", pure, inheritable, header: "configDeclaration.h".} = object of ConfigFlags

type
  ConfigVariableCore* {.importcpp: "ConfigVariableCore", pure, inheritable, header: "configVariableCore.h".} = object of ConfigFlags

type
  NotifySeverity* = enum
    NS_unspecified = 0
    NS_spam = 1
    NS_debug = 2
    NS_info = 3
    NS_warning = 4
    NS_error = 5
    NS_fatal = 6

type
  Notify* {.importcpp: "Notify", pure, inheritable, header: "notify.h".} = object

type
  ConfigPageManager* {.importcpp: "ConfigPageManager", pure, inheritable, header: "configPageManager.h".} = object of ConfigFlags

type
  ConfigVariableManager* {.importcpp: "ConfigVariableManager", pure, inheritable, header: "configVariableManager.h".} = object

type
  ConfigVariableBase* {.importcpp: "ConfigVariableBase", pure, inheritable, header: "configVariableBase.h".} = object of ConfigFlags

type
  ConfigVariable* {.importcpp: "ConfigVariable", pure, inheritable, header: "configVariable.h".} = object of ConfigVariableBase

type
  ConfigVariableBool* {.importcpp: "ConfigVariableBool", pure, inheritable, header: "configVariableBool.h".} = object of ConfigVariable

type
  ConfigVariableDouble* {.importcpp: "ConfigVariableDouble", pure, inheritable, header: "configVariableDouble.h".} = object of ConfigVariable

type
  ConfigVariableFilename* {.importcpp: "ConfigVariableFilename", pure, inheritable, header: "configVariableFilename.h".} = object of ConfigVariable

type
  ConfigVariableInt* {.importcpp: "ConfigVariableInt", pure, inheritable, header: "configVariableInt.h".} = object of ConfigVariable

type
  ConfigVariableInt64* {.importcpp: "ConfigVariableInt64", pure, inheritable, header: "configVariableInt64.h".} = object of ConfigVariable

type
  ConfigVariableList* {.importcpp: "ConfigVariableList", pure, inheritable, header: "configVariableList.h".} = object of ConfigVariableBase

type
  ConfigVariableSearchPath* {.importcpp: "ConfigVariableSearchPath", pure, inheritable, header: "configVariableSearchPath.h".} = object of ConfigVariableBase

type
  ConfigVariableString* {.importcpp: "ConfigVariableString", pure, inheritable, header: "configVariableString.h".} = object of ConfigVariable

type
  NotifyCategory* {.importcpp: "NotifyCategory", pure, inheritable, header: "notifyCategory.h".} = object of ConfigFlags

type
  IDecryptStream* {.importcpp: "IDecryptStream", pure, inheritable, header: "iDecryptStream.h".} = object of istream

type
  OEncryptStream* {.importcpp: "OEncryptStream", pure, inheritable, header: "oEncryptStream.h".} = object of ostream

type
  StreamReader* {.importcpp: "StreamReader", pure, inheritable, header: "streamReader.h".} = object

type
  StreamWriter* {.importcpp: "StreamWriter", pure, inheritable, header: "streamWriter.h".} = object

type
  StreamWrapperBase* {.importcpp: "StreamWrapperBase", pure, inheritable, header: "streamWrapperBase.h".} = object

type
  IStreamWrapper* {.importcpp: "IStreamWrapper", pure, inheritable, header: "iStreamWrapper.h".} = object of StreamWrapperBase

type
  OStreamWrapper* {.importcpp: "OStreamWrapper", pure, inheritable, header: "oStreamWrapper.h".} = object of StreamWrapperBase

type
  StreamWrapper* {.importcpp: "StreamWrapper", pure, inheritable, header: "streamWrapper.h".} = object of IStreamWrapper

type
  SSReader* {.importcpp: "SSReader", pure, inheritable, header: "sSReader.h".} = object

type
  SSWriter* {.importcpp: "SSWriter", pure, inheritable, header: "sSWriter.h".} = object

type
  ISocketStream* {.importcpp: "ISocketStream", pure, inheritable, header: "iSocketStream.h".} = object of istream

type
  OSocketStream* {.importcpp: "OSocketStream", pure, inheritable, header: "oSocketStream.h".} = object of ostream

type
  SocketStream* {.importcpp: "SocketStream", pure, inheritable, header: "socketStream.h".} = object of iostream

type
  URLSpec* {.importcpp: "URLSpec", pure, inheritable, header: "uRLSpec.h".} = object

type
  HTTPEnum* {.importcpp: "HTTPEnum", pure, inheritable, header: "hTTPEnum.h".} = object

type
  HTTPDate* {.importcpp: "HTTPDate", pure, inheritable, header: "hTTPDate.h".} = object

type
  HTTPCookie* {.importcpp: "HTTPCookie", pure, inheritable, header: "hTTPCookie.h".} = object

type
  ReferenceCount* {.importcpp: "PT(ReferenceCount)", bycopy, pure, inheritable, header: "referenceCount.h".} = object

converter toReferenceCount*(_: type(nil)): ReferenceCount {.importcpp: "(nullptr)".}
converter toBool*(this: ReferenceCount): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ReferenceCount, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type
  HTTPClient* {.importcpp: "PT(HTTPClient)", bycopy, pure, inheritable, header: "hTTPClient.h".} = object of ReferenceCount

converter toHTTPClient*(_: type(nil)): HTTPClient {.importcpp: "(nullptr)".}
converter toBool*(this: HTTPClient): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: HTTPClient, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[HTTPClient], obj: TypedObject): HTTPClient {.importcpp: "DCAST(HTTPClient, @)".}

type
  HTTPEntityTag* {.importcpp: "HTTPEntityTag", pure, inheritable, header: "hTTPEntityTag.h".} = object

type
  DocumentSpec* {.importcpp: "DocumentSpec", pure, inheritable, header: "documentSpec.h".} = object

type
  TypedReferenceCount* {.importcpp: "PT(TypedReferenceCount)", bycopy, pure, inheritable, header: "typedReferenceCount.h".} = object of TypedObject

converter toTypedReferenceCount*(_: type(nil)): TypedReferenceCount {.importcpp: "(nullptr)".}
converter toBool*(this: TypedReferenceCount): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TypedReferenceCount, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TypedReferenceCount], obj: TypedObject): TypedReferenceCount {.importcpp: "DCAST(TypedReferenceCount, @)".}

type
  HTTPChannel* {.importcpp: "PT(HTTPChannel)", bycopy, pure, inheritable, header: "hTTPChannel.h".} = object of TypedReferenceCount

converter toHTTPChannel*(_: type(nil)): HTTPChannel {.importcpp: "(nullptr)".}
converter toBool*(this: HTTPChannel): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: HTTPChannel, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[HTTPChannel], obj: TypedObject): HTTPChannel {.importcpp: "DCAST(HTTPChannel, @)".}

type
  Decompressor* {.importcpp: "Decompressor", pure, inheritable, header: "decompressor.h".} = object

type
  DownloadDb* {.importcpp: "DownloadDb", pure, inheritable, header: "downloadDb.h".} = object

type
  Extractor* {.importcpp: "Extractor", pure, inheritable, header: "extractor.h".} = object

type
  MultiplexStream* {.importcpp: "MultiplexStream", pure, inheritable, header: "multiplexStream.h".} = object of ostream

type
  VirtualFile* {.importcpp: "PT(VirtualFile)", bycopy, pure, inheritable, header: "virtualFile.h".} = object of TypedReferenceCount

converter toVirtualFile*(_: type(nil)): VirtualFile {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFile): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFile, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFile], obj: TypedObject): VirtualFile {.importcpp: "DCAST(VirtualFile, @)".}

type
  VirtualFileHTTP* {.importcpp: "PT(VirtualFileHTTP)", bycopy, pure, inheritable, header: "virtualFileHTTP.h".} = object of VirtualFile

converter toVirtualFileHTTP*(_: type(nil)): VirtualFileHTTP {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFileHTTP): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFileHTTP, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFileHTTP], obj: TypedObject): VirtualFileHTTP {.importcpp: "DCAST(VirtualFileHTTP, @)".}

type
  VirtualFileMount* {.importcpp: "PT(VirtualFileMount)", bycopy, pure, inheritable, header: "virtualFileMount.h".} = object of TypedReferenceCount

converter toVirtualFileMount*(_: type(nil)): VirtualFileMount {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFileMount): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFileMount, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFileMount], obj: TypedObject): VirtualFileMount {.importcpp: "DCAST(VirtualFileMount, @)".}

type
  VirtualFileMountHTTP* {.importcpp: "PT(VirtualFileMountHTTP)", bycopy, pure, inheritable, header: "virtualFileMountHTTP.h".} = object of VirtualFileMount

converter toVirtualFileMountHTTP*(_: type(nil)): VirtualFileMountHTTP {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFileMountHTTP): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFileMountHTTP, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFileMountHTTP], obj: TypedObject): VirtualFileMountHTTP {.importcpp: "DCAST(VirtualFileMountHTTP, @)".}

type
  Patcher* {.importcpp: "Patcher", pure, inheritable, header: "patcher.h".} = object

type
  StringStream* {.importcpp: "StringStream", pure, inheritable, header: "stringStream.h".} = object of iostream

type
  PointerToVoid* {.importcpp: "PointerToVoid", pure, inheritable, header: "pointerToVoid.h".} = object

type
  MemoryUsage* {.importcpp: "MemoryUsage", pure, inheritable, header: "memoryUsage.h".} = object

type
  Buffer* {.importcpp: "PT(Buffer)", bycopy, pure, inheritable, header: "buffer.h".} = object of ReferenceCount

converter toBuffer*(_: type(nil)): Buffer {.importcpp: "(nullptr)".}
converter toBool*(this: Buffer): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Buffer, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Buffer], obj: TypedObject): Buffer {.importcpp: "DCAST(Buffer, @)".}

type
  PStatCollectorForwardBase* {.importcpp: "PT(PStatCollectorForwardBase)", bycopy, pure, inheritable, header: "pStatCollectorForwardBase.h".} = object of ReferenceCount

converter toPStatCollectorForwardBase*(_: type(nil)): PStatCollectorForwardBase {.importcpp: "(nullptr)".}
converter toBool*(this: PStatCollectorForwardBase): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PStatCollectorForwardBase, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PStatCollectorForwardBase], obj: TypedObject): PStatCollectorForwardBase {.importcpp: "DCAST(PStatCollectorForwardBase, @)".}

type
  NodeReferenceCount* {.importcpp: "PT(NodeReferenceCount)", bycopy, pure, inheritable, header: "nodeReferenceCount.h".} = object of ReferenceCount

converter toNodeReferenceCount*(_: type(nil)): NodeReferenceCount {.importcpp: "(nullptr)".}
converter toBool*(this: NodeReferenceCount): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: NodeReferenceCount, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[NodeReferenceCount], obj: TypedObject): NodeReferenceCount {.importcpp: "DCAST(NodeReferenceCount, @)".}

type
  Datagram* {.importcpp: "Datagram", pure, inheritable, header: "datagram.h".} = object of TypedObject

type
  DatagramGenerator* {.importcpp: "DatagramGenerator", pure, inheritable, header: "datagramGenerator.h".} = object

type
  DatagramIterator* {.importcpp: "DatagramIterator", pure, inheritable, header: "datagramIterator.h".} = object

type
  DatagramSink* {.importcpp: "DatagramSink", pure, inheritable, header: "datagramSink.h".} = object

type
  FileReference* {.importcpp: "PT(FileReference)", bycopy, pure, inheritable, header: "fileReference.h".} = object of TypedReferenceCount

converter toFileReference*(_: type(nil)): FileReference {.importcpp: "(nullptr)".}
converter toBool*(this: FileReference): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: FileReference, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[FileReference], obj: TypedObject): FileReference {.importcpp: "DCAST(FileReference, @)".}

type
  ErrorUtilCode* = enum
    EU_error_zlib = -80
    EU_error_http_proxy_authentication = -73
    EU_error_http_service_unavailable = -72
    EU_error_http_gateway_timeout = -71
    EU_error_http_server_timeout = -70
    EU_error_write_file_rename = -67
    EU_error_write_disk_fault = -66
    EU_error_write_disk_sector_not_found = -65
    EU_error_write_disk_not_found = -64
    EU_error_write_disk_full = -63
    EU_error_write_sharing_violation = -62
    EU_error_write_out_of_memory = -61
    EU_error_write_out_of_files = -60
    EU_error_network_remote_host_no_response = -54
    EU_error_network_remote_host_not_found = -53
    EU_error_network_remote_host_unreachable = -52
    EU_error_network_remote_host_down = -51
    EU_error_network_remote_host_disconnected = -50
    EU_error_network_disk_quota_exceeded = -42
    EU_error_network_buffer_overflow = -41
    EU_error_network_disconnected_locally = -40
    EU_error_network_no_data = -34
    EU_error_network_timeout = -33
    EU_error_network_disconnected = -32
    EU_error_network_unreachable = -31
    EU_error_network_dead = -30
    EU_error_invalid_checksum = -4
    EU_error_file_invalid = -3
    EU_error_file_empty = -2
    EU_error_abort = -1
    EU_success = 1
    EU_ok = 2
    EU_write = 3
    EU_write_ram = 4
    EU_network_no_data = 5
    EU_eof = 6
    EU_http_redirect = 7

type
  Ramfile* {.importcpp: "Ramfile", pure, inheritable, header: "ramfile.h".} = object

type
  HashVal* {.importcpp: "HashVal", pure, inheritable, header: "hashVal.h".} = object

type
  MemoryUsagePointers* {.importcpp: "MemoryUsagePointers", pure, inheritable, header: "memoryUsagePointers.h".} = object

type
  ISubStream* {.importcpp: "ISubStream", pure, inheritable, header: "iSubStream.h".} = object of istream

type
  OSubStream* {.importcpp: "OSubStream", pure, inheritable, header: "oSubStream.h".} = object of ostream

type
  SubStream* {.importcpp: "SubStream", pure, inheritable, header: "subStream.h".} = object of iostream

type
  Multifile* {.importcpp: "PT(Multifile)", bycopy, pure, inheritable, header: "multifile.h".} = object of ReferenceCount

converter toMultifile*(_: type(nil)): Multifile {.importcpp: "(nullptr)".}
converter toBool*(this: Multifile): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Multifile, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Multifile], obj: TypedObject): Multifile {.importcpp: "DCAST(Multifile, @)".}

type
  Namable* {.importcpp: "Namable", pure, inheritable, header: "namable.h".} = object

type
  OpenSSLWrapper* {.importcpp: "OpenSSLWrapper", pure, inheritable, header: "openSSLWrapper.h".} = object

type
  SubfileInfo* {.importcpp: "SubfileInfo", pure, inheritable, header: "subfileInfo.h".} = object

type
  VirtualFileComposite* {.importcpp: "PT(VirtualFileComposite)", bycopy, pure, inheritable, header: "virtualFileComposite.h".} = object of VirtualFile

converter toVirtualFileComposite*(_: type(nil)): VirtualFileComposite {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFileComposite): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFileComposite, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFileComposite], obj: TypedObject): VirtualFileComposite {.importcpp: "DCAST(VirtualFileComposite, @)".}

type
  VirtualFileMountMultifile* {.importcpp: "PT(VirtualFileMountMultifile)", bycopy, pure, inheritable, header: "virtualFileMountMultifile.h".} = object of VirtualFileMount

converter toVirtualFileMountMultifile*(_: type(nil)): VirtualFileMountMultifile {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFileMountMultifile): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFileMountMultifile, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFileMountMultifile], obj: TypedObject): VirtualFileMountMultifile {.importcpp: "DCAST(VirtualFileMountMultifile, @)".}

type
  VirtualFileMountRamdisk* {.importcpp: "PT(VirtualFileMountRamdisk)", bycopy, pure, inheritable, header: "virtualFileMountRamdisk.h".} = object of VirtualFileMount

converter toVirtualFileMountRamdisk*(_: type(nil)): VirtualFileMountRamdisk {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFileMountRamdisk): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFileMountRamdisk, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFileMountRamdisk], obj: TypedObject): VirtualFileMountRamdisk {.importcpp: "DCAST(VirtualFileMountRamdisk, @)".}

type
  VirtualFileMountSystem* {.importcpp: "PT(VirtualFileMountSystem)", bycopy, pure, inheritable, header: "virtualFileMountSystem.h".} = object of VirtualFileMount

converter toVirtualFileMountSystem*(_: type(nil)): VirtualFileMountSystem {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFileMountSystem): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFileMountSystem, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFileMountSystem], obj: TypedObject): VirtualFileMountSystem {.importcpp: "DCAST(VirtualFileMountSystem, @)".}

type
  VirtualFileSimple* {.importcpp: "PT(VirtualFileSimple)", bycopy, pure, inheritable, header: "virtualFileSimple.h".} = object of VirtualFile

converter toVirtualFileSimple*(_: type(nil)): VirtualFileSimple {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFileSimple): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFileSimple, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFileSimple], obj: TypedObject): VirtualFileSimple {.importcpp: "DCAST(VirtualFileSimple, @)".}

type
  TemporaryFile* {.importcpp: "PT(TemporaryFile)", bycopy, pure, inheritable, header: "temporaryFile.h".} = object of FileReference

converter toTemporaryFile*(_: type(nil)): TemporaryFile {.importcpp: "(nullptr)".}
converter toBool*(this: TemporaryFile): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TemporaryFile, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TemporaryFile], obj: TypedObject): TemporaryFile {.importcpp: "DCAST(TemporaryFile, @)".}

type
  IDecompressStream* {.importcpp: "IDecompressStream", pure, inheritable, header: "iDecompressStream.h".} = object of istream

type
  OCompressStream* {.importcpp: "OCompressStream", pure, inheritable, header: "oCompressStream.h".} = object of ostream

type
  VirtualFileList* {.importcpp: "PT(VirtualFileList)", bycopy, pure, inheritable, header: "virtualFileList.h".} = object of ReferenceCount

converter toVirtualFileList*(_: type(nil)): VirtualFileList {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFileList): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFileList, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFileList], obj: TypedObject): VirtualFileList {.importcpp: "DCAST(VirtualFileList, @)".}

type
  VirtualFileSystem* {.importcpp: "VirtualFileSystem", pure, inheritable, header: "virtualFileSystem.h".} = object

type
  TrueClock* {.importcpp: "TrueClock", pure, inheritable, header: "trueClock.h".} = object

type
  Patchfile* {.importcpp: "Patchfile", pure, inheritable, header: "patchfile.h".} = object

type
  ProfileTimer* {.importcpp: "ProfileTimer", pure, inheritable, header: "profileTimer.h".} = object

type
  WeakPointerToVoid* {.importcpp: "WeakPointerToVoid", pure, inheritable, header: "weakPointerToVoid.h".} = object of PointerToVoid

type
  WindowsRegistry* {.importcpp: "WindowsRegistry", pure, inheritable, header: "windowsRegistry.h".} = object

type
  RecorderBase* {.importcpp: "RecorderBase", pure, inheritable, header: "recorderBase.h".} = object

type
  TypedWritable* {.importcpp: "TypedWritable", pure, inheritable, header: "typedWritable.h".} = object of TypedObject

type
  TypedWritableReferenceCount* {.importcpp: "PT(TypedWritableReferenceCount)", bycopy, pure, inheritable, header: "typedWritableReferenceCount.h".} = object of TypedWritable

converter toTypedWritableReferenceCount*(_: type(nil)): TypedWritableReferenceCount {.importcpp: "(nullptr)".}
converter toBool*(this: TypedWritableReferenceCount): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TypedWritableReferenceCount, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TypedWritableReferenceCount], obj: TypedObject): TypedWritableReferenceCount {.importcpp: "DCAST(TypedWritableReferenceCount, @)".}

type
  PandaNode* {.importcpp: "PT(PandaNode)", bycopy, pure, inheritable, header: "pandaNode.h".} = object of TypedWritableReferenceCount

converter toPandaNode*(_: type(nil)): PandaNode {.importcpp: "(nullptr)".}
converter toBool*(this: PandaNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PandaNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PandaNode], obj: TypedObject): PandaNode {.importcpp: "DCAST(PandaNode, @)".}

type
  DataNode* {.importcpp: "PT(DataNode)", bycopy, pure, inheritable, header: "dataNode.h".} = object of PandaNode

converter toDataNode*(_: type(nil)): DataNode {.importcpp: "(nullptr)".}
converter toBool*(this: DataNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DataNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DataNode], obj: TypedObject): DataNode {.importcpp: "DCAST(DataNode, @)".}

type
  MouseRecorder* {.importcpp: "PT(MouseRecorder)", bycopy, pure, inheritable, header: "mouseRecorder.h".} = object of DataNode

converter toMouseRecorder*(_: type(nil)): MouseRecorder {.importcpp: "(nullptr)".}
converter toBool*(this: MouseRecorder): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MouseRecorder, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MouseRecorder], obj: TypedObject): MouseRecorder {.importcpp: "DCAST(MouseRecorder, @)".}

type
  RecorderController* {.importcpp: "PT(RecorderController)", bycopy, pure, inheritable, header: "recorderController.h".} = object of TypedReferenceCount

converter toRecorderController*(_: type(nil)): RecorderController {.importcpp: "(nullptr)".}
converter toBool*(this: RecorderController): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RecorderController, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RecorderController], obj: TypedObject): RecorderController {.importcpp: "DCAST(RecorderController, @)".}

type
  SocketStreamRecorder* {.importcpp: "PT(SocketStreamRecorder)", bycopy, pure, inheritable, header: "socketStreamRecorder.h".} = object of RecorderBase

converter toSocketStreamRecorder*(_: type(nil)): SocketStreamRecorder {.importcpp: "(nullptr)".}
converter toBool*(this: SocketStreamRecorder): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SocketStreamRecorder, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[SocketStreamRecorder], obj: TypedObject): SocketStreamRecorder {.importcpp: "DCAST(SocketStreamRecorder, @)".}

type
  Light* {.importcpp: "Light", pure, inheritable, header: "light.h".} = object

type
  LightNode* {.importcpp: "PT(LightNode)", bycopy, pure, inheritable, header: "lightNode.h".} = object of Light

converter toLightNode*(_: type(nil)): LightNode {.importcpp: "(nullptr)".}
converter toBool*(this: LightNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: LightNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[LightNode], obj: TypedObject): LightNode {.importcpp: "DCAST(LightNode, @)".}

type
  AmbientLight* {.importcpp: "PT(AmbientLight)", bycopy, pure, inheritable, header: "ambientLight.h".} = object of LightNode

converter toAmbientLight*(_: type(nil)): AmbientLight {.importcpp: "(nullptr)".}
converter toBool*(this: AmbientLight): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AmbientLight, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AmbientLight], obj: TypedObject): AmbientLight {.importcpp: "DCAST(AmbientLight, @)".}

type
  CallbackNode* {.importcpp: "PT(CallbackNode)", bycopy, pure, inheritable, header: "callbackNode.h".} = object of PandaNode

converter toCallbackNode*(_: type(nil)): CallbackNode {.importcpp: "(nullptr)".}
converter toBool*(this: CallbackNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CallbackNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CallbackNode], obj: TypedObject): CallbackNode {.importcpp: "DCAST(CallbackNode, @)".}

type
  ComputeNode* {.importcpp: "PT(ComputeNode)", bycopy, pure, inheritable, header: "computeNode.h".} = object of PandaNode

converter toComputeNode*(_: type(nil)): ComputeNode {.importcpp: "(nullptr)".}
converter toBool*(this: ComputeNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ComputeNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ComputeNode], obj: TypedObject): ComputeNode {.importcpp: "DCAST(ComputeNode, @)".}

type
  LODNodeType* = enum
    LNT_pop = 0
    LNT_fade = 1

type
  LensNode* {.importcpp: "PT(LensNode)", bycopy, pure, inheritable, header: "lensNode.h".} = object of PandaNode

converter toLensNode*(_: type(nil)): LensNode {.importcpp: "(nullptr)".}
converter toBool*(this: LensNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: LensNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[LensNode], obj: TypedObject): LensNode {.importcpp: "DCAST(LensNode, @)".}

type
  Camera* {.importcpp: "PT(Camera)", bycopy, pure, inheritable, header: "camera.h".} = object of LensNode

converter toCamera*(_: type(nil)): Camera {.importcpp: "(nullptr)".}
converter toBool*(this: Camera): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Camera, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Camera], obj: TypedObject): Camera {.importcpp: "DCAST(Camera, @)".}

type
  LightLensNode* {.importcpp: "PT(LightLensNode)", bycopy, pure, inheritable, header: "lightLensNode.h".} = object of Light

converter toLightLensNode*(_: type(nil)): LightLensNode {.importcpp: "(nullptr)".}
converter toBool*(this: LightLensNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: LightLensNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[LightLensNode], obj: TypedObject): LightLensNode {.importcpp: "DCAST(LightLensNode, @)".}

type
  DirectionalLight* {.importcpp: "PT(DirectionalLight)", bycopy, pure, inheritable, header: "directionalLight.h".} = object of LightLensNode

converter toDirectionalLight*(_: type(nil)): DirectionalLight {.importcpp: "(nullptr)".}
converter toBool*(this: DirectionalLight): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DirectionalLight, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DirectionalLight], obj: TypedObject): DirectionalLight {.importcpp: "DCAST(DirectionalLight, @)".}

type
  LODNode* {.importcpp: "PT(LODNode)", bycopy, pure, inheritable, header: "lODNode.h".} = object of PandaNode

converter toLODNode*(_: type(nil)): LODNode {.importcpp: "(nullptr)".}
converter toBool*(this: LODNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: LODNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[LODNode], obj: TypedObject): LODNode {.importcpp: "DCAST(LODNode, @)".}

type
  FadeLODNode* {.importcpp: "PT(FadeLODNode)", bycopy, pure, inheritable, header: "fadeLODNode.h".} = object of LODNode

converter toFadeLODNode*(_: type(nil)): FadeLODNode {.importcpp: "(nullptr)".}
converter toBool*(this: FadeLODNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: FadeLODNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[FadeLODNode], obj: TypedObject): FadeLODNode {.importcpp: "DCAST(FadeLODNode, @)".}

type
  CallbackData* {.importcpp: "CallbackData", pure, inheritable, header: "callbackData.h".} = object of TypedObject

type
  NodeCullCallbackData* {.importcpp: "NodeCullCallbackData", pure, inheritable, header: "nodeCullCallbackData.h".} = object of CallbackData

type
  PointLight* {.importcpp: "PT(PointLight)", bycopy, pure, inheritable, header: "pointLight.h".} = object of LightLensNode

converter toPointLight*(_: type(nil)): PointLight {.importcpp: "(nullptr)".}
converter toBool*(this: PointLight): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PointLight, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PointLight], obj: TypedObject): PointLight {.importcpp: "DCAST(PointLight, @)".}

type
  RectangleLight* {.importcpp: "PT(RectangleLight)", bycopy, pure, inheritable, header: "rectangleLight.h".} = object of LightLensNode

converter toRectangleLight*(_: type(nil)): RectangleLight {.importcpp: "(nullptr)".}
converter toBool*(this: RectangleLight): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RectangleLight, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RectangleLight], obj: TypedObject): RectangleLight {.importcpp: "DCAST(RectangleLight, @)".}

type
  SelectiveChildNode* {.importcpp: "PT(SelectiveChildNode)", bycopy, pure, inheritable, header: "selectiveChildNode.h".} = object of PandaNode

converter toSelectiveChildNode*(_: type(nil)): SelectiveChildNode {.importcpp: "(nullptr)".}
converter toBool*(this: SelectiveChildNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SelectiveChildNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[SelectiveChildNode], obj: TypedObject): SelectiveChildNode {.importcpp: "DCAST(SelectiveChildNode, @)".}

type
  AnimInterface* {.importcpp: "AnimInterface*", bycopy, pure, inheritable, header: "animInterface.h".} = object

converter toAnimInterface*(_: type(nil)): AnimInterface {.importcpp: "(nullptr)".}
converter toBool*(this: AnimInterface): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimInterface, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type
  SequenceNode* {.importcpp: "PT(SequenceNode)", bycopy, pure, inheritable, header: "sequenceNode.h".} = object of SelectiveChildNode

converter toSequenceNode*(_: type(nil)): SequenceNode {.importcpp: "(nullptr)".}
converter toBool*(this: SequenceNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SequenceNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[SequenceNode], obj: TypedObject): SequenceNode {.importcpp: "DCAST(SequenceNode, @)".}

type
  ShaderGenerator* {.importcpp: "PT(ShaderGenerator)", bycopy, pure, inheritable, header: "shaderGenerator.h".} = object of TypedReferenceCount

converter toShaderGenerator*(_: type(nil)): ShaderGenerator {.importcpp: "(nullptr)".}
converter toBool*(this: ShaderGenerator): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ShaderGenerator, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ShaderGenerator], obj: TypedObject): ShaderGenerator {.importcpp: "DCAST(ShaderGenerator, @)".}

type
  SphereLight* {.importcpp: "PT(SphereLight)", bycopy, pure, inheritable, header: "sphereLight.h".} = object of PointLight

converter toSphereLight*(_: type(nil)): SphereLight {.importcpp: "(nullptr)".}
converter toBool*(this: SphereLight): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SphereLight, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[SphereLight], obj: TypedObject): SphereLight {.importcpp: "DCAST(SphereLight, @)".}

type
  Spotlight* {.importcpp: "PT(Spotlight)", bycopy, pure, inheritable, header: "spotlight.h".} = object of LightLensNode

converter toSpotlight*(_: type(nil)): Spotlight {.importcpp: "(nullptr)".}
converter toBool*(this: Spotlight): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Spotlight, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Spotlight], obj: TypedObject): Spotlight {.importcpp: "DCAST(Spotlight, @)".}

type
  SwitchNode* {.importcpp: "PT(SwitchNode)", bycopy, pure, inheritable, header: "switchNode.h".} = object of SelectiveChildNode

converter toSwitchNode*(_: type(nil)): SwitchNode {.importcpp: "(nullptr)".}
converter toBool*(this: SwitchNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SwitchNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[SwitchNode], obj: TypedObject): SwitchNode {.importcpp: "DCAST(SwitchNode, @)".}

type
  UvScrollNode* {.importcpp: "PT(UvScrollNode)", bycopy, pure, inheritable, header: "uvScrollNode.h".} = object of PandaNode

converter toUvScrollNode*(_: type(nil)): UvScrollNode {.importcpp: "(nullptr)".}
converter toBool*(this: UvScrollNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: UvScrollNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[UvScrollNode], obj: TypedObject): UvScrollNode {.importcpp: "DCAST(UvScrollNode, @)".}

type
  SceneGraphAnalyzer* {.importcpp: "SceneGraphAnalyzer", pure, inheritable, header: "sceneGraphAnalyzer.h".} = object

type
  CachedTypedWritableReferenceCount* {.importcpp: "PT(CachedTypedWritableReferenceCount)", bycopy, pure, inheritable, header: "cachedTypedWritableReferenceCount.h".} = object of TypedWritableReferenceCount

converter toCachedTypedWritableReferenceCount*(_: type(nil)): CachedTypedWritableReferenceCount {.importcpp: "(nullptr)".}
converter toBool*(this: CachedTypedWritableReferenceCount): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CachedTypedWritableReferenceCount, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CachedTypedWritableReferenceCount], obj: TypedObject): CachedTypedWritableReferenceCount {.importcpp: "DCAST(CachedTypedWritableReferenceCount, @)".}

type
  NodeCachedReferenceCount* {.importcpp: "PT(NodeCachedReferenceCount)", bycopy, pure, inheritable, header: "nodeCachedReferenceCount.h".} = object of CachedTypedWritableReferenceCount

converter toNodeCachedReferenceCount*(_: type(nil)): NodeCachedReferenceCount {.importcpp: "(nullptr)".}
converter toBool*(this: NodeCachedReferenceCount): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: NodeCachedReferenceCount, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[NodeCachedReferenceCount], obj: TypedObject): NodeCachedReferenceCount {.importcpp: "DCAST(NodeCachedReferenceCount, @)".}

type
  TransformState* {.importcpp: "PT(TransformState)", bycopy, pure, header: "transformState.h".} = object of NodeCachedReferenceCount

converter toTransformState*(_: type(nil)): TransformState {.importcpp: "(nullptr)".}
converter toBool*(this: TransformState): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TransformState, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TransformState], obj: TypedObject): TransformState {.importcpp: "DCAST(TransformState, @)".}

type
  RenderAttribRegistry* {.importcpp: "RenderAttribRegistry", pure, inheritable, header: "renderAttribRegistry.h".} = object

type
  RenderAttrib* {.importcpp: "PT(RenderAttrib)", bycopy, pure, inheritable, header: "renderAttrib.h".} = object of TypedWritableReferenceCount

converter toRenderAttrib*(_: type(nil)): RenderAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: RenderAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RenderAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RenderAttrib], obj: TypedObject): RenderAttrib {.importcpp: "DCAST(RenderAttrib, @)".}

type
  RenderModeAttrib* {.importcpp: "PT(RenderModeAttrib)", bycopy, pure, inheritable, header: "renderModeAttrib.h".} = object of RenderAttrib

converter toRenderModeAttrib*(_: type(nil)): RenderModeAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: RenderModeAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RenderModeAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RenderModeAttrib], obj: TypedObject): RenderModeAttrib {.importcpp: "DCAST(RenderModeAttrib, @)".}

type
  TexMatrixAttrib* {.importcpp: "PT(TexMatrixAttrib)", bycopy, pure, inheritable, header: "texMatrixAttrib.h".} = object of RenderAttrib

converter toTexMatrixAttrib*(_: type(nil)): TexMatrixAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: TexMatrixAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TexMatrixAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TexMatrixAttrib], obj: TypedObject): TexMatrixAttrib {.importcpp: "DCAST(TexMatrixAttrib, @)".}

type
  RenderState* {.importcpp: "PT(RenderState)", bycopy, pure, inheritable, header: "renderState.h".} = object of NodeCachedReferenceCount

converter toRenderState*(_: type(nil)): RenderState {.importcpp: "(nullptr)".}
converter toBool*(this: RenderState): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RenderState, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RenderState], obj: TypedObject): RenderState {.importcpp: "DCAST(RenderState, @)".}

type
  AlphaTestAttrib* {.importcpp: "PT(AlphaTestAttrib)", bycopy, pure, inheritable, header: "alphaTestAttrib.h".} = object of RenderAttrib

converter toAlphaTestAttrib*(_: type(nil)): AlphaTestAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: AlphaTestAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AlphaTestAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AlphaTestAttrib], obj: TypedObject): AlphaTestAttrib {.importcpp: "DCAST(AlphaTestAttrib, @)".}

type
  AntialiasAttrib* {.importcpp: "PT(AntialiasAttrib)", bycopy, pure, inheritable, header: "antialiasAttrib.h".} = object of RenderAttrib

converter toAntialiasAttrib*(_: type(nil)): AntialiasAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: AntialiasAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AntialiasAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AntialiasAttrib], obj: TypedObject): AntialiasAttrib {.importcpp: "DCAST(AntialiasAttrib, @)".}

type
  RenderEffect* {.importcpp: "PT(RenderEffect)", bycopy, pure, inheritable, header: "renderEffect.h".} = object of TypedWritableReferenceCount

converter toRenderEffect*(_: type(nil)): RenderEffect {.importcpp: "(nullptr)".}
converter toBool*(this: RenderEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RenderEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RenderEffect], obj: TypedObject): RenderEffect {.importcpp: "DCAST(RenderEffect, @)".}

type
  RenderEffects* {.importcpp: "PT(RenderEffects)", bycopy, pure, inheritable, header: "renderEffects.h".} = object of TypedWritableReferenceCount

converter toRenderEffects*(_: type(nil)): RenderEffects {.importcpp: "(nullptr)".}
converter toBool*(this: RenderEffects): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RenderEffects, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RenderEffects], obj: TypedObject): RenderEffects {.importcpp: "DCAST(RenderEffects, @)".}

type
  TransparencyAttrib* {.importcpp: "PT(TransparencyAttrib)", bycopy, pure, inheritable, header: "transparencyAttrib.h".} = object of RenderAttrib

converter toTransparencyAttrib*(_: type(nil)): TransparencyAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: TransparencyAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TransparencyAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TransparencyAttrib], obj: TypedObject): TransparencyAttrib {.importcpp: "DCAST(TransparencyAttrib, @)".}

type
  LogicOpAttrib* {.importcpp: "PT(LogicOpAttrib)", bycopy, pure, inheritable, header: "logicOpAttrib.h".} = object of RenderAttrib

converter toLogicOpAttrib*(_: type(nil)): LogicOpAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: LogicOpAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: LogicOpAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[LogicOpAttrib], obj: TypedObject): LogicOpAttrib {.importcpp: "DCAST(LogicOpAttrib, @)".}

type
  ShaderInput* {.importcpp: "ShaderInput", pure, inheritable, header: "shaderInput.h".} = object

type
  InternalNameCollection* {.importcpp: "InternalNameCollection", pure, inheritable, header: "internalNameCollection.h".} = object

type
  MaterialCollection* {.importcpp: "MaterialCollection", pure, inheritable, header: "materialCollection.h".} = object

type
  TextureStageCollection* {.importcpp: "TextureStageCollection", pure, inheritable, header: "textureStageCollection.h".} = object

type
  NodePath* {.importcpp: "NodePath", pure, inheritable, header: "nodePath.h".} = object

type
  NodePathCollection* {.importcpp: "NodePathCollection", pure, inheritable, header: "nodePathCollection.h".} = object

type
  AttribNodeRegistry* {.importcpp: "AttribNodeRegistry", pure, inheritable, header: "attribNodeRegistry.h".} = object

type
  AudioVolumeAttrib* {.importcpp: "PT(AudioVolumeAttrib)", bycopy, pure, inheritable, header: "audioVolumeAttrib.h".} = object of RenderAttrib

converter toAudioVolumeAttrib*(_: type(nil)): AudioVolumeAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: AudioVolumeAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AudioVolumeAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AudioVolumeAttrib], obj: TypedObject): AudioVolumeAttrib {.importcpp: "DCAST(AudioVolumeAttrib, @)".}

type
  AuxBitplaneAttrib* {.importcpp: "PT(AuxBitplaneAttrib)", bycopy, pure, inheritable, header: "auxBitplaneAttrib.h".} = object of RenderAttrib

converter toAuxBitplaneAttrib*(_: type(nil)): AuxBitplaneAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: AuxBitplaneAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AuxBitplaneAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AuxBitplaneAttrib], obj: TypedObject): AuxBitplaneAttrib {.importcpp: "DCAST(AuxBitplaneAttrib, @)".}

type
  AuxSceneData* {.importcpp: "PT(AuxSceneData)", bycopy, pure, inheritable, header: "auxSceneData.h".} = object of TypedReferenceCount

converter toAuxSceneData*(_: type(nil)): AuxSceneData {.importcpp: "(nullptr)".}
converter toBool*(this: AuxSceneData): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AuxSceneData, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AuxSceneData], obj: TypedObject): AuxSceneData {.importcpp: "DCAST(AuxSceneData, @)".}

type
  BamEnums* {.importcpp: "BamEnums", pure, inheritable, header: "bamEnums.h".} = object

type
  BamFile* {.importcpp: "BamFile", pure, inheritable, header: "bamFile.h".} = object of BamEnums

type
  BillboardEffect* {.importcpp: "PT(BillboardEffect)", bycopy, pure, inheritable, header: "billboardEffect.h".} = object of RenderEffect

converter toBillboardEffect*(_: type(nil)): BillboardEffect {.importcpp: "(nullptr)".}
converter toBool*(this: BillboardEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: BillboardEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[BillboardEffect], obj: TypedObject): BillboardEffect {.importcpp: "DCAST(BillboardEffect, @)".}

type
  WeakNodePath* {.importcpp: "WeakNodePath", pure, inheritable, header: "weakNodePath.h".} = object

type
  PlaneNode* {.importcpp: "PT(PlaneNode)", bycopy, pure, inheritable, header: "planeNode.h".} = object of PandaNode

converter toPlaneNode*(_: type(nil)): PlaneNode {.importcpp: "(nullptr)".}
converter toBool*(this: PlaneNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PlaneNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PlaneNode], obj: TypedObject): PlaneNode {.importcpp: "DCAST(PlaneNode, @)".}

type
  ClipPlaneAttrib* {.importcpp: "PT(ClipPlaneAttrib)", bycopy, pure, inheritable, header: "clipPlaneAttrib.h".} = object of RenderAttrib

converter toClipPlaneAttrib*(_: type(nil)): ClipPlaneAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: ClipPlaneAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ClipPlaneAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ClipPlaneAttrib], obj: TypedObject): ClipPlaneAttrib {.importcpp: "DCAST(ClipPlaneAttrib, @)".}

type
  ColorAttrib* {.importcpp: "PT(ColorAttrib)", bycopy, pure, inheritable, header: "colorAttrib.h".} = object of RenderAttrib

converter toColorAttrib*(_: type(nil)): ColorAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: ColorAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ColorAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ColorAttrib], obj: TypedObject): ColorAttrib {.importcpp: "DCAST(ColorAttrib, @)".}

type
  ColorBlendAttrib* {.importcpp: "PT(ColorBlendAttrib)", bycopy, pure, inheritable, header: "colorBlendAttrib.h".} = object of RenderAttrib

converter toColorBlendAttrib*(_: type(nil)): ColorBlendAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: ColorBlendAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ColorBlendAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ColorBlendAttrib], obj: TypedObject): ColorBlendAttrib {.importcpp: "DCAST(ColorBlendAttrib, @)".}

type
  ColorScaleAttrib* {.importcpp: "PT(ColorScaleAttrib)", bycopy, pure, inheritable, header: "colorScaleAttrib.h".} = object of RenderAttrib

converter toColorScaleAttrib*(_: type(nil)): ColorScaleAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: ColorScaleAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ColorScaleAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ColorScaleAttrib], obj: TypedObject): ColorScaleAttrib {.importcpp: "DCAST(ColorScaleAttrib, @)".}

type
  ColorWriteAttrib* {.importcpp: "PT(ColorWriteAttrib)", bycopy, pure, inheritable, header: "colorWriteAttrib.h".} = object of RenderAttrib

converter toColorWriteAttrib*(_: type(nil)): ColorWriteAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: ColorWriteAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ColorWriteAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ColorWriteAttrib], obj: TypedObject): ColorWriteAttrib {.importcpp: "DCAST(ColorWriteAttrib, @)".}

type
  CompassEffect* {.importcpp: "PT(CompassEffect)", bycopy, pure, inheritable, header: "compassEffect.h".} = object of RenderEffect

converter toCompassEffect*(_: type(nil)): CompassEffect {.importcpp: "(nullptr)".}
converter toBool*(this: CompassEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CompassEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CompassEffect], obj: TypedObject): CompassEffect {.importcpp: "DCAST(CompassEffect, @)".}

type
  CullBinEnums* {.importcpp: "CullBinEnums", pure, inheritable, header: "cullBinEnums.h".} = object

type
  GeomNode* {.importcpp: "PT(GeomNode)", bycopy, pure, inheritable, header: "geomNode.h".} = object of PandaNode

converter toGeomNode*(_: type(nil)): GeomNode {.importcpp: "(nullptr)".}
converter toBool*(this: GeomNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomNode], obj: TypedObject): GeomNode {.importcpp: "DCAST(GeomNode, @)".}

type
  CullBinAttrib* {.importcpp: "PT(CullBinAttrib)", bycopy, pure, inheritable, header: "cullBinAttrib.h".} = object of RenderAttrib

converter toCullBinAttrib*(_: type(nil)): CullBinAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: CullBinAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CullBinAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CullBinAttrib], obj: TypedObject): CullBinAttrib {.importcpp: "DCAST(CullBinAttrib, @)".}

type
  CullBinManager* {.importcpp: "CullBinManager", pure, inheritable, header: "cullBinManager.h".} = object of CullBinEnums

type
  CullFaceAttrib* {.importcpp: "PT(CullFaceAttrib)", bycopy, pure, inheritable, header: "cullFaceAttrib.h".} = object of RenderAttrib

converter toCullFaceAttrib*(_: type(nil)): CullFaceAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: CullFaceAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CullFaceAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CullFaceAttrib], obj: TypedObject): CullFaceAttrib {.importcpp: "DCAST(CullFaceAttrib, @)".}

type
  WorkingNodePath* {.importcpp: "WorkingNodePath", pure, inheritable, header: "workingNodePath.h".} = object

type
  CullTraverserData* {.importcpp: "CullTraverserData", pure, inheritable, header: "cullTraverserData.h".} = object

type
  SceneSetup* {.importcpp: "PT(SceneSetup)", bycopy, pure, inheritable, header: "sceneSetup.h".} = object of TypedReferenceCount

converter toSceneSetup*(_: type(nil)): SceneSetup {.importcpp: "(nullptr)".}
converter toBool*(this: SceneSetup): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SceneSetup, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[SceneSetup], obj: TypedObject): SceneSetup {.importcpp: "DCAST(SceneSetup, @)".}

type
  Fog* {.importcpp: "PT(Fog)", bycopy, pure, inheritable, header: "fog.h".} = object of PandaNode

converter toFog*(_: type(nil)): Fog {.importcpp: "(nullptr)".}
converter toBool*(this: Fog): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Fog, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Fog], obj: TypedObject): Fog {.importcpp: "DCAST(Fog, @)".}

type
  FogAttrib* {.importcpp: "PT(FogAttrib)", bycopy, pure, inheritable, header: "fogAttrib.h".} = object of RenderAttrib

converter toFogAttrib*(_: type(nil)): FogAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: FogAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: FogAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[FogAttrib], obj: TypedObject): FogAttrib {.importcpp: "DCAST(FogAttrib, @)".}

type
  CullTraverser* {.importcpp: "PT(CullTraverser)", bycopy, pure, inheritable, header: "cullTraverser.h".} = object of TypedReferenceCount

converter toCullTraverser*(_: type(nil)): CullTraverser {.importcpp: "(nullptr)".}
converter toBool*(this: CullTraverser): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CullTraverser, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CullTraverser], obj: TypedObject): CullTraverser {.importcpp: "DCAST(CullTraverser, @)".}

type
  GeomDrawCallbackData* {.importcpp: "GeomDrawCallbackData", pure, inheritable, header: "geomDrawCallbackData.h".} = object of CallbackData

type
  RescaleNormalAttrib* {.importcpp: "PT(RescaleNormalAttrib)", bycopy, pure, inheritable, header: "rescaleNormalAttrib.h".} = object of RenderAttrib

converter toRescaleNormalAttrib*(_: type(nil)): RescaleNormalAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: RescaleNormalAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RescaleNormalAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RescaleNormalAttrib], obj: TypedObject): RescaleNormalAttrib {.importcpp: "DCAST(RescaleNormalAttrib, @)".}

type
  CullResult* {.importcpp: "PT(CullResult)", bycopy, pure, inheritable, header: "cullResult.h".} = object of ReferenceCount

converter toCullResult*(_: type(nil)): CullResult {.importcpp: "(nullptr)".}
converter toBool*(this: CullResult): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CullResult, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CullResult], obj: TypedObject): CullResult {.importcpp: "DCAST(CullResult, @)".}

type
  DecalEffect* {.importcpp: "PT(DecalEffect)", bycopy, pure, inheritable, header: "decalEffect.h".} = object of RenderEffect

converter toDecalEffect*(_: type(nil)): DecalEffect {.importcpp: "(nullptr)".}
converter toBool*(this: DecalEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DecalEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DecalEffect], obj: TypedObject): DecalEffect {.importcpp: "DCAST(DecalEffect, @)".}

type
  DepthOffsetAttrib* {.importcpp: "PT(DepthOffsetAttrib)", bycopy, pure, inheritable, header: "depthOffsetAttrib.h".} = object of RenderAttrib

converter toDepthOffsetAttrib*(_: type(nil)): DepthOffsetAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: DepthOffsetAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DepthOffsetAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DepthOffsetAttrib], obj: TypedObject): DepthOffsetAttrib {.importcpp: "DCAST(DepthOffsetAttrib, @)".}

type
  DepthTestAttrib* {.importcpp: "PT(DepthTestAttrib)", bycopy, pure, inheritable, header: "depthTestAttrib.h".} = object of RenderAttrib

converter toDepthTestAttrib*(_: type(nil)): DepthTestAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: DepthTestAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DepthTestAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DepthTestAttrib], obj: TypedObject): DepthTestAttrib {.importcpp: "DCAST(DepthTestAttrib, @)".}

type
  DepthWriteAttrib* {.importcpp: "PT(DepthWriteAttrib)", bycopy, pure, inheritable, header: "depthWriteAttrib.h".} = object of RenderAttrib

converter toDepthWriteAttrib*(_: type(nil)): DepthWriteAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: DepthWriteAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DepthWriteAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DepthWriteAttrib], obj: TypedObject): DepthWriteAttrib {.importcpp: "DCAST(DepthWriteAttrib, @)".}

type
  LightAttrib* {.importcpp: "PT(LightAttrib)", bycopy, pure, inheritable, header: "lightAttrib.h".} = object of RenderAttrib

converter toLightAttrib*(_: type(nil)): LightAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: LightAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: LightAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[LightAttrib], obj: TypedObject): LightAttrib {.importcpp: "DCAST(LightAttrib, @)".}

type
  LightRampAttrib* {.importcpp: "PT(LightRampAttrib)", bycopy, pure, inheritable, header: "lightRampAttrib.h".} = object of RenderAttrib

converter toLightRampAttrib*(_: type(nil)): LightRampAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: LightRampAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: LightRampAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[LightRampAttrib], obj: TypedObject): LightRampAttrib {.importcpp: "DCAST(LightRampAttrib, @)".}

type
  Loader* {.importcpp: "PT(Loader)", bycopy, pure, inheritable, header: "loader.h".} = object of TypedReferenceCount

converter toLoader*(_: type(nil)): Loader {.importcpp: "(nullptr)".}
converter toBool*(this: Loader): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Loader, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Loader], obj: TypedObject): Loader {.importcpp: "DCAST(Loader, @)".}

type
  LoaderFileType* {.importcpp: "LoaderFileType", pure, inheritable, header: "loaderFileType.h".} = object of TypedObject

type
  LoaderFileTypeRegistry* {.importcpp: "LoaderFileTypeRegistry", pure, inheritable, header: "loaderFileTypeRegistry.h".} = object

type
  MaterialAttrib* {.importcpp: "PT(MaterialAttrib)", bycopy, pure, inheritable, header: "materialAttrib.h".} = object of RenderAttrib

converter toMaterialAttrib*(_: type(nil)): MaterialAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: MaterialAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MaterialAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MaterialAttrib], obj: TypedObject): MaterialAttrib {.importcpp: "DCAST(MaterialAttrib, @)".}

type
  AsyncFuture* {.importcpp: "PT(AsyncFuture)", bycopy, pure, inheritable, header: "asyncFuture.h".} = object of TypedReferenceCount

converter toAsyncFuture*(_: type(nil)): AsyncFuture {.importcpp: "(nullptr)".}
converter toBool*(this: AsyncFuture): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AsyncFuture, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AsyncFuture], obj: TypedObject): AsyncFuture {.importcpp: "DCAST(AsyncFuture, @)".}

type
  AsyncTask* {.importcpp: "PT(AsyncTask)", bycopy, pure, inheritable, header: "asyncTask.h".} = object of AsyncFuture

converter toAsyncTask*(_: type(nil)): AsyncTask {.importcpp: "(nullptr)".}
converter toBool*(this: AsyncTask): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AsyncTask, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AsyncTask], obj: TypedObject): AsyncTask {.importcpp: "DCAST(AsyncTask, @)".}

type
  ModelFlattenRequest* {.importcpp: "PT(ModelFlattenRequest)", bycopy, pure, inheritable, header: "modelFlattenRequest.h".} = object of AsyncTask

converter toModelFlattenRequest*(_: type(nil)): ModelFlattenRequest {.importcpp: "(nullptr)".}
converter toBool*(this: ModelFlattenRequest): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ModelFlattenRequest, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ModelFlattenRequest], obj: TypedObject): ModelFlattenRequest {.importcpp: "DCAST(ModelFlattenRequest, @)".}

type
  ModelLoadRequest* {.importcpp: "PT(ModelLoadRequest)", bycopy, pure, inheritable, header: "modelLoadRequest.h".} = object of AsyncTask

converter toModelLoadRequest*(_: type(nil)): ModelLoadRequest {.importcpp: "(nullptr)".}
converter toBool*(this: ModelLoadRequest): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ModelLoadRequest, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ModelLoadRequest], obj: TypedObject): ModelLoadRequest {.importcpp: "DCAST(ModelLoadRequest, @)".}

type
  ModelNode* {.importcpp: "PT(ModelNode)", bycopy, pure, inheritable, header: "modelNode.h".} = object of PandaNode

converter toModelNode*(_: type(nil)): ModelNode {.importcpp: "(nullptr)".}
converter toBool*(this: ModelNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ModelNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ModelNode], obj: TypedObject): ModelNode {.importcpp: "DCAST(ModelNode, @)".}

type
  ModelRoot* {.importcpp: "PT(ModelRoot)", bycopy, pure, inheritable, header: "modelRoot.h".} = object of ModelNode

converter toModelRoot*(_: type(nil)): ModelRoot {.importcpp: "(nullptr)".}
converter toBool*(this: ModelRoot): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ModelRoot, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ModelRoot], obj: TypedObject): ModelRoot {.importcpp: "DCAST(ModelRoot, @)".}

type
  ModelPool* {.importcpp: "ModelPool", pure, inheritable, header: "modelPool.h".} = object

type
  ModelSaveRequest* {.importcpp: "PT(ModelSaveRequest)", bycopy, pure, inheritable, header: "modelSaveRequest.h".} = object of AsyncTask

converter toModelSaveRequest*(_: type(nil)): ModelSaveRequest {.importcpp: "(nullptr)".}
converter toBool*(this: ModelSaveRequest): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ModelSaveRequest, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ModelSaveRequest], obj: TypedObject): ModelSaveRequest {.importcpp: "DCAST(ModelSaveRequest, @)".}

type
  TextureAttrib* {.importcpp: "PT(TextureAttrib)", bycopy, pure, inheritable, header: "textureAttrib.h".} = object of RenderAttrib

converter toTextureAttrib*(_: type(nil)): TextureAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: TextureAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TextureAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TextureAttrib], obj: TypedObject): TextureAttrib {.importcpp: "DCAST(TextureAttrib, @)".}

type
  TexGenAttrib* {.importcpp: "PT(TexGenAttrib)", bycopy, pure, inheritable, header: "texGenAttrib.h".} = object of RenderAttrib

converter toTexGenAttrib*(_: type(nil)): TexGenAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: TexGenAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TexGenAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TexGenAttrib], obj: TypedObject): TexGenAttrib {.importcpp: "DCAST(TexGenAttrib, @)".}

type
  OccluderNode* {.importcpp: "PT(OccluderNode)", bycopy, pure, inheritable, header: "occluderNode.h".} = object of PandaNode

converter toOccluderNode*(_: type(nil)): OccluderNode {.importcpp: "(nullptr)".}
converter toBool*(this: OccluderNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: OccluderNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[OccluderNode], obj: TypedObject): OccluderNode {.importcpp: "DCAST(OccluderNode, @)".}

type
  OccluderEffect* {.importcpp: "PT(OccluderEffect)", bycopy, pure, inheritable, header: "occluderEffect.h".} = object of RenderEffect

converter toOccluderEffect*(_: type(nil)): OccluderEffect {.importcpp: "(nullptr)".}
converter toBool*(this: OccluderEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: OccluderEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[OccluderEffect], obj: TypedObject): OccluderEffect {.importcpp: "DCAST(OccluderEffect, @)".}

type
  PolylightNode* {.importcpp: "PT(PolylightNode)", bycopy, pure, inheritable, header: "polylightNode.h".} = object of PandaNode

converter toPolylightNode*(_: type(nil)): PolylightNode {.importcpp: "(nullptr)".}
converter toBool*(this: PolylightNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PolylightNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PolylightNode], obj: TypedObject): PolylightNode {.importcpp: "DCAST(PolylightNode, @)".}

type
  PolylightEffect* {.importcpp: "PT(PolylightEffect)", bycopy, pure, inheritable, header: "polylightEffect.h".} = object of RenderEffect

converter toPolylightEffect*(_: type(nil)): PolylightEffect {.importcpp: "(nullptr)".}
converter toBool*(this: PolylightEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PolylightEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PolylightEffect], obj: TypedObject): PolylightEffect {.importcpp: "DCAST(PolylightEffect, @)".}

type
  ShaderAttrib* {.importcpp: "PT(ShaderAttrib)", bycopy, pure, inheritable, header: "shaderAttrib.h".} = object of RenderAttrib

converter toShaderAttrib*(_: type(nil)): ShaderAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: ShaderAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ShaderAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ShaderAttrib], obj: TypedObject): ShaderAttrib {.importcpp: "DCAST(ShaderAttrib, @)".}

type
  ShowBoundsEffect* {.importcpp: "PT(ShowBoundsEffect)", bycopy, pure, inheritable, header: "showBoundsEffect.h".} = object of RenderEffect

converter toShowBoundsEffect*(_: type(nil)): ShowBoundsEffect {.importcpp: "(nullptr)".}
converter toBool*(this: ShowBoundsEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ShowBoundsEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ShowBoundsEffect], obj: TypedObject): ShowBoundsEffect {.importcpp: "DCAST(ShowBoundsEffect, @)".}

type
  TexProjectorEffect* {.importcpp: "PT(TexProjectorEffect)", bycopy, pure, inheritable, header: "texProjectorEffect.h".} = object of RenderEffect

converter toTexProjectorEffect*(_: type(nil)): TexProjectorEffect {.importcpp: "(nullptr)".}
converter toBool*(this: TexProjectorEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TexProjectorEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TexProjectorEffect], obj: TypedObject): TexProjectorEffect {.importcpp: "DCAST(TexProjectorEffect, @)".}

type
  ScissorEffect* {.importcpp: "PT(ScissorEffect)", bycopy, pure, inheritable, header: "scissorEffect.h".} = object of RenderEffect

converter toScissorEffect*(_: type(nil)): ScissorEffect {.importcpp: "(nullptr)".}
converter toBool*(this: ScissorEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ScissorEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ScissorEffect], obj: TypedObject): ScissorEffect {.importcpp: "DCAST(ScissorEffect, @)".}

type
  SceneGraphReducer* {.importcpp: "SceneGraphReducer", pure, inheritable, header: "sceneGraphReducer.h".} = object

type
  PortalNode* {.importcpp: "PT(PortalNode)", bycopy, pure, inheritable, header: "portalNode.h".} = object of PandaNode

converter toPortalNode*(_: type(nil)): PortalNode {.importcpp: "(nullptr)".}
converter toBool*(this: PortalNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PortalNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PortalNode], obj: TypedObject): PortalNode {.importcpp: "DCAST(PortalNode, @)".}

type
  ScissorAttrib* {.importcpp: "PT(ScissorAttrib)", bycopy, pure, inheritable, header: "scissorAttrib.h".} = object of RenderAttrib

converter toScissorAttrib*(_: type(nil)): ScissorAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: ScissorAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ScissorAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ScissorAttrib], obj: TypedObject): ScissorAttrib {.importcpp: "DCAST(ScissorAttrib, @)".}

type
  ShadeModelAttrib* {.importcpp: "PT(ShadeModelAttrib)", bycopy, pure, inheritable, header: "shadeModelAttrib.h".} = object of RenderAttrib

converter toShadeModelAttrib*(_: type(nil)): ShadeModelAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: ShadeModelAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ShadeModelAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ShadeModelAttrib], obj: TypedObject): ShadeModelAttrib {.importcpp: "DCAST(ShadeModelAttrib, @)".}

type
  StencilAttrib* {.importcpp: "PT(StencilAttrib)", bycopy, pure, inheritable, header: "stencilAttrib.h".} = object of RenderAttrib

converter toStencilAttrib*(_: type(nil)): StencilAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: StencilAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: StencilAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[StencilAttrib], obj: TypedObject): StencilAttrib {.importcpp: "DCAST(StencilAttrib, @)".}

type
  ShaderPool* {.importcpp: "ShaderPool", pure, inheritable, header: "shaderPool.h".} = object

type
  MovieAudio* {.importcpp: "PT(MovieAudio)", bycopy, pure, inheritable, header: "movieAudio.h".} = object of TypedWritableReferenceCount

converter toMovieAudio*(_: type(nil)): MovieAudio {.importcpp: "(nullptr)".}
converter toBool*(this: MovieAudio): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MovieAudio, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MovieAudio], obj: TypedObject): MovieAudio {.importcpp: "DCAST(MovieAudio, @)".}

type
  FlacAudio* {.importcpp: "PT(FlacAudio)", bycopy, pure, inheritable, header: "flacAudio.h".} = object of MovieAudio

converter toFlacAudio*(_: type(nil)): FlacAudio {.importcpp: "(nullptr)".}
converter toBool*(this: FlacAudio): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: FlacAudio, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[FlacAudio], obj: TypedObject): FlacAudio {.importcpp: "DCAST(FlacAudio, @)".}

type
  MovieAudioCursor* {.importcpp: "PT(MovieAudioCursor)", bycopy, pure, inheritable, header: "movieAudioCursor.h".} = object of TypedWritableReferenceCount

converter toMovieAudioCursor*(_: type(nil)): MovieAudioCursor {.importcpp: "(nullptr)".}
converter toBool*(this: MovieAudioCursor): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MovieAudioCursor, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MovieAudioCursor], obj: TypedObject): MovieAudioCursor {.importcpp: "DCAST(MovieAudioCursor, @)".}

type
  FlacAudioCursor* {.importcpp: "PT(FlacAudioCursor)", bycopy, pure, inheritable, header: "flacAudioCursor.h".} = object of MovieAudioCursor

converter toFlacAudioCursor*(_: type(nil)): FlacAudioCursor {.importcpp: "(nullptr)".}
converter toBool*(this: FlacAudioCursor): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: FlacAudioCursor, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[FlacAudioCursor], obj: TypedObject): FlacAudioCursor {.importcpp: "DCAST(FlacAudioCursor, @)".}

type
  MovieVideo* {.importcpp: "PT(MovieVideo)", bycopy, pure, inheritable, header: "movieVideo.h".} = object of TypedWritableReferenceCount

converter toMovieVideo*(_: type(nil)): MovieVideo {.importcpp: "(nullptr)".}
converter toBool*(this: MovieVideo): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MovieVideo, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MovieVideo], obj: TypedObject): MovieVideo {.importcpp: "DCAST(MovieVideo, @)".}

type
  InkblotVideo* {.importcpp: "PT(InkblotVideo)", bycopy, pure, inheritable, header: "inkblotVideo.h".} = object of MovieVideo

converter toInkblotVideo*(_: type(nil)): InkblotVideo {.importcpp: "(nullptr)".}
converter toBool*(this: InkblotVideo): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: InkblotVideo, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[InkblotVideo], obj: TypedObject): InkblotVideo {.importcpp: "DCAST(InkblotVideo, @)".}

type
  MovieVideoCursor* {.importcpp: "PT(MovieVideoCursor)", bycopy, pure, inheritable, header: "movieVideoCursor.h".} = object of TypedWritableReferenceCount

converter toMovieVideoCursor*(_: type(nil)): MovieVideoCursor {.importcpp: "(nullptr)".}
converter toBool*(this: MovieVideoCursor): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MovieVideoCursor, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MovieVideoCursor], obj: TypedObject): MovieVideoCursor {.importcpp: "DCAST(MovieVideoCursor, @)".}

type
  InkblotVideoCursor* {.importcpp: "PT(InkblotVideoCursor)", bycopy, pure, inheritable, header: "inkblotVideoCursor.h".} = object of MovieVideoCursor

converter toInkblotVideoCursor*(_: type(nil)): InkblotVideoCursor {.importcpp: "(nullptr)".}
converter toBool*(this: InkblotVideoCursor): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: InkblotVideoCursor, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[InkblotVideoCursor], obj: TypedObject): InkblotVideoCursor {.importcpp: "DCAST(InkblotVideoCursor, @)".}

type
  MicrophoneAudio* {.importcpp: "PT(MicrophoneAudio)", bycopy, pure, inheritable, header: "microphoneAudio.h".} = object of MovieAudio

converter toMicrophoneAudio*(_: type(nil)): MicrophoneAudio {.importcpp: "(nullptr)".}
converter toBool*(this: MicrophoneAudio): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MicrophoneAudio, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MicrophoneAudio], obj: TypedObject): MicrophoneAudio {.importcpp: "DCAST(MicrophoneAudio, @)".}

type
  OpusAudio* {.importcpp: "PT(OpusAudio)", bycopy, pure, inheritable, header: "opusAudio.h".} = object of MovieAudio

converter toOpusAudio*(_: type(nil)): OpusAudio {.importcpp: "(nullptr)".}
converter toBool*(this: OpusAudio): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: OpusAudio, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[OpusAudio], obj: TypedObject): OpusAudio {.importcpp: "DCAST(OpusAudio, @)".}

type
  OpusAudioCursor* {.importcpp: "PT(OpusAudioCursor)", bycopy, pure, inheritable, header: "opusAudioCursor.h".} = object of MovieAudioCursor

converter toOpusAudioCursor*(_: type(nil)): OpusAudioCursor {.importcpp: "(nullptr)".}
converter toBool*(this: OpusAudioCursor): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: OpusAudioCursor, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[OpusAudioCursor], obj: TypedObject): OpusAudioCursor {.importcpp: "DCAST(OpusAudioCursor, @)".}

type
  UserDataAudio* {.importcpp: "PT(UserDataAudio)", bycopy, pure, inheritable, header: "userDataAudio.h".} = object of MovieAudio

converter toUserDataAudio*(_: type(nil)): UserDataAudio {.importcpp: "(nullptr)".}
converter toBool*(this: UserDataAudio): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: UserDataAudio, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[UserDataAudio], obj: TypedObject): UserDataAudio {.importcpp: "DCAST(UserDataAudio, @)".}

type
  UserDataAudioCursor* {.importcpp: "PT(UserDataAudioCursor)", bycopy, pure, inheritable, header: "userDataAudioCursor.h".} = object of MovieAudioCursor

converter toUserDataAudioCursor*(_: type(nil)): UserDataAudioCursor {.importcpp: "(nullptr)".}
converter toBool*(this: UserDataAudioCursor): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: UserDataAudioCursor, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[UserDataAudioCursor], obj: TypedObject): UserDataAudioCursor {.importcpp: "DCAST(UserDataAudioCursor, @)".}

type
  VorbisAudio* {.importcpp: "PT(VorbisAudio)", bycopy, pure, inheritable, header: "vorbisAudio.h".} = object of MovieAudio

converter toVorbisAudio*(_: type(nil)): VorbisAudio {.importcpp: "(nullptr)".}
converter toBool*(this: VorbisAudio): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VorbisAudio, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VorbisAudio], obj: TypedObject): VorbisAudio {.importcpp: "DCAST(VorbisAudio, @)".}

type
  VorbisAudioCursor* {.importcpp: "PT(VorbisAudioCursor)", bycopy, pure, inheritable, header: "vorbisAudioCursor.h".} = object of MovieAudioCursor

converter toVorbisAudioCursor*(_: type(nil)): VorbisAudioCursor {.importcpp: "(nullptr)".}
converter toBool*(this: VorbisAudioCursor): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VorbisAudioCursor, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VorbisAudioCursor], obj: TypedObject): VorbisAudioCursor {.importcpp: "DCAST(VorbisAudioCursor, @)".}

type
  WavAudio* {.importcpp: "PT(WavAudio)", bycopy, pure, inheritable, header: "wavAudio.h".} = object of MovieAudio

converter toWavAudio*(_: type(nil)): WavAudio {.importcpp: "(nullptr)".}
converter toBool*(this: WavAudio): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: WavAudio, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[WavAudio], obj: TypedObject): WavAudio {.importcpp: "DCAST(WavAudio, @)".}

type
  WavAudioCursor* {.importcpp: "PT(WavAudioCursor)", bycopy, pure, inheritable, header: "wavAudioCursor.h".} = object of MovieAudioCursor

converter toWavAudioCursor*(_: type(nil)): WavAudioCursor {.importcpp: "(nullptr)".}
converter toBool*(this: WavAudioCursor): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: WavAudioCursor, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[WavAudioCursor], obj: TypedObject): WavAudioCursor {.importcpp: "DCAST(WavAudioCursor, @)".}

type
  CardMaker* {.importcpp: "CardMaker", pure, inheritable, header: "cardMaker.h".} = object of Namable

type
  FisheyeMaker* {.importcpp: "FisheyeMaker", pure, inheritable, header: "fisheyeMaker.h".} = object of Namable

type
  TextProperties* {.importcpp: "TextProperties", pure, inheritable, header: "textProperties.h".} = object

type
  TextNode* {.importcpp: "PT(TextNode)", bycopy, pure, inheritable, header: "textNode.h".} = object of PandaNode

converter toTextNode*(_: type(nil)): TextNode {.importcpp: "(nullptr)".}
converter toBool*(this: TextNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TextNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TextNode], obj: TypedObject): TextNode {.importcpp: "DCAST(TextNode, @)".}

type
  FrameRateMeter* {.importcpp: "PT(FrameRateMeter)", bycopy, pure, inheritable, header: "frameRateMeter.h".} = object of TextNode

converter toFrameRateMeter*(_: type(nil)): FrameRateMeter {.importcpp: "(nullptr)".}
converter toBool*(this: FrameRateMeter): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: FrameRateMeter, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[FrameRateMeter], obj: TypedObject): FrameRateMeter {.importcpp: "DCAST(FrameRateMeter, @)".}

type
  GeoMipTerrain* {.importcpp: "GeoMipTerrain", pure, inheritable, header: "geoMipTerrain.h".} = object of TypedObject

type
  HeightfieldTesselator* {.importcpp: "HeightfieldTesselator", pure, inheritable, header: "heightfieldTesselator.h".} = object of Namable

type
  LineSegs* {.importcpp: "LineSegs", pure, inheritable, header: "lineSegs.h".} = object of Namable

type
  MeshDrawer* {.importcpp: "MeshDrawer", pure, inheritable, header: "meshDrawer.h".} = object of TypedObject

type
  MeshDrawer2D* {.importcpp: "MeshDrawer2D", pure, inheritable, header: "meshDrawer2D.h".} = object of TypedObject

type
  Texture* {.importcpp: "PT(Texture)", bycopy, pure, inheritable, header: "texture.h".} = object of TypedWritableReferenceCount

converter toTexture*(_: type(nil)): Texture {.importcpp: "(nullptr)".}
converter toBool*(this: Texture): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Texture, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Texture], obj: TypedObject): Texture {.importcpp: "DCAST(Texture, @)".}

type
  MovieTexture* {.importcpp: "PT(MovieTexture)", bycopy, pure, inheritable, header: "movieTexture.h".} = object of Texture

converter toMovieTexture*(_: type(nil)): MovieTexture {.importcpp: "(nullptr)".}
converter toBool*(this: MovieTexture): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MovieTexture, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MovieTexture], obj: TypedObject): MovieTexture {.importcpp: "DCAST(MovieTexture, @)".}

type
  MultitexReducer* {.importcpp: "MultitexReducer", pure, inheritable, header: "multitexReducer.h".} = object

type
  VertexTransform* {.importcpp: "PT(VertexTransform)", bycopy, pure, inheritable, header: "vertexTransform.h".} = object of TypedWritableReferenceCount

converter toVertexTransform*(_: type(nil)): VertexTransform {.importcpp: "(nullptr)".}
converter toBool*(this: VertexTransform): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VertexTransform, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VertexTransform], obj: TypedObject): VertexTransform {.importcpp: "DCAST(VertexTransform, @)".}

type
  NodeVertexTransform* {.importcpp: "PT(NodeVertexTransform)", bycopy, pure, inheritable, header: "nodeVertexTransform.h".} = object of VertexTransform

converter toNodeVertexTransform*(_: type(nil)): NodeVertexTransform {.importcpp: "(nullptr)".}
converter toBool*(this: NodeVertexTransform): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: NodeVertexTransform, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[NodeVertexTransform], obj: TypedObject): NodeVertexTransform {.importcpp: "DCAST(NodeVertexTransform, @)".}

type
  ShaderTerrainMesh* {.importcpp: "PT(ShaderTerrainMesh)", bycopy, pure, inheritable, header: "shaderTerrainMesh.h".} = object of PandaNode

converter toShaderTerrainMesh*(_: type(nil)): ShaderTerrainMesh {.importcpp: "(nullptr)".}
converter toBool*(this: ShaderTerrainMesh): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ShaderTerrainMesh, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ShaderTerrainMesh], obj: TypedObject): ShaderTerrainMesh {.importcpp: "DCAST(ShaderTerrainMesh, @)".}

type
  SceneGraphAnalyzerMeter* {.importcpp: "PT(SceneGraphAnalyzerMeter)", bycopy, pure, inheritable, header: "sceneGraphAnalyzerMeter.h".} = object of TextNode

converter toSceneGraphAnalyzerMeter*(_: type(nil)): SceneGraphAnalyzerMeter {.importcpp: "(nullptr)".}
converter toBool*(this: SceneGraphAnalyzerMeter): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SceneGraphAnalyzerMeter, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[SceneGraphAnalyzerMeter], obj: TypedObject): SceneGraphAnalyzerMeter {.importcpp: "DCAST(SceneGraphAnalyzerMeter, @)".}

type
  RigidBodyCombiner* {.importcpp: "PT(RigidBodyCombiner)", bycopy, pure, inheritable, header: "rigidBodyCombiner.h".} = object of PandaNode

converter toRigidBodyCombiner*(_: type(nil)): RigidBodyCombiner {.importcpp: "(nullptr)".}
converter toBool*(this: RigidBodyCombiner): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RigidBodyCombiner, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RigidBodyCombiner], obj: TypedObject): RigidBodyCombiner {.importcpp: "DCAST(RigidBodyCombiner, @)".}

type
  PipeOcclusionCullTraverser* {.importcpp: "PT(PipeOcclusionCullTraverser)", bycopy, pure, inheritable, header: "pipeOcclusionCullTraverser.h".} = object of CullTraverser

converter toPipeOcclusionCullTraverser*(_: type(nil)): PipeOcclusionCullTraverser {.importcpp: "(nullptr)".}
converter toBool*(this: PipeOcclusionCullTraverser): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PipeOcclusionCullTraverser, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PipeOcclusionCullTraverser], obj: TypedObject): PipeOcclusionCullTraverser {.importcpp: "DCAST(PipeOcclusionCullTraverser, @)".}

type
  PfmVizzer* {.importcpp: "PfmVizzer", pure, inheritable, header: "pfmVizzer.h".} = object

type
  AnimGroup* {.importcpp: "PT(AnimGroup)", bycopy, pure, inheritable, header: "animGroup.h".} = object of TypedWritableReferenceCount

converter toAnimGroup*(_: type(nil)): AnimGroup {.importcpp: "(nullptr)".}
converter toBool*(this: AnimGroup): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimGroup, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimGroup], obj: TypedObject): AnimGroup {.importcpp: "DCAST(AnimGroup, @)".}

type
  AnimBundle* {.importcpp: "PT(AnimBundle)", bycopy, pure, inheritable, header: "animBundle.h".} = object of AnimGroup

converter toAnimBundle*(_: type(nil)): AnimBundle {.importcpp: "(nullptr)".}
converter toBool*(this: AnimBundle): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimBundle, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimBundle], obj: TypedObject): AnimBundle {.importcpp: "DCAST(AnimBundle, @)".}

type
  AnimBundleNode* {.importcpp: "PT(AnimBundleNode)", bycopy, pure, inheritable, header: "animBundleNode.h".} = object of PandaNode

converter toAnimBundleNode*(_: type(nil)): AnimBundleNode {.importcpp: "(nullptr)".}
converter toBool*(this: AnimBundleNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimBundleNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimBundleNode], obj: TypedObject): AnimBundleNode {.importcpp: "DCAST(AnimBundleNode, @)".}

type
  PartGroup* {.importcpp: "PT(PartGroup)", bycopy, pure, inheritable, header: "partGroup.h".} = object of TypedWritableReferenceCount

converter toPartGroup*(_: type(nil)): PartGroup {.importcpp: "(nullptr)".}
converter toBool*(this: PartGroup): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PartGroup, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PartGroup], obj: TypedObject): PartGroup {.importcpp: "DCAST(PartGroup, @)".}

type
  AnimControl* {.importcpp: "PT(AnimControl)", bycopy, pure, inheritable, header: "animControl.h".} = object of TypedReferenceCount

converter toAnimControl*(_: type(nil)): AnimControl {.importcpp: "(nullptr)".}
converter toBool*(this: AnimControl): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimControl, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimControl], obj: TypedObject): AnimControl {.importcpp: "DCAST(AnimControl, @)".}

type
  AnimChannelBase* {.importcpp: "PT(AnimChannelBase)", bycopy, pure, inheritable, header: "animChannelBase.h".} = object of AnimGroup

converter toAnimChannelBase*(_: type(nil)): AnimChannelBase {.importcpp: "(nullptr)".}
converter toBool*(this: AnimChannelBase): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimChannelBase, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimChannelBase], obj: TypedObject): AnimChannelBase {.importcpp: "DCAST(AnimChannelBase, @)".}

type
  AnimChannelMatrixDynamic* {.importcpp: "PT(AnimChannelMatrixDynamic)", bycopy, pure, inheritable, header: "animChannelMatrixDynamic.h".} = object

converter toAnimChannelMatrixDynamic*(_: type(nil)): AnimChannelMatrixDynamic {.importcpp: "(nullptr)".}
converter toBool*(this: AnimChannelMatrixDynamic): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimChannelMatrixDynamic, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimChannelMatrixDynamic], obj: TypedObject): AnimChannelMatrixDynamic {.importcpp: "DCAST(AnimChannelMatrixDynamic, @)".}

type
  AnimChannelMatrixXfmTable* {.importcpp: "PT(AnimChannelMatrixXfmTable)", bycopy, pure, inheritable, header: "animChannelMatrixXfmTable.h".} = object

converter toAnimChannelMatrixXfmTable*(_: type(nil)): AnimChannelMatrixXfmTable {.importcpp: "(nullptr)".}
converter toBool*(this: AnimChannelMatrixXfmTable): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimChannelMatrixXfmTable, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimChannelMatrixXfmTable], obj: TypedObject): AnimChannelMatrixXfmTable {.importcpp: "DCAST(AnimChannelMatrixXfmTable, @)".}

type
  AnimChannelScalarDynamic* {.importcpp: "PT(AnimChannelScalarDynamic)", bycopy, pure, inheritable, header: "animChannelScalarDynamic.h".} = object

converter toAnimChannelScalarDynamic*(_: type(nil)): AnimChannelScalarDynamic {.importcpp: "(nullptr)".}
converter toBool*(this: AnimChannelScalarDynamic): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimChannelScalarDynamic, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimChannelScalarDynamic], obj: TypedObject): AnimChannelScalarDynamic {.importcpp: "DCAST(AnimChannelScalarDynamic, @)".}

type
  AnimChannelScalarTable* {.importcpp: "PT(AnimChannelScalarTable)", bycopy, pure, inheritable, header: "animChannelScalarTable.h".} = object

converter toAnimChannelScalarTable*(_: type(nil)): AnimChannelScalarTable {.importcpp: "(nullptr)".}
converter toBool*(this: AnimChannelScalarTable): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimChannelScalarTable, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimChannelScalarTable], obj: TypedObject): AnimChannelScalarTable {.importcpp: "DCAST(AnimChannelScalarTable, @)".}

type
  AnimControlCollection* {.importcpp: "AnimControlCollection", pure, inheritable, header: "animControlCollection.h".} = object

type
  CopyOnWriteObject* {.importcpp: "PT(CopyOnWriteObject)", bycopy, pure, inheritable, header: "copyOnWriteObject.h".} = object of CachedTypedWritableReferenceCount

converter toCopyOnWriteObject*(_: type(nil)): CopyOnWriteObject {.importcpp: "(nullptr)".}
converter toBool*(this: CopyOnWriteObject): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CopyOnWriteObject, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CopyOnWriteObject], obj: TypedObject): CopyOnWriteObject {.importcpp: "DCAST(CopyOnWriteObject, @)".}

type
  AnimPreloadTable* {.importcpp: "PT(AnimPreloadTable)", bycopy, pure, inheritable, header: "animPreloadTable.h".} = object of CopyOnWriteObject

converter toAnimPreloadTable*(_: type(nil)): AnimPreloadTable {.importcpp: "(nullptr)".}
converter toBool*(this: AnimPreloadTable): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimPreloadTable, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimPreloadTable], obj: TypedObject): AnimPreloadTable {.importcpp: "DCAST(AnimPreloadTable, @)".}

type
  PartSubset* {.importcpp: "PartSubset", pure, inheritable, header: "partSubset.h".} = object

type
  BindAnimRequest* {.importcpp: "PT(BindAnimRequest)", bycopy, pure, inheritable, header: "bindAnimRequest.h".} = object of ModelLoadRequest

converter toBindAnimRequest*(_: type(nil)): BindAnimRequest {.importcpp: "(nullptr)".}
converter toBool*(this: BindAnimRequest): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: BindAnimRequest, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[BindAnimRequest], obj: TypedObject): BindAnimRequest {.importcpp: "DCAST(BindAnimRequest, @)".}

type
  PartBundle* {.importcpp: "PT(PartBundle)", bycopy, pure, inheritable, header: "partBundle.h".} = object of PartGroup

converter toPartBundle*(_: type(nil)): PartBundle {.importcpp: "(nullptr)".}
converter toBool*(this: PartBundle): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PartBundle, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PartBundle], obj: TypedObject): PartBundle {.importcpp: "DCAST(PartBundle, @)".}

type
  PartBundleNode* {.importcpp: "PT(PartBundleNode)", bycopy, pure, inheritable, header: "partBundleNode.h".} = object of PandaNode

converter toPartBundleNode*(_: type(nil)): PartBundleNode {.importcpp: "(nullptr)".}
converter toBool*(this: PartBundleNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PartBundleNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PartBundleNode], obj: TypedObject): PartBundleNode {.importcpp: "DCAST(PartBundleNode, @)".}

type
  PartBundleHandle* {.importcpp: "PT(PartBundleHandle)", bycopy, pure, inheritable, header: "partBundleHandle.h".} = object of ReferenceCount

converter toPartBundleHandle*(_: type(nil)): PartBundleHandle {.importcpp: "(nullptr)".}
converter toBool*(this: PartBundleHandle): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PartBundleHandle, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PartBundleHandle], obj: TypedObject): PartBundleHandle {.importcpp: "DCAST(PartBundleHandle, @)".}

type
  MovingPartBase* {.importcpp: "PT(MovingPartBase)", bycopy, pure, inheritable, header: "movingPartBase.h".} = object of PartGroup

converter toMovingPartBase*(_: type(nil)): MovingPartBase {.importcpp: "(nullptr)".}
converter toBool*(this: MovingPartBase): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MovingPartBase, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MovingPartBase], obj: TypedObject): MovingPartBase {.importcpp: "DCAST(MovingPartBase, @)".}

type
  MovingPartMatrix* {.importcpp: "PT(MovingPartMatrix)", bycopy, pure, inheritable, header: "movingPartMatrix.h".} = object

converter toMovingPartMatrix*(_: type(nil)): MovingPartMatrix {.importcpp: "(nullptr)".}
converter toBool*(this: MovingPartMatrix): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MovingPartMatrix, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MovingPartMatrix], obj: TypedObject): MovingPartMatrix {.importcpp: "DCAST(MovingPartMatrix, @)".}

type
  MovingPartScalar* {.importcpp: "PT(MovingPartScalar)", bycopy, pure, inheritable, header: "movingPartScalar.h".} = object

converter toMovingPartScalar*(_: type(nil)): MovingPartScalar {.importcpp: "(nullptr)".}
converter toBool*(this: MovingPartScalar): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MovingPartScalar, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MovingPartScalar], obj: TypedObject): MovingPartScalar {.importcpp: "DCAST(MovingPartScalar, @)".}

type
  PStatClient* {.importcpp: "PStatClient", pure, inheritable, header: "pStatClient.h".} = object

type
  PStatCollector* {.importcpp: "PStatCollector", pure, inheritable, header: "pStatCollector.h".} = object

type
  PStatThread* {.importcpp: "PStatThread", pure, inheritable, header: "pStatThread.h".} = object

type
  PStatCollectorForward* {.importcpp: "PT(PStatCollectorForward)", bycopy, pure, inheritable, header: "pStatCollectorForward.h".} = object of PStatCollectorForwardBase

converter toPStatCollectorForward*(_: type(nil)): PStatCollectorForward {.importcpp: "(nullptr)".}
converter toBool*(this: PStatCollectorForward): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PStatCollectorForward, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PStatCollectorForward], obj: TypedObject): PStatCollectorForward {.importcpp: "DCAST(PStatCollectorForward, @)".}

type
  CharacterJoint* {.importcpp: "PT(CharacterJoint)", bycopy, pure, inheritable, header: "characterJoint.h".} = object of MovingPartMatrix

converter toCharacterJoint*(_: type(nil)): CharacterJoint {.importcpp: "(nullptr)".}
converter toBool*(this: CharacterJoint): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CharacterJoint, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CharacterJoint], obj: TypedObject): CharacterJoint {.importcpp: "DCAST(CharacterJoint, @)".}

type
  CharacterSlider* {.importcpp: "PT(CharacterSlider)", bycopy, pure, inheritable, header: "characterSlider.h".} = object of MovingPartScalar

converter toCharacterSlider*(_: type(nil)): CharacterSlider {.importcpp: "(nullptr)".}
converter toBool*(this: CharacterSlider): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CharacterSlider, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CharacterSlider], obj: TypedObject): CharacterSlider {.importcpp: "DCAST(CharacterSlider, @)".}

type
  VertexSlider* {.importcpp: "PT(VertexSlider)", bycopy, pure, inheritable, header: "vertexSlider.h".} = object of TypedWritableReferenceCount

converter toVertexSlider*(_: type(nil)): VertexSlider {.importcpp: "(nullptr)".}
converter toBool*(this: VertexSlider): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VertexSlider, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VertexSlider], obj: TypedObject): VertexSlider {.importcpp: "DCAST(VertexSlider, @)".}

type
  CharacterVertexSlider* {.importcpp: "PT(CharacterVertexSlider)", bycopy, pure, inheritable, header: "characterVertexSlider.h".} = object of VertexSlider

converter toCharacterVertexSlider*(_: type(nil)): CharacterVertexSlider {.importcpp: "(nullptr)".}
converter toBool*(this: CharacterVertexSlider): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CharacterVertexSlider, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CharacterVertexSlider], obj: TypedObject): CharacterVertexSlider {.importcpp: "DCAST(CharacterVertexSlider, @)".}

type
  JointVertexTransform* {.importcpp: "PT(JointVertexTransform)", bycopy, pure, inheritable, header: "jointVertexTransform.h".} = object of VertexTransform

converter toJointVertexTransform*(_: type(nil)): JointVertexTransform {.importcpp: "(nullptr)".}
converter toBool*(this: JointVertexTransform): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: JointVertexTransform, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[JointVertexTransform], obj: TypedObject): JointVertexTransform {.importcpp: "DCAST(JointVertexTransform, @)".}

type
  Character* {.importcpp: "PT(Character)", bycopy, pure, inheritable, header: "character.h".} = object of PartBundleNode

converter toCharacter*(_: type(nil)): Character {.importcpp: "(nullptr)".}
converter toBool*(this: Character): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Character, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Character], obj: TypedObject): Character {.importcpp: "DCAST(Character, @)".}

type
  CharacterJointBundle* {.importcpp: "PT(CharacterJointBundle)", bycopy, pure, inheritable, header: "characterJointBundle.h".} = object of PartBundle

converter toCharacterJointBundle*(_: type(nil)): CharacterJointBundle {.importcpp: "(nullptr)".}
converter toBool*(this: CharacterJointBundle): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CharacterJointBundle, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CharacterJointBundle], obj: TypedObject): CharacterJointBundle {.importcpp: "DCAST(CharacterJointBundle, @)".}

type
  CharacterJointEffect* {.importcpp: "PT(CharacterJointEffect)", bycopy, pure, inheritable, header: "characterJointEffect.h".} = object of RenderEffect

converter toCharacterJointEffect*(_: type(nil)): CharacterJointEffect {.importcpp: "(nullptr)".}
converter toBool*(this: CharacterJointEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CharacterJointEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CharacterJointEffect], obj: TypedObject): CharacterJointEffect {.importcpp: "DCAST(CharacterJointEffect, @)".}

type
  CollisionSolid* {.importcpp: "PT(CollisionSolid)", bycopy, pure, inheritable, header: "collisionSolid.h".} = object of CopyOnWriteObject

converter toCollisionSolid*(_: type(nil)): CollisionSolid {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionSolid): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionSolid, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionSolid], obj: TypedObject): CollisionSolid {.importcpp: "DCAST(CollisionSolid, @)".}

type
  CollisionBox* {.importcpp: "PT(CollisionBox)", bycopy, pure, inheritable, header: "collisionBox.h".} = object of CollisionSolid

converter toCollisionBox*(_: type(nil)): CollisionBox {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionBox): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionBox, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionBox], obj: TypedObject): CollisionBox {.importcpp: "DCAST(CollisionBox, @)".}

type
  CollisionCapsule* {.importcpp: "PT(CollisionCapsule)", bycopy, pure, inheritable, header: "collisionCapsule.h".} = object of CollisionSolid

converter toCollisionCapsule*(_: type(nil)): CollisionCapsule {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionCapsule): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionCapsule, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionCapsule], obj: TypedObject): CollisionCapsule {.importcpp: "DCAST(CollisionCapsule, @)".}

type
  CollisionHandler* {.importcpp: "PT(CollisionHandler)", bycopy, pure, inheritable, header: "collisionHandler.h".} = object of TypedReferenceCount

converter toCollisionHandler*(_: type(nil)): CollisionHandler {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionHandler): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionHandler, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionHandler], obj: TypedObject): CollisionHandler {.importcpp: "DCAST(CollisionHandler, @)".}

type
  CollisionNode* {.importcpp: "PT(CollisionNode)", bycopy, pure, inheritable, header: "collisionNode.h".} = object of PandaNode

converter toCollisionNode*(_: type(nil)): CollisionNode {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionNode], obj: TypedObject): CollisionNode {.importcpp: "DCAST(CollisionNode, @)".}

type
  CollisionTraverser* {.importcpp: "CollisionTraverser", pure, inheritable, header: "collisionTraverser.h".} = object of Namable

type
  CollisionRecorder* {.importcpp: "CollisionRecorder", pure, inheritable, header: "collisionRecorder.h".} = object of TypedObject

type
  CollisionEntry* {.importcpp: "PT(CollisionEntry)", bycopy, pure, inheritable, header: "collisionEntry.h".} = object of TypedWritableReferenceCount

converter toCollisionEntry*(_: type(nil)): CollisionEntry {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionEntry): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionEntry, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionEntry], obj: TypedObject): CollisionEntry {.importcpp: "DCAST(CollisionEntry, @)".}

type
  CollisionPlane* {.importcpp: "PT(CollisionPlane)", bycopy, pure, inheritable, header: "collisionPlane.h".} = object of CollisionSolid

converter toCollisionPlane*(_: type(nil)): CollisionPlane {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionPlane): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionPlane, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionPlane], obj: TypedObject): CollisionPlane {.importcpp: "DCAST(CollisionPlane, @)".}

type
  CollisionFloorMesh* {.importcpp: "PT(CollisionFloorMesh)", bycopy, pure, inheritable, header: "collisionFloorMesh.h".} = object of CollisionSolid

converter toCollisionFloorMesh*(_: type(nil)): CollisionFloorMesh {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionFloorMesh): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionFloorMesh, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionFloorMesh], obj: TypedObject): CollisionFloorMesh {.importcpp: "DCAST(CollisionFloorMesh, @)".}

type
  CollisionPolygon* {.importcpp: "PT(CollisionPolygon)", bycopy, pure, inheritable, header: "collisionPolygon.h".} = object of CollisionPlane

converter toCollisionPolygon*(_: type(nil)): CollisionPolygon {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionPolygon): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionPolygon, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionPolygon], obj: TypedObject): CollisionPolygon {.importcpp: "DCAST(CollisionPolygon, @)".}

type
  CollisionHandlerEvent* {.importcpp: "PT(CollisionHandlerEvent)", bycopy, pure, inheritable, header: "collisionHandlerEvent.h".} = object of CollisionHandler

converter toCollisionHandlerEvent*(_: type(nil)): CollisionHandlerEvent {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionHandlerEvent): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionHandlerEvent, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionHandlerEvent], obj: TypedObject): CollisionHandlerEvent {.importcpp: "DCAST(CollisionHandlerEvent, @)".}

type
  CollisionHandlerPhysical* {.importcpp: "PT(CollisionHandlerPhysical)", bycopy, pure, inheritable, header: "collisionHandlerPhysical.h".} = object of CollisionHandlerEvent

converter toCollisionHandlerPhysical*(_: type(nil)): CollisionHandlerPhysical {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionHandlerPhysical): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionHandlerPhysical, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionHandlerPhysical], obj: TypedObject): CollisionHandlerPhysical {.importcpp: "DCAST(CollisionHandlerPhysical, @)".}

type
  CollisionHandlerFloor* {.importcpp: "PT(CollisionHandlerFloor)", bycopy, pure, inheritable, header: "collisionHandlerFloor.h".} = object of CollisionHandlerPhysical

converter toCollisionHandlerFloor*(_: type(nil)): CollisionHandlerFloor {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionHandlerFloor): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionHandlerFloor, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionHandlerFloor], obj: TypedObject): CollisionHandlerFloor {.importcpp: "DCAST(CollisionHandlerFloor, @)".}

type
  CollisionHandlerPusher* {.importcpp: "PT(CollisionHandlerPusher)", bycopy, pure, inheritable, header: "collisionHandlerPusher.h".} = object of CollisionHandlerPhysical

converter toCollisionHandlerPusher*(_: type(nil)): CollisionHandlerPusher {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionHandlerPusher): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionHandlerPusher, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionHandlerPusher], obj: TypedObject): CollisionHandlerPusher {.importcpp: "DCAST(CollisionHandlerPusher, @)".}

type
  CollisionHandlerFluidPusher* {.importcpp: "PT(CollisionHandlerFluidPusher)", bycopy, pure, inheritable, header: "collisionHandlerFluidPusher.h".} = object of CollisionHandlerPusher

converter toCollisionHandlerFluidPusher*(_: type(nil)): CollisionHandlerFluidPusher {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionHandlerFluidPusher): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionHandlerFluidPusher, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionHandlerFluidPusher], obj: TypedObject): CollisionHandlerFluidPusher {.importcpp: "DCAST(CollisionHandlerFluidPusher, @)".}

type
  CollisionHandlerGravity* {.importcpp: "PT(CollisionHandlerGravity)", bycopy, pure, inheritable, header: "collisionHandlerGravity.h".} = object of CollisionHandlerPhysical

converter toCollisionHandlerGravity*(_: type(nil)): CollisionHandlerGravity {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionHandlerGravity): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionHandlerGravity, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionHandlerGravity], obj: TypedObject): CollisionHandlerGravity {.importcpp: "DCAST(CollisionHandlerGravity, @)".}

type
  CollisionHandlerHighestEvent* {.importcpp: "PT(CollisionHandlerHighestEvent)", bycopy, pure, inheritable, header: "collisionHandlerHighestEvent.h".} = object of CollisionHandlerEvent

converter toCollisionHandlerHighestEvent*(_: type(nil)): CollisionHandlerHighestEvent {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionHandlerHighestEvent): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionHandlerHighestEvent, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionHandlerHighestEvent], obj: TypedObject): CollisionHandlerHighestEvent {.importcpp: "DCAST(CollisionHandlerHighestEvent, @)".}

type
  CollisionHandlerQueue* {.importcpp: "PT(CollisionHandlerQueue)", bycopy, pure, inheritable, header: "collisionHandlerQueue.h".} = object of CollisionHandler

converter toCollisionHandlerQueue*(_: type(nil)): CollisionHandlerQueue {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionHandlerQueue): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionHandlerQueue, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionHandlerQueue], obj: TypedObject): CollisionHandlerQueue {.importcpp: "DCAST(CollisionHandlerQueue, @)".}

type
  CollisionSphere* {.importcpp: "PT(CollisionSphere)", bycopy, pure, inheritable, header: "collisionSphere.h".} = object of CollisionSolid

converter toCollisionSphere*(_: type(nil)): CollisionSphere {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionSphere): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionSphere, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionSphere], obj: TypedObject): CollisionSphere {.importcpp: "DCAST(CollisionSphere, @)".}

type
  CollisionInvSphere* {.importcpp: "PT(CollisionInvSphere)", bycopy, pure, inheritable, header: "collisionInvSphere.h".} = object of CollisionSphere

converter toCollisionInvSphere*(_: type(nil)): CollisionInvSphere {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionInvSphere): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionInvSphere, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionInvSphere], obj: TypedObject): CollisionInvSphere {.importcpp: "DCAST(CollisionInvSphere, @)".}

type
  CollisionRay* {.importcpp: "PT(CollisionRay)", bycopy, pure, inheritable, header: "collisionRay.h".} = object of CollisionSolid

converter toCollisionRay*(_: type(nil)): CollisionRay {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionRay): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionRay, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionRay], obj: TypedObject): CollisionRay {.importcpp: "DCAST(CollisionRay, @)".}

type
  CollisionLine* {.importcpp: "PT(CollisionLine)", bycopy, pure, inheritable, header: "collisionLine.h".} = object of CollisionRay

converter toCollisionLine*(_: type(nil)): CollisionLine {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionLine): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionLine, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionLine], obj: TypedObject): CollisionLine {.importcpp: "DCAST(CollisionLine, @)".}

type
  CollisionParabola* {.importcpp: "PT(CollisionParabola)", bycopy, pure, inheritable, header: "collisionParabola.h".} = object of CollisionSolid

converter toCollisionParabola*(_: type(nil)): CollisionParabola {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionParabola): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionParabola, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionParabola], obj: TypedObject): CollisionParabola {.importcpp: "DCAST(CollisionParabola, @)".}

type
  CollisionSegment* {.importcpp: "PT(CollisionSegment)", bycopy, pure, inheritable, header: "collisionSegment.h".} = object of CollisionSolid

converter toCollisionSegment*(_: type(nil)): CollisionSegment {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionSegment): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionSegment, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionSegment], obj: TypedObject): CollisionSegment {.importcpp: "DCAST(CollisionSegment, @)".}

type
  CollisionTube* = CollisionCapsule

type
  CollisionVisualizer* {.importcpp: "PT(CollisionVisualizer)", bycopy, pure, inheritable, header: "collisionVisualizer.h".} = object of PandaNode

converter toCollisionVisualizer*(_: type(nil)): CollisionVisualizer {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionVisualizer): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionVisualizer, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionVisualizer], obj: TypedObject): CollisionVisualizer {.importcpp: "DCAST(CollisionVisualizer, @)".}

type
  TrackerData* {.importcpp: "TrackerData", pure, inheritable, header: "trackerData.h".} = object

type
  InputDevice* {.importcpp: "PT(InputDevice)", bycopy, pure, inheritable, header: "inputDevice.h".} = object of TypedReferenceCount

converter toInputDevice*(_: type(nil)): InputDevice {.importcpp: "(nullptr)".}
converter toBool*(this: InputDevice): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: InputDevice, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[InputDevice], obj: TypedObject): InputDevice {.importcpp: "DCAST(InputDevice, @)".}

type
  ClientBase* {.importcpp: "PT(ClientBase)", bycopy, pure, inheritable, header: "clientBase.h".} = object of TypedReferenceCount

converter toClientBase*(_: type(nil)): ClientBase {.importcpp: "(nullptr)".}
converter toBool*(this: ClientBase): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ClientBase, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ClientBase], obj: TypedObject): ClientBase {.importcpp: "DCAST(ClientBase, @)".}

type
  AnalogNode* {.importcpp: "PT(AnalogNode)", bycopy, pure, inheritable, header: "analogNode.h".} = object of DataNode

converter toAnalogNode*(_: type(nil)): AnalogNode {.importcpp: "(nullptr)".}
converter toBool*(this: AnalogNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnalogNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnalogNode], obj: TypedObject): AnalogNode {.importcpp: "DCAST(AnalogNode, @)".}

type
  ButtonNode* {.importcpp: "PT(ButtonNode)", bycopy, pure, inheritable, header: "buttonNode.h".} = object of DataNode

converter toButtonNode*(_: type(nil)): ButtonNode {.importcpp: "(nullptr)".}
converter toBool*(this: ButtonNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ButtonNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ButtonNode], obj: TypedObject): ButtonNode {.importcpp: "DCAST(ButtonNode, @)".}

type
  DialNode* {.importcpp: "PT(DialNode)", bycopy, pure, inheritable, header: "dialNode.h".} = object of DataNode

converter toDialNode*(_: type(nil)): DialNode {.importcpp: "(nullptr)".}
converter toBool*(this: DialNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DialNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DialNode], obj: TypedObject): DialNode {.importcpp: "DCAST(DialNode, @)".}

type
  InputDeviceSet* {.importcpp: "InputDeviceSet", pure, inheritable, header: "inputDeviceSet.h".} = object

type
  InputDeviceManager* {.importcpp: "InputDeviceManager", pure, inheritable, header: "inputDeviceManager.h".} = object

type
  InputDeviceNode* {.importcpp: "PT(InputDeviceNode)", bycopy, pure, inheritable, header: "inputDeviceNode.h".} = object of DataNode

converter toInputDeviceNode*(_: type(nil)): InputDeviceNode {.importcpp: "(nullptr)".}
converter toBool*(this: InputDeviceNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: InputDeviceNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[InputDeviceNode], obj: TypedObject): InputDeviceNode {.importcpp: "DCAST(InputDeviceNode, @)".}

type
  TrackerNode* {.importcpp: "PT(TrackerNode)", bycopy, pure, inheritable, header: "trackerNode.h".} = object of DataNode

converter toTrackerNode*(_: type(nil)): TrackerNode {.importcpp: "(nullptr)".}
converter toBool*(this: TrackerNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TrackerNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TrackerNode], obj: TypedObject): TrackerNode {.importcpp: "DCAST(TrackerNode, @)".}

type
  VirtualMouse* {.importcpp: "PT(VirtualMouse)", bycopy, pure, inheritable, header: "virtualMouse.h".} = object of DataNode

converter toVirtualMouse*(_: type(nil)): VirtualMouse {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualMouse): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualMouse, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualMouse], obj: TypedObject): VirtualMouse {.importcpp: "DCAST(VirtualMouse, @)".}

type
  DataGraphTraverser* {.importcpp: "DataGraphTraverser", pure, inheritable, header: "dataGraphTraverser.h".} = object

type
  GraphicsDevice* {.importcpp: "PT(GraphicsDevice)", bycopy, pure, inheritable, header: "graphicsDevice.h".} = object of TypedReferenceCount

converter toGraphicsDevice*(_: type(nil)): GraphicsDevice {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsDevice): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsDevice, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsDevice], obj: TypedObject): GraphicsDevice {.importcpp: "DCAST(GraphicsDevice, @)".}

type
  GraphicsPipe* {.importcpp: "PT(GraphicsPipe)", bycopy, pure, inheritable, header: "graphicsPipe.h".} = object of TypedReferenceCount

converter toGraphicsPipe*(_: type(nil)): GraphicsPipe {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsPipe): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsPipe, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsPipe], obj: TypedObject): GraphicsPipe {.importcpp: "DCAST(GraphicsPipe, @)".}

type
  DisplayInformation* {.importcpp: "DisplayInformation", pure, inheritable, header: "displayInformation.h".} = object

type
  DrawableRegion* {.importcpp: "DrawableRegion", pure, inheritable, header: "drawableRegion.h".} = object

type
  WindowHandle* {.importcpp: "PT(WindowHandle)", bycopy, pure, inheritable, header: "windowHandle.h".} = object of TypedReferenceCount

converter toWindowHandle*(_: type(nil)): WindowHandle {.importcpp: "(nullptr)".}
converter toBool*(this: WindowHandle): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: WindowHandle, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[WindowHandle], obj: TypedObject): WindowHandle {.importcpp: "DCAST(WindowHandle, @)".}

type
  WindowProperties* {.importcpp: "WindowProperties", pure, inheritable, header: "windowProperties.h".} = object

type
  DisplayRegion* {.importcpp: "PT(DisplayRegion)", bycopy, pure, inheritable, header: "displayRegion.h".} = object of TypedReferenceCount

converter toDisplayRegion*(_: type(nil)): DisplayRegion {.importcpp: "(nullptr)".}
converter toBool*(this: DisplayRegion): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DisplayRegion, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DisplayRegion], obj: TypedObject): DisplayRegion {.importcpp: "DCAST(DisplayRegion, @)".}

type
  GraphicsOutputBase* {.importcpp: "PT(GraphicsOutputBase)", bycopy, pure, inheritable, header: "graphicsOutputBase.h".} = object of TypedWritableReferenceCount

converter toGraphicsOutputBase*(_: type(nil)): GraphicsOutputBase {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsOutputBase): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsOutputBase, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsOutputBase], obj: TypedObject): GraphicsOutputBase {.importcpp: "DCAST(GraphicsOutputBase, @)".}

type
  GraphicsOutput* {.importcpp: "PT(GraphicsOutput)", bycopy, pure, inheritable, header: "graphicsOutput.h".} = object of GraphicsOutputBase

converter toGraphicsOutput*(_: type(nil)): GraphicsOutput {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsOutput): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsOutput, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsOutput], obj: TypedObject): GraphicsOutput {.importcpp: "DCAST(GraphicsOutput, @)".}

type
  GraphicsStateGuardianBase* {.importcpp: "PT(GraphicsStateGuardianBase)", bycopy, pure, inheritable, header: "graphicsStateGuardianBase.h".} = object of TypedWritableReferenceCount

converter toGraphicsStateGuardianBase*(_: type(nil)): GraphicsStateGuardianBase {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsStateGuardianBase): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsStateGuardianBase, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsStateGuardianBase], obj: TypedObject): GraphicsStateGuardianBase {.importcpp: "DCAST(GraphicsStateGuardianBase, @)".}

type
  GraphicsStateGuardian* {.importcpp: "PT(GraphicsStateGuardian)", bycopy, pure, inheritable, header: "graphicsStateGuardian.h".} = object of GraphicsStateGuardianBase

converter toGraphicsStateGuardian*(_: type(nil)): GraphicsStateGuardian {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsStateGuardian): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsStateGuardian, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsStateGuardian], obj: TypedObject): GraphicsStateGuardian {.importcpp: "DCAST(GraphicsStateGuardian, @)".}

type
  GraphicsEngine* {.importcpp: "PT(GraphicsEngine)", bycopy, pure, inheritable, header: "graphicsEngine.h".} = object of ReferenceCount

converter toGraphicsEngine*(_: type(nil)): GraphicsEngine {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsEngine): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsEngine, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsEngine], obj: TypedObject): GraphicsEngine {.importcpp: "DCAST(GraphicsEngine, @)".}

type
  GraphicsThreadingModel* {.importcpp: "GraphicsThreadingModel", pure, inheritable, header: "graphicsThreadingModel.h".} = object

type
  StereoDisplayRegion* {.importcpp: "PT(StereoDisplayRegion)", bycopy, pure, inheritable, header: "stereoDisplayRegion.h".} = object of DisplayRegion

converter toStereoDisplayRegion*(_: type(nil)): StereoDisplayRegion {.importcpp: "(nullptr)".}
converter toBool*(this: StereoDisplayRegion): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: StereoDisplayRegion, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[StereoDisplayRegion], obj: TypedObject): StereoDisplayRegion {.importcpp: "DCAST(StereoDisplayRegion, @)".}

type
  FrameBufferProperties* {.importcpp: "FrameBufferProperties", pure, inheritable, header: "frameBufferProperties.h".} = object

type
  GraphicsWindowInputDevice* {.importcpp: "PT(GraphicsWindowInputDevice)", bycopy, pure, inheritable, header: "graphicsWindowInputDevice.h".} = object of InputDevice

converter toGraphicsWindowInputDevice*(_: type(nil)): GraphicsWindowInputDevice {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsWindowInputDevice): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsWindowInputDevice, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsWindowInputDevice], obj: TypedObject): GraphicsWindowInputDevice {.importcpp: "DCAST(GraphicsWindowInputDevice, @)".}

type
  TouchInfo* {.importcpp: "TouchInfo", pure, inheritable, header: "touchInfo.h".} = object

type
  GraphicsWindowProcCallbackData* {.importcpp: "GraphicsWindowProcCallbackData", pure, inheritable, header: "graphicsWindowProcCallbackData.h".} = object of CallbackData

type
  GraphicsWindow* {.importcpp: "PT(GraphicsWindow)", bycopy, pure, inheritable, header: "graphicsWindow.h".} = object of GraphicsOutput

converter toGraphicsWindow*(_: type(nil)): GraphicsWindow {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsWindow): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsWindow, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsWindow], obj: TypedObject): GraphicsWindow {.importcpp: "DCAST(GraphicsWindow, @)".}

type
  CallbackGraphicsWindow* {.importcpp: "PT(CallbackGraphicsWindow)", bycopy, pure, inheritable, header: "callbackGraphicsWindow.h".} = object of GraphicsWindow

converter toCallbackGraphicsWindow*(_: type(nil)): CallbackGraphicsWindow {.importcpp: "(nullptr)".}
converter toBool*(this: CallbackGraphicsWindow): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CallbackGraphicsWindow, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CallbackGraphicsWindow], obj: TypedObject): CallbackGraphicsWindow {.importcpp: "DCAST(CallbackGraphicsWindow, @)".}

type
  DisplayMode* {.importcpp: "DisplayMode", pure, inheritable, header: "displayMode.h".} = object

type
  DisplayRegionCullCallbackData* {.importcpp: "DisplayRegionCullCallbackData", pure, inheritable, header: "displayRegionCullCallbackData.h".} = object of CallbackData

type
  DisplayRegionDrawCallbackData* {.importcpp: "DisplayRegionDrawCallbackData", pure, inheritable, header: "displayRegionDrawCallbackData.h".} = object of CallbackData

type
  DisplaySearchParameters* {.importcpp: "DisplaySearchParameters", pure, inheritable, header: "displaySearchParameters.h".} = object

type
  GraphicsBuffer* {.importcpp: "PT(GraphicsBuffer)", bycopy, pure, inheritable, header: "graphicsBuffer.h".} = object of GraphicsOutput

converter toGraphicsBuffer*(_: type(nil)): GraphicsBuffer {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsBuffer): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsBuffer, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsBuffer], obj: TypedObject): GraphicsBuffer {.importcpp: "DCAST(GraphicsBuffer, @)".}

type
  GraphicsPipeSelection* {.importcpp: "GraphicsPipeSelection*", bycopy, pure, inheritable, header: "graphicsPipeSelection.h".} = object

converter toGraphicsPipeSelection*(_: type(nil)): GraphicsPipeSelection {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsPipeSelection): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsPipeSelection, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type
  MouseAndKeyboard* {.importcpp: "PT(MouseAndKeyboard)", bycopy, pure, inheritable, header: "mouseAndKeyboard.h".} = object of DataNode

converter toMouseAndKeyboard*(_: type(nil)): MouseAndKeyboard {.importcpp: "(nullptr)".}
converter toBool*(this: MouseAndKeyboard): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MouseAndKeyboard, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MouseAndKeyboard], obj: TypedObject): MouseAndKeyboard {.importcpp: "DCAST(MouseAndKeyboard, @)".}

type
  NativeWindowHandle* {.importcpp: "PT(NativeWindowHandle)", bycopy, pure, header: "nativeWindowHandle.h".} = object of WindowHandle

converter toNativeWindowHandle*(_: type(nil)): NativeWindowHandle {.importcpp: "(nullptr)".}
converter toBool*(this: NativeWindowHandle): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: NativeWindowHandle, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[NativeWindowHandle], obj: TypedObject): NativeWindowHandle {.importcpp: "DCAST(NativeWindowHandle, @)".}

type
  ParasiteBuffer* {.importcpp: "PT(ParasiteBuffer)", bycopy, pure, inheritable, header: "parasiteBuffer.h".} = object of GraphicsOutput

converter toParasiteBuffer*(_: type(nil)): ParasiteBuffer {.importcpp: "(nullptr)".}
converter toBool*(this: ParasiteBuffer): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ParasiteBuffer, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ParasiteBuffer], obj: TypedObject): ParasiteBuffer {.importcpp: "DCAST(ParasiteBuffer, @)".}

type
  ThreadPriority* = enum
    TP_low = 0
    TP_normal = 1
    TP_high = 2
    TP_urgent = 3

type
  Thread* {.importcpp: "PT(Thread)", bycopy, pure, inheritable, header: "thread.h".} = object of TypedReferenceCount

converter toThread*(_: type(nil)): Thread {.importcpp: "(nullptr)".}
converter toBool*(this: Thread): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Thread, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Thread], obj: TypedObject): Thread {.importcpp: "DCAST(Thread, @)".}

type
  MutexDirect* {.importcpp: "MutexDirect", pure, inheritable, header: "mutexDirect.h".} = object

type
  Mutex* {.importcpp: "Mutex", pure, inheritable, header: "mutex.h".} = object of MutexDirect

type
  ConditionVarDirect* {.importcpp: "ConditionVarDirect", pure, inheritable, header: "conditionVarDirect.h".} = object

type
  ConditionVar* {.importcpp: "ConditionVar", pure, inheritable, header: "conditionVar.h".} = object of ConditionVarDirect

type
  ConditionVarFullDirect* {.importcpp: "ConditionVarFullDirect", pure, inheritable, header: "conditionVarFullDirect.h".} = object

type
  ConditionVarFull* {.importcpp: "ConditionVarFull", pure, inheritable, header: "conditionVarFull.h".} = object of ConditionVarFullDirect

type
  ReMutexDirect* {.importcpp: "ReMutexDirect", pure, inheritable, header: "reMutexDirect.h".} = object

type
  ReMutex* {.importcpp: "ReMutex", pure, inheritable, header: "reMutex.h".} = object of ReMutexDirect

type
  ExternalThread* {.importcpp: "PT(ExternalThread)", bycopy, pure, inheritable, header: "externalThread.h".} = object of Thread

converter toExternalThread*(_: type(nil)): ExternalThread {.importcpp: "(nullptr)".}
converter toBool*(this: ExternalThread): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ExternalThread, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ExternalThread], obj: TypedObject): ExternalThread {.importcpp: "DCAST(ExternalThread, @)".}

type
  LightMutexDirect* {.importcpp: "LightMutexDirect", pure, inheritable, header: "lightMutexDirect.h".} = object

type
  LightMutex* {.importcpp: "LightMutex", pure, inheritable, header: "lightMutex.h".} = object of LightMutexDirect

type
  LightReMutexDirect* {.importcpp: "LightReMutexDirect", pure, inheritable, header: "lightReMutexDirect.h".} = object

type
  LightReMutex* {.importcpp: "LightReMutex", pure, inheritable, header: "lightReMutex.h".} = object of LightReMutexDirect

type
  MainThread* {.importcpp: "PT(MainThread)", bycopy, pure, inheritable, header: "mainThread.h".} = object of Thread

converter toMainThread*(_: type(nil)): MainThread {.importcpp: "(nullptr)".}
converter toBool*(this: MainThread): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MainThread, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MainThread], obj: TypedObject): MainThread {.importcpp: "DCAST(MainThread, @)".}

type
  Semaphore* {.importcpp: "Semaphore", pure, inheritable, header: "semaphore.h".} = object

type
  PythonThread* {.importcpp: "PT(PythonThread)", bycopy, pure, inheritable, header: "pythonThread.h".} = object of Thread

converter toPythonThread*(_: type(nil)): PythonThread {.importcpp: "(nullptr)".}
converter toBool*(this: PythonThread): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PythonThread, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PythonThread], obj: TypedObject): PythonThread {.importcpp: "DCAST(PythonThread, @)".}

type
  EventParameter* {.importcpp: "EventParameter", pure, inheritable, header: "eventParameter.h".} = object

type
  AsyncTaskManager* {.importcpp: "PT(AsyncTaskManager)", bycopy, pure, inheritable, header: "asyncTaskManager.h".} = object of TypedReferenceCount

converter toAsyncTaskManager*(_: type(nil)): AsyncTaskManager {.importcpp: "(nullptr)".}
converter toBool*(this: AsyncTaskManager): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AsyncTaskManager, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AsyncTaskManager], obj: TypedObject): AsyncTaskManager {.importcpp: "DCAST(AsyncTaskManager, @)".}

type
  AsyncTaskCollection* {.importcpp: "AsyncTaskCollection", pure, inheritable, header: "asyncTaskCollection.h".} = object

type
  AsyncTaskChain* {.importcpp: "PT(AsyncTaskChain)", bycopy, pure, inheritable, header: "asyncTaskChain.h".} = object of TypedReferenceCount

converter toAsyncTaskChain*(_: type(nil)): AsyncTaskChain {.importcpp: "(nullptr)".}
converter toBool*(this: AsyncTaskChain): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AsyncTaskChain, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AsyncTaskChain], obj: TypedObject): AsyncTaskChain {.importcpp: "DCAST(AsyncTaskChain, @)".}

type
  AsyncTaskPause* {.importcpp: "PT(AsyncTaskPause)", bycopy, pure, inheritable, header: "asyncTaskPause.h".} = object of AsyncTask

converter toAsyncTaskPause*(_: type(nil)): AsyncTaskPause {.importcpp: "(nullptr)".}
converter toBool*(this: AsyncTaskPause): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AsyncTaskPause, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AsyncTaskPause], obj: TypedObject): AsyncTaskPause {.importcpp: "DCAST(AsyncTaskPause, @)".}

type
  AsyncTaskSequence* {.importcpp: "PT(AsyncTaskSequence)", bycopy, pure, inheritable, header: "asyncTaskSequence.h".} = object of AsyncTask

converter toAsyncTaskSequence*(_: type(nil)): AsyncTaskSequence {.importcpp: "(nullptr)".}
converter toBool*(this: AsyncTaskSequence): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AsyncTaskSequence, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AsyncTaskSequence], obj: TypedObject): AsyncTaskSequence {.importcpp: "DCAST(AsyncTaskSequence, @)".}

type
  ButtonEvent* {.importcpp: "ButtonEvent", pure, inheritable, header: "buttonEvent.h".} = object

type
  ParamValueBase* {.importcpp: "PT(ParamValueBase)", bycopy, pure, inheritable, header: "paramValueBase.h".} = object of TypedWritableReferenceCount

converter toParamValueBase*(_: type(nil)): ParamValueBase {.importcpp: "(nullptr)".}
converter toBool*(this: ParamValueBase): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ParamValueBase, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ParamValueBase], obj: TypedObject): ParamValueBase {.importcpp: "DCAST(ParamValueBase, @)".}

type
  ButtonEventList* {.importcpp: "PT(ButtonEventList)", bycopy, pure, inheritable, header: "buttonEventList.h".} = object of ParamValueBase

converter toButtonEventList*(_: type(nil)): ButtonEventList {.importcpp: "(nullptr)".}
converter toBool*(this: ButtonEventList): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ButtonEventList, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ButtonEventList], obj: TypedObject): ButtonEventList {.importcpp: "DCAST(ButtonEventList, @)".}

type
  Event* {.importcpp: "PT(Event)", bycopy, pure, inheritable, header: "event.h".} = object of TypedReferenceCount

converter toEvent*(_: type(nil)): Event {.importcpp: "(nullptr)".}
converter toBool*(this: Event): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Event, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Event], obj: TypedObject): Event {.importcpp: "DCAST(Event, @)".}

type
  EventHandler* {.importcpp: "EventHandler", pure, inheritable, header: "eventHandler.h".} = object of TypedObject

type
  EventQueue* {.importcpp: "EventQueue*", bycopy, pure, inheritable, header: "eventQueue.h".} = object

converter toEventQueue*(_: type(nil)): EventQueue {.importcpp: "(nullptr)".}
converter toBool*(this: EventQueue): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: EventQueue, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type
  PointerEventList* {.importcpp: "PT(PointerEventList)", bycopy, pure, inheritable, header: "pointerEventList.h".} = object of ParamValueBase

converter toPointerEventList*(_: type(nil)): PointerEventList {.importcpp: "(nullptr)".}
converter toBool*(this: PointerEventList): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PointerEventList, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PointerEventList], obj: TypedObject): PointerEventList {.importcpp: "DCAST(PointerEventList, @)".}

type
  PythonTask* {.importcpp: "PT(PythonTask)", bycopy, pure, header: "pythonTask.h".} = object of AsyncTask

converter toPythonTask*(_: type(nil)): PythonTask {.importcpp: "(nullptr)".}
converter toBool*(this: PythonTask): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PythonTask, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PythonTask], obj: TypedObject): PythonTask {.importcpp: "DCAST(PythonTask, @)".}

type
  AdaptiveLru* {.importcpp: "AdaptiveLru", pure, inheritable, header: "adaptiveLru.h".} = object of Namable

type
  AdaptiveLruPage* {.importcpp: "AdaptiveLruPage", pure, inheritable, header: "adaptiveLruPage.h".} = object

type
  GeomEnums* {.importcpp: "GeomEnums", pure, inheritable, header: "geomEnums.h".} = object

type
  GeomVertexAnimationSpec* {.importcpp: "GeomVertexAnimationSpec", pure, inheritable, header: "geomVertexAnimationSpec.h".} = object of GeomEnums

type
  InternalName* {.importcpp: "PT(InternalName)", bycopy, pure, header: "internalName.h".} = object of TypedWritableReferenceCount

converter toInternalName*(_: type(nil)): InternalName {.importcpp: "(nullptr)".}
converter toBool*(this: InternalName): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: InternalName, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[InternalName], obj: TypedObject): InternalName {.importcpp: "DCAST(InternalName, @)".}

type
  GeomVertexColumn* {.importcpp: "GeomVertexColumn", pure, inheritable, header: "geomVertexColumn.h".} = object of GeomEnums

type
  GeomVertexArrayFormat* {.importcpp: "PT(GeomVertexArrayFormat)", bycopy, pure, header: "geomVertexArrayFormat.h".} = object of TypedWritableReferenceCount

converter toGeomVertexArrayFormat*(_: type(nil)): GeomVertexArrayFormat {.importcpp: "(nullptr)".}
converter toBool*(this: GeomVertexArrayFormat): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomVertexArrayFormat, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomVertexArrayFormat], obj: TypedObject): GeomVertexArrayFormat {.importcpp: "DCAST(GeomVertexArrayFormat, @)".}

type
  GeomVertexFormat* {.importcpp: "PT(GeomVertexFormat)", bycopy, pure, header: "geomVertexFormat.h".} = object of TypedWritableReferenceCount

converter toGeomVertexFormat*(_: type(nil)): GeomVertexFormat {.importcpp: "(nullptr)".}
converter toBool*(this: GeomVertexFormat): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomVertexFormat, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomVertexFormat], obj: TypedObject): GeomVertexFormat {.importcpp: "DCAST(GeomVertexFormat, @)".}

type
  SimpleLru* {.importcpp: "SimpleLru", pure, inheritable, header: "simpleLru.h".} = object of Namable

type
  SimpleLruPage* {.importcpp: "SimpleLruPage", pure, inheritable, header: "simpleLruPage.h".} = object

type
  SimpleAllocator* {.importcpp: "SimpleAllocator", pure, inheritable, header: "simpleAllocator.h".} = object

type
  SimpleAllocatorBlock* {.importcpp: "SimpleAllocatorBlock", pure, inheritable, header: "simpleAllocatorBlock.h".} = object

type
  VertexDataSaveFile* {.importcpp: "VertexDataSaveFile", pure, inheritable, header: "vertexDataSaveFile.h".} = object of SimpleAllocator

type
  VertexDataPage* {.importcpp: "VertexDataPage", pure, inheritable, header: "vertexDataPage.h".} = object of SimpleAllocator

type
  VertexDataBook* {.importcpp: "VertexDataBook", pure, inheritable, header: "vertexDataBook.h".} = object

type
  VertexDataBlock* {.importcpp: "PT(VertexDataBlock)", bycopy, pure, inheritable, header: "vertexDataBlock.h".} = object of SimpleAllocatorBlock

converter toVertexDataBlock*(_: type(nil)): VertexDataBlock {.importcpp: "(nullptr)".}
converter toBool*(this: VertexDataBlock): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VertexDataBlock, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VertexDataBlock], obj: TypedObject): VertexDataBlock {.importcpp: "DCAST(VertexDataBlock, @)".}

type
  GeomVertexArrayData* {.importcpp: "PT(GeomVertexArrayData)", bycopy, pure, inheritable, header: "geomVertexArrayData.h".} = object of CopyOnWriteObject

converter toGeomVertexArrayData*(_: type(nil)): GeomVertexArrayData {.importcpp: "(nullptr)".}
converter toBool*(this: GeomVertexArrayData): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomVertexArrayData, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomVertexArrayData], obj: TypedObject): GeomVertexArrayData {.importcpp: "DCAST(GeomVertexArrayData, @)".}

type
  GeomVertexArrayDataHandle* {.importcpp: "PT(GeomVertexArrayDataHandle)", bycopy, pure, inheritable, header: "geomVertexArrayDataHandle.h".} = object of ReferenceCount

converter toGeomVertexArrayDataHandle*(_: type(nil)): GeomVertexArrayDataHandle {.importcpp: "(nullptr)".}
converter toBool*(this: GeomVertexArrayDataHandle): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomVertexArrayDataHandle, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomVertexArrayDataHandle], obj: TypedObject): GeomVertexArrayDataHandle {.importcpp: "DCAST(GeomVertexArrayDataHandle, @)".}

type
  GeomCacheManager* {.importcpp: "GeomCacheManager", pure, inheritable, header: "geomCacheManager.h".} = object

type
  TransformTable* {.importcpp: "PT(TransformTable)", bycopy, pure, inheritable, header: "transformTable.h".} = object of TypedWritableReferenceCount

converter toTransformTable*(_: type(nil)): TransformTable {.importcpp: "(nullptr)".}
converter toBool*(this: TransformTable): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TransformTable, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TransformTable], obj: TypedObject): TransformTable {.importcpp: "DCAST(TransformTable, @)".}

type
  TransformBlend* {.importcpp: "TransformBlend", pure, inheritable, header: "transformBlend.h".} = object

type
  TransformBlendTable* {.importcpp: "PT(TransformBlendTable)", bycopy, pure, inheritable, header: "transformBlendTable.h".} = object of CopyOnWriteObject

converter toTransformBlendTable*(_: type(nil)): TransformBlendTable {.importcpp: "(nullptr)".}
converter toBool*(this: TransformBlendTable): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TransformBlendTable, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TransformBlendTable], obj: TypedObject): TransformBlendTable {.importcpp: "DCAST(TransformBlendTable, @)".}

type
  SliderTable* {.importcpp: "PT(SliderTable)", bycopy, pure, inheritable, header: "sliderTable.h".} = object of TypedWritableReferenceCount

converter toSliderTable*(_: type(nil)): SliderTable {.importcpp: "(nullptr)".}
converter toBool*(this: SliderTable): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SliderTable, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[SliderTable], obj: TypedObject): SliderTable {.importcpp: "DCAST(SliderTable, @)".}

type
  GeomVertexData* {.importcpp: "PT(GeomVertexData)", bycopy, pure, inheritable, header: "geomVertexData.h".} = object of CopyOnWriteObject

converter toGeomVertexData*(_: type(nil)): GeomVertexData {.importcpp: "(nullptr)".}
converter toBool*(this: GeomVertexData): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomVertexData, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomVertexData], obj: TypedObject): GeomVertexData {.importcpp: "DCAST(GeomVertexData, @)".}

type
  AnimateVerticesRequest* {.importcpp: "PT(AnimateVerticesRequest)", bycopy, pure, inheritable, header: "animateVerticesRequest.h".} = object of AsyncTask

converter toAnimateVerticesRequest*(_: type(nil)): AnimateVerticesRequest {.importcpp: "(nullptr)".}
converter toBool*(this: AnimateVerticesRequest): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimateVerticesRequest, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimateVerticesRequest], obj: TypedObject): AnimateVerticesRequest {.importcpp: "DCAST(AnimateVerticesRequest, @)".}

type
  SavedContext* {.importcpp: "SavedContext", pure, inheritable, header: "savedContext.h".} = object of TypedObject

type
  BufferContext* {.importcpp: "BufferContext", pure, inheritable, header: "bufferContext.h".} = object of SavedContext

type
  GeomPrimitive* {.importcpp: "PT(GeomPrimitive)", bycopy, pure, inheritable, header: "geomPrimitive.h".} = object of CopyOnWriteObject

converter toGeomPrimitive*(_: type(nil)): GeomPrimitive {.importcpp: "(nullptr)".}
converter toBool*(this: GeomPrimitive): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomPrimitive, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomPrimitive], obj: TypedObject): GeomPrimitive {.importcpp: "DCAST(GeomPrimitive, @)".}

type
  TextureStage* {.importcpp: "PT(TextureStage)", bycopy, pure, inheritable, header: "textureStage.h".} = object of TypedWritableReferenceCount

converter toTextureStage*(_: type(nil)): TextureStage {.importcpp: "(nullptr)".}
converter toBool*(this: TextureStage): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TextureStage, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TextureStage], obj: TypedObject): TextureStage {.importcpp: "DCAST(TextureStage, @)".}

type
  Geom* {.importcpp: "PT(Geom)", bycopy, pure, inheritable, header: "geom.h".} = object of CopyOnWriteObject

converter toGeom*(_: type(nil)): Geom {.importcpp: "(nullptr)".}
converter toBool*(this: Geom): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Geom, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Geom], obj: TypedObject): Geom {.importcpp: "DCAST(Geom, @)".}

type
  GeomContext* {.importcpp: "GeomContext", pure, inheritable, header: "geomContext.h".} = object of SavedContext

type
  GeomLines* {.importcpp: "PT(GeomLines)", bycopy, pure, inheritable, header: "geomLines.h".} = object of GeomPrimitive

converter toGeomLines*(_: type(nil)): GeomLines {.importcpp: "(nullptr)".}
converter toBool*(this: GeomLines): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomLines, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomLines], obj: TypedObject): GeomLines {.importcpp: "DCAST(GeomLines, @)".}

type
  GeomLinesAdjacency* {.importcpp: "PT(GeomLinesAdjacency)", bycopy, pure, inheritable, header: "geomLinesAdjacency.h".} = object of GeomPrimitive

converter toGeomLinesAdjacency*(_: type(nil)): GeomLinesAdjacency {.importcpp: "(nullptr)".}
converter toBool*(this: GeomLinesAdjacency): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomLinesAdjacency, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomLinesAdjacency], obj: TypedObject): GeomLinesAdjacency {.importcpp: "DCAST(GeomLinesAdjacency, @)".}

type
  GeomLinestrips* {.importcpp: "PT(GeomLinestrips)", bycopy, pure, inheritable, header: "geomLinestrips.h".} = object of GeomPrimitive

converter toGeomLinestrips*(_: type(nil)): GeomLinestrips {.importcpp: "(nullptr)".}
converter toBool*(this: GeomLinestrips): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomLinestrips, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomLinestrips], obj: TypedObject): GeomLinestrips {.importcpp: "DCAST(GeomLinestrips, @)".}

type
  GeomLinestripsAdjacency* {.importcpp: "PT(GeomLinestripsAdjacency)", bycopy, pure, inheritable, header: "geomLinestripsAdjacency.h".} = object of GeomPrimitive

converter toGeomLinestripsAdjacency*(_: type(nil)): GeomLinestripsAdjacency {.importcpp: "(nullptr)".}
converter toBool*(this: GeomLinestripsAdjacency): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomLinestripsAdjacency, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomLinestripsAdjacency], obj: TypedObject): GeomLinestripsAdjacency {.importcpp: "DCAST(GeomLinestripsAdjacency, @)".}

type
  GeomPatches* {.importcpp: "PT(GeomPatches)", bycopy, pure, inheritable, header: "geomPatches.h".} = object of GeomPrimitive

converter toGeomPatches*(_: type(nil)): GeomPatches {.importcpp: "(nullptr)".}
converter toBool*(this: GeomPatches): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomPatches, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomPatches], obj: TypedObject): GeomPatches {.importcpp: "DCAST(GeomPatches, @)".}

type
  GeomPoints* {.importcpp: "PT(GeomPoints)", bycopy, pure, inheritable, header: "geomPoints.h".} = object of GeomPrimitive

converter toGeomPoints*(_: type(nil)): GeomPoints {.importcpp: "(nullptr)".}
converter toBool*(this: GeomPoints): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomPoints, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomPoints], obj: TypedObject): GeomPoints {.importcpp: "DCAST(GeomPoints, @)".}

type
  GeomTriangles* {.importcpp: "PT(GeomTriangles)", bycopy, pure, inheritable, header: "geomTriangles.h".} = object of GeomPrimitive

converter toGeomTriangles*(_: type(nil)): GeomTriangles {.importcpp: "(nullptr)".}
converter toBool*(this: GeomTriangles): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomTriangles, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomTriangles], obj: TypedObject): GeomTriangles {.importcpp: "DCAST(GeomTriangles, @)".}

type
  GeomTrianglesAdjacency* {.importcpp: "PT(GeomTrianglesAdjacency)", bycopy, pure, inheritable, header: "geomTrianglesAdjacency.h".} = object of GeomPrimitive

converter toGeomTrianglesAdjacency*(_: type(nil)): GeomTrianglesAdjacency {.importcpp: "(nullptr)".}
converter toBool*(this: GeomTrianglesAdjacency): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomTrianglesAdjacency, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomTrianglesAdjacency], obj: TypedObject): GeomTrianglesAdjacency {.importcpp: "DCAST(GeomTrianglesAdjacency, @)".}

type
  GeomTrifans* {.importcpp: "PT(GeomTrifans)", bycopy, pure, inheritable, header: "geomTrifans.h".} = object of GeomPrimitive

converter toGeomTrifans*(_: type(nil)): GeomTrifans {.importcpp: "(nullptr)".}
converter toBool*(this: GeomTrifans): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomTrifans, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomTrifans], obj: TypedObject): GeomTrifans {.importcpp: "DCAST(GeomTrifans, @)".}

type
  GeomTristrips* {.importcpp: "PT(GeomTristrips)", bycopy, pure, inheritable, header: "geomTristrips.h".} = object of GeomPrimitive

converter toGeomTristrips*(_: type(nil)): GeomTristrips {.importcpp: "(nullptr)".}
converter toBool*(this: GeomTristrips): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomTristrips, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomTristrips], obj: TypedObject): GeomTristrips {.importcpp: "DCAST(GeomTristrips, @)".}

type
  GeomTristripsAdjacency* {.importcpp: "PT(GeomTristripsAdjacency)", bycopy, pure, inheritable, header: "geomTristripsAdjacency.h".} = object of GeomPrimitive

converter toGeomTristripsAdjacency*(_: type(nil)): GeomTristripsAdjacency {.importcpp: "(nullptr)".}
converter toBool*(this: GeomTristripsAdjacency): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomTristripsAdjacency, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomTristripsAdjacency], obj: TypedObject): GeomTristripsAdjacency {.importcpp: "DCAST(GeomTristripsAdjacency, @)".}

type
  GeomVertexReader* {.importcpp: "GeomVertexReader", pure, inheritable, header: "geomVertexReader.h".} = object of GeomEnums

type
  GeomVertexWriter* {.importcpp: "GeomVertexWriter", pure, inheritable, header: "geomVertexWriter.h".} = object of GeomEnums

type
  GeomVertexRewriter* {.importcpp: "GeomVertexRewriter", pure, inheritable, header: "geomVertexRewriter.h".} = object of GeomVertexWriter

type
  SamplerState* {.importcpp: "SamplerState", pure, inheritable, header: "samplerState.h".} = object

type
  Shader* {.importcpp: "PT(Shader)", bycopy, pure, inheritable, header: "shader.h".} = object of TypedWritableReferenceCount

converter toShader*(_: type(nil)): Shader {.importcpp: "(nullptr)".}
converter toBool*(this: Shader): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Shader, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Shader], obj: TypedObject): Shader {.importcpp: "DCAST(Shader, @)".}

type
  ShaderBuffer* {.importcpp: "PT(ShaderBuffer)", bycopy, pure, inheritable, header: "shaderBuffer.h".} = object of TypedWritableReferenceCount

converter toShaderBuffer*(_: type(nil)): ShaderBuffer {.importcpp: "(nullptr)".}
converter toBool*(this: ShaderBuffer): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ShaderBuffer, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ShaderBuffer], obj: TypedObject): ShaderBuffer {.importcpp: "DCAST(ShaderBuffer, @)".}

type
  PreparedGraphicsObjects* {.importcpp: "PT(PreparedGraphicsObjects)", bycopy, pure, inheritable, header: "preparedGraphicsObjects.h".} = object of ReferenceCount

converter toPreparedGraphicsObjects*(_: type(nil)): PreparedGraphicsObjects {.importcpp: "(nullptr)".}
converter toBool*(this: PreparedGraphicsObjects): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PreparedGraphicsObjects, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PreparedGraphicsObjects], obj: TypedObject): PreparedGraphicsObjects {.importcpp: "DCAST(PreparedGraphicsObjects, @)".}

type
  IndexBufferContext* {.importcpp: "IndexBufferContext", pure, inheritable, header: "indexBufferContext.h".} = object of BufferContext

type
  Lens* {.importcpp: "PT(Lens)", bycopy, pure, inheritable, header: "lens.h".} = object of TypedWritableReferenceCount

converter toLens*(_: type(nil)): Lens {.importcpp: "(nullptr)".}
converter toBool*(this: Lens): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Lens, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Lens], obj: TypedObject): Lens {.importcpp: "DCAST(Lens, @)".}

type
  Material* {.importcpp: "PT(Material)", bycopy, pure, inheritable, header: "material.h".} = object of TypedWritableReferenceCount

converter toMaterial*(_: type(nil)): Material {.importcpp: "(nullptr)".}
converter toBool*(this: Material): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Material, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Material], obj: TypedObject): Material {.importcpp: "DCAST(Material, @)".}

type
  MaterialPool* {.importcpp: "MaterialPool", pure, inheritable, header: "materialPool.h".} = object

type
  MatrixLens* {.importcpp: "PT(MatrixLens)", bycopy, pure, inheritable, header: "matrixLens.h".} = object of Lens

converter toMatrixLens*(_: type(nil)): MatrixLens {.importcpp: "(nullptr)".}
converter toBool*(this: MatrixLens): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MatrixLens, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MatrixLens], obj: TypedObject): MatrixLens {.importcpp: "DCAST(MatrixLens, @)".}

type
  OrthographicLens* {.importcpp: "PT(OrthographicLens)", bycopy, pure, inheritable, header: "orthographicLens.h".} = object of Lens

converter toOrthographicLens*(_: type(nil)): OrthographicLens {.importcpp: "(nullptr)".}
converter toBool*(this: OrthographicLens): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: OrthographicLens, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[OrthographicLens], obj: TypedObject): OrthographicLens {.importcpp: "DCAST(OrthographicLens, @)".}

type
  ParamTextureSampler* {.importcpp: "PT(ParamTextureSampler)", bycopy, pure, inheritable, header: "paramTextureSampler.h".} = object of ParamValueBase

converter toParamTextureSampler*(_: type(nil)): ParamTextureSampler {.importcpp: "(nullptr)".}
converter toBool*(this: ParamTextureSampler): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ParamTextureSampler, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ParamTextureSampler], obj: TypedObject): ParamTextureSampler {.importcpp: "DCAST(ParamTextureSampler, @)".}

type
  ParamTextureImage* {.importcpp: "PT(ParamTextureImage)", bycopy, pure, inheritable, header: "paramTextureImage.h".} = object of ParamValueBase

converter toParamTextureImage*(_: type(nil)): ParamTextureImage {.importcpp: "(nullptr)".}
converter toBool*(this: ParamTextureImage): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ParamTextureImage, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ParamTextureImage], obj: TypedObject): ParamTextureImage {.importcpp: "DCAST(ParamTextureImage, @)".}

type
  PerspectiveLens* {.importcpp: "PT(PerspectiveLens)", bycopy, pure, inheritable, header: "perspectiveLens.h".} = object of Lens

converter toPerspectiveLens*(_: type(nil)): PerspectiveLens {.importcpp: "(nullptr)".}
converter toBool*(this: PerspectiveLens): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PerspectiveLens, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PerspectiveLens], obj: TypedObject): PerspectiveLens {.importcpp: "DCAST(PerspectiveLens, @)".}

type
  TextureReloadRequest* {.importcpp: "PT(TextureReloadRequest)", bycopy, pure, inheritable, header: "textureReloadRequest.h".} = object of AsyncTask

converter toTextureReloadRequest*(_: type(nil)): TextureReloadRequest {.importcpp: "(nullptr)".}
converter toBool*(this: TextureReloadRequest): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TextureReloadRequest, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TextureReloadRequest], obj: TypedObject): TextureReloadRequest {.importcpp: "DCAST(TextureReloadRequest, @)".}

type
  TextureContext* {.importcpp: "TextureContext", pure, inheritable, header: "textureContext.h".} = object of BufferContext

type
  ShaderContext* {.importcpp: "ShaderContext", pure, inheritable, header: "shaderContext.h".} = object of SavedContext

type
  UserVertexSlider* {.importcpp: "PT(UserVertexSlider)", bycopy, pure, inheritable, header: "userVertexSlider.h".} = object of VertexSlider

converter toUserVertexSlider*(_: type(nil)): UserVertexSlider {.importcpp: "(nullptr)".}
converter toBool*(this: UserVertexSlider): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: UserVertexSlider, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[UserVertexSlider], obj: TypedObject): UserVertexSlider {.importcpp: "DCAST(UserVertexSlider, @)".}

type
  UserVertexTransform* {.importcpp: "PT(UserVertexTransform)", bycopy, pure, inheritable, header: "userVertexTransform.h".} = object of VertexTransform

converter toUserVertexTransform*(_: type(nil)): UserVertexTransform {.importcpp: "(nullptr)".}
converter toBool*(this: UserVertexTransform): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: UserVertexTransform, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[UserVertexTransform], obj: TypedObject): UserVertexTransform {.importcpp: "DCAST(UserVertexTransform, @)".}

type
  VideoTexture* {.importcpp: "PT(VideoTexture)", bycopy, pure, inheritable, header: "videoTexture.h".} = object of Texture

converter toVideoTexture*(_: type(nil)): VideoTexture {.importcpp: "(nullptr)".}
converter toBool*(this: VideoTexture): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VideoTexture, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VideoTexture], obj: TypedObject): VideoTexture {.importcpp: "DCAST(VideoTexture, @)".}

type
  VertexBufferContext* {.importcpp: "VertexBufferContext", pure, inheritable, header: "vertexBufferContext.h".} = object of BufferContext

type
  TextureCollection* {.importcpp: "TextureCollection", pure, inheritable, header: "textureCollection.h".} = object

type
  TexturePool* {.importcpp: "TexturePool", pure, inheritable, header: "texturePool.h".} = object

type
  TexturePeeker* {.importcpp: "PT(TexturePeeker)", bycopy, pure, inheritable, header: "texturePeeker.h".} = object of ReferenceCount

converter toTexturePeeker*(_: type(nil)): TexturePeeker {.importcpp: "(nullptr)".}
converter toBool*(this: TexturePeeker): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TexturePeeker, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TexturePeeker], obj: TypedObject): TexturePeeker {.importcpp: "DCAST(TexturePeeker, @)".}

type
  TextureStagePool* {.importcpp: "TextureStagePool", pure, inheritable, header: "textureStagePool.h".} = object

type
  MathNumbers* {.importcpp: "MathNumbers", pure, inheritable, header: "mathNumbers.h".} = object

type
  LVecBase2f* {.importcpp: "LVecBase2f", pure, inheritable, header: "lvecBase2.h".} = object

type
  LVecBase2d* {.importcpp: "LVecBase2d", pure, inheritable, header: "lvecBase2.h".} = object

type
  LVecBase2i* {.importcpp: "LVecBase2i", pure, inheritable, header: "lvecBase2.h".} = object

type
  LVector2f* {.importcpp: "LVector2f", pure, inheritable, header: "lvector2.h".} = object of LVecBase2f

type
  LVector2d* {.importcpp: "LVector2d", pure, inheritable, header: "lvector2.h".} = object of LVecBase2d

type
  LVector2i* {.importcpp: "LVector2i", pure, inheritable, header: "lvector2.h".} = object of LVecBase2i

type
  LPoint2f* {.importcpp: "LPoint2f", pure, inheritable, header: "lpoint2.h".} = object of LVecBase2f

type
  LPoint2d* {.importcpp: "LPoint2d", pure, inheritable, header: "lpoint2.h".} = object of LVecBase2d

type
  LPoint2i* {.importcpp: "LPoint2i", pure, inheritable, header: "lpoint2.h".} = object of LVecBase2i

type
  LVecBase3f* {.importcpp: "LVecBase3f", pure, inheritable, header: "lvecBase3.h".} = object

type
  LVecBase3d* {.importcpp: "LVecBase3d", pure, inheritable, header: "lvecBase3.h".} = object

type
  LVecBase3i* {.importcpp: "LVecBase3i", pure, inheritable, header: "lvecBase3.h".} = object

type
  CoordinateSystem* = enum
    CS_default = 0
    CS_zup_right = 1
    CS_yup_right = 2
    CS_zup_left = 3
    CS_yup_left = 4
    CS_invalid = 5

type
  LVector3f* {.importcpp: "LVector3f", pure, inheritable, header: "lvector3.h".} = object of LVecBase3f

type
  LVector3d* {.importcpp: "LVector3d", pure, inheritable, header: "lvector3.h".} = object of LVecBase3d

type
  LVector3i* {.importcpp: "LVector3i", pure, inheritable, header: "lvector3.h".} = object of LVecBase3i

type
  LPoint3f* {.importcpp: "LPoint3f", pure, inheritable, header: "lpoint3.h".} = object of LVecBase3f

type
  LPoint3d* {.importcpp: "LPoint3d", pure, inheritable, header: "lpoint3.h".} = object of LVecBase3d

type
  LPoint3i* {.importcpp: "LPoint3i", pure, inheritable, header: "lpoint3.h".} = object of LVecBase3i

type
  LVecBase4f* {.importcpp: "LVecBase4f", pure, inheritable, header: "lvecBase4.h".} = object

type
  UnalignedLVecBase4f* {.importcpp: "UnalignedLVecBase4f", pure, inheritable, header: "unalignedLVecBase4f.h".} = object

type
  LVecBase4d* {.importcpp: "LVecBase4d", pure, inheritable, header: "lvecBase4.h".} = object

type
  UnalignedLVecBase4d* {.importcpp: "UnalignedLVecBase4d", pure, inheritable, header: "unalignedLVecBase4d.h".} = object

type
  LVecBase4i* {.importcpp: "LVecBase4i", pure, inheritable, header: "lvecBase4.h".} = object

type
  UnalignedLVecBase4i* {.importcpp: "UnalignedLVecBase4i", pure, inheritable, header: "unalignedLVecBase4i.h".} = object

type
  LVector4f* {.importcpp: "LVector4f", pure, inheritable, header: "lvector4.h".} = object of LVecBase4f

type
  LVector4d* {.importcpp: "LVector4d", pure, inheritable, header: "lvector4.h".} = object of LVecBase4d

type
  LVector4i* {.importcpp: "LVector4i", pure, inheritable, header: "lvector4.h".} = object of LVecBase4i

type
  LPoint4f* {.importcpp: "LPoint4f", pure, inheritable, header: "lpoint4.h".} = object of LVecBase4f

type
  LPoint4d* {.importcpp: "LPoint4d", pure, inheritable, header: "lpoint4.h".} = object of LVecBase4d

type
  LPoint4i* {.importcpp: "LPoint4i", pure, inheritable, header: "lpoint4.h".} = object of LVecBase4i

type
  LMatrix3f* {.importcpp: "LMatrix3f", pure, inheritable, header: "lmatrix3.h".} = object

type
  LMatrix4f* {.importcpp: "LMatrix4f", pure, inheritable, header: "lmatrix4.h".} = object

type
  UnalignedLMatrix4f* {.importcpp: "UnalignedLMatrix4f", pure, inheritable, header: "unalignedLMatrix4f.h".} = object

type
  LMatrix3d* {.importcpp: "LMatrix3d", pure, inheritable, header: "lmatrix3.h".} = object

type
  LMatrix4d* {.importcpp: "LMatrix4d", pure, inheritable, header: "lmatrix4.h".} = object

type
  UnalignedLMatrix4d* {.importcpp: "UnalignedLMatrix4d", pure, inheritable, header: "unalignedLMatrix4d.h".} = object

type
  LQuaternionf* {.importcpp: "LQuaternionf", pure, inheritable, header: "lquaternion.h".} = object of LVecBase4f

type
  LQuaterniond* {.importcpp: "LQuaterniond", pure, inheritable, header: "lquaternion.h".} = object of LVecBase4d

type
  LRotationf* {.importcpp: "LRotationf", pure, inheritable, header: "lrotation.h".} = object of LQuaternionf

type
  LRotationd* {.importcpp: "LRotationd", pure, inheritable, header: "lrotation.h".} = object of LQuaterniond

type
  LOrientationf* {.importcpp: "LOrientationf", pure, inheritable, header: "lorientation.h".} = object of LQuaternionf

type
  LOrientationd* {.importcpp: "LOrientationd", pure, inheritable, header: "lorientation.h".} = object of LQuaterniond

type
  LVertexf* = LPoint3f

type
  LNormalf* = LVector3f

type
  LTexCoordf* = LPoint2f

type
  LTexCoord3f* = LPoint3f

type
  LColorf* = LVecBase4f

type
  LRGBColorf* = LVecBase3f

type
  LVertexd* = LPoint3d

type
  LNormald* = LVector3d

type
  LTexCoordd* = LPoint2d

type
  LTexCoord3d* = LPoint3d

type
  LColord* = LVecBase4d

type
  LRGBColord* = LVecBase3d

type
  Mat4F* = LMatrix4f

type
  Mat3F* = LMatrix3f

type
  VBase4F* = LVecBase4f

type
  Vec4F* = LVector4f

type
  Point4F* = LPoint4f

type
  VBase3F* = LVecBase3f

type
  Vec3F* = LVector3f

type
  Point3F* = LPoint3f

type
  VBase2F* = LVecBase2f

type
  Vec2F* = LVector2f

type
  Point2F* = LPoint2f

type
  QuatF* = LQuaternionf

type
  Mat4D* = LMatrix4d

type
  Mat3D* = LMatrix3d

type
  VBase4D* = LVecBase4d

type
  Vec4D* = LVector4d

type
  Point4D* = LPoint4d

type
  VBase3D* = LVecBase3d

type
  Vec3D* = LVector3d

type
  Point3D* = LPoint3d

type
  VBase2D* = LVecBase2d

type
  Vec2D* = LVector2d

type
  Point2D* = LPoint2d

type
  QuatD* = LQuaterniond

type
  LVecBase2* = LVecBase2f

type
  LPoint2* = LPoint2f

type
  LVector2* = LVector2f

type
  LVecBase3* = LVecBase3f

type
  LPoint3* = LPoint3f

type
  LVector3* = LVector3f

type
  LVecBase4* = LVecBase4f

type
  LPoint4* = LPoint4f

type
  LVector4* = LVector4f

type
  LQuaternion* = LQuaternionf

type
  LRotation* = LRotationf

type
  LOrientation* = LOrientationf

type
  LMatrix3* = LMatrix3f

type
  LMatrix4* = LMatrix4f

type
  LVertex* = LVertexf

type
  LNormal* = LNormalf

type
  LTexCoord* = LTexCoordf

type
  LTexCoord3* = LTexCoord3f

type
  LColor* = LColorf

type
  LRGBColor* = LRGBColorf

type
  UnalignedLVecBase4* = UnalignedLVecBase4f

type
  UnalignedLMatrix4* = UnalignedLMatrix4f

type
  Mat4* = LMatrix4f

type
  Mat3* = LMatrix3f

type
  VBase4* = LVecBase4f

type
  Vec4* = LVector4f

type
  Point4* = LPoint4f

type
  VBase3* = LVecBase3f

type
  Vec3* = LVector3f

type
  Point3* = LPoint3f

type
  VBase2* = LVecBase2f

type
  Vec2* = LVector2f

type
  Point2* = LPoint2f

type
  Quat* = LQuaternionf

type
  ConfigVariableColor* {.importcpp: "ConfigVariableColor", pure, inheritable, header: "configVariableColor.h".} = object of ConfigVariable

type
  BoundingVolume* {.importcpp: "PT(BoundingVolume)", bycopy, pure, inheritable, header: "boundingVolume.h".} = object of TypedReferenceCount

converter toBoundingVolume*(_: type(nil)): BoundingVolume {.importcpp: "(nullptr)".}
converter toBool*(this: BoundingVolume): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: BoundingVolume, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[BoundingVolume], obj: TypedObject): BoundingVolume {.importcpp: "DCAST(BoundingVolume, @)".}

type
  GeometricBoundingVolume* {.importcpp: "PT(GeometricBoundingVolume)", bycopy, pure, inheritable, header: "geometricBoundingVolume.h".} = object of BoundingVolume

converter toGeometricBoundingVolume*(_: type(nil)): GeometricBoundingVolume {.importcpp: "(nullptr)".}
converter toBool*(this: GeometricBoundingVolume): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeometricBoundingVolume, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeometricBoundingVolume], obj: TypedObject): GeometricBoundingVolume {.importcpp: "DCAST(GeometricBoundingVolume, @)".}

type
  FiniteBoundingVolume* {.importcpp: "PT(FiniteBoundingVolume)", bycopy, pure, inheritable, header: "finiteBoundingVolume.h".} = object of GeometricBoundingVolume

converter toFiniteBoundingVolume*(_: type(nil)): FiniteBoundingVolume {.importcpp: "(nullptr)".}
converter toBool*(this: FiniteBoundingVolume): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: FiniteBoundingVolume, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[FiniteBoundingVolume], obj: TypedObject): FiniteBoundingVolume {.importcpp: "DCAST(FiniteBoundingVolume, @)".}

type
  LParabolaf* {.importcpp: "LParabolaf", pure, inheritable, header: "lparabola.h".} = object

type
  LParabolad* {.importcpp: "LParabolad", pure, inheritable, header: "lparabola.h".} = object

type
  LParabola* = LParabolaf

type
  LPlanef* {.importcpp: "LPlanef", pure, inheritable, header: "lplane.h".} = object of LVecBase4f

type
  LPlaned* {.importcpp: "LPlaned", pure, inheritable, header: "lplane.h".} = object of LVecBase4d

type
  LPlane* = LPlanef

type
  PlaneF* = LPlanef

type
  PlaneD* = LPlaned

type
  Plane* = LPlanef

type
  BoundingBox* {.importcpp: "PT(BoundingBox)", bycopy, pure, inheritable, header: "boundingBox.h".} = object of FiniteBoundingVolume

converter toBoundingBox*(_: type(nil)): BoundingBox {.importcpp: "(nullptr)".}
converter toBool*(this: BoundingBox): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: BoundingBox, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[BoundingBox], obj: TypedObject): BoundingBox {.importcpp: "DCAST(BoundingBox, @)".}

type
  LFrustumf* {.importcpp: "LFrustumf", pure, inheritable, header: "lfrustum.h".} = object

type
  LFrustumd* {.importcpp: "LFrustumd", pure, inheritable, header: "lfrustum.h".} = object

type
  LFrustum* = LFrustumf

type
  FrustumF* = LFrustumf

type
  FrustumD* = LFrustumd

type
  Frustum* = LFrustumf

type
  BoundingHexahedron* {.importcpp: "PT(BoundingHexahedron)", bycopy, pure, inheritable, header: "boundingHexahedron.h".} = object of FiniteBoundingVolume

converter toBoundingHexahedron*(_: type(nil)): BoundingHexahedron {.importcpp: "(nullptr)".}
converter toBool*(this: BoundingHexahedron): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: BoundingHexahedron, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[BoundingHexahedron], obj: TypedObject): BoundingHexahedron {.importcpp: "DCAST(BoundingHexahedron, @)".}

type
  BoundingLine* {.importcpp: "PT(BoundingLine)", bycopy, pure, inheritable, header: "boundingLine.h".} = object of GeometricBoundingVolume

converter toBoundingLine*(_: type(nil)): BoundingLine {.importcpp: "(nullptr)".}
converter toBool*(this: BoundingLine): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: BoundingLine, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[BoundingLine], obj: TypedObject): BoundingLine {.importcpp: "DCAST(BoundingLine, @)".}

type
  BoundingPlane* {.importcpp: "PT(BoundingPlane)", bycopy, pure, inheritable, header: "boundingPlane.h".} = object of GeometricBoundingVolume

converter toBoundingPlane*(_: type(nil)): BoundingPlane {.importcpp: "(nullptr)".}
converter toBool*(this: BoundingPlane): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: BoundingPlane, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[BoundingPlane], obj: TypedObject): BoundingPlane {.importcpp: "DCAST(BoundingPlane, @)".}

type
  BoundingSphere* {.importcpp: "PT(BoundingSphere)", bycopy, pure, inheritable, header: "boundingSphere.h".} = object of FiniteBoundingVolume

converter toBoundingSphere*(_: type(nil)): BoundingSphere {.importcpp: "(nullptr)".}
converter toBool*(this: BoundingSphere): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: BoundingSphere, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[BoundingSphere], obj: TypedObject): BoundingSphere {.importcpp: "DCAST(BoundingSphere, @)".}

type
  IntersectionBoundingVolume* {.importcpp: "PT(IntersectionBoundingVolume)", bycopy, pure, inheritable, header: "intersectionBoundingVolume.h".} = object of GeometricBoundingVolume

converter toIntersectionBoundingVolume*(_: type(nil)): IntersectionBoundingVolume {.importcpp: "(nullptr)".}
converter toBool*(this: IntersectionBoundingVolume): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: IntersectionBoundingVolume, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[IntersectionBoundingVolume], obj: TypedObject): IntersectionBoundingVolume {.importcpp: "DCAST(IntersectionBoundingVolume, @)".}

type
  Mersenne* {.importcpp: "Mersenne", pure, inheritable, header: "mersenne.h".} = object

type
  OmniBoundingVolume* {.importcpp: "PT(OmniBoundingVolume)", bycopy, pure, inheritable, header: "omniBoundingVolume.h".} = object of GeometricBoundingVolume

converter toOmniBoundingVolume*(_: type(nil)): OmniBoundingVolume {.importcpp: "(nullptr)".}
converter toBool*(this: OmniBoundingVolume): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: OmniBoundingVolume, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[OmniBoundingVolume], obj: TypedObject): OmniBoundingVolume {.importcpp: "DCAST(OmniBoundingVolume, @)".}

type
  UnionBoundingVolume* {.importcpp: "PT(UnionBoundingVolume)", bycopy, pure, inheritable, header: "unionBoundingVolume.h".} = object of GeometricBoundingVolume

converter toUnionBoundingVolume*(_: type(nil)): UnionBoundingVolume {.importcpp: "(nullptr)".}
converter toBool*(this: UnionBoundingVolume): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: UnionBoundingVolume, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[UnionBoundingVolume], obj: TypedObject): UnionBoundingVolume {.importcpp: "DCAST(UnionBoundingVolume, @)".}

type
  Randomizer* {.importcpp: "Randomizer", pure, inheritable, header: "randomizer.h".} = object

type
  PerlinNoise* {.importcpp: "PerlinNoise", pure, inheritable, header: "perlinNoise.h".} = object

type
  PerlinNoise2* {.importcpp: "PerlinNoise2", pure, inheritable, header: "perlinNoise2.h".} = object of PerlinNoise

type
  PerlinNoise3* {.importcpp: "PerlinNoise3", pure, inheritable, header: "perlinNoise3.h".} = object of PerlinNoise

type
  StackedPerlinNoise2* {.importcpp: "StackedPerlinNoise2", pure, inheritable, header: "stackedPerlinNoise2.h".} = object

type
  StackedPerlinNoise3* {.importcpp: "StackedPerlinNoise3", pure, inheritable, header: "stackedPerlinNoise3.h".} = object

type
  Triangulator* {.importcpp: "Triangulator", pure, inheritable, header: "triangulator.h".} = object

type
  Triangulator3* {.importcpp: "Triangulator3", pure, inheritable, header: "triangulator3.h".} = object of Triangulator

type
  ParametricCurve* {.importcpp: "PT(ParametricCurve)", bycopy, pure, inheritable, header: "parametricCurve.h".} = object of PandaNode

converter toParametricCurve*(_: type(nil)): ParametricCurve {.importcpp: "(nullptr)".}
converter toBool*(this: ParametricCurve): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ParametricCurve, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ParametricCurve], obj: TypedObject): ParametricCurve {.importcpp: "DCAST(ParametricCurve, @)".}

type
  CubicCurveseg* {.importcpp: "PT(CubicCurveseg)", bycopy, pure, inheritable, header: "cubicCurveseg.h".} = object of ParametricCurve

converter toCubicCurveseg*(_: type(nil)): CubicCurveseg {.importcpp: "(nullptr)".}
converter toBool*(this: CubicCurveseg): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CubicCurveseg, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CubicCurveseg], obj: TypedObject): CubicCurveseg {.importcpp: "DCAST(CubicCurveseg, @)".}

type
  ParametricCurveCollection* {.importcpp: "PT(ParametricCurveCollection)", bycopy, pure, inheritable, header: "parametricCurveCollection.h".} = object of ReferenceCount

converter toParametricCurveCollection*(_: type(nil)): ParametricCurveCollection {.importcpp: "(nullptr)".}
converter toBool*(this: ParametricCurveCollection): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ParametricCurveCollection, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ParametricCurveCollection], obj: TypedObject): ParametricCurveCollection {.importcpp: "DCAST(ParametricCurveCollection, @)".}

type
  CurveFitter* {.importcpp: "CurveFitter", pure, inheritable, header: "curveFitter.h".} = object

type
  PiecewiseCurve* {.importcpp: "PT(PiecewiseCurve)", bycopy, pure, inheritable, header: "piecewiseCurve.h".} = object of ParametricCurve

converter toPiecewiseCurve*(_: type(nil)): PiecewiseCurve {.importcpp: "(nullptr)".}
converter toBool*(this: PiecewiseCurve): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PiecewiseCurve, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PiecewiseCurve], obj: TypedObject): PiecewiseCurve {.importcpp: "DCAST(PiecewiseCurve, @)".}

type
  HermiteCurve* {.importcpp: "PT(HermiteCurve)", bycopy, pure, inheritable, header: "hermiteCurve.h".} = object of PiecewiseCurve

converter toHermiteCurve*(_: type(nil)): HermiteCurve {.importcpp: "(nullptr)".}
converter toBool*(this: HermiteCurve): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: HermiteCurve, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[HermiteCurve], obj: TypedObject): HermiteCurve {.importcpp: "DCAST(HermiteCurve, @)".}

type
  NurbsCurveInterface* {.importcpp: "NurbsCurveInterface", pure, inheritable, header: "nurbsCurveInterface.h".} = object

type
  NurbsCurve* {.importcpp: "PT(NurbsCurve)", bycopy, pure, inheritable, header: "nurbsCurve.h".} = object of PiecewiseCurve

converter toNurbsCurve*(_: type(nil)): NurbsCurve {.importcpp: "(nullptr)".}
converter toBool*(this: NurbsCurve): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: NurbsCurve, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[NurbsCurve], obj: TypedObject): NurbsCurve {.importcpp: "DCAST(NurbsCurve, @)".}

type
  NurbsCurveResult* {.importcpp: "PT(NurbsCurveResult)", bycopy, pure, inheritable, header: "nurbsCurveResult.h".} = object of ReferenceCount

converter toNurbsCurveResult*(_: type(nil)): NurbsCurveResult {.importcpp: "(nullptr)".}
converter toBool*(this: NurbsCurveResult): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: NurbsCurveResult, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[NurbsCurveResult], obj: TypedObject): NurbsCurveResult {.importcpp: "DCAST(NurbsCurveResult, @)".}

type
  NurbsCurveEvaluator* {.importcpp: "PT(NurbsCurveEvaluator)", bycopy, pure, inheritable, header: "nurbsCurveEvaluator.h".} = object of ReferenceCount

converter toNurbsCurveEvaluator*(_: type(nil)): NurbsCurveEvaluator {.importcpp: "(nullptr)".}
converter toBool*(this: NurbsCurveEvaluator): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: NurbsCurveEvaluator, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[NurbsCurveEvaluator], obj: TypedObject): NurbsCurveEvaluator {.importcpp: "DCAST(NurbsCurveEvaluator, @)".}

type
  NurbsSurfaceResult* {.importcpp: "PT(NurbsSurfaceResult)", bycopy, pure, inheritable, header: "nurbsSurfaceResult.h".} = object of ReferenceCount

converter toNurbsSurfaceResult*(_: type(nil)): NurbsSurfaceResult {.importcpp: "(nullptr)".}
converter toBool*(this: NurbsSurfaceResult): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: NurbsSurfaceResult, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[NurbsSurfaceResult], obj: TypedObject): NurbsSurfaceResult {.importcpp: "DCAST(NurbsSurfaceResult, @)".}

type
  NurbsSurfaceEvaluator* {.importcpp: "PT(NurbsSurfaceEvaluator)", bycopy, pure, inheritable, header: "nurbsSurfaceEvaluator.h".} = object of ReferenceCount

converter toNurbsSurfaceEvaluator*(_: type(nil)): NurbsSurfaceEvaluator {.importcpp: "(nullptr)".}
converter toBool*(this: NurbsSurfaceEvaluator): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: NurbsSurfaceEvaluator, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[NurbsSurfaceEvaluator], obj: TypedObject): NurbsSurfaceEvaluator {.importcpp: "DCAST(NurbsSurfaceEvaluator, @)".}

type
  RopeNode* {.importcpp: "PT(RopeNode)", bycopy, pure, inheritable, header: "ropeNode.h".} = object of PandaNode

converter toRopeNode*(_: type(nil)): RopeNode {.importcpp: "(nullptr)".}
converter toBool*(this: RopeNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RopeNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RopeNode], obj: TypedObject): RopeNode {.importcpp: "DCAST(RopeNode, @)".}

type
  SheetNode* {.importcpp: "PT(SheetNode)", bycopy, pure, inheritable, header: "sheetNode.h".} = object of PandaNode

converter toSheetNode*(_: type(nil)): SheetNode {.importcpp: "(nullptr)".}
converter toBool*(this: SheetNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SheetNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[SheetNode], obj: TypedObject): SheetNode {.importcpp: "DCAST(SheetNode, @)".}

type
  pixel* {.importcpp: "pixel", pure, inheritable, header: "pixel.h".} = object

type
  xel* = pixel

type
  PNMFileType* {.importcpp: "PNMFileType", pure, inheritable, header: "pNMFileType.h".} = object of TypedWritable

type
  PNMFileTypeRegistry* {.importcpp: "PNMFileTypeRegistry", pure, inheritable, header: "pNMFileTypeRegistry.h".} = object

type
  PNMImageHeader* {.importcpp: "PNMImageHeader", pure, inheritable, header: "pNMImageHeader.h".} = object

type
  PfmFile* {.importcpp: "PfmFile", pure, inheritable, header: "pfmFile.h".} = object of PNMImageHeader

type
  PNMBrush* {.importcpp: "PT(PNMBrush)", bycopy, pure, inheritable, header: "pNMBrush.h".} = object of ReferenceCount

converter toPNMBrush*(_: type(nil)): PNMBrush {.importcpp: "(nullptr)".}
converter toBool*(this: PNMBrush): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PNMBrush, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PNMBrush], obj: TypedObject): PNMBrush {.importcpp: "DCAST(PNMBrush, @)".}

type
  PNMImage* {.importcpp: "PNMImage", pure, inheritable, header: "pNMImage.h".} = object of PNMImageHeader

type
  PNMPainter* {.importcpp: "PNMPainter", pure, inheritable, header: "pNMPainter.h".} = object

type
  TextGlyph* {.importcpp: "PT(TextGlyph)", bycopy, pure, inheritable, header: "textGlyph.h".} = object of TypedReferenceCount

converter toTextGlyph*(_: type(nil)): TextGlyph {.importcpp: "(nullptr)".}
converter toBool*(this: TextGlyph): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TextGlyph, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TextGlyph], obj: TypedObject): TextGlyph {.importcpp: "DCAST(TextGlyph, @)".}

type
  TextFont* {.importcpp: "PT(TextFont)", bycopy, pure, inheritable, header: "textFont.h".} = object of TypedReferenceCount

converter toTextFont*(_: type(nil)): TextFont {.importcpp: "(nullptr)".}
converter toBool*(this: TextFont): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TextFont, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TextFont], obj: TypedObject): TextFont {.importcpp: "DCAST(TextFont, @)".}

type
  DynamicTextGlyph* {.importcpp: "PT(DynamicTextGlyph)", bycopy, pure, inheritable, header: "dynamicTextGlyph.h".} = object of TextGlyph

converter toDynamicTextGlyph*(_: type(nil)): DynamicTextGlyph {.importcpp: "(nullptr)".}
converter toBool*(this: DynamicTextGlyph): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DynamicTextGlyph, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DynamicTextGlyph], obj: TypedObject): DynamicTextGlyph {.importcpp: "DCAST(DynamicTextGlyph, @)".}

type
  DynamicTextPage* {.importcpp: "PT(DynamicTextPage)", bycopy, pure, inheritable, header: "dynamicTextPage.h".} = object of Texture

converter toDynamicTextPage*(_: type(nil)): DynamicTextPage {.importcpp: "(nullptr)".}
converter toBool*(this: DynamicTextPage): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DynamicTextPage, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DynamicTextPage], obj: TypedObject): DynamicTextPage {.importcpp: "DCAST(DynamicTextPage, @)".}

type
  FreetypeFont* {.importcpp: "FreetypeFont", pure, inheritable, header: "freetypeFont.h".} = object of Namable

type
  DynamicTextFont* {.importcpp: "PT(DynamicTextFont)", bycopy, pure, inheritable, header: "dynamicTextFont.h".} = object of TextFont

converter toDynamicTextFont*(_: type(nil)): DynamicTextFont {.importcpp: "(nullptr)".}
converter toBool*(this: DynamicTextFont): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DynamicTextFont, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DynamicTextFont], obj: TypedObject): DynamicTextFont {.importcpp: "DCAST(DynamicTextFont, @)".}

type
  FontPool* {.importcpp: "FontPool", pure, inheritable, header: "fontPool.h".} = object

type
  GeomTextGlyph* {.importcpp: "PT(GeomTextGlyph)", bycopy, pure, inheritable, header: "geomTextGlyph.h".} = object of Geom

converter toGeomTextGlyph*(_: type(nil)): GeomTextGlyph {.importcpp: "(nullptr)".}
converter toBool*(this: GeomTextGlyph): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomTextGlyph, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomTextGlyph], obj: TypedObject): GeomTextGlyph {.importcpp: "DCAST(GeomTextGlyph, @)".}

type
  StaticTextFont* {.importcpp: "PT(StaticTextFont)", bycopy, pure, inheritable, header: "staticTextFont.h".} = object of TextFont

converter toStaticTextFont*(_: type(nil)): StaticTextFont {.importcpp: "(nullptr)".}
converter toBool*(this: StaticTextFont): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: StaticTextFont, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[StaticTextFont], obj: TypedObject): StaticTextFont {.importcpp: "DCAST(StaticTextFont, @)".}

type
  TextGraphic* {.importcpp: "TextGraphic", pure, inheritable, header: "textGraphic.h".} = object

type
  TextPropertiesManager* {.importcpp: "TextPropertiesManager", pure, inheritable, header: "textPropertiesManager.h".} = object

type
  TextAssembler* {.importcpp: "TextAssembler", pure, inheritable, header: "textAssembler.h".} = object

type
  ButtonThrower* {.importcpp: "PT(ButtonThrower)", bycopy, pure, inheritable, header: "buttonThrower.h".} = object of DataNode

converter toButtonThrower*(_: type(nil)): ButtonThrower {.importcpp: "(nullptr)".}
converter toBool*(this: ButtonThrower): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ButtonThrower, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ButtonThrower], obj: TypedObject): ButtonThrower {.importcpp: "DCAST(ButtonThrower, @)".}

type
  MouseInterfaceNode* {.importcpp: "PT(MouseInterfaceNode)", bycopy, pure, inheritable, header: "mouseInterfaceNode.h".} = object of DataNode

converter toMouseInterfaceNode*(_: type(nil)): MouseInterfaceNode {.importcpp: "(nullptr)".}
converter toBool*(this: MouseInterfaceNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MouseInterfaceNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MouseInterfaceNode], obj: TypedObject): MouseInterfaceNode {.importcpp: "DCAST(MouseInterfaceNode, @)".}

type
  DriveInterface* {.importcpp: "PT(DriveInterface)", bycopy, pure, inheritable, header: "driveInterface.h".} = object of MouseInterfaceNode

converter toDriveInterface*(_: type(nil)): DriveInterface {.importcpp: "(nullptr)".}
converter toBool*(this: DriveInterface): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DriveInterface, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DriveInterface], obj: TypedObject): DriveInterface {.importcpp: "DCAST(DriveInterface, @)".}

type
  MouseSubregion* {.importcpp: "PT(MouseSubregion)", bycopy, pure, inheritable, header: "mouseSubregion.h".} = object of MouseInterfaceNode

converter toMouseSubregion*(_: type(nil)): MouseSubregion {.importcpp: "(nullptr)".}
converter toBool*(this: MouseSubregion): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MouseSubregion, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MouseSubregion], obj: TypedObject): MouseSubregion {.importcpp: "DCAST(MouseSubregion, @)".}

type
  MouseWatcherRegion* {.importcpp: "PT(MouseWatcherRegion)", bycopy, pure, inheritable, header: "mouseWatcherRegion.h".} = object of TypedWritableReferenceCount

converter toMouseWatcherRegion*(_: type(nil)): MouseWatcherRegion {.importcpp: "(nullptr)".}
converter toBool*(this: MouseWatcherRegion): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MouseWatcherRegion, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MouseWatcherRegion], obj: TypedObject): MouseWatcherRegion {.importcpp: "DCAST(MouseWatcherRegion, @)".}

type
  MouseWatcherBase* {.importcpp: "MouseWatcherBase", pure, inheritable, header: "mouseWatcherBase.h".} = object

type
  MouseWatcherGroup* {.importcpp: "PT(MouseWatcherGroup)", bycopy, pure, inheritable, header: "mouseWatcherGroup.h".} = object of MouseWatcherBase

converter toMouseWatcherGroup*(_: type(nil)): MouseWatcherGroup {.importcpp: "(nullptr)".}
converter toBool*(this: MouseWatcherGroup): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MouseWatcherGroup, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MouseWatcherGroup], obj: TypedObject): MouseWatcherGroup {.importcpp: "DCAST(MouseWatcherGroup, @)".}

type
  MouseWatcher* {.importcpp: "PT(MouseWatcher)", bycopy, pure, inheritable, header: "mouseWatcher.h".} = object of DataNode

converter toMouseWatcher*(_: type(nil)): MouseWatcher {.importcpp: "(nullptr)".}
converter toBool*(this: MouseWatcher): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MouseWatcher, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MouseWatcher], obj: TypedObject): MouseWatcher {.importcpp: "DCAST(MouseWatcher, @)".}

type
  MouseWatcherParameter* {.importcpp: "MouseWatcherParameter", pure, inheritable, header: "mouseWatcherParameter.h".} = object

type
  Trackball* {.importcpp: "PT(Trackball)", bycopy, pure, inheritable, header: "trackball.h".} = object of MouseInterfaceNode

converter toTrackball*(_: type(nil)): Trackball {.importcpp: "(nullptr)".}
converter toBool*(this: Trackball): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Trackball, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Trackball], obj: TypedObject): Trackball {.importcpp: "DCAST(Trackball, @)".}

type
  Transform2SG* {.importcpp: "PT(Transform2SG)", bycopy, pure, inheritable, header: "transform2SG.h".} = object of DataNode

converter toTransform2SG*(_: type(nil)): Transform2SG {.importcpp: "(nullptr)".}
converter toBool*(this: Transform2SG): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Transform2SG, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Transform2SG], obj: TypedObject): Transform2SG {.importcpp: "DCAST(Transform2SG, @)".}

type
  AutoTextureScale* = enum
    ATS_none = 0
    ATS_down = 1
    ATS_up = 2
    ATS_pad = 3
    ATS_unspecified = 4

type
  UpdateSeq* {.importcpp: "UpdateSeq", pure, inheritable, header: "updateSeq.h".} = object

type
  BamCacheRecord* {.importcpp: "PT(BamCacheRecord)", bycopy, pure, inheritable, header: "bamCacheRecord.h".} = object of TypedWritableReferenceCount

converter toBamCacheRecord*(_: type(nil)): BamCacheRecord {.importcpp: "(nullptr)".}
converter toBool*(this: BamCacheRecord): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: BamCacheRecord, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[BamCacheRecord], obj: TypedObject): BamCacheRecord {.importcpp: "DCAST(BamCacheRecord, @)".}

type
  BamCache* {.importcpp: "BamCache", pure, inheritable, header: "bamCache.h".} = object

type
  LoaderOptions* {.importcpp: "LoaderOptions", pure, inheritable, header: "loaderOptions.h".} = object

type
  BamReader* {.importcpp: "BamReader", pure, inheritable, header: "bamReader.h".} = object of BamEnums

type
  BamWriter* {.importcpp: "BamWriter", pure, inheritable, header: "bamWriter.h".} = object of BamEnums

type
  BitMaskNative* {.importcpp: "BitMaskNative", pure, inheritable, header: "bitMaskNative.h".} = object

type
  BitArray* {.importcpp: "BitArray", pure, inheritable, header: "bitArray.h".} = object

type
  ButtonHandle* {.importcpp: "ButtonHandle", pure, header: "buttonHandle.h".} = object

type
  ButtonRegistry* {.importcpp: "ButtonRegistry", pure, inheritable, header: "buttonRegistry.h".} = object

type
  ButtonMap* {.importcpp: "PT(ButtonMap)", bycopy, pure, inheritable, header: "buttonMap.h".} = object of TypedReferenceCount

converter toButtonMap*(_: type(nil)): ButtonMap {.importcpp: "(nullptr)".}
converter toBool*(this: ButtonMap): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ButtonMap, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ButtonMap], obj: TypedObject): ButtonMap {.importcpp: "DCAST(ButtonMap, @)".}

type
  CallbackObject* {.importcpp: "PT(CallbackObject)", bycopy, pure, inheritable, header: "callbackObject.h".} = object of TypedReferenceCount

converter toCallbackObject*(_: type(nil)): CallbackObject {.importcpp: "(nullptr)".}
converter toBool*(this: CallbackObject): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CallbackObject, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CallbackObject], obj: TypedObject): CallbackObject {.importcpp: "DCAST(CallbackObject, @)".}

type
  PythonCallbackObject* {.importcpp: "PT(PythonCallbackObject)", bycopy, pure, inheritable, header: "pythonCallbackObject.h".} = object of CallbackObject

converter toPythonCallbackObject*(_: type(nil)): PythonCallbackObject {.importcpp: "(nullptr)".}
converter toBool*(this: PythonCallbackObject): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PythonCallbackObject, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PythonCallbackObject], obj: TypedObject): PythonCallbackObject {.importcpp: "DCAST(PythonCallbackObject, @)".}

type
  TimeVal* {.importcpp: "TimeVal", pure, inheritable, header: "timeVal.h".} = object

type
  ClockObject* {.importcpp: "PT(ClockObject)", bycopy, pure, inheritable, header: "clockObject.h".} = object of ReferenceCount

converter toClockObject*(_: type(nil)): ClockObject {.importcpp: "(nullptr)".}
converter toBool*(this: ClockObject): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ClockObject, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ClockObject], obj: TypedObject): ClockObject {.importcpp: "DCAST(ClockObject, @)".}

type
  ColorSpace* = enum
    CS_unspecified = 0
    CS_linear = 1
    CS_sRGB = 2
    CS_scRGB = 3

type
  DatagramBuffer* {.importcpp: "DatagramBuffer", pure, inheritable, header: "datagramBuffer.h".} = object of DatagramSink

type
  DatagramInputFile* {.importcpp: "DatagramInputFile", pure, inheritable, header: "datagramInputFile.h".} = object of DatagramGenerator

type
  DatagramOutputFile* {.importcpp: "DatagramOutputFile", pure, inheritable, header: "datagramOutputFile.h".} = object of DatagramSink

type
  GamepadButton* {.importcpp: "GamepadButton", pure, inheritable, header: "gamepadButton.h".} = object

type
  KeyboardButton* {.importcpp: "KeyboardButton", pure, inheritable, header: "keyboardButton.h".} = object

type
  ModifierButtons* {.importcpp: "ModifierButtons", pure, inheritable, header: "modifierButtons.h".} = object

type
  MouseButton* {.importcpp: "MouseButton", pure, inheritable, header: "mouseButton.h".} = object

type
  PointerType* {.pure.} = enum
    unknown = 0
    mouse = 1
    finger = 2
    stylus = 3
    eraser = 4

type
  PointerData* {.importcpp: "PointerData", pure, inheritable, header: "pointerData.h".} = object

type
  MouseData* = PointerData

type
  SparseArray* {.importcpp: "SparseArray", pure, inheritable, header: "sparseArray.h".} = object

type
  ParamTypedRefCount* {.importcpp: "PT(ParamTypedRefCount)", bycopy, pure, inheritable, header: "paramTypedRefCount.h".} = object of ParamValueBase

converter toParamTypedRefCount*(_: type(nil)): ParamTypedRefCount {.importcpp: "(nullptr)".}
converter toBool*(this: ParamTypedRefCount): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ParamTypedRefCount, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ParamTypedRefCount], obj: TypedObject): ParamTypedRefCount {.importcpp: "DCAST(ParamTypedRefCount, @)".}

type
  WritableConfigurable* {.importcpp: "WritableConfigurable", pure, inheritable, header: "writableConfigurable.h".} = object of TypedWritable

type
  UniqueIdAllocator* {.importcpp: "UniqueIdAllocator", pure, inheritable, header: "uniqueIdAllocator.h".} = object

type
  FilterProperties* {.importcpp: "PT(FilterProperties)", bycopy, pure, inheritable, header: "filterProperties.h".} = object of TypedReferenceCount

converter toFilterProperties*(_: type(nil)): FilterProperties {.importcpp: "(nullptr)".}
converter toBool*(this: FilterProperties): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: FilterProperties, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[FilterProperties], obj: TypedObject): FilterProperties {.importcpp: "DCAST(FilterProperties, @)".}

type
  AudioSound* {.importcpp: "PT(AudioSound)", bycopy, pure, inheritable, header: "audioSound.h".} = object of TypedReferenceCount

converter toAudioSound*(_: type(nil)): AudioSound {.importcpp: "(nullptr)".}
converter toBool*(this: AudioSound): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AudioSound, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AudioSound], obj: TypedObject): AudioSound {.importcpp: "DCAST(AudioSound, @)".}

type
  AudioManager* {.importcpp: "PT(AudioManager)", bycopy, pure, inheritable, header: "audioManager.h".} = object of TypedReferenceCount

converter toAudioManager*(_: type(nil)): AudioManager {.importcpp: "(nullptr)".}
converter toBool*(this: AudioManager): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AudioManager, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AudioManager], obj: TypedObject): AudioManager {.importcpp: "DCAST(AudioManager, @)".}

type
  AudioLoadRequest* {.importcpp: "PT(AudioLoadRequest)", bycopy, pure, inheritable, header: "audioLoadRequest.h".} = object of AsyncTask

converter toAudioLoadRequest*(_: type(nil)): AudioLoadRequest {.importcpp: "(nullptr)".}
converter toBool*(this: AudioLoadRequest): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AudioLoadRequest, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AudioLoadRequest], obj: TypedObject): AudioLoadRequest {.importcpp: "DCAST(AudioLoadRequest, @)".}

type
  PGFrameStyle* {.importcpp: "PGFrameStyle", pure, inheritable, header: "pGFrameStyle.h".} = object

type
  PGItem* {.importcpp: "PT(PGItem)", bycopy, pure, inheritable, header: "pGItem.h".} = object of PandaNode

converter toPGItem*(_: type(nil)): PGItem {.importcpp: "(nullptr)".}
converter toBool*(this: PGItem): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGItem, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGItem], obj: TypedObject): PGItem {.importcpp: "DCAST(PGItem, @)".}

type
  PGButton* {.importcpp: "PT(PGButton)", bycopy, pure, inheritable, header: "pGButton.h".} = object of PGItem

converter toPGButton*(_: type(nil)): PGButton {.importcpp: "(nullptr)".}
converter toBool*(this: PGButton): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGButton, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGButton], obj: TypedObject): PGButton {.importcpp: "DCAST(PGButton, @)".}

type
  PGTop* {.importcpp: "PT(PGTop)", bycopy, pure, inheritable, header: "pGTop.h".} = object of PandaNode

converter toPGTop*(_: type(nil)): PGTop {.importcpp: "(nullptr)".}
converter toBool*(this: PGTop): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGTop, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGTop], obj: TypedObject): PGTop {.importcpp: "DCAST(PGTop, @)".}

type
  PGEntry* {.importcpp: "PT(PGEntry)", bycopy, pure, inheritable, header: "pGEntry.h".} = object of PGItem

converter toPGEntry*(_: type(nil)): PGEntry {.importcpp: "(nullptr)".}
converter toBool*(this: PGEntry): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGEntry, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGEntry], obj: TypedObject): PGEntry {.importcpp: "DCAST(PGEntry, @)".}

type
  PGMouseWatcherParameter* {.importcpp: "PT(PGMouseWatcherParameter)", bycopy, pure, inheritable, header: "pGMouseWatcherParameter.h".} = object of TypedWritableReferenceCount

converter toPGMouseWatcherParameter*(_: type(nil)): PGMouseWatcherParameter {.importcpp: "(nullptr)".}
converter toBool*(this: PGMouseWatcherParameter): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGMouseWatcherParameter, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGMouseWatcherParameter], obj: TypedObject): PGMouseWatcherParameter {.importcpp: "DCAST(PGMouseWatcherParameter, @)".}

type
  PGMouseWatcherBackground* {.importcpp: "PT(PGMouseWatcherBackground)", bycopy, pure, inheritable, header: "pGMouseWatcherBackground.h".} = object of MouseWatcherRegion

converter toPGMouseWatcherBackground*(_: type(nil)): PGMouseWatcherBackground {.importcpp: "(nullptr)".}
converter toBool*(this: PGMouseWatcherBackground): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGMouseWatcherBackground, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGMouseWatcherBackground], obj: TypedObject): PGMouseWatcherBackground {.importcpp: "DCAST(PGMouseWatcherBackground, @)".}

type
  PGVirtualFrame* {.importcpp: "PT(PGVirtualFrame)", bycopy, pure, inheritable, header: "pGVirtualFrame.h".} = object of PGItem

converter toPGVirtualFrame*(_: type(nil)): PGVirtualFrame {.importcpp: "(nullptr)".}
converter toBool*(this: PGVirtualFrame): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGVirtualFrame, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGVirtualFrame], obj: TypedObject): PGVirtualFrame {.importcpp: "DCAST(PGVirtualFrame, @)".}

type
  PGSliderBar* {.importcpp: "PT(PGSliderBar)", bycopy, pure, inheritable, header: "pGSliderBar.h".} = object of PGItem

converter toPGSliderBar*(_: type(nil)): PGSliderBar {.importcpp: "(nullptr)".}
converter toBool*(this: PGSliderBar): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGSliderBar, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGSliderBar], obj: TypedObject): PGSliderBar {.importcpp: "DCAST(PGSliderBar, @)".}

type
  PGScrollFrame* {.importcpp: "PT(PGScrollFrame)", bycopy, pure, inheritable, header: "pGScrollFrame.h".} = object of PGVirtualFrame

converter toPGScrollFrame*(_: type(nil)): PGScrollFrame {.importcpp: "(nullptr)".}
converter toBool*(this: PGScrollFrame): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGScrollFrame, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGScrollFrame], obj: TypedObject): PGScrollFrame {.importcpp: "DCAST(PGScrollFrame, @)".}

type
  PGWaitBar* {.importcpp: "PT(PGWaitBar)", bycopy, pure, inheritable, header: "pGWaitBar.h".} = object of PGItem

converter toPGWaitBar*(_: type(nil)): PGWaitBar {.importcpp: "(nullptr)".}
converter toBool*(this: PGWaitBar): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGWaitBar, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGWaitBar], obj: TypedObject): PGWaitBar {.importcpp: "DCAST(PGWaitBar, @)".}

type
  NetAddress* {.importcpp: "NetAddress", pure, inheritable, header: "netAddress.h".} = object

type
  Connection* {.importcpp: "PT(Connection)", bycopy, pure, inheritable, header: "connection.h".} = object of ReferenceCount

converter toConnection*(_: type(nil)): Connection {.importcpp: "(nullptr)".}
converter toBool*(this: Connection): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Connection, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Connection], obj: TypedObject): Connection {.importcpp: "DCAST(Connection, @)".}

type
  ConnectionReader* {.importcpp: "ConnectionReader", pure, inheritable, header: "connectionReader.h".} = object

type
  ConnectionListener* {.importcpp: "ConnectionListener", pure, inheritable, header: "connectionListener.h".} = object of ConnectionReader

type
  NetDatagram* {.importcpp: "NetDatagram", pure, inheritable, header: "netDatagram.h".} = object of Datagram

type
  ConnectionManager* {.importcpp: "ConnectionManager", pure, inheritable, header: "connectionManager.h".} = object

type
  ConnectionWriter* {.importcpp: "ConnectionWriter", pure, inheritable, header: "connectionWriter.h".} = object

type
  DatagramGeneratorNet* {.importcpp: "DatagramGeneratorNet", pure, inheritable, header: "datagramGeneratorNet.h".} = object of DatagramGenerator

type
  DatagramSinkNet* {.importcpp: "DatagramSinkNet", pure, inheritable, header: "datagramSinkNet.h".} = object of DatagramSink

type
  QueuedConnectionListener* {.importcpp: "QueuedConnectionListener", pure, inheritable, header: "queuedConnectionListener.h".} = object of ConnectionListener

type
  QueuedConnectionManager* {.importcpp: "QueuedConnectionManager", pure, inheritable, header: "queuedConnectionManager.h".} = object of ConnectionManager

type
  QueuedConnectionReader* {.importcpp: "QueuedConnectionReader", pure, inheritable, header: "queuedConnectionReader.h".} = object of ConnectionReader

type
  RecentConnectionReader* {.importcpp: "RecentConnectionReader", pure, inheritable, header: "recentConnectionReader.h".} = object of ConnectionReader

type
  Socket_Address* {.importcpp: "Socket_Address", pure, inheritable, header: "socket_Address.h".} = object

type
  Socket_IP* {.importcpp: "Socket_IP", pure, inheritable, header: "socket_IP.h".} = object of TypedObject

type
  Socket_TCP* {.importcpp: "Socket_TCP", pure, inheritable, header: "socket_TCP.h".} = object of Socket_IP

type
  Socket_TCP_Listen* {.importcpp: "Socket_TCP_Listen", pure, inheritable, header: "socket_TCP_Listen.h".} = object of Socket_IP

type
  Socket_UDP_Incoming* {.importcpp: "Socket_UDP_Incoming", pure, inheritable, header: "socket_UDP_Incoming.h".} = object of Socket_IP

type
  Socket_UDP_Outgoing* {.importcpp: "Socket_UDP_Outgoing", pure, inheritable, header: "socket_UDP_Outgoing.h".} = object of Socket_IP

type
  Socket_fdset* {.importcpp: "Socket_fdset", pure, inheritable, header: "socket_fdset.h".} = object

type
  Buffered_DatagramConnection* {.importcpp: "Buffered_DatagramConnection", pure, inheritable, header: "buffered_DatagramConnection.h".} = object of Socket_TCP

type
  Socket_UDP* {.importcpp: "Socket_UDP", pure, inheritable, header: "socket_UDP.h".} = object of Socket_UDP_Incoming

type
  TiXmlBase* {.importcpp: "TiXmlBase", pure, inheritable, header: "tiXmlBase.h".} = object

type
  TiXmlNode* {.importcpp: "TiXmlNode", pure, inheritable, header: "tiXmlNode.h".} = object of TiXmlBase

type
  TiXmlDeclaration* {.importcpp: "TiXmlDeclaration", pure, inheritable, header: "tiXmlDeclaration.h".} = object of TiXmlNode

type
  TiXmlDocument* {.importcpp: "TiXmlDocument", pure, inheritable, header: "tiXmlDocument.h".} = object of TiXmlNode

type
  TiXmlElement* {.importcpp: "TiXmlElement", pure, inheritable, header: "tiXmlElement.h".} = object of TiXmlNode

type
  TiXmlCursor* {.importcpp: "TiXmlCursor", pure, inheritable, header: "tiXmlCursor.h".} = object

type
  TiXmlVisitor* {.importcpp: "TiXmlVisitor", pure, inheritable, header: "tiXmlVisitor.h".} = object

const TIXML_SUCCESS*: int = 0
const TIXML_NO_ATTRIBUTE*: int = 1
const TIXML_WRONG_TYPE*: int = 2

type
  TiXmlEncoding* = enum
    TIXML_ENCODING_UNKNOWN = 0
    TIXML_ENCODING_UTF8 = 1
    TIXML_ENCODING_LEGACY = 2

type
  TiXmlAttribute* {.importcpp: "TiXmlAttribute", pure, inheritable, header: "tiXmlAttribute.h".} = object of TiXmlBase

type
  TiXmlAttributeSet* {.importcpp: "TiXmlAttributeSet", pure, inheritable, header: "tiXmlAttributeSet.h".} = object

type
  TiXmlComment* {.importcpp: "TiXmlComment", pure, inheritable, header: "tiXmlComment.h".} = object of TiXmlNode

type
  TiXmlText* {.importcpp: "TiXmlText", pure, inheritable, header: "tiXmlText.h".} = object of TiXmlNode

type
  TiXmlUnknown* {.importcpp: "TiXmlUnknown", pure, inheritable, header: "tiXmlUnknown.h".} = object of TiXmlNode

type
  TiXmlHandle* {.importcpp: "TiXmlHandle", pure, inheritable, header: "tiXmlHandle.h".} = object

type
  TiXmlPrinter* {.importcpp: "TiXmlPrinter", pure, inheritable, header: "tiXmlPrinter.h".} = object of TiXmlVisitor

type
  PNMTextGlyph* {.importcpp: "PNMTextGlyph", pure, inheritable, header: "pNMTextGlyph.h".} = object

type
  PNMTextMaker* {.importcpp: "PNMTextMaker", pure, inheritable, header: "pNMTextMaker.h".} = object of FreetypeFont

func index*(this: TypeHandle): int {.importcpp: "#.get_index()".} ## \
## Returns the integer index associated with this TypeHandle.  Each different
## TypeHandle will have a different index.  However, you probably shouldn't be
## using this method; you should just treat the TypeHandles as opaque classes.
## This is provided for the convenience of non-C++ scripting languages to
## build a hashtable of TypeHandles.

func name*(this: TypeHandle, `object`: TypedObject): string {.importcpp: "nimStringFromStdString(#.get_name(#))", header: stringConversionCode.} ## \
## Returns the name of the type.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

func name*(this: TypeHandle): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the type.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

func version_string*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_version_string())", header: stringConversionCode.} ## \
## Returns the current version of Panda, expressed as a string, e.g.  "1.0.0".
## The string will end in the letter "c" if this build does not represent an
## official version.

func major_version*(_: typedesc[PandaSystem]): int {.importcpp: "PandaSystem::get_major_version()", header: "pandaSystem.h".} ## \
## Returns the major version number of the current version of Panda.  This is
## the first number of the dotted triple returned by get_version_string().  It
## changes very rarely.

func minor_version*(_: typedesc[PandaSystem]): int {.importcpp: "PandaSystem::get_minor_version()", header: "pandaSystem.h".} ## \
## Returns the minor version number of the current version of Panda.  This is
## the second number of the dotted triple returned by get_version_string().
## It changes with each release that introduces new features.

func sequence_version*(_: typedesc[PandaSystem]): int {.importcpp: "PandaSystem::get_sequence_version()", header: "pandaSystem.h".} ## \
## Returns the sequence version number of the current version of Panda.  This
## is the third number of the dotted triple returned by get_version_string().
## It changes with bugfix updates and very minor feature updates.

func official_version*(_: typedesc[PandaSystem]): bool {.importcpp: "PandaSystem::is_official_version()", header: "pandaSystem.h".} ## \
## Returns true if current version of Panda claims to be an "official"
## version, that is, one that was compiled by an official distributor of Panda
## using a specific version of the panda source tree.  If this is true, there
## will not be a "c" at the end of the version string returned by
## get_version_string().
##
## Note that we must take the distributor's word for it here.

func memory_alignment*(_: typedesc[PandaSystem]): int {.importcpp: "PandaSystem::get_memory_alignment()", header: "pandaSystem.h".} ## \
## Returns the memory alignment that Panda's allocators are using.

func distributor*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_distributor())", header: stringConversionCode.} ## \
## Returns the string defined by the distributor of this version of Panda, or
## "homebuilt" if this version was built directly from the sources by the end-
## user.  This is a completely arbitrary string.

func compiler*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_compiler())", header: stringConversionCode.} ## \
## Returns a string representing the compiler that was used to generate this
## version of Panda, if it is available, or "unknown" if it is not.

func build_date*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_build_date())", header: stringConversionCode.} ## \
## Returns a string representing the date and time at which this version of
## Panda (or at least dtool) was compiled, if available.

func git_commit*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_git_commit())", header: stringConversionCode.} ## \
## Returns a string representing the git commit hash that this source tree is
## based on, or the empty string if it has not been specified at build time.

func platform*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_platform())", header: stringConversionCode.} ## \
## Returns a string representing the runtime platform that we are currently
## running on.  This will be something like "win32" or "osx_i386" or
## "linux_amd64".

func binary_name*(_: typedesc[ExecutionEnvironment]): string {.importcpp: "nimStringFromStdString(ExecutionEnvironment::get_binary_name())", header: stringConversionCode.} ## \
## Returns the name of the binary executable that started this program, if it
## can be determined.

proc `binary_name=`*(_: typedesc[ExecutionEnvironment], name: string) {.importcpp: "ExecutionEnvironment::set_binary_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Do not use.

func dtool_name*(_: typedesc[ExecutionEnvironment]): string {.importcpp: "nimStringFromStdString(ExecutionEnvironment::get_dtool_name())", header: stringConversionCode.} ## \
## Returns the name of the libdtool DLL that is used in this program, if it
## can be determined.

proc `dtool_name=`*(_: typedesc[ExecutionEnvironment], name: string) {.importcpp: "ExecutionEnvironment::set_dtool_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Do not use.

func cwd*(_: typedesc[ExecutionEnvironment]): Filename {.importcpp: "ExecutionEnvironment::get_cwd()", header: "executionEnvironment.h".} ## \
## Returns the name of the current working directory.

func pattern*(this: GlobPattern): string {.importcpp: "nimStringFromStdString(#.get_pattern())", header: stringConversionCode.} ## \
## Returns the pattern string that the GlobPattern object matches.

proc `pattern=`*(this: GlobPattern, pattern: string) {.importcpp: "#.set_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the pattern string that the GlobPattern object matches.

func case_sensitive*(this: GlobPattern): bool {.importcpp: "#.get_case_sensitive()".} ## \
## Returns whether the match is case sensitive (true) or case insensitive
## (false).  The default is case sensitive.

proc `case_sensitive=`*(this: GlobPattern, case_sensitive: bool) {.importcpp: "#.set_case_sensitive(#)".} ## \
## Sets whether the match is case sensitive (true) or case insensitive
## (false).  The default is case sensitive.

func nomatch_chars*(this: GlobPattern): string {.importcpp: "nimStringFromStdString(#.get_nomatch_chars())", header: stringConversionCode.} ## \
## Returns the set of characters that are not matched by * or ?.

proc `nomatch_chars=`*(this: GlobPattern, nomatch_chars: string) {.importcpp: "#.set_nomatch_chars(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies a set of characters that are not matched by * or ?.

func name*(this: ConfigPage): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the page.  If the page was loaded from a .prc file,
## this is usually the filename.

func special*(this: ConfigPage): bool {.importcpp: "#.is_special()".} ## \
## Returns true if this is the special "default" or "local" page, or false if
## it is an ordinary page, e.g.  an implicit page loaded from a prc file at
## startup, or an explicit page created by
## ConfigPageManager::make_explicit_page().

func implicit*(this: ConfigPage): bool {.importcpp: "#.is_implicit()".} ## \
## Returns true if the page was loaded by implicitly searching the config path
## on startup, or false if it was explicitly loaded by dynamic code after
## initial startup.

func sort*(this: ConfigPage): int {.importcpp: "#.get_sort()".} ## \
## Returns the explicit sort order of this particular ConfigPage.  See
## set_sort().

proc `sort=`*(this: ConfigPage, sort: int) {.importcpp: "#.set_sort(#)".} ## \
## Changes the explicit sort order of this particular ConfigPage.  Lower-
## numbered pages supercede higher-numbered pages.  Initially, all explicitly-
## loaded pages have sort value 0, and implicitly-loaded pages (found on disk)
## have sort value 10; you may set an individual page higher or lower to
## influence its priority relative to other pages.

func page_seq*(this: ConfigPage): int {.importcpp: "#.get_page_seq()".} ## \
## Returns the sequence number of the page.
##
## Sequence numbers for a particular class (implicit vs.  explicit) of pages
## are assigned as each page is loaded; each page is given a higher sequence
## number than all the pages loaded before it.
##
## The implicit_load pages, which are discovered in the file system
## automatically, have a different set of sequence numbers than the explicit
## pages.

func trust_level*(this: ConfigPage): int {.importcpp: "#.get_trust_level()".} ## \
## Returns the trust level associated with this page.  An untrusted page is
## trust level 0; if the page was loaded from a signed .prc file, its trust
## level is the index number of the certificate that signed it.  Generally, a
## higher trust level value represents a greater level of trust.

proc `trust_level=`*(this: ConfigPage, trust_level: int) {.importcpp: "#.set_trust_level(#)".} ## \
## Explicitly sets the trust level on this particular page.  Note that any
## subsequent changes to the page, or to any variable declarations on it, will
## reset the trust level to zero.

func signature*(this: ConfigPage): string {.importcpp: "nimStringFromStdString(#.get_signature())", header: stringConversionCode.} ## \
## Returns the raw binary signature that was found in the prc file, if any.
## This method is probably not terribly useful for most applications.

func page*(this: ConfigDeclaration): ConfigPage {.importcpp: "#.get_page()".} ## \
## Returns the page on which this declaration can be found.

func variable*(this: ConfigDeclaration): ConfigVariableCore {.importcpp: "#.get_variable()".} ## \
## Returns the variable that this declaration names.  This variable may or may
## not have been defined by the time the declaration is read.

func name*(this: ConfigVariableCore): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the variable.

func used*(this: ConfigVariableCore): bool {.importcpp: "#.is_used()".} ## \
## Returns true if the variable has been referenced by a ConfigVariable
## somewhere in code, false otherwise.

func closed*(this: ConfigVariableCore): bool {.importcpp: "#.is_closed()".} ## \
## Returns true if the variable is not trusted by any prc file (and hence
## cannot be modified from its compiled-in default value), or false for the
## normal case, in which the variable can be modified by any prc file at or
## above its trust level (see get_trust_level()).
##
## This value only has effect in a release build (specifically, when
## PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).

func trust_level*(this: ConfigVariableCore): int {.importcpp: "#.get_trust_level()".} ## \
## Returns the minimum trust_level a prc file must demonstrate in order to
## redefine the value for this variable.  Arguably, this should be called the
## "mistrust level", since the larger the value, the more suspicious we are of
## prc files.  This value is not used if is_closed() returns true, which
## indicates no file may be trusted.
##
## This value only has effect in a release build (specifically, when
## PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).

func dynamic*(this: ConfigVariableCore): bool {.importcpp: "#.is_dynamic()".} ## \
## Returns true if the variable was indicated as "dynamic" by its constructor,
## indicating that its name was dynamically generated, possibly from a large
## pool, and it should not be listed along with the other variables.

func description*(this: ConfigVariableCore): string {.importcpp: "nimStringFromStdString(#.get_description())", header: stringConversionCode.} ## \
## Returns the brief description of this variable, if it has been defined.

proc `description=`*(this: ConfigVariableCore, description: string) {.importcpp: "#.set_description(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the one-line description of this variable.  See
## get_description().  It is not an error to call this multiple times, but if
## the value changes once get_declaration() has been called, a warning is
## printed.

func default_value*(this: ConfigVariableCore): ConfigDeclaration {.importcpp: "#.get_default_value()".} ## \
## Returns the default variable specified for this variable.  If the variable
## has not yet been defined, this will return NULL.

proc `default_value=`*(this: ConfigVariableCore, default_value: string) {.importcpp: "#.set_default_value(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the default value for this variable if it is not defined in any
## prc file.

func search_path*(this: ConfigPageManager): DSearchPath {.importcpp: "#.get_search_path()".} ## \
## Returns the search path used to locate implicit .prc files.  This is
## determined by the PRC_DIR and PRC_PATH environment variables.  The object
## returned by this method may be modified to change the path at runtime, and
## then reload_implicit_pages() called.

func name*(this: ConfigVariableBase): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the variable.

func description*(this: ConfigVariableBase): string {.importcpp: "nimStringFromStdString(#.get_description())", header: stringConversionCode.} ## \
## Returns the brief description of this variable, if it has been defined.

func closed*(this: ConfigVariableBase): bool {.importcpp: "#.is_closed()".} ## \
## Returns true if the variable is not trusted by any prc file (and hence
## cannot be modified from its compiled-in default value), or false for the
## normal case, in which the variable can be modified by any prc file at or
## above its trust level (see get_trust_level()).
##
## This value only has effect in a release build (specifically, when
## PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).

func trust_level*(this: ConfigVariableBase): int {.importcpp: "#.get_trust_level()".} ## \
## Returns the minimum trust_level a prc file must demonstrate in order to
## redefine the value for this variable.  Arguably, this should be called the
## "mistrust level", since the larger the value, the more suspicious we are of
## prc files.  This value is not used if is_closed() returns true, which
## indicates no file may be trusted.
##
## This value only has effect in a release build (specifically, when
## PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).

func dynamic*(this: ConfigVariableBase): bool {.importcpp: "#.is_dynamic()".} ## \
## Returns true if the variable was indicated as "dynamic" by its constructor,
## indicating that its name was dynamically generated, possibly from a large
## pool, and it should not be listed along with the other variables.

func value*(this: ConfigVariableBool): bool {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc `value=`*(this: ConfigVariableBool, value: bool) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

func default_value*(this: ConfigVariableBool): bool {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

func value*(this: ConfigVariableDouble): float64 {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc `value=`*(this: ConfigVariableDouble, value: float64) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

func default_value*(this: ConfigVariableDouble): float64 {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

func value*(this: ConfigVariableFilename): Filename {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc `value=`*(this: ConfigVariableFilename, value: Filename) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

func default_value*(this: ConfigVariableFilename): Filename {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

func value*(this: ConfigVariableInt): int {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc `value=`*(this: ConfigVariableInt, value: int) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

func default_value*(this: ConfigVariableInt): int {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

func value*(this: ConfigVariableInt64): clonglong {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc `value=`*(this: ConfigVariableInt64, value: clonglong) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

func default_value*(this: ConfigVariableInt64): clonglong {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

func value*(this: ConfigVariableSearchPath): DSearchPath {.importcpp: "#.get_value()".}

func default_value*(this: ConfigVariableSearchPath): DSearchPath {.importcpp: "#.get_default_value()".}

func value*(this: ConfigVariableString): string {.importcpp: "nimStringFromStdString(#.get_value())", header: stringConversionCode.} ## \
## Returns the variable's value.

proc `value=`*(this: ConfigVariableString, value: string) {.importcpp: "#.set_value(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reassigns the variable's local value.

func default_value*(this: ConfigVariableString): string {.importcpp: "nimStringFromStdString(#.get_default_value())", header: stringConversionCode.} ## \
## Returns the variable's default value.

func fullname*(this: NotifyCategory): string {.importcpp: "nimStringFromStdString(#.get_fullname())", header: stringConversionCode.}

func basename*(this: NotifyCategory): string {.importcpp: "nimStringFromStdString(#.get_basename())", header: stringConversionCode.}

func severity*(this: NotifyCategory): NotifySeverity {.importcpp: "#.get_severity()".}

proc `severity=`*(this: NotifyCategory, severity: NotifySeverity) {.importcpp: "#.set_severity(#)".} ## \
## Sets the severity level of messages that will be reported from this
## Category.  This allows any message of this severity level or higher.

func algorithm*(this: IDecryptStream): string {.importcpp: "nimStringFromStdString(#.get_algorithm())", header: stringConversionCode.} ## \
## Returns the encryption algorithm that was read from the stream.

func key_length*(this: IDecryptStream): int {.importcpp: "#.get_key_length()".} ## \
## Returns the encryption key length, in bits, that was read from the stream.

func iteration_count*(this: IDecryptStream): int {.importcpp: "#.get_iteration_count()".} ## \
## Returns the value that was was read from the stream.

proc `algorithm=`*(this: OEncryptStream, algorithm: string) {.importcpp: "#.set_algorithm(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the encryption algorithm that should be used for future calls to
## open().  The default is whatever is specified by the encryption-algorithm
## config variable.  The complete set of available algorithms is defined by
## the current version of OpenSSL.
##
## If an invalid algorithm is specified, there is no immediate error return
## code, but open() will fail.

proc `key_length=`*(this: OEncryptStream, key_length: int) {.importcpp: "#.set_key_length(#)".} ## \
## Specifies the length of the key, in bits, that should be used to encrypt
## the stream in future calls to open().  The default is whatever is specified
## by the encryption-key-length config variable.
##
## If an invalid key_length for the chosen algorithm is specified, there is no
## immediate error return code, but open() will fail.

proc `iteration_count=`*(this: OEncryptStream, iteration_count: int) {.importcpp: "#.set_iteration_count(#)".} ## \
## Specifies the number of times to repeatedly hash the key before writing it
## to the stream in future calls to open().  Its purpose is to make it
## computationally more expensive for an attacker to search the key space
## exhaustively.  This should be a multiple of 1,000 and should not exceed
## about 65 million; the value 0 indicates just one application of the hashing
## algorithm.
##
## The default is whatever is specified by the encryption-iteration-count
## config variable.

func scheme*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_scheme())", header: stringConversionCode.} ## \
## Returns the scheme specified by the URL, or empty string if no scheme is
## specified.

proc `scheme=`*(this: URLSpec, scheme: string) {.importcpp: "#.set_scheme(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the scheme part of the URL specification.

func authority*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_authority())", header: stringConversionCode.} ## \
## Returns the authority specified by the URL (this includes username, server,
## and/or port), or empty string if no authority is specified.

proc `authority=`*(this: URLSpec, authority: string) {.importcpp: "#.set_authority(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the authority part of the URL specification.  This includes the
## username, server, and port.

func username*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_username())", header: stringConversionCode.} ## \
## Returns the username specified by the URL, if any.  This might also include
## a password, e.g.  "username:password", although putting a password on the
## URL is probably a bad idea.

proc `username=`*(this: URLSpec, username: string) {.importcpp: "#.set_username(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the username part of the URL specification.

func server*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_server())", header: stringConversionCode.} ## \
## Returns the server name specified by the URL, if any.  In case of an IPv6
## address, does not include the enclosing brackets.

proc `server=`*(this: URLSpec, server: string) {.importcpp: "#.set_server(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the server part of the URL specification.
## Unlike set_server_and_port, this method does not require IPv6 addresses to
## be enclosed in square brackets.

func port*(this: URLSpec): int {.importcpp: "#.get_port()".} ## \
## Returns the port number specified by the URL, or the default port if not
## specified.

proc `port=`*(this: URLSpec, port: string) {.importcpp: "#.set_port(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the port part of the URL specification.

proc `port=`*(this: URLSpec, port: int) {.importcpp: "#.set_port(#)".} ## \
## Replaces the port part of the URL specification, given a numeric port
## number.

func server_and_port*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_server_and_port())", header: stringConversionCode.} ## \
## Returns a string consisting of the server name, followed by a colon,
## followed by the port number.  If the port number is not explicitly given in
## the URL, this string will include the implicit port number.
## If the server is an IPv6 address, it will be enclosed in square brackets.

proc `server_and_port=`*(this: URLSpec, server_and_port: string) {.importcpp: "#.set_server_and_port(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the server and port parts of the URL specification simultaneously.
## The input string should be of the form "server:port", or just "server" to
## make the port number implicit.
## Any IPv6 address must be enclosed in square brackets.

func path*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_path())", header: stringConversionCode.} ## \
## Returns the path specified by the URL, or "/" if no path is specified.

proc `path=`*(this: URLSpec, path: string) {.importcpp: "#.set_path(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the path part of the URL specification.

func query*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_query())", header: stringConversionCode.} ## \
## Returns the query specified by the URL, or empty string if no query is
## specified.

proc `query=`*(this: URLSpec, query: string) {.importcpp: "#.set_query(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the query part of the URL specification.

func ssl*(this: URLSpec): bool {.importcpp: "#.is_ssl()".} ## \
## Returns true if the URL's scheme specifies an SSL-secured protocol such as
## https, or false otherwise.

func name*(this: HTTPCookie): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the cookie.  This is the key value specified by the
## server.

proc `name=`*(this: HTTPCookie, name: string) {.importcpp: "#.set_name(nimStringToStdString(#))", header: stringConversionCode.}

func value*(this: HTTPCookie): string {.importcpp: "nimStringFromStdString(#.get_value())", header: stringConversionCode.} ## \
## Returns the value of the cookie.  This is the arbitrary string associated
## with the cookie's name, as specified by the server.

proc `value=`*(this: HTTPCookie, value: string) {.importcpp: "#.set_value(nimStringToStdString(#))", header: stringConversionCode.}

func domain*(this: HTTPCookie): string {.importcpp: "nimStringFromStdString(#.get_domain())", header: stringConversionCode.}

proc `domain=`*(this: HTTPCookie, domain: string) {.importcpp: "#.set_domain(nimStringToStdString(#))", header: stringConversionCode.}

func path*(this: HTTPCookie): string {.importcpp: "nimStringFromStdString(#.get_path())", header: stringConversionCode.} ## \
## Returns the prefix of the URL paths on the server for which this cookie
## will be sent.

proc `path=`*(this: HTTPCookie, path: string) {.importcpp: "#.set_path(nimStringToStdString(#))", header: stringConversionCode.}

func expires*(this: HTTPCookie): HTTPDate {.importcpp: "#.get_expires()".} ## \
## Returns the expiration date of the cookie if it is set, or an invalid date
## if it is not.

proc `expires=`*(this: HTTPCookie, expires: HTTPDate) {.importcpp: "#.set_expires(#)".}

func secure*(this: HTTPCookie): bool {.importcpp: "#.get_secure()".} ## \
## Returns true if the server has indicated this is a "secure" cookie which
## should only be sent over an HTTPS channel.

proc `secure=`*(this: HTTPCookie, flag: bool) {.importcpp: "#.set_secure(#)".}

func ref_count*(this: ReferenceCount): int {.importcpp: "#->get_ref_count()".} ## \
## Returns the current reference count.

func url*(this: DocumentSpec): URLSpec {.importcpp: "#.get_url()".} ## \
## Retrieves the URL of the DocumentSpec.

proc `url=`*(this: DocumentSpec, url: URLSpec) {.importcpp: "#.set_url(#)".} ## \
## Changes the URL of the DocumentSpec without modifying its other properties.
## Normally this would be a strange thing to do, because the tag and date are
## usually strongly associated with the URL.  To get a DocumentSpec pointing
## to a new URL, you would normally create a new DocumentSpec object.

func tag*(this: DocumentSpec): HTTPEntityTag {.importcpp: "#.get_tag()".} ## \
## Returns the identity tag associated with the DocumentSpec, if there is one.
## It is an error to call this if has_tag() returns false.
##
## The identity tag is set by the HTTP server to uniquely refer to a
## particular version of a document.

proc `tag=`*(this: DocumentSpec, tag: HTTPEntityTag) {.importcpp: "#.set_tag(#)".} ## \
## Changes the identity tag associated with the DocumentSpec.

func date*(this: DocumentSpec): HTTPDate {.importcpp: "#.get_date()".} ## \
## Returns the last-modified date associated with the DocumentSpec, if there
## is one.  It is an error to call this if has_date() returns false.

proc `date=`*(this: DocumentSpec, date: HTTPDate) {.importcpp: "#.set_date(#)".} ## \
## Changes the last-modified date associated with the DocumentSpec.

func progress*(this: Decompressor): float32 {.importcpp: "#.get_progress()".} ## \
## Returns the ratio through the decompression step in the background.

func progress*(this: Extractor): float32 {.importcpp: "#.get_progress()".} ## \
## Returns the fraction of the Multifile extracted so far.

func tracking*(_: typedesc[MemoryUsage]): bool {.importcpp: "MemoryUsage::is_tracking()", header: "memoryUsage.h".} ## \
## Returns true if the MemoryUsage object is currently tracking memory (e.g.
## track-memory-usage is configured #t).

func counting*(_: typedesc[MemoryUsage]): bool {.importcpp: "MemoryUsage::is_counting()", header: "memoryUsage.h".} ## \
## Returns true if the MemoryUsage object is currently at least counting
## memory (e.g.  this is a Windows debug build), even if it's not fully
## tracking it.

func current_cpp_size*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_current_cpp_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes of allocated memory consumed by C++
## objects, not including the memory previously frozen.

func total_cpp_size*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_total_cpp_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes of allocated memory consumed by C++
## objects, including the memory previously frozen.

func panda_heap_single_size*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_panda_heap_single_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes allocated from the heap from code within
## Panda, for individual objects.

func panda_heap_array_size*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_panda_heap_array_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes allocated from the heap from code within
## Panda, for arrays.

func panda_heap_overhead*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_panda_heap_overhead()", header: "memoryUsage.h".} ## \
## Returns the extra bytes allocated from the system that are not immediately
## used for holding allocated objects.  This can only be determined if
## ALTERNATIVE_MALLOC is enabled.

func panda_mmap_size*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_panda_mmap_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes allocated from the virtual memory pool
## from code within Panda.

func external_size*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_external_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes of allocated memory in the heap that
## Panda didn't seem to be responsible for.  This includes a few bytes for
## very low-level objects (like ConfigVariables) that cannot use Panda memory
## tracking because they are so very low-level.
##
## This also includes all of the memory that might have been allocated by a
## high-level interpreter, like Python.
##
## This number is only available if Panda is able to hook into the actual heap
## callback.

func total_size*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_total_size()", header: "memoryUsage.h".} ## \
## Returns the total size of allocated memory consumed by the process, as
## nearly as can be determined.

func filename*(this: DatagramSink): Filename {.importcpp: "#.get_filename()".} ## \
## Returns the filename that provides the target for these datagrams, if any,
## or empty string if the datagrams do not get written to a file on disk.

func file*(this: DatagramSink): FileReference {.importcpp: "#.get_file()".} ## \
## Returns the FileReference that provides the target for these datagrams, if
## any, or NULL if the datagrams do not written to a file on disk.

func file_pos*(this: DatagramSink): clonglong {.importcpp: "#.get_file_pos()".} ## \
## Returns the current file position within the data stream, if any, or 0 if
## the file position is not meaningful or cannot be determined.
##
## For DatagramSinks that return a meaningful file position, this will be
## pointing to the first byte following the datagram returned after a call to
## put_datagram().

func magic_number*(_: typedesc[Multifile]): string {.importcpp: "nimStringFromStdString(Multifile::get_magic_number())", header: "multifile.h".} ## \
## Returns a string with the first n bytes written to a Multifile, to identify
## it as a Multifile.

func name*(this: Namable): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.}

proc `name=`*(this: Namable, name: string) {.importcpp: "#.set_name(nimStringToStdString(#))", header: stringConversionCode.}

func long_time*(this: TrueClock): float64 {.importcpp: "#.get_long_time()".} ## \
## get_long_time() returns the most accurate timer we have over a long
## interval.  It may not be very precise for measuring short intervals, but
## it should not drift substantially over the long haul.

func short_time*(this: TrueClock): float64 {.importcpp: "#.get_short_time()".} ## \
## get_short_time() returns the most precise timer we have over a short
## interval.  It may tend to drift over the long haul, but it should have
## lots of digits to measure short intervals very precisely.

func short_raw_time*(this: TrueClock): float64 {.importcpp: "#.get_short_raw_time()".} ## \
## get_short_raw_time() is like get_short_time(), but does not apply any
## corrections (e.g.  paranoid-clock) to the result returned by the OS.

func error_count*(this: TrueClock): int {.importcpp: "#.get_error_count()".} ## \
## Returns the number of clock errors that have been detected.  Each time a
## clock error is detected, in which the value returned by either of the above
## methods is suspect, the value returned by this method will be incremented.
## Applications can monitor this value and react, for instance, by
## resynchronizing their clocks each time this value changes.

func progress*(this: Patchfile): float32 {.importcpp: "#.get_progress()".} ## \
## Returns a value in the range 0..1, representing the amount of progress
## through the patchfile, during a session.

func allow_multifile*(this: Patchfile): bool {.importcpp: "#.get_allow_multifile()".} ## \
## See set_allow_multifile().

proc `allow_multifile=`*(this: Patchfile, allow_multifile: bool) {.importcpp: "#.set_allow_multifile(#)".} ## \
## If this flag is set true, the Patchfile will make a special case for
## patching Panda Multifiles, if detected, and attempt to patch them on a
## subfile-by-subfile basis.  If this flag is false, the Patchfile will always
## patch the file on a full-file basis.
##
## This has effect only when building patches; it is not used for applying
## patches.

func footprint_length*(this: Patchfile): int {.importcpp: "#.get_footprint_length()".}

proc `footprint_length=`*(this: Patchfile, length: int) {.importcpp: "#.set_footprint_length(#)".}

func source_hash*(this: Patchfile): HashVal {.importcpp: "#.get_source_hash()".} ## \
## Returns the MD5 hash for the source file.

func result_hash*(this: Patchfile): HashVal {.importcpp: "#.get_result_hash()".} ## \
## Returns the MD5 hash for the file after the patch has been applied.

func state*(this: PandaNode, current_thread: Thread): RenderState {.importcpp: "#->get_state(#)".} ## \
## Returns the complete RenderState that will be applied to all nodes at this
## level and below, as set on this node.  This returns only the RenderState
## set on this particular node, and has nothing to do with state that might be
## inherited from above.

func state*(this: PandaNode): RenderState {.importcpp: "#->get_state()".} ## \
## Returns the complete RenderState that will be applied to all nodes at this
## level and below, as set on this node.  This returns only the RenderState
## set on this particular node, and has nothing to do with state that might be
## inherited from above.

proc `state=`*(this: PandaNode, state: RenderState, current_thread: Thread) {.importcpp: "#->set_state(#, #)".} ## \
## Sets the complete RenderState that will be applied to all nodes at this
## level and below.  (The actual state that will be applied to lower nodes is
## based on the composition of RenderStates from above this node as well).
## This completely replaces whatever has been set on this node via repeated
## calls to set_attrib().

proc `state=`*(this: PandaNode, state: RenderState) {.importcpp: "#->set_state(#)".} ## \
## Sets the complete RenderState that will be applied to all nodes at this
## level and below.  (The actual state that will be applied to lower nodes is
## based on the composition of RenderStates from above this node as well).
## This completely replaces whatever has been set on this node via repeated
## calls to set_attrib().

func effects*(this: PandaNode, current_thread: Thread): RenderEffects {.importcpp: "#->get_effects(#)".} ## \
## Returns the complete RenderEffects that will be applied to this node.

func effects*(this: PandaNode): RenderEffects {.importcpp: "#->get_effects()".} ## \
## Returns the complete RenderEffects that will be applied to this node.

proc `effects=`*(this: PandaNode, effects: RenderEffects, current_thread: Thread) {.importcpp: "#->set_effects(#, #)".} ## \
## Sets the complete RenderEffects that will be applied this node.  This
## completely replaces whatever has been set on this node via repeated calls
## to set_attrib().

proc `effects=`*(this: PandaNode, effects: RenderEffects) {.importcpp: "#->set_effects(#)".} ## \
## Sets the complete RenderEffects that will be applied this node.  This
## completely replaces whatever has been set on this node via repeated calls
## to set_attrib().

func transform*(this: PandaNode, current_thread: Thread): TransformState {.importcpp: "#->get_transform(#)".} ## \
## Returns the transform that has been set on this particular node.  This is
## not the net transform from the root, but simply the transform on this
## particular node.

func transform*(this: PandaNode): TransformState {.importcpp: "#->get_transform()".} ## \
## Returns the transform that has been set on this particular node.  This is
## not the net transform from the root, but simply the transform on this
## particular node.

proc `transform=`*(this: PandaNode, transform: TransformState, current_thread: Thread) {.importcpp: "#->set_transform(#, #)".} ## \
## Sets the transform that will be applied to this node and below.  This
## defines a new coordinate space at this point in the scene graph and below.

proc `transform=`*(this: PandaNode, transform: TransformState) {.importcpp: "#->set_transform(#)".} ## \
## Sets the transform that will be applied to this node and below.  This
## defines a new coordinate space at this point in the scene graph and below.

func prev_transform*(this: PandaNode, current_thread: Thread): TransformState {.importcpp: "#->get_prev_transform(#)".} ## \
## Returns the transform that has been set as this node's "previous" position.
## See set_prev_transform().

func prev_transform*(this: PandaNode): TransformState {.importcpp: "#->get_prev_transform()".} ## \
## Returns the transform that has been set as this node's "previous" position.
## See set_prev_transform().

func overall_hidden*(this: PandaNode): bool {.importcpp: "#->is_overall_hidden()".} ## \
## Returns true if the node has been hidden to all cameras by clearing its
## overall bit.

proc `overall_hidden=`*(this: PandaNode, overall_hidden: bool) {.importcpp: "#->set_overall_hidden(#)".} ## \
## Sets or clears the hidden flag.  When the hidden flag is true, the node and
## all of its children are invisible to all cameras, regardless of the setting
## of any draw masks.  Setting the hidden flag to false restores the previous
## visibility as established by the draw masks.
##
## This actually works by twiddling the reserved _overall_bit in the node's
## draw mask, which has special meaning.

func nested_vertices*(this: PandaNode, current_thread: Thread): int {.importcpp: "#->get_nested_vertices(#)".} ## \
## Returns the total number of vertices that will be rendered by this node and
## all of its descendents.
##
## This is not necessarily an accurate count of vertices that will actually be
## rendered, since this will include all vertices of all LOD's, and it will
## also include hidden nodes.  It may also omit or only approximate certain
## kinds of dynamic geometry.  However, it will not include stashed nodes.

func nested_vertices*(this: PandaNode): int {.importcpp: "#->get_nested_vertices()".} ## \
## Returns the total number of vertices that will be rendered by this node and
## all of its descendents.
##
## This is not necessarily an accurate count of vertices that will actually be
## rendered, since this will include all vertices of all LOD's, and it will
## also include hidden nodes.  It may also omit or only approximate certain
## kinds of dynamic geometry.  However, it will not include stashed nodes.

func internal_bounds*(this: PandaNode, current_thread: Thread): BoundingVolume {.importcpp: "#->get_internal_bounds(#)".} ## \
## Returns the node's internal bounding volume.  This is the bounding volume
## around the node alone, without including children.  If the user has called
## set_bounds(), it will be the specified bounding volume.

func internal_bounds*(this: PandaNode): BoundingVolume {.importcpp: "#->get_internal_bounds()".} ## \
## Returns the node's internal bounding volume.  This is the bounding volume
## around the node alone, without including children.  If the user has called
## set_bounds(), it will be the specified bounding volume.

func internal_vertices*(this: PandaNode, current_thread: Thread): int {.importcpp: "#->get_internal_vertices(#)".} ## \
## Returns the total number of vertices that will be rendered by this
## particular node alone, not accounting for its children.
##
## This may not include all vertices for certain dynamic effects.

func internal_vertices*(this: PandaNode): int {.importcpp: "#->get_internal_vertices()".} ## \
## Returns the total number of vertices that will be rendered by this
## particular node alone, not accounting for its children.
##
## This may not include all vertices for certain dynamic effects.

func bounds_stale*(this: PandaNode): bool {.importcpp: "#->is_bounds_stale()".} ## \
## Returns true if the bounding volume of this node is stale and will be
## implicitly recomputed at the next call to get_bounds(), or false if it is
## fresh and need not be recomputed.

func final*(this: PandaNode, current_thread: Thread): bool {.importcpp: "#->is_final(#)".} ## \
## Returns the current state of the "final" flag.  Initially, this flag is off
## (false), but it may be changed by an explicit call to set_final().  See
## set_final().

func final*(this: PandaNode): bool {.importcpp: "#->is_final()".} ## \
## Returns the current state of the "final" flag.  Initially, this flag is off
## (false), but it may be changed by an explicit call to set_final().  See
## set_final().

proc `final=`*(this: PandaNode, flag: bool) {.importcpp: "#->set_final(#)".} ## \
## Sets the "final" flag on this PandaNode.  If this is true, than no bounding
## volume need be tested below it; a positive intersection with this node's
## bounding volume is deemed to be a positive intersection with all geometry
## inside.
##
## This is useful to quickly force a larger bounding volume around a node when
## the GeomNodes themselves are inaccurate for some reason, without forcing a
## recompute of every nested bounding volume.  It's also helpful when the
## bounding volume is tricked by some special properties, like billboards,
## that may move geometry out of its bounding volume otherwise.

func stashed*(this: PandaNode, n: int, current_thread: Thread): PandaNode {.importcpp: "#->get_stashed(#, #)".} ## \
## Returns the nth stashed child of this node.  See get_num_stashed().  Also
## see get_stashed(), if your intention is to iterate through the complete
## list of stashed children; get_stashed() is preferable in this case.

func stashed*(this: PandaNode, n: int): PandaNode {.importcpp: "#->get_stashed(#)".} ## \
## Returns the nth stashed child of this node.  See get_num_stashed().  Also
## see get_stashed(), if your intention is to iterate through the complete
## list of stashed children; get_stashed() is preferable in this case.

func color*(this: Light): LColor {.importcpp: "#.get_color()".} ## \
## Returns the basic color of the light.

proc `color=`*(this: Light, color: LColor) {.importcpp: "#.set_color(#)".} ## \
## Sets the basic color of the light.

func color_temperature*(this: Light): float32 {.importcpp: "#.get_color_temperature()".} ## \
## Returns the basic color temperature of the light, assuming
## has_color_temperature() returns true.
##
## @since 1.10.0

proc `color_temperature=`*(this: Light, temperature: float32) {.importcpp: "#.set_color_temperature(#)".} ## \
## Sets the color temperature of the light in kelvins.  This will recalculate
## the light's color.
##
## The default value is 6500 K, corresponding to a perfectly white light
## assuming a D65 white point.
##
## @since 1.10.0

func priority*(this: Light): int {.importcpp: "#.get_priority()".} ## \
## Returns the priority associated with this light.  See set_priority().

proc `priority=`*(this: Light, priority: int) {.importcpp: "#.set_priority(#)".} ## \
## Changes the relative importance of this light relative to the other lights
## that are applied simultaneously.
##
## The priority number is used to decide which of the requested lights are to
## be selected for rendering when more lights are requested than the hardware
## will support.  The highest-priority n lights are selected for rendering.
##
## This is similar to TextureStage::set_priority().

func cull_callback*(this: CallbackNode): CallbackObject {.importcpp: "#->get_cull_callback()".} ## \
## Returns the CallbackObject set by set_cull_callback().

proc `cull_callback=`*(this: CallbackNode, `object`: CallbackObject) {.importcpp: "#->set_cull_callback(#)".} ## \
## Sets the CallbackObject that will be notified when this node is visited
## during the cull traversal.  This callback will be made during the cull
## thread.
##
## The cull traversal is responsible for determining which nodes are visible
## and within the view frustum, and for accumulating state and transform, and
## generally building up the list of CullableObjects that are to be eventually
## passed to the draw traversal for rendering.
##
## At the time the cull traversal callback is made, the node has been
## determined to be visible and it has passed the bounding-volume test, so it
## lies within the view frustum.
##
## The callback is passed an instance of a NodeCullCallbackData, which
## contains pointers to the CullTraverser and CullTraverserData--enough data
## to examine the current node and its place within the scene graph.  The
## callback *replaces* the normal cull behavior, so if your callback does
## nothing, the cull traversal will not continue below this node.  If you wish
## the cull traversal to continue to visit this node and below, you must call
## cbdata->upcall() from your callback.

func draw_callback*(this: CallbackNode): CallbackObject {.importcpp: "#->get_draw_callback()".} ## \
## Returns the CallbackObject set by set_draw_callback().

proc `draw_callback=`*(this: CallbackNode, `object`: CallbackObject) {.importcpp: "#->set_draw_callback(#)".} ## \
## Sets the CallbackObject that will be notified when this node is visited
## during the draw traversal.  This callback will be made during the draw
## thread.
##
## The draw traversal is responsible for actually issuing the commands to the
## graphics engine to draw primitives.  Its job is to walk through the list of
## CullableObjects build up by the cull traversal, as quickly as possible,
## issuing the appropriate commands to draw each one.
##
## At the time the draw traversal callback is made, the graphics state has
## been loaded with the correct modelview transform and render state, and the
## primitives (if any) in this node are ready to be drawn.
##
## The callback is passed an instance of a GeomDrawCallbackData, which
## contains pointers to the current state and transform, as well as the
## current GSG.  There is a Geom pointer as well, but it will always be NULL
## to this callback, since the CallbackNode does not itself contain any Geoms.

func active*(this: Camera): bool {.importcpp: "#->is_active()".} ## \
## Returns the current setting of the active flag on the camera.

proc `active=`*(this: Camera, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets the active flag on the camera.  When the camera is not active, nothing
## will be rendered.

func scene*(this: Camera): NodePath {.importcpp: "#->get_scene()".} ## \
## Returns the scene that will be rendered by the camera.  See set_scene().

proc `scene=`*(this: Camera, scene: NodePath) {.importcpp: "#->set_scene(#)".} ## \
## Sets the scene that will be rendered by the camera.  This is normally the
## root node of a scene graph, typically a node called 'render', although it
## could represent the root of any subgraph.
##
## Note that the use of this method is now deprecated.  In the absence of an
## explicit scene set on the camera, the camera will render whatever scene it
## is parented into.  This is the preferred way to specify the scene, since it
## is the more intuitive mechanism.

func cull_center*(this: Camera): NodePath {.importcpp: "#->get_cull_center()".} ## \
## Returns the point from which the culling operations will be performed, if
## it was set by set_cull_center(), or the empty NodePath otherwise.

proc `cull_center=`*(this: Camera, cull_center: NodePath) {.importcpp: "#->set_cull_center(#)".} ## \
## Specifies the point from which the culling operations are performed.
## Normally, this is the same as the camera, and that is the default if this
## is not specified; but it may sometimes be useful to perform the culling
## from some other viewpoint, particularly when you are debugging the culling
## itself.

func cull_bounds*(this: Camera): BoundingVolume {.importcpp: "#->get_cull_bounds()".} ## \
## Returns the custom cull volume that was set by set_cull_bounds(), if any,
## or NULL if no custom cull volume was set.

proc `cull_bounds=`*(this: Camera, cull_bounds: BoundingVolume) {.importcpp: "#->set_cull_bounds(#)".} ## \
## Specifies the bounding volume that should be used to perform culling from
## this camera.  Normally, this is the bounding volume returned from the
## active lens' make_bounds() call, but you may override this to specify a
## custom volume if you require.  The specified bounding volume will be
## understood to be in the coordinate space of the get_cull_center() node.

func lod_center*(this: Camera): NodePath {.importcpp: "#->get_lod_center()".} ## \
## Returns the point from which the LOD distances will be measured, if it was
## set by set_lod_center(), or the empty NodePath otherwise.

proc `lod_center=`*(this: Camera, lod_center: NodePath) {.importcpp: "#->set_lod_center(#)".} ## \
## Specifies the point from which the LOD distances are measured.  Normally,
## this is the same as the camera, and that is the default if this is not
## specified; but it may sometimes be useful to perform the distance test from
## some other viewpoint.  This may be used, for instance, to reduce LOD
## popping when the camera rotates in a small circle about an avatar.

func initial_state*(this: Camera): RenderState {.importcpp: "#->get_initial_state()".} ## \
## Returns the initial state as set by a previous call to set_initial_state().

proc `initial_state=`*(this: Camera, state: RenderState) {.importcpp: "#->set_initial_state(#)".} ## \
## Sets the initial state which is applied to all nodes in the scene, as if it
## were set at the top of the scene graph.

func tag_state_key*(this: Camera): string {.importcpp: "nimStringFromStdString(#->get_tag_state_key())", header: stringConversionCode.} ## \
## Returns the tag key as set by a previous call to set_tag_state_key().

proc `tag_state_key=`*(this: Camera, tag_state_key: string) {.importcpp: "#->set_tag_state_key(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the tag key which, when encountered as a tag on nodes in the scene
## graph, causes this Camera to apply an arbitrary state transition based on
## the value of the tag (as specified to set_tag_state()).

func lod_scale*(this: Camera): float32 {.importcpp: "#->get_lod_scale()".} ## \
## Returns the multiplier for LOD distances.

proc `lod_scale=`*(this: Camera, value: float32) {.importcpp: "#->set_lod_scale(#)".} ## \
## Sets the multiplier for LOD distances.  This value is multiplied with the
## LOD scale set on LodNodes.

func shadow_caster*(this: LightLensNode): bool {.importcpp: "#->is_shadow_caster()".} ## \
## Returns whether this light is configured to cast shadows or not.

func shadow_buffer_size*(this: LightLensNode): LVecBase2i {.importcpp: "#->get_shadow_buffer_size()".} ## \
## Returns the size of the shadow buffer to be created for this light source.

proc `shadow_buffer_size=`*(this: LightLensNode, size: LVecBase2i) {.importcpp: "#->set_shadow_buffer_size(#)".} ## \
## Sets the size of the shadow buffer to be created for this light source.

proc `specular_color=`*(this: DirectionalLight, color: LColor) {.importcpp: "#->set_specular_color(#)".} ## \
## Sets the color of specular highlights generated by the light.

func point*(this: DirectionalLight): LPoint3 {.importcpp: "#->get_point()".} ## \
## Returns the point in space at which the light is located.  This is local to
## the coordinate space in which the light is assigned.
##
## This actually has no bearing on the visual effect of the light, since the
## light is rendered as if it were infinitely far away.  This is only used to
## create a visible representation of the light.

proc `point=`*(this: DirectionalLight, point: LPoint3) {.importcpp: "#->set_point(#)".} ## \
## Sets the point in space at which the light is located.

func direction*(this: DirectionalLight): LVector3 {.importcpp: "#->get_direction()".} ## \
## Returns the direction in which the light is aimed.  This is local to the
## coordinate space in which the light is assigned.

proc `direction=`*(this: DirectionalLight, direction: LVector3) {.importcpp: "#->set_direction(#)".} ## \
## Sets the direction in which the light is aimed.

func lowest_switch*(this: LODNode): int {.importcpp: "#->get_lowest_switch()".} ## \
## Returns the index number of the child with the lowest level of detail; that
## is, the one that is designed to be seen from the farthest away.  This is
## usually the first child, but it is not necessarily so.

func highest_switch*(this: LODNode): int {.importcpp: "#->get_highest_switch()".} ## \
## Returns the index number of the child with the highest level of detail;
## that is, the one that is designed to be seen from the closest to the
## camera.  This is usually the last child, but it is not necessarily so.

func lod_scale*(this: LODNode): float32 {.importcpp: "#->get_lod_scale()".} ## \
## Returns the multiplier for lod distances

proc `lod_scale=`*(this: LODNode, value: float32) {.importcpp: "#->set_lod_scale(#)".} ## \
## Sets the multiplier for lod distances.  A higher value means you'll see
## farther switchs than normal

func center*(this: LODNode): LPoint3 {.importcpp: "#->get_center()".} ## \
## Returns the center of the LOD.  This is the point that is compared to the
## camera (in camera space) to determine the particular LOD that should be
## chosen.

proc `center=`*(this: LODNode, center: LPoint3) {.importcpp: "#->set_center(#)".} ## \
## Specifies the center of the LOD.  This is the point that is compared to the
## camera (in camera space) to determine the particular LOD that should be
## chosen.

func fade_time*(this: FadeLODNode): float32 {.importcpp: "#->get_fade_time()".} ## \
## get the time taken to complete an LOD switch

proc `fade_time=`*(this: FadeLODNode, t: float32) {.importcpp: "#->set_fade_time(#)".} ## \
## set the time taken to complete an LOD switch

func fade_bin_name*(this: FadeLODNode): string {.importcpp: "nimStringFromStdString(#->get_fade_bin_name())", header: stringConversionCode.} ## \
## Returns the cull bin that is assigned to the fading part of the geometry
## during a transition.

func fade_bin_draw_order*(this: FadeLODNode): int {.importcpp: "#->get_fade_bin_draw_order()".} ## \
## Returns the draw order that is assigned (along with the bin name) to the
## fading part of the geometry during a transition.

func fade_state_override*(this: FadeLODNode): int {.importcpp: "#->get_fade_state_override()".} ## \
## Returns the override value that is applied to the state changes necessary
## to apply the fade effect.  This should be larger than any attrib overrides
## on the fading geometry.

proc `fade_state_override=`*(this: FadeLODNode, override: int) {.importcpp: "#->set_fade_state_override(#)".} ## \
## Specifies the override value that is applied to the state changes necessary
## to apply the fade effect.  This should be larger than any attrib overrides
## on the fading geometry.

proc `specular_color=`*(this: PointLight, color: LColor) {.importcpp: "#->set_specular_color(#)".} ## \
## Sets the color of specular highlights generated by the light.

proc `attenuation=`*(this: PointLight, attenuation: LVecBase3) {.importcpp: "#->set_attenuation(#)".} ## \
## Sets the terms of the attenuation equation for the light.  These are, in
## order, the constant, linear, and quadratic terms based on the distance from
## the point to the vertex.

func max_distance*(this: PointLight): float32 {.importcpp: "#->get_max_distance()".} ## \
## Returns the maximum distance at which the light has any effect, as previously
## specified by set_max_distance.

proc `max_distance=`*(this: PointLight, max_distance: float32) {.importcpp: "#->set_max_distance(#)".} ## \
## Sets the radius of the light's sphere of influence.  Beyond this distance, the
## light may be attenuated to zero, if this is supported by the shader.

func point*(this: PointLight): LPoint3 {.importcpp: "#->get_point()".} ## \
## Returns the point in space at which the light is located.  This is local to
## the coordinate space in which the light is assigned, and is usually 0.

proc `point=`*(this: PointLight, point: LPoint3) {.importcpp: "#->set_point(#)".} ## \
## Sets the point in space at which the light is located.  Usually 0.

func max_distance*(this: RectangleLight): float32 {.importcpp: "#->get_max_distance()".} ## \
## Returns the maximum distance at which the light has any effect, as previously
## specified by set_max_distance.

proc `max_distance=`*(this: RectangleLight, max_distance: float32) {.importcpp: "#->set_max_distance(#)".} ## \
## Sets the radius of the light's sphere of influence.  Beyond this distance, the
## light may be attenuated to zero, if this is supported by the shader.

func play_rate*(this: AnimInterface): float64 {.importcpp: "#->get_play_rate()".} ## \
## Returns the rate at which the animation plays.  See set_play_rate().

proc `play_rate=`*(this: AnimInterface, play_rate: float64) {.importcpp: "#->set_play_rate(#)".} ## \
## Changes the rate at which the animation plays.  1.0 is the normal speed,
## 2.0 is twice normal speed, and 0.5 is half normal speed.  0.0 is legal to
## pause the animation, and a negative value will play the animation
## backwards.

func frame_rate*(this: AnimInterface): float64 {.importcpp: "#->get_frame_rate()".} ## \
## Returns the native frame rate of the animation.  This is the number of
## frames per second that will elapse when the play_rate is set to 1.0.  It is
## a fixed property of the animation and may not be adjusted by the user.

func num_frames*(this: AnimInterface): int {.importcpp: "#->get_num_frames()".} ## \
## Returns the number of frames in the animation.  This is a property of the
## animation and may not be directly adjusted by the user (although it may
## change without warning with certain kinds of animations, since this is a
## virtual method that may be overridden).

func frame*(this: AnimInterface): int {.importcpp: "#->get_frame()".} ## \
## Returns the current integer frame number.  This number will be in the range
## 0 <= f < get_num_frames().

func next_frame*(this: AnimInterface): int {.importcpp: "#->get_next_frame()".} ## \
## Returns the current integer frame number + 1, constrained to the range 0 <=
## f < get_num_frames().
##
## If the play mode is PM_play, this will clamp to the same value as
## get_frame() at the end of the animation.  If the play mode is any other
## value, this will wrap around to frame 0 at the end of the animation.

func frac*(this: AnimInterface): float64 {.importcpp: "#->get_frac()".} ## \
## Returns the fractional part of the current frame.  Normally, this is in the
## range 0.0 <= f < 1.0, but in the one special case of an animation playing
## to its end frame and stopping, it might exactly equal 1.0.
##
## It will always be true that get_full_frame() + get_frac() ==
## get_full_fframe().

func full_frame*(this: AnimInterface): int {.importcpp: "#->get_full_frame()".} ## \
## Returns the current integer frame number.
##
## Unlike the value returned by get_frame(), this frame number may extend
## beyond the range of get_num_frames() if the frame range passed to play(),
## loop(), etc.  did.
##
## Unlike the value returned by get_full_fframe(), this return value will
## never exceed the value passed to to_frame in the play() method.

func full_fframe*(this: AnimInterface): float64 {.importcpp: "#->get_full_fframe()".} ## \
## Returns the current floating-point frame number.
##
## Unlike the value returned by get_frame(), this frame number may extend
## beyond the range of get_num_frames() if the frame range passed to play(),
## loop(), etc.  did.
##
## Unlike the value returned by get_full_frame(), this return value may equal
## (to_frame + 1.0), when the animation has played to its natural end.
## However, in this case the return value of get_full_frame() will be
## to_frame, not (to_frame + 1).

func playing*(this: AnimInterface): bool {.importcpp: "#->is_playing()".} ## \
## Returns true if the animation is currently playing, false if it is stopped
## (e.g.  because stop() or pose() was called, or because it reached the end
## of the animation after play() was called).

proc `frame_rate=`*(this: SequenceNode, frame_rate: float64) {.importcpp: "#->set_frame_rate(#)".} ## \
## Changes the advertised frame rate of the SequenceNode.  This can be used in
## conjunction with get_play_rate() to change the effective frame rate of the
## node.

func radius*(this: SphereLight): float32 {.importcpp: "#->get_radius()".} ## \
## Returns the radius of the sphere.

proc `radius=`*(this: SphereLight, radius: float32) {.importcpp: "#->set_radius(#)".} ## \
## Sets the radius of the sphere.

proc `exponent=`*(this: Spotlight, exponent: float32) {.importcpp: "#->set_exponent(#)".} ## \
## Sets the exponent that controls the amount of light falloff from the center
## of the spotlight.  The light is attenuated by the cosine of the angle
## between the direction of the light and the direction of the point being
## lighted, raised to the power of this exponent.  Thus, higher exponents
## result in a more focused light source, regardless of the field-of-view of
## the lens.

proc `specular_color=`*(this: Spotlight, color: LColor) {.importcpp: "#->set_specular_color(#)".} ## \
## Sets the color of specular highlights generated by the light.

proc `attenuation=`*(this: Spotlight, attenuation: LVecBase3) {.importcpp: "#->set_attenuation(#)".} ## \
## Sets the terms of the attenuation equation for the light.  These are, in
## order, the constant, linear, and quadratic terms based on the distance from
## the point to the vertex.

func max_distance*(this: Spotlight): float32 {.importcpp: "#->get_max_distance()".} ## \
## Returns the maximum distance at which the light has any effect, as previously
## specified by set_max_distance.

proc `max_distance=`*(this: Spotlight, max_distance: float32) {.importcpp: "#->set_max_distance(#)".} ## \
## Sets the radius of the light's sphere of influence.  Beyond this distance, the
## light may be attenuated to zero, if this is supported by the shader.

func visible_child*(this: SwitchNode): int {.importcpp: "#->get_visible_child()".} ## \
## Returns the index of the child that should be visible.

proc `visible_child=`*(this: SwitchNode, index: int) {.importcpp: "#->set_visible_child(#)".} ## \
## Specifies the particular child of this node, by index, that will be
## visible.

func u_speed*(this: UvScrollNode): float32 {.importcpp: "#->get_u_speed()".}

proc `u_speed=`*(this: UvScrollNode, u_speed: float32) {.importcpp: "#->set_u_speed(#)".}

func v_speed*(this: UvScrollNode): float32 {.importcpp: "#->get_v_speed()".}

proc `v_speed=`*(this: UvScrollNode, v_speed: float32) {.importcpp: "#->set_v_speed(#)".}

func w_speed*(this: UvScrollNode): float32 {.importcpp: "#->get_w_speed()".}

proc `w_speed=`*(this: UvScrollNode, w_speed: float32) {.importcpp: "#->set_w_speed(#)".}

func r_speed*(this: UvScrollNode): float32 {.importcpp: "#->get_r_speed()".}

proc `r_speed=`*(this: UvScrollNode, r_speed: float32) {.importcpp: "#->set_r_speed(#)".}

func cache_ref_count*(this: CachedTypedWritableReferenceCount): int {.importcpp: "#->get_cache_ref_count()".} ## \
## Returns the current reference count.

func pos*(this: TransformState): LPoint3 {.importcpp: "#->get_pos()".} ## \
## Returns the pos component of the transform.  It is an error to call this if
## has_pos() returned false.

func hpr*(this: TransformState): LVecBase3 {.importcpp: "#->get_hpr()".} ## \
## Returns the rotation component of the transform as a trio of Euler angles.
## It is an error to call this if has_components() returned false.

func quat*(this: TransformState): LQuaternion {.importcpp: "#->get_quat()".} ## \
## Returns the rotation component of the transform as a quaternion.  The
## return value will be normalized if a normalized quaternion was given to the
## constructor (or if the quaternion was computed implicitly); it will be non-
## normalized if a non-normalized quaternion was given to the constructor.
## See also get_norm_quat().
##
## It is an error to call this if has_components() returned false.

func norm_quat*(this: TransformState): LQuaternion {.importcpp: "#->get_norm_quat()".} ## \
## Returns the rotation component of the transform as a quaternion.  Unlike
## the result of get_quat(), the return value of this method is guaranteed to
## be normalized.  It is an error to call this if has_components() returned
## false.

func scale*(this: TransformState): LVecBase3 {.importcpp: "#->get_scale()".} ## \
## Returns the scale component of the transform.  It is an error to call this
## if has_components() returned false.

func shear*(this: TransformState): LVecBase3 {.importcpp: "#->get_shear()".} ## \
## Returns the shear component of the transform.  It is an error to call this
## if has_components() returned false.

func mat*(this: TransformState): LMatrix4 {.importcpp: "#->get_mat()".} ## \
## Returns the matrix that describes the transform.

func slot*(this: RenderAttrib): int {.importcpp: "#->get_slot()".}

func thickness*(this: RenderModeAttrib): float32 {.importcpp: "#->get_thickness()".} ## \
## Returns the line width or point thickness.  This is only relevant when
## rendering points or lines, such as when the mode is M_wireframe or M_point
## (or when rendering actual points or lines primitives in M_polygon mode).

func perspective*(this: RenderModeAttrib): bool {.importcpp: "#->get_perspective()".} ## \
## Returns the perspective flag.  When this is true, the point thickness
## represented by get_thickness() is actually a width in 3-d units, and the
## points should scale according to perspective.  When it is false, the
## default, the point thickness is actually a width in pixels, and points are
## a uniform size regardless of distance from the camera.

func wireframe_color*(this: RenderModeAttrib): LColor {.importcpp: "#->get_wireframe_color()".} ## \
## Returns the color that is used in M_filled_wireframe mode to distinguish
## the wireframe from the rest of the geometry.

func class_slot*(_: typedesc[RenderModeAttrib]): int {.importcpp: "RenderModeAttrib::get_class_slot()", header: "renderModeAttrib.h".}

func class_slot*(_: typedesc[TexMatrixAttrib]): int {.importcpp: "TexMatrixAttrib::get_class_slot()", header: "texMatrixAttrib.h".}

func reference_alpha*(this: AlphaTestAttrib): float32 {.importcpp: "#->get_reference_alpha()".} ## \
## Returns the alpha reference value.

func class_slot*(_: typedesc[AlphaTestAttrib]): int {.importcpp: "AlphaTestAttrib::get_class_slot()", header: "alphaTestAttrib.h".}

func mode*(this: AntialiasAttrib): int {.importcpp: "#->get_mode()".} ## \
## Returns the specified antialias mode.

func mode_type*(this: AntialiasAttrib): int {.importcpp: "#->get_mode_type()".} ## \
## Returns the specified antialias mode, with the quality bits masked out.
## This therefore indicates only the requested type of antialiasing: M_none,
## M_auto, or some specific combination.

func mode_quality*(this: AntialiasAttrib): int {.importcpp: "#->get_mode_quality()".} ## \
## Returns the specified antialias mode, with the type bits masked out.  This
## therefore indicates only the requested quality settings: one of M_faster,
## M_better, M_dont_care, or zero (unspecified).

func class_slot*(_: typedesc[AntialiasAttrib]): int {.importcpp: "AntialiasAttrib::get_class_slot()", header: "antialiasAttrib.h".}

func class_slot*(_: typedesc[TransparencyAttrib]): int {.importcpp: "TransparencyAttrib::get_class_slot()", header: "transparencyAttrib.h".}

func class_slot*(_: typedesc[LogicOpAttrib]): int {.importcpp: "LogicOpAttrib::get_class_slot()", header: "logicOpAttrib.h".}

func children*(this: NodePath, current_thread: Thread): NodePathCollection {.importcpp: "#.get_children(#)".} ## \
## Returns the set of all child nodes of the referenced node.

func children*(this: NodePath): NodePathCollection {.importcpp: "#.get_children()".} ## \
## Returns the set of all child nodes of the referenced node.

func stashed_children*(this: NodePath, current_thread: Thread): NodePathCollection {.importcpp: "#.get_stashed_children(#)".} ## \
## Returns the set of all child nodes of the referenced node that have been
## stashed.  These children are not normally visible on the node, and do not
## appear in the list returned by get_children().

func stashed_children*(this: NodePath): NodePathCollection {.importcpp: "#.get_stashed_children()".} ## \
## Returns the set of all child nodes of the referenced node that have been
## stashed.  These children are not normally visible on the node, and do not
## appear in the list returned by get_children().

func parent*(this: NodePath, current_thread: Thread): NodePath {.importcpp: "#.get_parent(#)".} ## \
## Returns the NodePath to the parent of the referenced node: that is, this
## NodePath, shortened by one node.  The parent of a singleton NodePath is
## defined to be the empty NodePath.

func parent*(this: NodePath): NodePath {.importcpp: "#.get_parent()".} ## \
## Returns the NodePath to the parent of the referenced node: that is, this
## NodePath, shortened by one node.  The parent of a singleton NodePath is
## defined to be the empty NodePath.

func sort*(this: NodePath, current_thread: Thread): int {.importcpp: "#.get_sort(#)".} ## \
## Returns the sort value of the referenced node within its parent; that is,
## the sort number passed on the last reparenting operation for this node.
## This will control the position of the node within its parent's list of
## children.

func sort*(this: NodePath): int {.importcpp: "#.get_sort()".} ## \
## Returns the sort value of the referenced node within its parent; that is,
## the sort number passed on the last reparenting operation for this node.
## This will control the position of the node within its parent's list of
## children.

func name*(this: NodePath): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the referenced node.

proc `name=`*(this: NodePath, name: string) {.importcpp: "#.set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of the referenced node.

func volume*(this: AudioVolumeAttrib): float32 {.importcpp: "#->get_volume()".} ## \
## Returns the volume to be applied to sounds.

func class_slot*(_: typedesc[AudioVolumeAttrib]): int {.importcpp: "AudioVolumeAttrib::get_class_slot()", header: "audioVolumeAttrib.h".}

func outputs*(this: AuxBitplaneAttrib): int {.importcpp: "#->get_outputs()".} ## \
## Returns the AuxBitplaneAttrib output bits.

func class_slot*(_: typedesc[AuxBitplaneAttrib]): int {.importcpp: "AuxBitplaneAttrib::get_class_slot()", header: "auxBitplaneAttrib.h".}

func file_stdfloat_double*(this: BamFile): bool {.importcpp: "#.get_file_stdfloat_double()".} ## \
## Returns true if the file stores all "standard" floats as 64-bit doubles, or
## false if they are 32-bit floats.

func reader*(this: BamFile): BamReader {.importcpp: "#.get_reader()".} ## \
## Returns the BamReader in charge of performing the read operations.  This
## will return NULL unless open_read() was called.

func writer*(this: BamFile): BamWriter {.importcpp: "#.get_writer()".} ## \
## Returns the BamWriter in charge of performing the write operations.  This
## will return NULL unless open_write() was called.

func plane*(this: PlaneNode): LPlane {.importcpp: "#->get_plane()".} ## \
## Returns the plane represented by the PlaneNode.

proc `plane=`*(this: PlaneNode, plane: LPlane) {.importcpp: "#->set_plane(#)".} ## \
## Sets the particular plane represented by the PlaneNode.

func viz_scale*(this: PlaneNode): float32 {.importcpp: "#->get_viz_scale()".} ## \
## Returns the size of the visual representation of the plane that is drawn if
## the PlaneNode is shown.

proc `viz_scale=`*(this: PlaneNode, viz_scale: float32) {.importcpp: "#->set_viz_scale(#)".} ## \
## Specifies the size of the visual representation of the plane that is drawn
## if the PlaneNode is shown.

func priority*(this: PlaneNode): int {.importcpp: "#->get_priority()".} ## \
## Returns the priority associated with this clip plane.  See set_priority().

proc `priority=`*(this: PlaneNode, priority: int) {.importcpp: "#->set_priority(#)".} ## \
## Changes the relative importance of this PlaneNode (when it is used as a
## clip plane) relative to the other clip planes that are applied
## simultaneously.
##
## The priority number is used to decide which of the requested clip planes
## are to be activated when more clip planes are requested than the hardware
## will support.  The highest-priority n planes are selected for rendering.
##
## This is similar to TextureStage::set_priority().

func clip_effect*(this: PlaneNode): int {.importcpp: "#->get_clip_effect()".} ## \
## Returns the clip_effect bits for this clip plane.  See set_clip_effect().

proc `clip_effect=`*(this: PlaneNode, clip_effect: int) {.importcpp: "#->set_clip_effect(#)".} ## \
## Specifies the sort of things this plane will actually clip (when it is used
## as a clip plane).  This is a bitmask union of ClipEffect values.  If it
## includes CE_visible, then it will clip visible geometry; if it includes
## CE_collision, then it will clip collision polygons.  If it includes neither
## bit, it will still affect culling, but objects will either be wholly behind
## the clipping plane, or wholly present.

func class_slot*(_: typedesc[ClipPlaneAttrib]): int {.importcpp: "ClipPlaneAttrib::get_class_slot()", header: "clipPlaneAttrib.h".}

func color*(this: ColorAttrib): LColor {.importcpp: "#->get_color()".} ## \
## If the type is T_flat or T_off, this returns the color that will be applied
## to geometry.  If the type is T_vertex, this is meaningless.

func class_slot*(_: typedesc[ColorAttrib]): int {.importcpp: "ColorAttrib::get_class_slot()", header: "colorAttrib.h".}

func color*(this: ColorBlendAttrib): LColor {.importcpp: "#->get_color()".} ## \
## Returns the constant color associated with the attrib.

func class_slot*(_: typedesc[ColorBlendAttrib]): int {.importcpp: "ColorBlendAttrib::get_class_slot()", header: "colorBlendAttrib.h".}

func scale*(this: ColorScaleAttrib): LVecBase4 {.importcpp: "#->get_scale()".} ## \
## Returns the scale to be applied to colors.

func class_slot*(_: typedesc[ColorScaleAttrib]): int {.importcpp: "ColorScaleAttrib::get_class_slot()", header: "colorScaleAttrib.h".}

func channels*(this: ColorWriteAttrib): int {.importcpp: "#->get_channels()".} ## \
## Returns the mask of color channels that are enabled by this attrib.

func class_slot*(_: typedesc[ColorWriteAttrib]): int {.importcpp: "ColorWriteAttrib::get_class_slot()", header: "colorWriteAttrib.h".}

func bin_name*(this: CullBinAttrib): string {.importcpp: "nimStringFromStdString(#->get_bin_name())", header: stringConversionCode.} ## \
## Returns the name of the bin this attribute specifies.  If this is the empty
## string, it refers to the default bin.

func draw_order*(this: CullBinAttrib): int {.importcpp: "#->get_draw_order()".} ## \
## Returns the draw order this attribute specifies.  Some bins (in particular,
## CullBinFixed bins) use this to further specify the order in which objects
## should be rendered.

func class_slot*(_: typedesc[CullBinAttrib]): int {.importcpp: "CullBinAttrib::get_class_slot()", header: "cullBinAttrib.h".}

func reverse*(this: CullFaceAttrib): bool {.importcpp: "#->get_reverse()".} ## \
## Returns the 'reverse' flag.  If this is true, the actual cull direction
## (clockwise vs.  counterclockwise) is the reverse of what is specified here.
## This allows support for make_reverse(), which defines a CullFaceAttrib that
## reverses whatever the sense of culling would have been.

func class_slot*(_: typedesc[CullFaceAttrib]): int {.importcpp: "CullFaceAttrib::get_class_slot()", header: "cullFaceAttrib.h".}

func color*(this: Fog): LColor {.importcpp: "#->get_color()".} ## \
## Returns the color of the fog.

proc `color=`*(this: Fog, color: LColor) {.importcpp: "#->set_color(#)".} ## \
## Sets the color of the fog.  The alpha component is not used.

proc `color=`*(this: Fog, r: float32, g: float32, b: float32) {.importcpp: "#->set_color(#, #, #)".} ## \
## Sets the color of the fog.

func linear_onset_point*(this: Fog): LPoint3 {.importcpp: "#->get_linear_onset_point()".} ## \
## Returns the point in space at which the fog begins.  This is only used if
## the mode is M_linear.

proc `linear_onset_point=`*(this: Fog, linear_onset_point: LPoint3) {.importcpp: "#->set_linear_onset_point(#)".} ## \
## Specifies the point in space at which the fog begins.  This is only used if
## the mode is M_linear.

proc `linear_onset_point=`*(this: Fog, x: float32, y: float32, z: float32) {.importcpp: "#->set_linear_onset_point(#, #, #)".} ## \
## Specifies the point in space at which the fog begins.  This is only used if
## the mode is M_linear.

func linear_opaque_point*(this: Fog): LPoint3 {.importcpp: "#->get_linear_opaque_point()".} ## \
## Returns the point in space at which the fog completely obscures geometry.
## This is only used if the mode is M_linear.

proc `linear_opaque_point=`*(this: Fog, linear_opaque_point: LPoint3) {.importcpp: "#->set_linear_opaque_point(#)".} ## \
## Specifies the point in space at which the fog completely obscures geometry.
## This is only used if the mode is M_linear.

proc `linear_opaque_point=`*(this: Fog, x: float32, y: float32, z: float32) {.importcpp: "#->set_linear_opaque_point(#, #, #)".} ## \
## Specifies the point in space at which the fog completely obscures geometry.
## This is only used if the mode is M_linear.

func exp_density*(this: Fog): float32 {.importcpp: "#->get_exp_density()".} ## \
## Returns the density of the fog for exponential calculations.  This is only
## used if the mode is not M_linear.

proc `exp_density=`*(this: Fog, exp_density: float32) {.importcpp: "#->set_exp_density(#)".} ## \
## Sets the density of the fog for exponential calculations.  This is only
## used if the mode is not M_linear.
##
## If the mode is currently set to M_linear, this function implicitly sets it
## to M_exponential.

func fog*(this: FogAttrib): Fog {.importcpp: "#->get_fog()".} ## \
## If the FogAttrib is not an 'off' FogAttrib, returns the fog that is
## associated.  Otherwise, return NULL.

func class_slot*(_: typedesc[FogAttrib]): int {.importcpp: "FogAttrib::get_class_slot()", header: "fogAttrib.h".}

func class_slot*(_: typedesc[RescaleNormalAttrib]): int {.importcpp: "RescaleNormalAttrib::get_class_slot()", header: "rescaleNormalAttrib.h".}

func offset*(this: DepthOffsetAttrib): int {.importcpp: "#->get_offset()".} ## \
## Returns the depth offset represented by this attrib.

func min_value*(this: DepthOffsetAttrib): float32 {.importcpp: "#->get_min_value()".} ## \
## Returns the value for the minimum (closest) depth value to be stored in the
## buffer, in the range 0 .. 1.

func max_value*(this: DepthOffsetAttrib): float32 {.importcpp: "#->get_max_value()".} ## \
## Returns the value for the maximum (farthest) depth value to be stored in
## the buffer, in the range 0 .. 1.

func class_slot*(_: typedesc[DepthOffsetAttrib]): int {.importcpp: "DepthOffsetAttrib::get_class_slot()", header: "depthOffsetAttrib.h".}

func class_slot*(_: typedesc[DepthTestAttrib]): int {.importcpp: "DepthTestAttrib::get_class_slot()", header: "depthTestAttrib.h".}

func class_slot*(_: typedesc[DepthWriteAttrib]): int {.importcpp: "DepthWriteAttrib::get_class_slot()", header: "depthWriteAttrib.h".}

func class_slot*(_: typedesc[LightAttrib]): int {.importcpp: "LightAttrib::get_class_slot()", header: "lightAttrib.h".}

func class_slot*(_: typedesc[LightRampAttrib]): int {.importcpp: "LightRampAttrib::get_class_slot()", header: "lightRampAttrib.h".}

func material*(this: MaterialAttrib): Material {.importcpp: "#->get_material()".} ## \
## If the MaterialAttrib is not an 'off' MaterialAttrib, returns the material
## that is associated.  Otherwise, return NULL.

func class_slot*(_: typedesc[MaterialAttrib]): int {.importcpp: "MaterialAttrib::get_class_slot()", header: "materialAttrib.h".}

func done_event*(this: AsyncFuture): string {.importcpp: "nimStringFromStdString(#->get_done_event())", header: stringConversionCode.} ## \
## Returns the event name that will be triggered when the future finishes.
## See set_done_event().

proc `done_event=`*(this: AsyncFuture, done_event: string) {.importcpp: "#->set_done_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the event name that will be triggered when the future finishes.  Will
## not be triggered if the future is cancelled, but it will be triggered for
## a coroutine task that exits with an exception.

func alive*(this: AsyncTask): bool {.importcpp: "#->is_alive()".} ## \
## Returns true if the task is currently active or sleeping on some task
## chain, meaning that it will be executed in its turn, or false if it is not
## active.  If the task has recently been removed while it is in the middle of
## execution, this will return false, because the task will not run again once
## it finishes.

func manager*(this: AsyncTask): AsyncTaskManager {.importcpp: "#->get_manager()".} ## \
## Returns the AsyncTaskManager that this task is active on.  This will be
## NULL if the state is S_inactive.

proc `name=`*(this: AsyncTask, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.}

func id*(this: AsyncTask): int {.importcpp: "#->get_task_id()".} ## \
## Returns a number guaranteed to be unique for each different AsyncTask
## object in the universe.

func task_chain*(this: AsyncTask): string {.importcpp: "nimStringFromStdString(#->get_task_chain())", header: stringConversionCode.} ## \
## Returns the AsyncTaskChain on which this task will be running.  Each task
## chain runs tasks independently of the others.

proc `task_chain=`*(this: AsyncTask, chain_name: string) {.importcpp: "#->set_task_chain(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the AsyncTaskChain on which this task will be running.  Each task
## chain runs tasks independently of the others.

func sort*(this: AsyncTask): int {.importcpp: "#->get_sort()".} ## \
## Returns the task's current sort value.  See set_sort().

proc `sort=`*(this: AsyncTask, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Specifies a sort value for this task.  Within a given AsyncTaskManager, all
## of the tasks with a given sort value are guaranteed to be completed before
## any tasks with a higher sort value are begun.
##
## To put it another way, two tasks might execute in parallel with each other
## only if they both have the same sort value.  Tasks with a lower sort value
## are executed first.
##
## This is different from the priority, which makes no such exclusion
## guarantees.

func priority*(this: AsyncTask): int {.importcpp: "#->get_priority()".} ## \
## Returns the task's current priority value.  See set_priority().

proc `priority=`*(this: AsyncTask, priority: int) {.importcpp: "#->set_priority(#)".} ## \
## Specifies a priority value for this task.  In general, tasks with a higher
## priority value are executed before tasks with a lower priority value (but
## only for tasks with the same sort value).
##
## Unlike the sort value, tasks with different priorities may execute at the
## same time, if the AsyncTaskManager has more than one thread servicing
## tasks.
##
## Also see AsyncTaskChain::set_timeslice_priority(), which changes the
## meaning of this value.  In the default mode, when the timeslice_priority
## flag is false, all tasks always run once per epoch, regardless of their
## priority values (that is, the priority controls the order of the task
## execution only, not the number of times it runs).  On the other hand, if
## you set the timeslice_priority flag to true, then changing a task's
## priority has an effect on the number of times it runs.

proc `done_event=`*(this: AsyncTask, done_event: string) {.importcpp: "#->set_done_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the event name that will be triggered when the task finishes.  This
## should only be called before the task has been started, or after it has
## finished and before it is about to be restarted (i.e.  when get_state()
## returns S_inactive).

func dt*(this: AsyncTask): float64 {.importcpp: "#->get_dt()".} ## \
## Returns the amount of time elapsed during the task's previous run cycle, in
## seconds.

func max_dt*(this: AsyncTask): float64 {.importcpp: "#->get_max_dt()".} ## \
## Returns the maximum amount of time elapsed during any one of the task's
## previous run cycles, in seconds.

func average_dt*(this: AsyncTask): float64 {.importcpp: "#->get_average_dt()".} ## \
## Returns the average amount of time elapsed during each of the task's
## previous run cycles, in seconds.

func orig*(this: ModelFlattenRequest): PandaNode {.importcpp: "#->get_orig()".} ## \
## Returns the original, unflattened node.

func filename*(this: ModelLoadRequest): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the filename associated with this asynchronous ModelLoadRequest.

func options*(this: ModelLoadRequest): LoaderOptions {.importcpp: "#->get_options()".} ## \
## Returns the LoaderOptions associated with this asynchronous
## ModelLoadRequest.

func loader*(this: ModelLoadRequest): Loader {.importcpp: "#->get_loader()".} ## \
## Returns the Loader object associated with this asynchronous
## ModelLoadRequest.

func model_ref_count*(this: ModelRoot): int {.importcpp: "#->get_model_ref_count()".} ## \
## Returns the number of copies that exist of this particular ModelRoot node.
## Each time ModelRoot::copy_subgraph() or make_copy() is called (or some
## other copying mechanism, such as NodePath.copy_to(), is used), this count
## will increment by one in all copies; when one of the copies is destructed,
## this count will decrement.

func fullpath*(this: ModelRoot): Filename {.importcpp: "#->get_fullpath()".} ## \
## Returns the full pathname of the model represented by this node, as found
## on disk.  This is mainly useful for reference purposes, but is also used to
## index the ModelRoot into the ModelPool.

proc `fullpath=`*(this: ModelRoot, fullpath: Filename) {.importcpp: "#->set_fullpath(#)".} ## \
## Sets the full pathname of the model represented by this node, as found on
## disk.  This is mainly useful for reference purposes, but is also used to
## index the ModelRoot into the ModelPool.
##
## This is normally set automatically when a model is loaded, and should not
## be set directly by the user.  If you change this on a loaded model, then
## ModelPool::release_model() may fail.

func timestamp*(this: ModelRoot): int {.importcpp: "#->get_timestamp()".} ## \
## Returns the timestamp of the file on disk that was read for this model, at
## the time it was read, if it is known.  Returns 0 if the timestamp is not
## known or could not be provided.  This can be used as a quick (but fallible)
## check to verify whether the file might have changed since the model was
## read.

proc `timestamp=`*(this: ModelRoot, timestamp: int) {.importcpp: "#->set_timestamp(#)".} ## \
## Sets the timestamp of the file on disk that was read for this model.  This
## is normally set automatically when a model is loaded, and should not be set
## directly by the user.

func filename*(this: ModelSaveRequest): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the filename associated with this asynchronous ModelSaveRequest.

func options*(this: ModelSaveRequest): LoaderOptions {.importcpp: "#->get_options()".} ## \
## Returns the LoaderOptions associated with this asynchronous
## ModelSaveRequest.

func node*(this: ModelSaveRequest): PandaNode {.importcpp: "#->get_node()".} ## \
## Returns the node that was passed to the constructor.

func loader*(this: ModelSaveRequest): Loader {.importcpp: "#->get_loader()".} ## \
## Returns the Loader object associated with this asynchronous
## ModelSaveRequest.

func class_slot*(_: typedesc[TextureAttrib]): int {.importcpp: "TextureAttrib::get_class_slot()", header: "textureAttrib.h".}

func class_slot*(_: typedesc[TexGenAttrib]): int {.importcpp: "TexGenAttrib::get_class_slot()", header: "texGenAttrib.h".}

func double_sided*(this: OccluderNode): bool {.importcpp: "#->is_double_sided()".} ## \
## Is this occluder double-sided

proc `double_sided=`*(this: OccluderNode, value: bool) {.importcpp: "#->set_double_sided(#)".} ## \
## If true, the back-face will also be used to occlude

func min_coverage*(this: OccluderNode): float32 {.importcpp: "#->get_min_coverage()".} ## \
## Returns the minimum screen coverage.

proc `min_coverage=`*(this: OccluderNode, value: float32) {.importcpp: "#->set_min_coverage(#)".} ## \
## Minimum screen coverage needed before occluder used.  Range should be 0 to
## 1. For example, setting to 0.2 would mean that the occluder needs to cover
## 20% of the screen to be considered.

func shader*(this: ShaderAttrib): Shader {.importcpp: "#->get_shader()".} ## \
## Returns the shader object associated with the node.  If get_override
## returns true, but get_shader returns NULL, that means that this attribute
## should disable the shader.

func instance_count*(this: ShaderAttrib): int {.importcpp: "#->get_instance_count()".} ## \
## Returns the number of geometry instances.  A value of 0 means not to use
## instancing at all.

func class_slot*(_: typedesc[ShaderAttrib]): int {.importcpp: "ShaderAttrib::get_class_slot()", header: "shaderAttrib.h".}

func portal_geom*(this: PortalNode): bool {.importcpp: "#->get_portal_geom()".} ## \
## Returns the current state of the portal_geom flag.  See set_portal_geom().

proc `portal_geom=`*(this: PortalNode, flag: bool) {.importcpp: "#->set_portal_geom(#)".} ## \
## Sets the state of the "portal geom" flag for this PortalNode.  Normally,
## this is false; when this is set true, the PortalSolids in this node will
## test for portals with actual renderable geometry, in addition to whatever
## PortalSolids may be indicated by the from_portal_mask.
##
## Setting this to true causes this to test *all* GeomNodes for portals.  It
## is an all-or-none thing; there is no way to portal with only some
## GeomNodes, as GeomNodes have no into_portal_mask.

func cell_in*(this: PortalNode): NodePath {.importcpp: "#->get_cell_in()".} ## \
## Sets the cell that this portal belongs to

proc `cell_in=`*(this: PortalNode, cell: NodePath) {.importcpp: "#->set_cell_in(#)".} ## \
## Sets the cell that this portal belongs to

func cell_out*(this: PortalNode): NodePath {.importcpp: "#->get_cell_out()".} ## \
## Sets the cell that this portal leads out to

proc `cell_out=`*(this: PortalNode, cell: NodePath) {.importcpp: "#->set_cell_out(#)".} ## \
## Sets the cell that this portal leads out to

func clip_plane*(this: PortalNode): bool {.importcpp: "#->is_clip_plane()".} ## \
## Is this portal clipping against its left-right planes

proc `clip_plane=`*(this: PortalNode, value: bool) {.importcpp: "#->set_clip_plane(#)".} ## \
## this is set if the portal will clip against its left and right planes

func visible*(this: PortalNode): bool {.importcpp: "#->is_visible()".} ## \
## Is this portal facing the camera

proc `visible=`*(this: PortalNode, value: bool) {.importcpp: "#->set_visible(#)".} ## \
## this is set if the portal is facing camera

func max_depth*(this: PortalNode): int {.importcpp: "#->get_max_depth()".} ## \
## Returns the maximum depth this portal will be visible at

proc `max_depth=`*(this: PortalNode, value: int) {.importcpp: "#->set_max_depth(#)".} ## \
## Set the maximum depth this portal will be visible at

func open*(this: PortalNode): bool {.importcpp: "#->is_open()".} ## \
## Is this portal open from current camera zone

proc `open=`*(this: PortalNode, value: bool) {.importcpp: "#->set_open(#)".} ## \
## Python sets this based on curent camera zone

func frame*(this: ScissorAttrib): LVecBase4 {.importcpp: "#->get_frame()".} ## \
## Returns the left, right, bottom, top coordinates of the scissor frame.
## This defines a frame within the current DisplayRegion, where 0,0 is the
## lower-left corner of the DisplayRegion, and 1,1 is the upper-right corner.

func class_slot*(_: typedesc[ScissorAttrib]): int {.importcpp: "ScissorAttrib::get_class_slot()", header: "scissorAttrib.h".}

func class_slot*(_: typedesc[ShadeModelAttrib]): int {.importcpp: "ShadeModelAttrib::get_class_slot()", header: "shadeModelAttrib.h".}

func class_slot*(_: typedesc[StencilAttrib]): int {.importcpp: "StencilAttrib::get_class_slot()", header: "stencilAttrib.h".}

func filename*(this: MovieAudio): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the movie's filename.  A movie is not guaranteed to have a
## filename, if not, then this function returns a null filename.

func filename*(this: MovieVideo): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the movie's filename.  A movie is not guaranteed to have a
## filename, if not, then this function returns an empty filename.

func subfile_info*(this: MovieVideo): SubfileInfo {.importcpp: "#->get_subfile_info()".} ## \
## If the movie is to be loaded from a subfile on disk, this returns the
## subfile info.  Check info.is_empty() to see if this is valid data.

func channels*(this: MicrophoneAudio): int {.importcpp: "#->get_channels()".} ## \
## Returns the number of channels.

func rate*(this: MicrophoneAudio): int {.importcpp: "#->get_rate()".} ## \
## Returns the sample rate.

func font*(this: TextProperties): TextFont {.importcpp: "#.get_font()".} ## \
## Returns the font currently in use, if any.  If no font is in use, this
## returns the default font.

proc `font=`*(this: TextProperties, font: TextFont) {.importcpp: "#.set_font(#)".} ## \
## Sets the font that will be used when making text.  If this is set to NULL,
## the default font will be used, which can be set via set_default_font().

func small_caps*(this: TextProperties): bool {.importcpp: "#.get_small_caps()".} ## \
## Returns the small_caps flag.  See set_small_caps().

proc `small_caps=`*(this: TextProperties, small_caps: bool) {.importcpp: "#.set_small_caps(#)".} ## \
## Sets the small_caps flag.  When this is set, lowercase letters are
## generated as scaled-down versions of their uppercase equivalents.  This is
## particularly useful to set for fonts that do not have lowercase letters.
##
## It is also a good idea to set this for a (dynamic) font that has already
## implemented lowercase letters as scaled-down versions of their uppercase
## equivalents, since without this flag the texture memory may needlessly
## duplicate equivalent glyphs for upper and lowercase letters.  Setting this
## flag causes the texture memory to share the mixed-case letters.
##
## The amount by which the lowercase letters are scaled is specified by
## set_small_caps_scale().

func small_caps_scale*(this: TextProperties): float32 {.importcpp: "#.get_small_caps_scale()".} ## \
## Returns the scale factor applied to lowercase letters from their uppercase
## equivalents, when the small_caps flag is in effect.  See set_small_caps()
## and set_small_caps_scale().

proc `small_caps_scale=`*(this: TextProperties, small_caps_scale: float32) {.importcpp: "#.set_small_caps_scale(#)".} ## \
## Sets the scale factor applied to lowercase letters from their uppercase
## equivalents, when the small_caps flag is in effect.  See set_small_caps().
## Normally, this will be a number less than one.

func slant*(this: TextProperties): float32 {.importcpp: "#.get_slant()".} ## \
## Returns the factor by which the text is specified to slant to the right.

proc `slant=`*(this: TextProperties, slant: float32) {.importcpp: "#.set_slant(#)".} ## \
## Specifies the factor by which the text slants to the right.

func underscore*(this: TextProperties): bool {.importcpp: "#.get_underscore()".} ## \
## Returns the underscore flag.  See set_underscore().

proc `underscore=`*(this: TextProperties, underscore: bool) {.importcpp: "#.set_underscore(#)".} ## \
## Sets the underscore flag.  When this is set, the text is underscored with a
## one-pixel line the same color as the text foreground, drawn at the
## baseline.

func underscore_height*(this: TextProperties): float32 {.importcpp: "#.get_underscore_height()".} ## \
## Returns the vertical height of the underscore; see set_underscore_height().

proc `underscore_height=`*(this: TextProperties, underscore_height: float32) {.importcpp: "#.set_underscore_height(#)".} ## \
## Specifies the vertical height of the underscore, relative to the text
## baseline.  This only has meaning if the underscore mode is enabled with
## set_underscore().

func indent*(this: TextProperties): float32 {.importcpp: "#.get_indent()".}

proc `indent=`*(this: TextProperties, indent: float32) {.importcpp: "#.set_indent(#)".} ## \
## Specifies the amount of extra space that is inserted before the first
## character of each line.  This can be thought of as a left margin.

func wordwrap*(this: TextProperties): float32 {.importcpp: "#.get_wordwrap()".}

proc `wordwrap=`*(this: TextProperties, wordwrap: float32) {.importcpp: "#.set_wordwrap(#)".} ## \
## Sets the text up to automatically wordwrap when it exceeds the indicated
## width.  This can be thought of as a right margin or margin width.

func preserve_trailing_whitespace*(this: TextProperties): bool {.importcpp: "#.get_preserve_trailing_whitespace()".} ## \
## Returns the preserve_trailing_whitespace flag.  See
## set_preserve_trailing_whitespace().

proc `preserve_trailing_whitespace=`*(this: TextProperties, preserve_trailing_whitespace: bool) {.importcpp: "#.set_preserve_trailing_whitespace(#)".} ## \
## Sets the preserve_trailing_whitespace flag.  When this is set, trailing
## whitespace at the end of the line is not stripped when the text is
## wordwrapped (it is stripped by default).  Since the trailing whitespace is
## invisible, this is important primarily for determining the proper width of
## a frame or card behind the text.

func text_color*(this: TextProperties): LColor {.importcpp: "#.get_text_color()".}

proc `text_color=`*(this: TextProperties, text_color: LColor) {.importcpp: "#.set_text_color(#)".}

proc `text_color=`*(this: TextProperties, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_text_color(#, #, #, #)".}

func shadow_color*(this: TextProperties): LColor {.importcpp: "#.get_shadow_color()".}

proc `shadow_color=`*(this: TextProperties, shadow_color: LColor) {.importcpp: "#.set_shadow_color(#)".}

proc `shadow_color=`*(this: TextProperties, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_shadow_color(#, #, #, #)".}

func shadow*(this: TextProperties): LVector2 {.importcpp: "#.get_shadow()".} ## \
## Returns the offset of the shadow as set by set_shadow().  It is an error to
## call this if has_shadow() is false.

proc `shadow=`*(this: TextProperties, shadow_offset: LVecBase2) {.importcpp: "#.set_shadow(#)".} ## \
## Specifies that the text should be drawn with a shadow, by creating a second
## copy of the text and offsetting it slightly behind the first.

proc `shadow=`*(this: TextProperties, xoffset: float32, yoffset: float32) {.importcpp: "#.set_shadow(#, #)".} ## \
## Specifies that the text should be drawn with a shadow, by creating a second
## copy of the text and offsetting it slightly behind the first.

func bin*(this: TextProperties): string {.importcpp: "nimStringFromStdString(#.get_bin())", header: stringConversionCode.} ## \
## Returns the drawing bin set with set_bin(), or empty string if no bin has
## been set.

proc `bin=`*(this: TextProperties, bin: string) {.importcpp: "#.set_bin(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Names the CullBin that the text geometry should be assigned to.  If this is
## set, then a CullBinAttrib will be created to explicitly place each
## component in the named bin.
##
## The draw_order value will also be passed to each CullBinAttrib as
## appropriate; this is particularly useful if this names a CullBinFixed, e.g.
## "fixed".

func draw_order*(this: TextProperties): int {.importcpp: "#.get_draw_order()".} ## \
## Returns the drawing order set with set_draw_order().

proc `draw_order=`*(this: TextProperties, draw_order: int): int {.importcpp: "#.set_draw_order(#)".} ## \
## Sets the drawing order of text created by the TextNode.  This is actually
## the draw order of the card and frame.  The shadow is drawn at
## _draw_order+1, and the text at _draw_order+2.
##
## This affects the sorting order assigned to the nodes as they are created,
## and also is passed to whatever bin may be assigned via set_bin().
##
## The return value is the first unused draw_order number, e.g.  _draw_order +
## 3.

func tab_width*(this: TextProperties): float32 {.importcpp: "#.get_tab_width()".} ## \
## Returns the width set via set_tab_width().

proc `tab_width=`*(this: TextProperties, tab_width: float32) {.importcpp: "#.set_tab_width(#)".} ## \
## Sets the width of each tab stop, in screen units.  A tab character embedded
## in the text will advance the horizontal position to the next tab stop.

func glyph_scale*(this: TextProperties): float32 {.importcpp: "#.get_glyph_scale()".} ## \
## Returns the scale factor of each letter as specified by set_glyph_scale().

proc `glyph_scale=`*(this: TextProperties, glyph_scale: float32) {.importcpp: "#.set_glyph_scale(#)".} ## \
## Specifies the factor by which to scale each letter of the text as it is
## placed, in addition to any scales inherited from the node or from
## set_text_scale(). This can be used (possibly in conjunction with
## set_glyph_shift()) to implement superscripting or subscripting.
##
## The glyph scale is cumulative when applied to nested TextProperties.  It is
## intended primarily for implementing superscripts, not for scaling the text
## in general.  See also set_text_scale(), which is intended primarily for
## scaling the text in general, and is not cumulative.

func glyph_shift*(this: TextProperties): float32 {.importcpp: "#.get_glyph_shift()".} ## \
## Returns the vertical shift of each letter as specified by
## set_glyph_shift().

proc `glyph_shift=`*(this: TextProperties, glyph_shift: float32) {.importcpp: "#.set_glyph_shift(#)".} ## \
## Specifies a vertical amount to shift each letter of the text as it is
## placed.  This can be used (possibly in conjunction with set_glyph_scale())
## to implement superscripting or subscripting.

func text_scale*(this: TextProperties): float32 {.importcpp: "#.get_text_scale()".} ## \
## Returns the scale factor of the text as specified by set_text_scale().

proc `text_scale=`*(this: TextProperties, text_scale: float32) {.importcpp: "#.set_text_scale(#)".} ## \
## Specifies the factor by which to scale the text, in addition to any
## scalings imposed by the node, as well as in addition to the glyph scale.
##
## The text scale is not cumulative when applied to nested TextProperties.
## See also set_glyph_scale(), which is cumulative.

func max_rows*(this: TextNode): int {.importcpp: "#->get_max_rows()".} ## \
## Returns the limit on the height of the TextNode specified by
## set_max_rows().

proc `max_rows=`*(this: TextNode, max_rows: int) {.importcpp: "#->set_max_rows(#)".} ## \
## Sets the maximum number of rows that may be formatted by the TextNode.  If
## more text than this is attempted, it will be truncated and has_overflow()
## will return true.

func frame_color*(this: TextNode): LColor {.importcpp: "#->get_frame_color()".}

proc `frame_color=`*(this: TextNode, frame_color: LColor) {.importcpp: "#->set_frame_color(#)".}

proc `frame_color=`*(this: TextNode, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#->set_frame_color(#, #, #, #)".}

func card_color*(this: TextNode): LColor {.importcpp: "#->get_card_color()".}

proc `card_color=`*(this: TextNode, card_color: LColor) {.importcpp: "#->set_card_color(#)".}

proc `card_color=`*(this: TextNode, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#->set_card_color(#, #, #, #)".}

func card_texture*(this: TextNode): Texture {.importcpp: "#->get_card_texture()".}

proc `card_texture=`*(this: TextNode, card_texture: Texture) {.importcpp: "#->set_card_texture(#)".}

func frame_line_width*(this: TextNode): float32 {.importcpp: "#->get_frame_line_width()".} ## \
## Returns the thickness of the lines that will be used to draw the frame.

proc `frame_line_width=`*(this: TextNode, line_width: float32) {.importcpp: "#->set_frame_line_width(#)".} ## \
## Specifies the thickness of the lines that will be used to draw the frame.

func frame_corners*(this: TextNode): bool {.importcpp: "#->get_frame_corners()".}

proc `frame_corners=`*(this: TextNode, corners: bool) {.importcpp: "#->set_frame_corners(#)".} ## \
## Enables or disables the drawing of corners for the frame.  These are extra
## points drawn at each of the four corners, to soften the ugly edges
## generated when the line width is greater than one.

func transform*(this: TextNode): LMatrix4 {.importcpp: "#->get_transform()".}

proc `transform=`*(this: TextNode, transform: LMatrix4) {.importcpp: "#->set_transform(#)".} ## \
## Sets an additional transform that is applied to the entire text paragraph.

func coordinate_system*(this: TextNode): CoordinateSystem {.importcpp: "#->get_coordinate_system()".}

proc `coordinate_system=`*(this: TextNode, cs: CoordinateSystem) {.importcpp: "#->set_coordinate_system(#)".} ## \
## Specifies the coordinate system in which the text will be generated.

func flatten_flags*(this: TextNode): int {.importcpp: "#->get_flatten_flags()".} ## \
## Returns the flatten flags.  See set_flatten_flags().

proc `flatten_flags=`*(this: TextNode, flatten_flags: int) {.importcpp: "#->set_flatten_flags(#)".} ## \
## Sets the flatten flags.  This should be a union of the
## TextNode::FlattenFlags options.  This controls the degree of flattening
## performed on the TextNode's internal geometry (i.e.  the scene graph
## returned by generate()) each time the text is changed.  In general, more
## flattening means a more optimal result, but it will take more time to
## generate.
##
## The choice may be any of these three:
##
## FF_none - No flatten operation is called.  The letters are left as
## independent Geoms.
##
## FF_light - A flatten_light() operation is called.  The attributes are
## applied to the vertices, but no nodes are removed.
##
## FF_medium - A flatten_medium() operation is called.  The attributes are
## applied to the vertices, and a few trivial nodes are removed.
##
## FF_strong - A flatten_strong() operation is called.  The attributes are
## applied to the vertices, and the resulting nodes are aggressively combined
## into as few nodes as possible.
##
## In addition to the above choices, you may optionally include the following
## flag:
##
## FF_dynamic_merge - Copy the geoms into a single GeomVertexData as we go,
## instead of relying on the flatten operation at the end.  This pre-flattens
## the text considerably, and may obviate the need for flatten altogether; it
## also tends to improve performance considerably even if you do call flatten.
## However, it is not as fast as not calling flatten at all.
##
## The default is taken from the text-flatten and text-dynamic-merge config
## variables.

proc `font=`*(this: TextNode, font: TextFont) {.importcpp: "#->set_font(#)".} ## \
## Sets the font that will be used when making text.  If this is set to NULL,
## the default font will be used, which can be set via set_default_font().

proc `small_caps=`*(this: TextNode, small_caps: bool) {.importcpp: "#->set_small_caps(#)".} ## \
## Sets the small_caps flag.  When this is set, lowercase letters are
## generated as scaled-down versions of their uppercase equivalents.  This is
## particularly useful to set for fonts that do not have lowercase letters.
##
## It is also a good idea to set this for a (dynamic) font that has already
## implemented lowercase letters as scaled-down versions of their uppercase
## equivalents, since without this flag the texture memory may needlessly
## duplicate equivalent glyphs for upper and lowercase letters.  Setting this
## flag causes the texture memory to share the mixed-case letters.
##
## The amount by which the lowercase letters are scaled is specified by
## set_small_caps_scale().

proc `small_caps_scale=`*(this: TextNode, small_caps_scale: float32) {.importcpp: "#->set_small_caps_scale(#)".} ## \
## Sets the scale factor applied to lowercase letters from their uppercase
## equivalents, when the small_caps flag is in effect.  See set_small_caps().
## Normally, this will be a number less than one.

proc `slant=`*(this: TextNode, slant: float32) {.importcpp: "#->set_slant(#)".}

proc `indent=`*(this: TextNode, indent: float32) {.importcpp: "#->set_indent(#)".} ## \
## Specifies the amount of extra space that is inserted before the first
## character of each line.  This can be thought of as a left margin.

proc `wordwrap=`*(this: TextNode, wordwrap: float32) {.importcpp: "#->set_wordwrap(#)".} ## \
## Sets the text up to automatically wordwrap when it exceeds the indicated
## width.  This can be thought of as a right margin or margin width.

proc `text_color=`*(this: TextNode, text_color: LColor) {.importcpp: "#->set_text_color(#)".}

proc `text_color=`*(this: TextNode, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#->set_text_color(#, #, #, #)".}

proc `shadow_color=`*(this: TextNode, shadow_color: LColor) {.importcpp: "#->set_shadow_color(#)".}

proc `shadow_color=`*(this: TextNode, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#->set_shadow_color(#, #, #, #)".}

proc `shadow=`*(this: TextNode, shadow_offset: LVecBase2) {.importcpp: "#->set_shadow(#)".} ## \
## Specifies that the text should be drawn with a shadow, by creating a second
## copy of the text and offsetting it slightly behind the first.

proc `shadow=`*(this: TextNode, xoffset: float32, yoffset: float32) {.importcpp: "#->set_shadow(#, #)".} ## \
## Specifies that the text should be drawn with a shadow, by creating a second
## copy of the text and offsetting it slightly behind the first.

proc `bin=`*(this: TextNode, bin: string) {.importcpp: "#->set_bin(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Names the GeomBin that the TextNode geometry should be assigned to.  If
## this is set, then a GeomBinTransition will be created to explicitly place
## each component in the named bin.
##
## The draw_order value will also be passed to each GeomBinTransition as
## appropriate; this is particularly useful if this names a GeomBinFixed, e.g.
## "fixed".

proc `draw_order=`*(this: TextNode, draw_order: int): int {.importcpp: "#->set_draw_order(#)".} ## \
## Sets the drawing order of text created by the TextMaker.  This is actually
## the draw order of the card and frame.  The shadow is drawn at
## _draw_order+1, and the text at _draw_order+2.
##
## This affects the sorting order assigned to the arcs as they are created,
## and also is passed to whatever bin may be assigned via set_bin().
##
## The return value is the first unused draw_order number, e.g.  _draw_order +
## 3.

proc `tab_width=`*(this: TextNode, tab_width: float32) {.importcpp: "#->set_tab_width(#)".} ## \
## Sets the width of each tab stop, in screen units.  A tab character embedded
## in the text will advance the horizontal position to the next tab stop.

proc `glyph_scale=`*(this: TextNode, glyph_scale: float32) {.importcpp: "#->set_glyph_scale(#)".} ## \
## Specifies the factor by which to scale each letter of the text as it is
## placed.  This can be used (possibly in conjunction with set_glyph_shift())
## to implement superscripting or subscripting.

proc `glyph_shift=`*(this: TextNode, glyph_shift: float32) {.importcpp: "#->set_glyph_shift(#)".} ## \
## Specifies a vertical amount to shift each letter of the text as it is
## placed.  This can be used (possibly in conjunction with set_glyph_scale())
## to implement superscripting or subscripting.

func clear_color*(this: Texture): LColor {.importcpp: "#->get_clear_color()".} ## \
## Returns the color that was previously set using set_clear_color.

proc `clear_color=`*(this: Texture, color: LColor) {.importcpp: "#->set_clear_color(#)".} ## \
## Sets the color that will be used to fill the texture image in absence of
## any image data.  It is used when any of the setup_texture functions or
## clear_image is called and image data is not provided using read() or
## modify_ram_image().
##
## This does not affect a texture that has already been cleared; call
## clear_image to clear it again.

func filename*(this: Texture): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the filename that has been set.  This is the name of the file as it
## was requested.  Also see get_fullpath().

proc `filename=`*(this: Texture, filename: Filename) {.importcpp: "#->set_filename(#)".} ## \
## Sets the name of the file that contains the image's contents.  Normally,
## this is set automatically when the image is loaded, for instance via
## Texture::read().
##
## The Texture's get_name() function used to return the filename, but now
## returns just the basename (without the extension), which is a more useful
## name for identifying an image in show code.

func alpha_filename*(this: Texture): Filename {.importcpp: "#->get_alpha_filename()".} ## \
## Returns the alpha_filename that has been set.  If this is set, it
## represents the name of the alpha component, which is stored in a separate
## file.  See also get_filename(), and get_alpha_fullpath().

proc `alpha_filename=`*(this: Texture, alpha_filename: Filename) {.importcpp: "#->set_alpha_filename(#)".} ## \
## Sets the name of the file that contains the image's alpha channel contents.
## Normally, this is set automatically when the image is loaded, for instance
## via Texture::read().
##
## The Texture's get_filename() function returns the name of the image file
## that was loaded into the buffer.  In the case where a texture specified two
## separate files to load, a 1- or 3-channel color image and a 1-channel alpha
## image, this Filename is update to contain the name of the image file that
## was loaded into the buffer's alpha channel.

func fullpath*(this: Texture): Filename {.importcpp: "#->get_fullpath()".} ## \
## Returns the fullpath that has been set.  This is the full path to the file
## as it was found along the texture search path.

proc `fullpath=`*(this: Texture, fullpath: Filename) {.importcpp: "#->set_fullpath(#)".} ## \
## Sets the full pathname to the file that contains the image's contents, as
## found along the search path.  Normally, this is set automatically when the
## image is loaded, for instance via Texture::read().

func alpha_fullpath*(this: Texture): Filename {.importcpp: "#->get_alpha_fullpath()".} ## \
## Returns the alpha_fullpath that has been set.  This is the full path to the
## alpha part of the image file as it was found along the texture search path.

proc `alpha_fullpath=`*(this: Texture, alpha_fullpath: Filename) {.importcpp: "#->set_alpha_fullpath(#)".} ## \
## Sets the full pathname to the file that contains the image's alpha channel
## contents, as found along the search path.  Normally, this is set
## automatically when the image is loaded, for instance via Texture::read().

func x_size*(this: Texture): int {.importcpp: "#->get_x_size()".} ## \
## Returns the width of the texture image in texels.

proc `x_size=`*(this: Texture, x_size: int) {.importcpp: "#->set_x_size(#)".} ## \
## Changes the x size indicated for the texture.  This also implicitly unloads
## the texture if it has already been loaded.

func y_size*(this: Texture): int {.importcpp: "#->get_y_size()".} ## \
## Returns the height of the texture image in texels.  For a 1-d texture, this
## will be 1.

proc `y_size=`*(this: Texture, y_size: int) {.importcpp: "#->set_y_size(#)".} ## \
## Changes the y size indicated for the texture.  This also implicitly unloads
## the texture if it has already been loaded.

func z_size*(this: Texture): int {.importcpp: "#->get_z_size()".} ## \
## Returns the depth of the texture image in texels.  For a 1-d texture or 2-d
## texture, this will be 1. For a cube map texture, this will be 6.

proc `z_size=`*(this: Texture, z_size: int) {.importcpp: "#->set_z_size(#)".} ## \
## Changes the z size indicated for the texture.  This also implicitly unloads
## the texture if it has already been loaded.

func num_views*(this: Texture): int {.importcpp: "#->get_num_views()".} ## \
## Returns the number of "views" in the texture.  A view is a completely
## separate image stored within the Texture object.  Most textures have only
## one view, but a stereo texture, for instance, may have two views, a left
## and a right image.  Other uses for multiple views are not yet defined.
##
## If this value is greater than one, the additional views are accessed as
## additional pages beyond get_z_size().

proc `num_views=`*(this: Texture, num_views: int) {.importcpp: "#->set_num_views(#)".} ## \
## Sets the number of "views" within a texture.  A view is a completely
## separate image stored within the Texture object.  Most textures have only
## one view, but a stereo texture, for instance, may have two views, a left
## and a right image.  Other uses for multiple views are not yet defined.
##
## If this value is greater than one, the additional views are accessed as
## additional pages beyond get_z_size().
##
## This also implicitly unloads the texture if it has already been loaded.

func num_pages*(this: Texture): int {.importcpp: "#->get_num_pages()".} ## \
## Returns the total number of pages in the texture.  Each "page" is a 2-d
## texture image within the larger image--a face of a cube map, or a level of
## a 3-d texture.  Normally, get_num_pages() is the same as get_z_size().
## However, in a multiview texture, this returns get_z_size() *
## get_num_views().

func num_components*(this: Texture): int {.importcpp: "#->get_num_components()".} ## \
## Returns the number of color components for each texel of the texture image.
## This is 3 for an rgb texture or 4 for an rgba texture; it may also be 1 or
## 2 for a grayscale texture.

func component_width*(this: Texture): int {.importcpp: "#->get_component_width()".} ## \
## Returns the number of bytes stored for each color component of a texel.
## Typically this is 1, but it may be 2 for 16-bit texels.

func anisotropic_degree*(this: Texture): int {.importcpp: "#->get_anisotropic_degree()".} ## \
## Returns the degree of anisotropic filtering that should be applied to the
## texture.  This value may return 0, indicating the default value; see also
## get_effective_anisotropic_degree.
##
## This returns the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

proc `anisotropic_degree=`*(this: Texture, anisotropic_degree: int) {.importcpp: "#->set_anisotropic_degree(#)".} ## \
## Specifies the level of anisotropic filtering to apply to the texture.  Set
## this 0 to indicate the default value, which is specified in the texture-
## anisotropic-degree config variable.
##
## To explicitly disable anisotropic filtering, set this value to 1.  To
## explicitly enable anisotropic filtering, set it to a value higher than 1;
## larger numbers indicate greater degrees of filtering.
##
## This sets the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

func effective_anisotropic_degree*(this: Texture): int {.importcpp: "#->get_effective_anisotropic_degree()".} ## \
## Returns the degree of anisotropic filtering that should be applied to the
## texture.  This value will normally not return 0, unless there is an error
## in the config file.
##
## This returns the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

func border_color*(this: Texture): LColor {.importcpp: "#->get_border_color()".} ## \
## Returns the solid color of the texture's border.  Some OpenGL
## implementations use a border for tiling textures; in Panda, it is only used
## for specifying the clamp color.
##
## This returns the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

proc `border_color=`*(this: Texture, color: LColor) {.importcpp: "#->set_border_color(#)".} ## \
## Specifies the solid color of the texture's border.  Some OpenGL
## implementations use a border for tiling textures; in Panda, it is only used
## for specifying the clamp color.
##
## This sets the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

func render_to_texture*(this: Texture): bool {.importcpp: "#->get_render_to_texture()".} ## \
## Returns a flag on the texture that indicates whether the texture is
## intended to be used as a direct-render target, by binding a framebuffer to
## a texture and rendering directly into the texture.
##
## Normally, a user should not need to set this flag directly; it is set
## automatically by the low-level display code when a texture is bound to a
## framebuffer.

proc `render_to_texture=`*(this: Texture, render_to_texture: bool) {.importcpp: "#->set_render_to_texture(#)".} ## \
## Sets a flag on the texture that indicates whether the texture is intended
## to be used as a direct-render target, by binding a framebuffer to a texture
## and rendering directly into the texture.
##
## This controls some low-level choices made about the texture object itself.
## For instance, compressed textures are disallowed when this flag is set
## true.
##
## Normally, a user should not need to set this flag directly; it is set
## automatically by the low-level display code when a texture is bound to a
## framebuffer.

func default_sampler*(this: Texture): SamplerState {.importcpp: "#->get_default_sampler()".} ## \
## This returns the default sampler state for this texture, containing the
## wrap and filter properties specified on the texture level; it may still be
## overridden by a sampler state specified at a higher level.

proc `default_sampler=`*(this: Texture, sampler: SamplerState) {.importcpp: "#->set_default_sampler(#)".} ## \
## This sets the default sampler state for this texture, containing the wrap
## and filter properties specified on the texture level; it may still be
## overridden by a sampler state specified at a higher level.  This
## encompasses the settings for get_wrap_u, get_minfilter,
## get_anisotropic_degree, etc.
##
## This makes a copy of the SamplerState object, so future modifications of
## the same SamplerState will have no effect on this texture unless you call
## set_default_sampler again.

func expected_num_mipmap_levels*(this: Texture): int {.importcpp: "#->get_expected_num_mipmap_levels()".} ## \
## Returns the number of mipmap levels that should be defined for this
## texture, given the texture's size.
##
## Note that this returns a number appropriate for mipmapping, even if the
## texture does not currently have mipmapping enabled.

func ram_image_size*(this: Texture): clonglong {.importcpp: "#->get_ram_image_size()".} ## \
## Returns the total number of bytes used by the in-memory image, across all
## pages and views, or 0 if there is no in-memory image.

func ram_view_size*(this: Texture): clonglong {.importcpp: "#->get_ram_view_size()".} ## \
## Returns the number of bytes used by the in-memory image per view, or 0 if
## there is no in-memory image.  Since each view is a stack of z_size pages,
## this is get_z_size() * get_ram_page_size().

func ram_page_size*(this: Texture): clonglong {.importcpp: "#->get_ram_page_size()".} ## \
## Returns the number of bytes used by the in-memory image per page, or 0 if
## there is no in-memory image.
##
## For a non-compressed texture, this is the same as
## get_expected_ram_page_size().  For a compressed texture, this may be a
## smaller value.  (We do assume that all pages will be the same size on a
## compressed texture).

func expected_ram_image_size*(this: Texture): clonglong {.importcpp: "#->get_expected_ram_image_size()".} ## \
## Returns the number of bytes that *ought* to be used by the in-memory image,
## based on the texture parameters.

func expected_ram_page_size*(this: Texture): clonglong {.importcpp: "#->get_expected_ram_page_size()".} ## \
## Returns the number of bytes that should be used per each Z page of the 3-d
## texture.  For a 2-d or 1-d texture, this is the same as
## get_expected_ram_image_size().

func keep_ram_image*(this: Texture): bool {.importcpp: "#->get_keep_ram_image()".} ## \
## Returns the flag that indicates whether this Texture is eligible to have
## its main RAM copy of the texture memory dumped when the texture is prepared
## for rendering.  See set_keep_ram_image().

proc `keep_ram_image=`*(this: Texture, keep_ram_image: bool) {.importcpp: "#->set_keep_ram_image(#)".} ## \
## Sets the flag that indicates whether this Texture is eligible to have its
## main RAM copy of the texture memory dumped when the texture is prepared for
## rendering.
##
## This will be false for most textures, which can reload their images if
## needed by rereading the input file.  However, textures that were generated
## dynamically and cannot be easily reloaded will want to set this flag to
## true, so that the texture will always keep its image copy around.

func cacheable*(this: Texture): bool {.importcpp: "#->is_cacheable()".} ## \
## Returns true if there is enough information in this Texture object to write
## it to the bam cache successfully, false otherwise.  For most textures, this
## is the same as has_ram_image().

func num_ram_mipmap_images*(this: Texture): int {.importcpp: "#->get_num_ram_mipmap_images()".} ## \
## Returns the maximum number of mipmap level images available in system
## memory.  The actual number may be less than this (that is, there might be
## gaps in the sequence); use has_ram_mipmap_image() to verify each level.
##
## Also see get_num_loadable_ram_mipmap_images().

func num_loadable_ram_mipmap_images*(this: Texture): int {.importcpp: "#->get_num_loadable_ram_mipmap_images()".} ## \
## Returns the number of contiguous mipmap levels that exist in RAM, up until
## the first gap in the sequence.  It is guaranteed that at least mipmap
## levels [0, get_num_ram_mipmap_images()) exist.
##
## The number returned will never exceed the number of required mipmap images
## based on the size of the texture and its filter mode.
##
## This method is different from get_num_ram_mipmap_images() in that it
## returns only the number of mipmap levels that can actually be usefully
## loaded, regardless of the actual number that may be stored.

func simple_x_size*(this: Texture): int {.importcpp: "#->get_simple_x_size()".} ## \
## Returns the width of the "simple" image in texels.

func simple_y_size*(this: Texture): int {.importcpp: "#->get_simple_y_size()".} ## \
## Returns the height of the "simple" image in texels.

func properties_modified*(this: Texture): UpdateSeq {.importcpp: "#->get_properties_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the texture properties (unrelated to the image) are modified.

func image_modified*(this: Texture): UpdateSeq {.importcpp: "#->get_image_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the texture image data (including mipmap levels) are modified.

func simple_image_modified*(this: Texture): UpdateSeq {.importcpp: "#->get_simple_image_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the texture's "simple" image data is modified.

func auto_texture_scale*(this: Texture): AutoTextureScale {.importcpp: "#->get_auto_texture_scale()".} ## \
## Returns the power-of-2 texture-scaling mode that will be applied to this
## particular texture when it is next loaded from disk.  See
## set_textures_power_2().

proc `auto_texture_scale=`*(this: Texture, scale: AutoTextureScale) {.importcpp: "#->set_auto_texture_scale(#)".} ## \
## Specifies the power-of-2 texture-scaling mode that will be applied to this
## particular texture when it is next loaded from disk.  See
## set_textures_power_2().

func orig_file_x_size*(this: Texture): int {.importcpp: "#->get_orig_file_x_size()".} ## \
## Returns the X size of the original disk image that this Texture was loaded
## from (if it came from a disk file), before any automatic rescaling by
## Panda.

func orig_file_y_size*(this: Texture): int {.importcpp: "#->get_orig_file_y_size()".} ## \
## Returns the Y size of the original disk image that this Texture was loaded
## from (if it came from a disk file), before any automatic rescaling by
## Panda.

func orig_file_z_size*(this: Texture): int {.importcpp: "#->get_orig_file_z_size()".} ## \
## Returns the Z size of the original disk image that this Texture was loaded
## from (if it came from a disk file), before any automatic rescaling by
## Panda.

func loaded_from_image*(this: Texture): bool {.importcpp: "#->get_loaded_from_image()".} ## \
## Returns the flag that indicates the texture has been loaded from a disk
## file or PNMImage.  See set_loaded_from_image().

proc `loaded_from_image=`*(this: Texture, flag: bool) {.importcpp: "#->set_loaded_from_image(#)".} ## \
## Sets the flag that indicates the texture has been loaded from a disk file
## or PNMImage.  You should also ensure the filename has been set correctly.
## When this flag is true, the texture may be automatically reloaded when its
## ram image needs to be replaced.

proc `loaded_from_image=`*(this: Texture) {.importcpp: "#->set_loaded_from_image()".} ## \
## Sets the flag that indicates the texture has been loaded from a disk file
## or PNMImage.  You should also ensure the filename has been set correctly.
## When this flag is true, the texture may be automatically reloaded when its
## ram image needs to be replaced.

func loaded_from_txo*(this: Texture): bool {.importcpp: "#->get_loaded_from_txo()".} ## \
## Returns the flag that indicates the texture has been loaded from a txo
## file.

proc `loaded_from_txo=`*(this: Texture, flag: bool) {.importcpp: "#->set_loaded_from_txo(#)".} ## \
## Sets the flag that indicates the texture has been loaded from a txo file.
## You probably shouldn't be setting this directly; it is set automatically
## when a Texture is loaded.

proc `loaded_from_txo=`*(this: Texture) {.importcpp: "#->set_loaded_from_txo()".} ## \
## Sets the flag that indicates the texture has been loaded from a txo file.
## You probably shouldn't be setting this directly; it is set automatically
## when a Texture is loaded.

func match_framebuffer_format*(this: Texture): bool {.importcpp: "#->get_match_framebuffer_format()".} ## \
## Returns true if the special flag was set that indicates to the GSG that the
## Texture's format should be chosen to exactly match the framebuffer's
## format, presumably because the application intends to copy image data from
## the framebuffer into the Texture (or vice-versa).

proc `match_framebuffer_format=`*(this: Texture, flag: bool) {.importcpp: "#->set_match_framebuffer_format(#)".} ## \
## Sets the special flag that, if true, indicates to the GSG that the
## Texture's format should be chosen to exactly match the framebuffer's
## format, presumably because the application intends to copy image data from
## the framebuffer into the Texture (or vice-versa).
##
## This sets only the graphics card's idea of the texture format; it is not
## related to the system-memory format.

func post_load_store_cache*(this: Texture): bool {.importcpp: "#->get_post_load_store_cache()".} ## \
## Returns the setting of the post_load_store_cache flag.  See
## set_post_load_store_cache().

proc `post_load_store_cache=`*(this: Texture, flag: bool) {.importcpp: "#->set_post_load_store_cache(#)".} ## \
## Sets the post_load_store_cache flag.  When this is set, the next time the
## texture is loaded on a GSG, it will automatically extract its RAM image
## from the GSG and save it to the global BamCache.
##
## This is used to store compressed RAM images in the BamCache.  This flag
## should not be set explicitly; it is set automatically by the TexturePool
## when model-cache-compressed-textures is set true.

func video_length*(this: MovieTexture): float64 {.importcpp: "#->get_video_length()".} ## \
## Returns the length of the video.

func video_width*(this: MovieTexture): int {.importcpp: "#->get_video_width()".} ## \
## Returns the width in texels of the source video stream.  This is not
## necessarily the width of the actual texture, since the texture may have
## been expanded to raise it to a power of 2.

func video_height*(this: MovieTexture): int {.importcpp: "#->get_video_height()".} ## \
## Returns the height in texels of the source video stream.  This is not
## necessarily the height of the actual texture, since the texture may have
## been expanded to raise it to a power of 2.

func time*(this: MovieTexture): float64 {.importcpp: "#->get_time()".} ## \
## Returns the current value of the movie's cursor.  If the movie's loop count
## is greater than one, then its length is effectively multiplied for the
## purposes of this function.  In other words, the return value will be in the
## range 0.0 to (length * loopcount).

proc `time=`*(this: MovieTexture, t: float64) {.importcpp: "#->set_time(#)".} ## \
## Sets the movie's cursor.

func loop*(this: MovieTexture): bool {.importcpp: "#->get_loop()".} ## \
## Returns true if the movie's loop count is not equal to one.

proc `loop=`*(this: MovieTexture, enable: bool) {.importcpp: "#->set_loop(#)".} ## \
## If true, sets the movie's loop count to 1 billion.  If false, sets the
## movie's loop count to one.

func loop_count*(this: MovieTexture): int {.importcpp: "#->get_loop_count()".} ## \
## Returns the movie's loop count.

proc `loop_count=`*(this: MovieTexture, count: int) {.importcpp: "#->set_loop_count(#)".} ## \
## Sets the movie's loop count to the desired value.

func play_rate*(this: MovieTexture): float64 {.importcpp: "#->get_play_rate()".} ## \
## Gets the movie's play-rate.

proc `play_rate=`*(this: MovieTexture, play_rate: float64) {.importcpp: "#->set_play_rate(#)".} ## \
## Sets the movie's play-rate.  This is the speed at which the movie's cursor
## advances.  The default is to advance 1.0 movie-seconds per real-time
## second.

func playing*(this: MovieTexture): bool {.importcpp: "#->is_playing()".} ## \
## Returns true if the movie's cursor is advancing.

func modified*(this: VertexTransform, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number that's guaranteed to change at least every time
## the value reported by get_matrix() changes.

func modified*(this: VertexTransform): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number that's guaranteed to change at least every time
## the value reported by get_matrix() changes.

func node*(this: NodeVertexTransform): PandaNode {.importcpp: "#->get_node()".} ## \
## Returns the PandaNode whose transform supplies this object.

func prev*(this: NodeVertexTransform): VertexTransform {.importcpp: "#->get_prev()".} ## \
## Returns the VertexTransform object whose matrix will be composed with the
## result of this node's transform.

func heightfield*(this: ShaderTerrainMesh): Texture {.importcpp: "#->get_heightfield()".} ## \
## @brief Returns the heightfield
## @details This returns the terrain heightfield, previously set with
## set_heightfield()
##
## @return Path to the heightfield

proc `heightfield=`*(this: ShaderTerrainMesh, heightfield: Texture) {.importcpp: "#->set_heightfield(#)".} ## \
## @brief Sets the heightfield texture
## @details This sets the heightfield texture. It should be 16bit
## single channel, and have a power-of-two resolution greater than 32.
## Common sizes are 2048x2048 or 4096x4096.
##
## You should call generate() after setting the heightfield.
##
## @param filename Heightfield texture

func chunk_size*(this: ShaderTerrainMesh): clonglong {.importcpp: "#->get_chunk_size()".} ## \
## @brief Returns the chunk size
## @details This returns the chunk size, previously set with set_chunk_size()
## @return Chunk size

proc `chunk_size=`*(this: ShaderTerrainMesh, chunk_size: clonglong) {.importcpp: "#->set_chunk_size(#)".} ## \
## @brief Sets the chunk size
## @details This sets the chunk size of the terrain. A chunk is basically the
## smallest unit in LOD. If the chunk size is too small, the terrain will
## perform bad, since there will be way too many chunks. If the chunk size
## is too big, you will not get proper LOD, and might also get bad performance.
##
## For terrains of the size 4096x4096 or 8192x8192, a chunk size of 32 seems
## to produce good results. For smaller resolutions, you should try out a
## size of 16 or even 8 for very small terrains.
##
## The amount of chunks generated for the last level equals to
## (heightfield_size / chunk_size) ** 2. The chunk size has to be a power
## of two.
##
## @param chunk_size Size of the chunks, has to be a power of two

func generate_patches*(this: ShaderTerrainMesh): bool {.importcpp: "#->get_generate_patches()".} ## \
## @brief Returns whether to generate patches
## @details This returns whether patches are generated, previously set with
## set_generate_patches()
##
## @return Whether to generate patches

proc `generate_patches=`*(this: ShaderTerrainMesh, generate_patches: bool) {.importcpp: "#->set_generate_patches(#)".} ## \
## @brief Sets whether to generate patches
## @details If this option is set to true, GeomPatches will be used instead of
## GeomTriangles. This is required when the terrain is used with tesselation
## shaders, since patches are required for tesselation, whereas triangles
## are required for regular rendering.
##
## If this option is set to true while not using a tesselation shader, the
## terrain will not get rendered, or even produce errors. The same applies
## when this is option is not set, but the terrain is used with tesselation
## shaders.
##
## @param generate_patches [description]

func update_enabled*(this: ShaderTerrainMesh): bool {.importcpp: "#->get_update_enabled()".} ## \
## @brief Returns whether the terrain is getting updated
## @details This returns whether the terrain is getting updates, previously set with
## set_update_enabled()
##
## @return Whether to update the terrain

proc `update_enabled=`*(this: ShaderTerrainMesh, update_enabled: bool) {.importcpp: "#->set_update_enabled(#)".} ## \
## @brief Sets whether to enable terrain updates
## @details This flag controls whether the terrain should be updated. If this value
## is set to false, no updating of the terrain will happen. This can be useful
## to debug the culling algorithm used by the terrain.
##
## @param update_enabled Whether to update the terrain

func target_triangle_width*(this: ShaderTerrainMesh): float32 {.importcpp: "#->get_target_triangle_width()".} ## \
## @brief Returns the target triangle width
## @details This returns the target triangle width, previously set with
## ShaderTerrainMesh::set_target_triangle_width()
##
## @return Target triangle width

proc `target_triangle_width=`*(this: ShaderTerrainMesh, target_triangle_width: float32) {.importcpp: "#->set_target_triangle_width(#)".} ## \
## @brief Sets the desired triangle width
## @details This sets the desired width a triangle should have in pixels.
## A value of 10.0 for example will make the terrain tesselate everything
## in a way that each triangle edge roughly is 10 pixels wide.
## Of course this will not always accurately match, however you can use this
## setting to control the LOD algorithm of the terrain.
##
## @param target_triangle_width Desired triangle width in pixels

func internal_scene*(this: RigidBodyCombiner): NodePath {.importcpp: "#->get_internal_scene()".} ## \
## Returns a special NodePath that represents the internal node of this
## object.  This is the node that is actually sent to the graphics card for
## rendering; it contains the collection of the children of this node into as
## few Geoms as possible.
##
## This node is filled up by the last call to collect().

func base_frame_rate*(this: AnimBundle): float64 {.importcpp: "#->get_base_frame_rate()".} ## \
## Returns the ideal number of frames per second of the animation, when it is
## running at normal speed.  This may not be the same as the actual playing
## frame rate, as it might have been adjusted through set_play_rate() on the
## AnimControl object.  See AnimControl::get_effective_frame_rate().

func num_frames*(this: AnimBundle): int {.importcpp: "#->get_num_frames()".} ## \
## Returns the number of frames of animation, or 0 if the animation has no
## fixed number of frames.

func bundle*(this: AnimBundleNode): AnimBundle {.importcpp: "#->get_bundle()".}

func value_node*(this: AnimChannelMatrixDynamic): PandaNode {.importcpp: "#->get_value_node()".} ## \
## Returns the node that was set via set_value_node(), if any.

proc `value_node=`*(this: AnimChannelMatrixDynamic, node: PandaNode) {.importcpp: "#->set_value_node(#)".} ## \
## Specifies a node whose transform will be queried each frame to implicitly
## specify the transform of this joint.

proc `value=`*(this: AnimChannelScalarDynamic, value: float32) {.importcpp: "#->set_value(#)".} ## \
## Explicitly sets the value.  This will remove any node assigned via
## set_value_node().

proc `value_node=`*(this: AnimChannelScalarDynamic, node: PandaNode) {.importcpp: "#->set_value_node(#)".} ## \
## Specifies a node whose transform will be queried each frame to implicitly
## specify the transform of this joint.  This will override the values set by
## set_value().

func anim_blend_flag*(this: PartBundle): bool {.importcpp: "#->get_anim_blend_flag()".} ## \
## Returns whether the character allows multiple different animations to be
## bound simultaneously.  See set_anim_blend_flag().

proc `anim_blend_flag=`*(this: PartBundle, anim_blend_flag: bool) {.importcpp: "#->set_anim_blend_flag(#)".} ## \
## Defines the way the character responds to multiple calls to
## set_control_effect()).  By default, this flag is set false, which disallows
## multiple animations.  When this flag is false, it is not necessary to
## explicitly set the control_effect when starting an animation; starting the
## animation will implicitly remove the control_effect from the previous
## animation and set it on the current one.
##
## However, if this flag is set true, the control_effect must be explicitly
## set via set_control_effect() whenever an animation is to affect the
## character.

func frame_blend_flag*(this: PartBundle): bool {.importcpp: "#->get_frame_blend_flag()".} ## \
## Returns whether the character interpolates (blends) between two sequential
## animation frames, or whether it holds the current frame until the next one
## is ready.  See set_frame_blend_flag().

proc `frame_blend_flag=`*(this: PartBundle, frame_blend_flag: bool) {.importcpp: "#->set_frame_blend_flag(#)".} ## \
## Specifies whether the character interpolates (blends) between two
## sequential frames of an active animation, showing a smooth intra-frame
## motion, or whether it holds each frame until the next frame is ready,
## showing precisely the specified animation.
##
## When this value is false, the character holds each frame until the next is
## ready.  When this is true, the character will interpolate between two
## consecutive frames of animation for each frame the animation is onscreen,
## according to the amount of time elapsed between the frames.
##
## The default value of this flag is determined by the interpolate-frames
## Config.prc variable.
##
## Use set_blend_type() to change the algorithm that the character uses to
## interpolate matrix positions.

func root_xform*(this: PartBundle): LMatrix4 {.importcpp: "#->get_root_xform()".} ## \
## Returns the transform matrix which is implicitly applied at the root of the
## animated hierarchy.

proc `root_xform=`*(this: PartBundle, root_xform: LMatrix4) {.importcpp: "#->set_root_xform(#)".} ## \
## Specifies the transform matrix which is implicitly applied at the root of
## the animated hierarchy.

func bundle*(this: PartBundleHandle): PartBundle {.importcpp: "#->get_bundle()".} ## \
## Returns the actual PartBundle embedded within the handle.

proc `bundle=`*(this: PartBundleHandle, bundle: PartBundle) {.importcpp: "#->set_bundle(#)".} ## \
## Changes the actual PartBundle embedded within the handle.

func client_name*(this: PStatClient): string {.importcpp: "nimStringFromStdString(#.get_client_name())", header: stringConversionCode.} ## \
## Retrieves the name of the client as set.

proc `client_name=`*(this: PStatClient, name: string) {.importcpp: "#.set_client_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the name of the client.  This is reported to the PStatsServer, and
## will presumably be written in the title bar or something.

func max_rate*(this: PStatClient): float64 {.importcpp: "#.get_max_rate()".} ## \
## Returns the maximum number of packets that will be sent to the server per
## second, per thread.  See set_max_rate().

proc `max_rate=`*(this: PStatClient, rate: float64) {.importcpp: "#.set_max_rate(#)".} ## \
## Controls the number of packets that will be sent to the server.  Normally,
## one packet is sent per frame, but this can flood the server with more
## packets than it can handle if the frame rate is especially good (e.g.  if
## nothing is onscreen at the moment).  Set this parameter to a reasonable
## number to prevent this from happening.
##
## This number specifies the maximum number of packets that will be sent to
## the server per second, per thread.

func main_thread*(this: PStatClient): PStatThread {.importcpp: "#.get_main_thread()".} ## \
## Returns a handle to the client's Main thread.  This is the thread that
## started the application.

func current_thread*(this: PStatClient): PStatThread {.importcpp: "#.get_current_thread()".} ## \
## Returns a handle to the currently-executing thread.  This is the thread
## that PStatCollectors will be counted in if they do not specify otherwise.

func real_time*(this: PStatClient): float64 {.importcpp: "#.get_real_time()".} ## \
## Returns the time according to to the PStatClient's clock object.  It keeps
## its own clock, instead of using the global clock object, so the stats won't
## get mucked up if you put the global clock in non-real-time mode or
## something.

func thread*(this: PStatThread): Thread {.importcpp: "#.get_thread()".} ## \
## Returns the Panda Thread object associated with this particular
## PStatThread.

func index*(this: PStatThread): int {.importcpp: "#.get_index()".} ## \
## Returns the index number of this particular thread within the PStatClient.

func name*(this: VertexSlider): InternalName {.importcpp: "#->get_name()".} ## \
## Returns the name of this particular slider.  Every unique blend shape
## within a particular Geom must be identified with a different name, which is
## shared by the slider that controls it.

func slider*(this: VertexSlider): float32 {.importcpp: "#->get_slider()".}

func modified*(this: VertexSlider, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number that's guaranteed to change at least every time
## the value reported by get_slider() changes.

func modified*(this: VertexSlider): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number that's guaranteed to change at least every time
## the value reported by get_slider() changes.

func collision_origin*(this: CollisionSolid): LPoint3 {.importcpp: "#->get_collision_origin()".}

func tangible*(this: CollisionSolid): bool {.importcpp: "#->is_tangible()".} ## \
## Returns whether the solid is considered 'tangible' or not.  An intangible
## solid has no effect in a CollisionHandlerPusher (except to throw an event);
## it's useful for defining 'trigger' planes and spheres, that cause an effect
## when passed through.

proc `tangible=`*(this: CollisionSolid, tangible: bool) {.importcpp: "#->set_tangible(#)".} ## \
## Sets the current state of the 'tangible' flag.  Set this true to make the
## solid tangible, so that a CollisionHandlerPusher will not allow another
## object to intersect it, or false to make it intangible, so that a
## CollisionHandlerPusher will ignore it except to throw an event.

func respect_effective_normal*(this: CollisionSolid): bool {.importcpp: "#->get_respect_effective_normal()".} ## \
## See set_respect_effective_normal().

proc `respect_effective_normal=`*(this: CollisionSolid, respect_effective_normal: bool) {.importcpp: "#->set_respect_effective_normal(#)".} ## \
## This is only meaningful for CollisionSolids that will be added to a
## traverser as colliders.  It is normally true, but if set false, it means
## that this particular solid does not care about the "effective" normal of
## other solids it meets, but rather always uses the true normal.

func bounds*(this: CollisionSolid): BoundingVolume {.importcpp: "#->get_bounds()".} ## \
## Returns the solid's bounding volume.

proc `bounds=`*(this: CollisionSolid, bounding_volume: BoundingVolume) {.importcpp: "#->set_bounds(#)".} ## \
## Returns the solid's bounding volume.

func center*(this: CollisionBox): LPoint3 {.importcpp: "#->get_center()".}

func min*(this: CollisionBox): LPoint3 {.importcpp: "#->get_min()".}

func max*(this: CollisionBox): LPoint3 {.importcpp: "#->get_max()".}

func dimensions*(this: CollisionBox): LVector3 {.importcpp: "#->get_dimensions()".}

func point_a*(this: CollisionCapsule): LPoint3 {.importcpp: "#->get_point_a()".}

proc `point_a=`*(this: CollisionCapsule, a: LPoint3) {.importcpp: "#->set_point_a(#)".}

proc `point_a=`*(this: CollisionCapsule, x: float32, y: float32, z: float32) {.importcpp: "#->set_point_a(#, #, #)".}

func point_b*(this: CollisionCapsule): LPoint3 {.importcpp: "#->get_point_b()".}

proc `point_b=`*(this: CollisionCapsule, b: LPoint3) {.importcpp: "#->set_point_b(#)".}

proc `point_b=`*(this: CollisionCapsule, x: float32, y: float32, z: float32) {.importcpp: "#->set_point_b(#, #, #)".}

func radius*(this: CollisionCapsule): float32 {.importcpp: "#->get_radius()".}

proc `radius=`*(this: CollisionCapsule, radius: float32) {.importcpp: "#->set_radius(#)".}

func collider_sort*(this: CollisionNode): int {.importcpp: "#->get_collider_sort()".} ## \
## Returns the collider_sort value that has been set for this particular node.
## See set_collider_sort().

proc `collider_sort=`*(this: CollisionNode, sort: int) {.importcpp: "#->set_collider_sort(#)".} ## \
## Sets a particular collider_sort value on this node.  This controls the
## order in which colliders (that is, "from nodes") are grouped together for
## the collision traversal.
##
## If there are 32 or fewer colliders added to any particular
## CollisionTraverser, then this value has no meaning.  It is only useful if
## there are many colliders, which may force the CollisionTraverser to make
## multiple passes through the data; in that case, it may be a useful
## optimization to group colliders that have similar bounding volumes together
## (by giving them similar sort values).

func respect_prev_transform*(this: CollisionTraverser): bool {.importcpp: "#.get_respect_prev_transform()".} ## \
## Returns the flag that indicates whether the prev_transform stored on a node
## is respected to calculate collisions.  See set_respect_prev_transform().

proc `respect_prev_transform=`*(this: CollisionTraverser, flag: bool) {.importcpp: "#.set_respect_prev_transform(#)".} ## \
## Sets the flag that indicates whether the prev_transform stored on a node
## (as updated via set_fluid_pos(), etc.) is respected to calculate
## collisions.  If this is true, certain types of collision tests will be
## enhanced by the information about objects in motion.  If this is false,
## objects are always considered to be static.  The default is false.

func recorder*(this: CollisionTraverser): CollisionRecorder {.importcpp: "#.get_recorder()".} ## \
## Returns the CollisionRecorder currently assigned, or NULL if no recorder is
## assigned.

proc `recorder=`*(this: CollisionTraverser, recorder: CollisionRecorder) {.importcpp: "#.set_recorder(#)".} ## \
## Uses the indicated CollisionRecorder object to start recording the
## intersection tests made by each subsequent call to traverse() on this
## object.  A particular CollisionRecorder object can only record one
## traverser at a time; if this object has already been assigned to another
## traverser, that assignment is broken.
##
## This is intended to be used in a debugging mode to try to determine what
## work is being performed by the collision traversal.  Usually, attaching a
## recorder will impose significant runtime overhead.
##
## This does not transfer ownership of the CollisionRecorder pointer;
## maintenance of that remains the caller's responsibility.  If the
## CollisionRecorder is destructed, it will cleanly remove itself from the
## traverser.

func from_solid*(this: CollisionEntry): CollisionSolid {.importcpp: "#->get_from()".} ## \
## Returns the CollisionSolid pointer for the particular solid that triggered
## this collision.

func into_solid*(this: CollisionEntry): CollisionSolid {.importcpp: "#->get_into()".} ## \
## Returns the CollisionSolid pointer for the particular solid was collided
## into.  This pointer might be NULL if the collision was into a piece of
## visible geometry, instead of a normal CollisionSolid collision; see
## has_into().

func from_node*(this: CollisionEntry): CollisionNode {.importcpp: "#->get_from_node()".} ## \
## Returns the node that contains the CollisionSolid that triggered this
## collision.  This will be a node that has been added to a CollisionTraverser
## via add_collider().

func into_node*(this: CollisionEntry): PandaNode {.importcpp: "#->get_into_node()".} ## \
## Returns the node that contains the CollisionSolid that was collided into.
## This returns a PandaNode pointer instead of something more specific,
## because it might be either a CollisionNode or a GeomNode.
##
## Also see get_into_node_path().

func from_node_path*(this: CollisionEntry): NodePath {.importcpp: "#->get_from_node_path()".} ## \
## Returns the NodePath that represents the CollisionNode that contains the
## CollisionSolid that triggered this collision.  This will be a NodePath that
## has been added to a CollisionTraverser via add_collider().

func into_node_path*(this: CollisionEntry): NodePath {.importcpp: "#->get_into_node_path()".} ## \
## Returns the NodePath that represents the specific CollisionNode or GeomNode
## instance that was collided into.  This is the same node returned by
## get_into_node(), represented as a NodePath; however, it may be more useful
## because the NodePath can resolve the particular instance of the node, if
## there is more than one.

func t*(this: CollisionEntry): float32 {.importcpp: "#->get_t()".} ## \
## returns time value for this collision relative to other CollisionEntries

proc `t=`*(this: CollisionEntry, t: float32) {.importcpp: "#->set_t(#)".} ## \
## Sets a time value for this collision relative to other CollisionEntries

func respect_prev_transform*(this: CollisionEntry): bool {.importcpp: "#->get_respect_prev_transform()".} ## \
## Returns true if the collision was detected by a CollisionTraverser whose
## respect_prev_transform flag was set true, meaning we should consider motion
## significant in evaluating collisions.

func normal*(this: CollisionPlane): LVector3 {.importcpp: "#->get_normal()".}

func plane*(this: CollisionPlane): LPlane {.importcpp: "#->get_plane()".}

proc `plane=`*(this: CollisionPlane, plane: LPlane) {.importcpp: "#->set_plane(#)".}

func valid*(this: CollisionPolygon): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the CollisionPolygon is valid (that is, it has at least
## three vertices), or false otherwise.

func concave*(this: CollisionPolygon): bool {.importcpp: "#->is_concave()".} ## \
## Returns true if the CollisionPolygon appears to be concave, or false if it
## is safely convex.

func center*(this: CollisionHandlerPhysical): NodePath {.importcpp: "#->get_center()".} ## \
## Returns the NodePath specified with set_center, or the empty NodePath if
## nothing has been specified.

proc `center=`*(this: CollisionHandlerPhysical, center: NodePath) {.importcpp: "#->set_center(#)".} ## \
## Specifies an arbitrary NodePath that the handler is always considered to be
## facing.  It does not detect collisions with surfaces that appear to be
## facing away from this NodePath.  This works best when the collision
## surfaces in question are polygons.

func offset*(this: CollisionHandlerFloor): float32 {.importcpp: "#->get_offset()".} ## \
## Returns the linear offset to add to (or subtract from) the highest detected
## collision point to determine the actual height at which to set the
## collider.

proc `offset=`*(this: CollisionHandlerFloor, offset: float32) {.importcpp: "#->set_offset(#)".} ## \
## Sets the linear offset to add to (or subtract from) the highest detected
## collision point to determine the actual height at which to set the
## collider.

func reach*(this: CollisionHandlerFloor): float32 {.importcpp: "#->get_reach()".} ## \
## Returns the reach to add to (or subtract from) the highest collision point

proc `reach=`*(this: CollisionHandlerFloor, reach: float32) {.importcpp: "#->set_reach(#)".} ## \
## Sets the reach to add to (or subtract from) the highest collision point

func max_velocity*(this: CollisionHandlerFloor): float32 {.importcpp: "#->get_max_velocity()".} ## \
## Retrieves the maximum speed at which the object will be allowed to descend
## towards a floor below it, in units per second.  See set_max_velocity().

proc `max_velocity=`*(this: CollisionHandlerFloor, max_vel: float32) {.importcpp: "#->set_max_velocity(#)".} ## \
## Sets the maximum speed at which the object will be allowed to descend
## towards a floor below it, in units per second.  Set this to zero to allow
## it to instantly teleport any distance.

func horizontal*(this: CollisionHandlerPusher): bool {.importcpp: "#->get_horizontal()".}

proc `horizontal=`*(this: CollisionHandlerPusher, flag: bool) {.importcpp: "#->set_horizontal(#)".}

func offset*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_offset()".} ## \
## Returns the linear offset to add to (or subtract from) the highest detected
## collision point to determine the actual height at which to set the
## collider.

proc `offset=`*(this: CollisionHandlerGravity, offset: float32) {.importcpp: "#->set_offset(#)".} ## \
## Sets the linear offset to add to (or subtract from) the highest detected
## collision point to determine the actual height at which to set the
## collider.

func reach*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_reach()".} ## \
## Returns the reach to add to (or subtract from) the highest collision point

proc `reach=`*(this: CollisionHandlerGravity, reach: float32) {.importcpp: "#->set_reach(#)".} ## \
## Sets the reach to add to (or subtract from) the highest collision point

func airborne_height*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_airborne_height()".} ## \
## Return the height of the object from the ground.
##
## The object might not necessarily be at rest.  Use is_on_ground() if you
## want to know whether the object is on the ground and at rest.

func on_ground*(this: CollisionHandlerGravity): bool {.importcpp: "#->is_on_ground()".} ## \
## Is the object at rest?

func impact_velocity*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_impact_velocity()".} ## \
## How hard did the object hit the ground.  This value is set on impact with
## the ground.  You may want to watch (poll) on is_on_ground() and when that is
## true, call get_impact_velocity(). Normally I avoid polling, but we are
## calling is_on_ground() frequently anyway.

func contact_normal*(this: CollisionHandlerGravity): LVector3 {.importcpp: "#->get_contact_normal()".}

func velocity*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_velocity()".} ## \
## Gets the current vertical velocity.
##
## Generally, negative values mean the object is in free fall; while postive
## values mean the object has vertical thrust.
##
## A zero value does not necessarily mean the object on the ground, it may
## also be weightless and/or at the apex of its jump.
##
## See Also: is_on_ground() and get_gravity()

proc `velocity=`*(this: CollisionHandlerGravity, velocity: float32) {.importcpp: "#->set_velocity(#)".} ## \
## Sets the current vertical velocity.

func gravity*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_gravity()".} ## \
## Gets the linear gravity force (always plumb).

proc `gravity=`*(this: CollisionHandlerGravity, gravity: float32) {.importcpp: "#->set_gravity(#)".} ## \
## Sets the linear gravity force (always plumb).

func max_velocity*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_max_velocity()".} ## \
## Retrieves the maximum speed at which the object will be allowed to descend
## towards a floor below it, in units per second.  See set_max_velocity().

proc `max_velocity=`*(this: CollisionHandlerGravity, max_vel: float32) {.importcpp: "#->set_max_velocity(#)".} ## \
## Sets the maximum speed at which the object will be allowed to descend
## towards a floor below it, in units per second.  Set this to zero to allow
## it to instantly teleport any distance.

func center*(this: CollisionSphere): LPoint3 {.importcpp: "#->get_center()".}

proc `center=`*(this: CollisionSphere, center: LPoint3) {.importcpp: "#->set_center(#)".}

proc `center=`*(this: CollisionSphere, x: float32, y: float32, z: float32) {.importcpp: "#->set_center(#, #, #)".}

func radius*(this: CollisionSphere): float32 {.importcpp: "#->get_radius()".}

proc `radius=`*(this: CollisionSphere, radius: float32) {.importcpp: "#->set_radius(#)".}

func origin*(this: CollisionRay): LPoint3 {.importcpp: "#->get_origin()".}

proc `origin=`*(this: CollisionRay, origin: LPoint3) {.importcpp: "#->set_origin(#)".}

proc `origin=`*(this: CollisionRay, x: float32, y: float32, z: float32) {.importcpp: "#->set_origin(#, #, #)".}

func direction*(this: CollisionRay): LVector3 {.importcpp: "#->get_direction()".}

proc `direction=`*(this: CollisionRay, direction: LVector3) {.importcpp: "#->set_direction(#)".}

proc `direction=`*(this: CollisionRay, x: float32, y: float32, z: float32) {.importcpp: "#->set_direction(#, #, #)".}

func parabola*(this: CollisionParabola): LParabola {.importcpp: "#->get_parabola()".} ## \
## Returns the parabola specified by this solid.

proc `parabola=`*(this: CollisionParabola, parabola: LParabola) {.importcpp: "#->set_parabola(#)".} ## \
## Replaces the parabola specified by this solid.

func t1*(this: CollisionParabola): float32 {.importcpp: "#->get_t1()".} ## \
## Returns the starting point on the parabola.

proc `t1=`*(this: CollisionParabola, t1: float32) {.importcpp: "#->set_t1(#)".} ## \
## Changes the starting point on the parabola.

func t2*(this: CollisionParabola): float32 {.importcpp: "#->get_t2()".} ## \
## Returns the ending point on the parabola.

proc `t2=`*(this: CollisionParabola, t2: float32) {.importcpp: "#->set_t2(#)".} ## \
## Changes the ending point on the parabola.

func point_a*(this: CollisionSegment): LPoint3 {.importcpp: "#->get_point_a()".}

proc `point_a=`*(this: CollisionSegment, a: LPoint3) {.importcpp: "#->set_point_a(#)".}

proc `point_a=`*(this: CollisionSegment, x: float32, y: float32, z: float32) {.importcpp: "#->set_point_a(#, #, #)".}

func point_b*(this: CollisionSegment): LPoint3 {.importcpp: "#->get_point_b()".}

proc `point_b=`*(this: CollisionSegment, b: LPoint3) {.importcpp: "#->set_point_b(#)".}

proc `point_b=`*(this: CollisionSegment, x: float32, y: float32, z: float32) {.importcpp: "#->set_point_b(#, #, #)".}

func point_scale*(this: CollisionVisualizer): float32 {.importcpp: "#->get_point_scale()".} ## \
## Returns the value last set by set_point_scale().

proc `point_scale=`*(this: CollisionVisualizer, point_scale: float32) {.importcpp: "#->set_point_scale(#)".} ## \
## Scales the points that are drawn to represent the surface and interior
## intersection points of the collisions.  By default, these objects are drawn
## at an arbitrary scale which is appropriate if the window units are the
## default range -1 .. 1.  Change this scale accordinatly if the window units
## are measured on some other scale or if you need to observe these objects in
## a smaller window.

func normal_scale*(this: CollisionVisualizer): float32 {.importcpp: "#->get_normal_scale()".} ## \
## Returns the value last set by set_normal_scale().

proc `normal_scale=`*(this: CollisionVisualizer, normal_scale: float32) {.importcpp: "#->set_normal_scale(#)".} ## \
## Scales the line segments that are drawn to represent the normals of the
## collisions.  By default, these objects are drawn at an arbitrary scale
## which is appropriate if the scene units are measured in feet.  Change this
## scale accordinatly if the scene units are measured on some other scale or
## if you need to observe these normals from farther away.

func display_width*(this: GraphicsPipe): int {.importcpp: "#->get_display_width()".} ## \
## Returns the width of the entire display, if it is known.  This may return
## 0.  This is not a guarantee that windows (particularly fullscreen windows)
## may not be created larger than this width, but it is intended to provide a
## hint to the application.

func display_height*(this: GraphicsPipe): int {.importcpp: "#->get_display_height()".} ## \
## Returns the height of the entire display, if it is known.  This may return
## 0.  See the caveats for get_display_width().

func display_zoom*(this: GraphicsPipe): float32 {.importcpp: "#->get_display_zoom()".} ## \
## Returns the display zoom factor configured in the operating system.  If the
## operating system automatically scales windows to match the DPI (such as when
## dpi-aware is set to false), this will be 1.0.  Otherwise, this will be set to
## a value approximating the density of the monitor divided by the standard
## density of the operating system (usually 96), yielding a value like 1.5 or
## 2.0.
##
## @since 1.10.8

func display_information*(this: GraphicsPipe): DisplayInformation {.importcpp: "#->get_display_information()".} ## \
## Gets the pipe's DisplayInformation.

func interface_name*(this: GraphicsPipe): string {.importcpp: "nimStringFromStdString(#->get_interface_name())", header: stringConversionCode.}

func clear_color*(this: DrawableRegion): LColor {.importcpp: "#.get_clear_color()".} ## \
## Returns the current clear color value.  This is the value that will be used
## to clear the color buffer every frame, but only if get_clear_color_active()
## returns true.  If get_clear_color_active() returns false, this is
## meaningless.

proc `clear_color=`*(this: DrawableRegion, color: LColor) {.importcpp: "#.set_clear_color(#)".} ## \
## Sets the clear color to the indicated value.  This is the value that will
## be used to clear the color buffer every frame, but only if
## get_clear_color_active() returns true.  If get_clear_color_active() returns
## false, this is meaningless.

func clear_depth*(this: DrawableRegion): float32 {.importcpp: "#.get_clear_depth()".} ## \
## Returns the current clear depth value.  This is the value that will be used
## to clear the depth buffer every frame, but only if get_clear_depth_active()
## returns true.  If get_clear_depth_active() returns false, this is
## meaningless.

proc `clear_depth=`*(this: DrawableRegion, depth: float32) {.importcpp: "#.set_clear_depth(#)".} ## \
## Sets the clear depth to the indicated value.  This is the value that will
## be used to clear the depth buffer every frame, but only if
## get_clear_depth_active() returns true.  If get_clear_depth_active() returns
## false, this is meaningless.

func clear_stencil*(this: DrawableRegion): int {.importcpp: "#.get_clear_stencil()".} ## \
## Returns the current clear stencil value.  This is the value that will be
## used to clear the stencil buffer every frame, but only if
## get_clear_stencil_active() returns true.  If get_clear_stencil_active()
## returns false, this is meaningless.

proc `clear_stencil=`*(this: DrawableRegion, stencil: int) {.importcpp: "#.set_clear_stencil(#)".}

func pixel_zoom*(this: DrawableRegion): float32 {.importcpp: "#.get_pixel_zoom()".} ## \
## Returns the value set by set_pixel_zoom(), regardless of whether it is
## being respected or not.  Also see get_pixel_factor().

proc `pixel_zoom=`*(this: DrawableRegion, pixel_zoom: float32) {.importcpp: "#.set_pixel_zoom(#)".} ## \
## Sets the amount by which the pixels of the region are scaled internally
## when filling the image interally.  Setting this number larger makes the
## pixels blockier, but may make the rendering faster, particularly for
## software renderers.  Setting this number to 2.0 reduces the number of
## pixels that have to be filled by the renderer by a factor of 2.0.  It
## doesn't make sense to set this lower than 1.0.
##
## It is possible to set this on either individual DisplayRegions or on
## overall GraphicsWindows, but you will get better performance for setting it
## on the window rather than its individual DisplayRegions.  Also, you may not
## set it on a DisplayRegion that doesn't have both clear_color() and
## clear_depth() enabled.
##
## This property is only supported on renderers for which it is particularly
## useful--currently, this is the tinydisplay software renderer.  Other kinds
## of renderers allow you to set this property, but ignore it.

func pixel_factor*(this: DrawableRegion): float32 {.importcpp: "#.get_pixel_factor()".} ## \
## Returns the amount by which the height and width of the region will be
## scaled internally, based on the zoom factor set by set_pixel_zoom().  This
## will return 1.0 if the pixel_zoom was not set or if it is not being
## respected (for instance, because the underlying renderer doesn't support it
## --see supports_pixel_zoom).

func config_properties*(_: typedesc[WindowProperties]): WindowProperties {.importcpp: "WindowProperties::get_config_properties()", header: "windowProperties.h".} ## \
## Returns a WindowProperties structure with all of the default values filled
## in according to the user's config file.

func default*(_: typedesc[WindowProperties]): WindowProperties {.importcpp: "WindowProperties::get_default()", header: "windowProperties.h".} ## \
## Returns the "default" WindowProperties.  If set_default() has been called,
## this returns that WindowProperties structure; otherwise, this returns
## get_config_properties().

proc `default=`*(_: typedesc[WindowProperties], default_properties: WindowProperties) {.importcpp: "WindowProperties::set_default(#)", header: "windowProperties.h".} ## \
## Replaces the "default" WindowProperties with the specified structure.  The
## specified WindowProperties will be returned by future calls to
## get_default(), until clear_default() is called.
##
## Note that this completely replaces the default properties; it is not
## additive.

func origin*(this: WindowProperties): LPoint2i {.importcpp: "#.get_origin()".} ## \
## Returns the coordinates of the window's top-left corner, not including
## decorations.

proc `origin=`*(this: WindowProperties, origin: LPoint2i) {.importcpp: "#.set_origin(#)".} ## \
## Specifies the origin on the screen (in pixels, relative to the top-left
## corner) at which the window should appear.  This is the origin of the top-
## left corner of the useful part of the window, not including decorations.

proc `origin=`*(this: WindowProperties, x_origin: int, y_origin: int) {.importcpp: "#.set_origin(#, #)".} ## \
## Specifies the origin on the screen (in pixels, relative to the top-left
## corner) at which the window should appear.  This is the origin of the top-
## left corner of the useful part of the window, not including decorations.

func size*(this: WindowProperties): LVector2i {.importcpp: "#.get_size()".} ## \
## Returns size in pixels of the useful part of the window, not including
## decorations.

proc `size=`*(this: WindowProperties, size: LVector2i) {.importcpp: "#.set_size(#)".} ## \
## Specifies the requested size of the window, in pixels.  This is the size of
## the useful part of the window, not including decorations.

proc `size=`*(this: WindowProperties, x_size: int, y_size: int) {.importcpp: "#.set_size(#, #)".} ## \
## Specifies the requested size of the window, in pixels.  This is the size of
## the useful part of the window, not including decorations.

func title*(this: WindowProperties): string {.importcpp: "nimStringFromStdString(#.get_title())", header: stringConversionCode.} ## \
## Returns the window's title.

proc `title=`*(this: WindowProperties, title: string) {.importcpp: "#.set_title(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the title that should be assigned to the window.

func undecorated*(this: WindowProperties): bool {.importcpp: "#.get_undecorated()".} ## \
## Returns true if the window has no border.

proc `undecorated=`*(this: WindowProperties, undecorated: bool) {.importcpp: "#.set_undecorated(#)".} ## \
## Specifies whether the window should be created with a visible title and
## border (false, the default) or not (true).

func fixed_size*(this: WindowProperties): bool {.importcpp: "#.get_fixed_size()".} ## \
## Returns true if the window cannot be resized by the user, false otherwise.

proc `fixed_size=`*(this: WindowProperties, fixed_size: bool) {.importcpp: "#.set_fixed_size(#)".} ## \
## Specifies whether the window should be resizable by the user.

func fullscreen*(this: WindowProperties): bool {.importcpp: "#.get_fullscreen()".} ## \
## Returns true if the window is in fullscreen mode.

proc `fullscreen=`*(this: WindowProperties, fullscreen: bool) {.importcpp: "#.set_fullscreen(#)".} ## \
## Specifies whether the window should be opened in fullscreen mode (true) or
## normal windowed mode (false, the default).

func foreground*(this: WindowProperties): bool {.importcpp: "#.get_foreground()".} ## \
## Returns true if the window is in the foreground.

proc `foreground=`*(this: WindowProperties, foreground: bool) {.importcpp: "#.set_foreground(#)".} ## \
## Specifies whether the window should be opened in the foreground (true), or
## left in the background (false).

func minimized*(this: WindowProperties): bool {.importcpp: "#.get_minimized()".} ## \
## Returns true if the window is minimized.

proc `minimized=`*(this: WindowProperties, minimized: bool) {.importcpp: "#.set_minimized(#)".} ## \
## Specifies whether the window should be created minimized (true), or normal
## (false).

func open*(this: WindowProperties): bool {.importcpp: "#.get_open()".} ## \
## Returns true if the window is open.

proc `open=`*(this: WindowProperties, open: bool) {.importcpp: "#.set_open(#)".} ## \
## Specifies whether the window should be open.  It is legal to create a
## GraphicsWindow in the closed state, and later request it to open by
## changing this flag.

func cursor_hidden*(this: WindowProperties): bool {.importcpp: "#.get_cursor_hidden()".} ## \
## Returns true if the mouse cursor is invisible.

proc `cursor_hidden=`*(this: WindowProperties, cursor_hidden: bool) {.importcpp: "#.set_cursor_hidden(#)".} ## \
## Specifies whether the mouse cursor should be visible.

func icon_filename*(this: WindowProperties): Filename {.importcpp: "#.get_icon_filename()".} ## \
## Returns the icon filename associated with the window.

proc `icon_filename=`*(this: WindowProperties, icon_filename: Filename) {.importcpp: "#.set_icon_filename(#)".} ## \
## Specifies the file that contains the icon to associate with the window when
## it is minimized.

func cursor_filename*(this: WindowProperties): Filename {.importcpp: "#.get_cursor_filename()".} ## \
## Returns the icon filename associated with the mouse cursor.

proc `cursor_filename=`*(this: WindowProperties, cursor_filename: Filename) {.importcpp: "#.set_cursor_filename(#)".} ## \
## Specifies the file that contains the icon to associate with the mouse
## cursor when it is within the window (and visible).

func parent_window*(this: WindowProperties): WindowHandle {.importcpp: "#.get_parent_window()".} ## \
## Returns the parent window specification, or NULL if there is no parent
## window specified.

proc `parent_window=`*(this: WindowProperties, parent_window: WindowHandle) {.importcpp: "#.set_parent_window(#)".} ## \
## Specifies the window that this window should be attached to.  If this is
## NULL or unspecified, the window will be created as a toplevel window on the
## desktop; if this is non-NULL, the window will be bound as a child window to
## the indicated parent window.
##
## You should use GraphicsPipe::make_window_handle() to create an instance of
## a WindowHandle object given an appropriate OS-specific window handle
## representation.  Each OS-specific GraphicsPipe class defines a
## make_window_handle() method that returns an appropriate WindowHandle object
## to wrap the particular OS-specific representation.

proc `parent_window=`*(this: WindowProperties) {.importcpp: "#.set_parent_window()".} ## \
## Specifies the window that this window should be attached to.  If this is
## NULL or unspecified, the window will be created as a toplevel window on the
## desktop; if this is non-NULL, the window will be bound as a child window to
## the indicated parent window.
##
## You should use GraphicsPipe::make_window_handle() to create an instance of
## a WindowHandle object given an appropriate OS-specific window handle
## representation.  Each OS-specific GraphicsPipe class defines a
## make_window_handle() method that returns an appropriate WindowHandle object
## to wrap the particular OS-specific representation.

proc `parent_window=`*(this: WindowProperties, parent: clonglong) {.importcpp: "#.set_parent_window(#)".} ## \
## Specifies the window that this window should be attached to.
##
## This is a deprecated variant on this method, and exists only for backward
## compatibility.  Future code should use the version of set_parent_window()
## below that receives a WindowHandle object; that interface is much more
## robust.
##
## In this deprecated variant, the actual value for "parent" is platform-
## specific.  On Windows, it is the HWND of the parent window, cast to an
## unsigned integer.  On X11, it is the Window pointer of the parent window,
## similarly cast.  On OSX, this is the NSWindow pointer, which doesn't appear
## to work at all.

func dimensions*(this: DisplayRegion, i: int): LVecBase4 {.importcpp: "#->get_dimensions(#)".} ## \
## Retrieves the coordinates of the DisplayRegion's rectangle within its
## GraphicsOutput.  These numbers will be in the range [0..1].

func dimensions*(this: DisplayRegion): LVecBase4 {.importcpp: "#->get_dimensions()".} ## \
## Retrieves the coordinates of the DisplayRegion's rectangle within its
## GraphicsOutput.  These numbers will be in the range [0..1].

proc `dimensions=`*(this: DisplayRegion, dimensions: LVecBase4) {.importcpp: "#->set_dimensions(#)".} ## \
## Changes the portion of the framebuffer this DisplayRegion corresponds to.
## The parameters range from 0 to 1, where 0,0 is the lower left corner and
## 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.

proc `dimensions=`*(this: DisplayRegion, l: float32, r: float32, b: float32, t: float32) {.importcpp: "#->set_dimensions(#, #, #, #)".} ## \
## Changes the portion of the framebuffer this DisplayRegion corresponds to.
## The parameters range from 0 to 1, where 0,0 is the lower left corner and
## 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.

proc `dimensions=`*(this: DisplayRegion, i: int, dimensions: LVecBase4) {.importcpp: "#->set_dimensions(#, #)".} ## \
## Changes the portion of the framebuffer this DisplayRegion corresponds to.
## The parameters range from 0 to 1, where 0,0 is the lower left corner and
## 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc `dimensions=`*(this: DisplayRegion, i: int, l: float32, r: float32, b: float32, t: float32) {.importcpp: "#->set_dimensions(#, #, #, #, #)".} ## \
## Changes the portion of the framebuffer this DisplayRegion corresponds to.
## The parameters range from 0 to 1, where 0,0 is the lower left corner and
## 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.

func window*(this: DisplayRegion): GraphicsOutput {.importcpp: "#->get_window()".} ## \
## Returns the GraphicsOutput that this DisplayRegion is ultimately associated
## with, or NULL if no window is associated.

func pipe*(this: DisplayRegion): GraphicsPipe {.importcpp: "#->get_pipe()".} ## \
## Returns the GraphicsPipe that this DisplayRegion is ultimately associated
## with, or NULL if no pipe is associated.

func stereo*(this: DisplayRegion): bool {.importcpp: "#->is_stereo()".} ## \
## Returns true if this is a StereoDisplayRegion, false otherwise.

func camera*(this: DisplayRegion, current_thread: Thread): NodePath {.importcpp: "#->get_camera(#)".} ## \
## Returns the camera associated with this DisplayRegion, or an empty NodePath
## if no camera is associated.

func camera*(this: DisplayRegion): NodePath {.importcpp: "#->get_camera()".} ## \
## Returns the camera associated with this DisplayRegion, or an empty NodePath
## if no camera is associated.

proc `camera=`*(this: DisplayRegion, camera: NodePath) {.importcpp: "#->set_camera(#)".} ## \
## Sets the camera that is associated with this DisplayRegion.  There is a
## one-to-many association between cameras and DisplayRegions; one camera may
## be shared by multiple DisplayRegions.
##
## The camera is actually set via a NodePath, which clarifies which instance
## of the camera (if there happen to be multiple instances) we should use.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

func active*(this: DisplayRegion): bool {.importcpp: "#->is_active()".} ## \
## Returns the active flag associated with the DisplayRegion.

proc `active=`*(this: DisplayRegion, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets the active flag associated with the DisplayRegion.  If the
## DisplayRegion is marked inactive, nothing is rendered.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

func sort*(this: DisplayRegion): int {.importcpp: "#->get_sort()".} ## \
## Returns the sort value associated with the DisplayRegion.

proc `sort=`*(this: DisplayRegion, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Sets the sort value associated with the DisplayRegion.  Within a window,
## DisplayRegions will be rendered in order from the lowest sort value to the
## highest.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

func tex_view_offset*(this: DisplayRegion): int {.importcpp: "#->get_tex_view_offset()".} ## \
## Returns the current texture view offset for this DisplayRegion.  This is
## normally set to zero.  If nonzero, it is used to select a particular view
## of any multiview textures that are rendered within this DisplayRegion.
##
## For a StereoDisplayRegion, this is normally 0 for the left eye, and 1 for
## the right eye, to support stereo textures.

proc `tex_view_offset=`*(this: DisplayRegion, tex_view_offset: int) {.importcpp: "#->set_tex_view_offset(#)".} ## \
## Sets the current texture view offset for this DisplayRegion.  This is
## normally set to zero.  If nonzero, it is used to select a particular view
## of any multiview textures that are rendered within this DisplayRegion.
##
## For a StereoDisplayRegion, this is normally 0 for the left eye, and 1 for
## the right eye, to support stereo textures.  This is set automatically when
## you call set_stereo_channel().

func incomplete_render*(this: DisplayRegion): bool {.importcpp: "#->get_incomplete_render()".} ## \
## Returns the incomplete_render flag.  See set_incomplete_render().

proc `incomplete_render=`*(this: DisplayRegion, incomplete_render: bool) {.importcpp: "#->set_incomplete_render(#)".} ## \
## Sets the incomplete_render flag.  When this is true, the frame will be
## rendered even if some of the geometry or textures in the scene are not
## available (e.g.  they have been temporarily paged out).  When this is
## false, the frame will be held up while this data is reloaded.
##
## This flag may also be set on the GraphicsStateGuardian.  It will be
## considered true for a given DisplayRegion only if it is true on both the
## GSG and on the DisplayRegion.
##
## See GraphicsStateGuardian::set_incomplete_render() for more detail.

func texture_reload_priority*(this: DisplayRegion): int {.importcpp: "#->get_texture_reload_priority()".} ## \
## Returns the priority which is assigned to asynchronous texture reload
## requests.  See set_texture_reload_priority().

proc `texture_reload_priority=`*(this: DisplayRegion, texture_reload_priority: int) {.importcpp: "#->set_texture_reload_priority(#)".} ## \
## Specifies an integer priority which is assigned to any asynchronous texture
## reload requests spawned while processing this DisplayRegion.  This controls
## which textures are loaded first when multiple textures need to be reloaded
## at once; it also controls the relative priority between asynchronous
## texture loads and asynchronous model or animation loads.
##
## Specifying a larger number here makes the textures rendered by this
## DisplayRegion load up first.  This may be particularly useful to do, for
## instance, for the DisplayRegion that renders the gui.

func lens_index*(this: DisplayRegion): int {.importcpp: "#->get_lens_index()".} ## \
## Returns the specific lens of the associated Camera that will be used for
## rendering this scene.  Most Cameras hold only one lens, but for multiple
## lenses this method may be used to selected between them.

proc `lens_index=`*(this: DisplayRegion, index: int) {.importcpp: "#->set_lens_index(#)".} ## \
## Sets the lens index, allows for multiple lenses to be attached to a camera.
## This is useful for a variety of setups, such as fish eye rendering.  The
## default is 0.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

func cull_traverser*(this: DisplayRegion): CullTraverser {.importcpp: "#->get_cull_traverser()".} ## \
## Returns the CullTraverser that will be used to draw the contents of this
## DisplayRegion.

proc `cull_traverser=`*(this: DisplayRegion, trav: CullTraverser) {.importcpp: "#->set_cull_traverser(#)".} ## \
## Specifies the CullTraverser that will be used to draw the contents of this
## DisplayRegion.  Normally the default CullTraverser is sufficient, but this
## may be changed to change the default cull behavior.

func target_tex_page*(this: DisplayRegion): int {.importcpp: "#->get_target_tex_page()".} ## \
## Returns the target page number associated with this particular
## DisplayRegion, or -1 if it is not associated with a page.  See
## set_target_tex_page().

proc `target_tex_page=`*(this: DisplayRegion, page: int) {.importcpp: "#->set_target_tex_page(#)".} ## \
## This is a special parameter that is only used when rendering the faces of a
## cube map or multipage and/or multiview texture.
##
## This sets up the DisplayRegion to render to the ith page and jth view of
## its associated texture(s); the value must be consistent with the range of
## values availble to the texture.  A normal DisplayRegion that is not
## associated with any particular page should be set to page -1 and view 0.
##
## This is particularly useful when rendering cube maps and/or stereo
## textures.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

func scissor_enabled*(this: DisplayRegion): bool {.importcpp: "#->get_scissor_enabled()".} ## \
## Returns whether or not scissor testing is enabled for this region.  The
## default is true, except for the overlay display region.

proc `scissor_enabled=`*(this: DisplayRegion, scissor_enabled: bool) {.importcpp: "#->set_scissor_enabled(#)".} ## \
## Sets whether or not scissor testing is enabled for this region.  The
## default is true, except for the overlay display region.

func cull_callback*(this: DisplayRegion): CallbackObject {.importcpp: "#->get_cull_callback()".} ## \
## Returns the CallbackObject set by set_cull_callback().

proc `cull_callback=`*(this: DisplayRegion, `object`: CallbackObject) {.importcpp: "#->set_cull_callback(#)".} ## \
## Sets the CallbackObject that will be notified when the DisplayRegion is
## visited during the cull traversal.  This callback will be made during the
## cull thread.
##
## The cull traversal is responsible for determining which nodes are visible
## and within the view frustum, and for accumulating state and transform, and
## generally building up the list of CullableObjects that are to be eventually
## passed to the draw traversal for rendering.
##
## At the time the cull traversal callback is made, the traversal for this
## DisplayRegion has not yet started.
##
## The callback is passed an instance of a DisplayRegionCullCallbackData,
## which contains pointers to the current scene information, as well as the
## current DisplayRegion and GSG.  The callback *replaces* the normal cull
## behavior, so if your callback does nothing, the scene graph will not be
## traversed and therefore nothing will be drawn.  If you wish the normal cull
## traversal to be performed for this DisplayRegion, you must call
## cbdata->upcall() from your callback.

func draw_callback*(this: DisplayRegion): CallbackObject {.importcpp: "#->get_draw_callback()".} ## \
## Returns the CallbackObject set by set_draw_callback().

proc `draw_callback=`*(this: DisplayRegion, `object`: CallbackObject) {.importcpp: "#->set_draw_callback(#)".} ## \
## Sets the CallbackObject that will be notified when the contents of
## DisplayRegion is drawn during the draw traversal.  This callback will be
## made during the draw thread.
##
## The draw traversal is responsible for actually issuing the commands to the
## graphics engine to draw primitives.  Its job is to walk through the list of
## CullableObjects build up by the cull traversal, as quickly as possible,
## issuing the appropriate commands to draw each one.
##
## At the time the draw traversal callback is made, the graphics state is in
## the initial state, and no projection matrix or modelview matrix is in
## effect.  begin_scene() has not yet been called, and no objects have yet
## been drawn.  However, the viewport has already been set to the appropriate
## part of the window, and the clear commands for this DisplayRegion (if any)
## have been issued.
##
## The callback is passed an instance of a DisplayRegionDrawCallbackData,
## which contains pointers to the current scene information, as well as the
## current DisplayRegion and GSG.  The callback *replaces* the normal draw
## behavior, so if your callback does nothing, nothing in the DisplayRegion
## will be drawn.  If you wish the draw traversal to continue to draw the
## contents of this DisplayRegion, you must call cbdata->upcall() from your
## callback.

func pixel_size*(this: DisplayRegion, i: int): LVecBase2i {.importcpp: "#->get_pixel_size(#)".} ## \
## Returns the size of the DisplayRegion in pixels.

func pixel_size*(this: DisplayRegion): LVecBase2i {.importcpp: "#->get_pixel_size()".} ## \
## Returns the size of the DisplayRegion in pixels.

func gsg*(this: GraphicsOutput): GraphicsStateGuardian {.importcpp: "#->get_gsg()".} ## \
## Returns the GSG that is associated with this window.  There is a one-to-one
## association between windows and GSG's.
##
## This may return NULL if the graphics context has not yet been created for
## the window, e.g.  before the first frame has rendered; or after the window
## has been closed.

func pipe*(this: GraphicsOutput): GraphicsPipe {.importcpp: "#->get_pipe()".} ## \
## Returns the GraphicsPipe that this window is associated with.  It is
## possible that the GraphicsPipe might have been deleted while an outstanding
## PT(GraphicsOutput) prevented all of its children windows from also being
## deleted; in this unlikely case, get_pipe() may return NULL.

func engine*(this: GraphicsOutput): GraphicsEngine {.importcpp: "#->get_engine()".} ## \
## Returns the graphics engine that created this output.  Since there is
## normally only one GraphicsEngine object in an application, this is usually
## the same as the global GraphicsEngine.

func name*(this: GraphicsOutput): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the name that was passed to the GraphicsOutput constructor.

func size*(this: GraphicsOutput): LVecBase2i {.importcpp: "#->get_size()".} ## \
## Returns the visible size of the window or buffer, if it is known.  In
## certain cases (e.g.  fullscreen windows), the size may not be known until
## after the object has been fully created.  Check has_size() first.
##
## Certain objects (like windows) may change size spontaneously; this method
## is not thread-safe.  To get the size of a window in a thread-safe manner,
## query get_properties().

func fb_size*(this: GraphicsOutput): LVecBase2i {.importcpp: "#->get_fb_size()".} ## \
## Returns the internal size of the window or buffer.  This is almost always
## the same as get_size(), except when a pixel_zoom is in effect--see
## set_pixel_zoom().

func sbs_left_size*(this: GraphicsOutput): LVecBase2i {.importcpp: "#->get_sbs_left_size()".} ## \
## If side-by-side stereo is enabled, this returns the pixel size of the left
## eye, based on scaling get_size() by get_sbs_left_dimensions().  If side-by-
## side stereo is not enabled, this returns the same as get_size().

func sbs_right_size*(this: GraphicsOutput): LVecBase2i {.importcpp: "#->get_sbs_right_size()".} ## \
## If side-by-side stereo is enabled, this returns the pixel size of the right
## eye, based on scaling get_size() by get_sbs_right_dimensions().  If side-
## by-side stereo is not enabled, this returns the same as get_size().

func active*(this: GraphicsOutput): bool {.importcpp: "#->is_active()".} ## \
## Returns true if the window is ready to be rendered into, false otherwise.

proc `active=`*(this: GraphicsOutput, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets the active flag associated with the GraphicsOutput.  If the
## GraphicsOutput is marked inactive, nothing is rendered.

func one_shot*(this: GraphicsOutput): bool {.importcpp: "#->get_one_shot()".} ## \
## Returns the current setting of the one-shot flag.  When this is true, the
## GraphicsOutput will automatically set itself inactive after the next frame.

proc `one_shot=`*(this: GraphicsOutput, one_shot: bool) {.importcpp: "#->set_one_shot(#)".} ## \
## Changes the current setting of the one-shot flag.  When this is true, the
## GraphicsOutput will render the current frame and then automatically set
## itself inactive.  This is particularly useful for buffers that are created
## for the purposes of render-to-texture, for static textures that don't need
## to be continually re-rendered once they have been rendered the first time.
##
## Setting the buffer inactive is not the same thing as destroying it.  You
## are still responsible for passing this buffer to
## GraphicsEngine::remove_window() when you no longer need the texture, in
## order to clean up fully.  (However, you should not call remove_window() on
## this buffer while the texture is still needed, because depending on the
## render-to-texture mechanism in use, this may invalidate the texture
## contents.)

func inverted*(this: GraphicsOutput): bool {.importcpp: "#->get_inverted()".} ## \
## Returns the current setting of the inverted flag.  When this is true, the
## scene is rendered into the window upside-down, flipped like a mirror along
## the X axis.  See set_inverted().

proc `inverted=`*(this: GraphicsOutput, inverted: bool) {.importcpp: "#->set_inverted(#)".} ## \
## Changes the current setting of the inverted flag.  When this is true, the
## scene is rendered into the window upside-down and backwards, that is,
## inverted as if viewed through a mirror placed on the floor.
##
## This is primarily intended to support DirectX (and a few buggy OpenGL
## graphics drivers) that perform a framebuffer-to-texture copy upside-down
## from the usual OpenGL (and Panda) convention.  Panda will automatically set
## this flag for offscreen buffers on hardware that is known to do this, to
## compensate when rendering offscreen into a texture.

func swap_eyes*(this: GraphicsOutput): bool {.importcpp: "#->get_swap_eyes()".} ## \
## Returns the current setting of the "swap eyes" flag.  See set_swap_eyes().

proc `swap_eyes=`*(this: GraphicsOutput, swap_eyes: bool) {.importcpp: "#->set_swap_eyes(#)".} ## \
## Changes the "swap eyes" flag.  This flag is normally false.  When it is
## true, the left and right channels of a stereo DisplayRegion are sent to the
## opposite channels in the rendering backend.  This is meant to work around
## hardware that inadvertently swaps the output channels, or hardware for
## which it cannot be determined which channel is which until runtime.

func sort*(this: GraphicsOutput): int {.importcpp: "#->get_sort()".} ## \
## Returns the sorting order of this particular GraphicsOutput.  The various
## GraphicsOutputs within a particular thread will be rendered in the
## indicated order.

proc `sort=`*(this: GraphicsOutput, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Adjusts the sorting order of this particular GraphicsOutput, relative to
## other GraphicsOutputs.

func child_sort*(this: GraphicsOutput): int {.importcpp: "#->get_child_sort()".} ## \
## Returns the sort value of future offscreen buffers created by
## make_texture_sort(). See set_child_sort().

proc `child_sort=`*(this: GraphicsOutput, child_sort: int) {.importcpp: "#->set_child_sort(#)".} ## \
## Specifies the sort value of future offscreen buffers created by
## make_texture_sort().
##
## The purpose of this method is to allow the user to limit the sort value
## chosen for a buffer created via make_texture_buffer().  Normally, this
## buffer will be assigned a value of get_sort() - 1, so that it will be
## rendered before this window is rendered; but sometimes this isn't
## sufficiently early, especially if other buffers also have a view into the
## same scene.
##
## If you specify a value here, then new buffers created via
## make_texture_buffer() will be given that sort value instead of get_sort() -
## 1.

func supports_render_texture*(this: GraphicsOutput): bool {.importcpp: "#->get_supports_render_texture()".} ## \
## Returns true if this particular GraphicsOutput can render directly into a
## texture, or false if it must always copy-to-texture at the end of each
## frame to achieve this effect.

func active*(this: GraphicsStateGuardian): bool {.importcpp: "#->is_active()".} ## \
## Returns the active flag associated with the GraphicsStateGuardian.

proc `active=`*(this: GraphicsStateGuardian, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets the active flag associated with the GraphicsStateGuardian.  If the
## GraphicsStateGuardian is marked inactive, nothing is rendered.  This is not
## normally turned off unless there is a problem with the rendering detected
## at a low level.

func valid*(this: GraphicsStateGuardian): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the GSG has been correctly initialized within a graphics
## context, false if there has been some problem or it hasn't been initialized
## yet.

proc `incomplete_render=`*(this: GraphicsStateGuardian, incomplete_render: bool) {.importcpp: "#->set_incomplete_render(#)".} ## \
## Sets the incomplete_render flag.  When this is true, the frame will be
## rendered even if some of the geometry or textures in the scene are not
## available (e.g.  they have been temporarily paged out).  When this is
## false, the frame will be held up while this data is reloaded.
##
## Setting this true allows for a smoother frame rate, but occasionally parts
## of the frame will be invisible or missing (they will generally come in
## within a second or two).  Setting this false guarantees that every frame
## will be complete, but may cause more chugs as things are loaded up at
## runtime.
##
## You may want to set this false during loading screens, to guarantee that
## all of your assets are available by the time you take the loading screen
## down.
##
## This flag may also be set individually on each DisplayRegion.  It will be
## considered true for a given DisplayRegion only if it is true on both the
## GSG and on the DisplayRegion.

func loader*(this: GraphicsStateGuardian): Loader {.importcpp: "#->get_loader()".} ## \
## Returns the Loader object that will be used by this GSG to load textures
## when necessary, if get_incomplete_render() is true.

proc `loader=`*(this: GraphicsStateGuardian, loader: Loader) {.importcpp: "#->set_loader(#)".} ## \
## Sets the Loader object that will be used by this GSG to load textures when
## necessary, if get_incomplete_render() is true.

func shader_generator*(this: GraphicsStateGuardian): ShaderGenerator {.importcpp: "#->get_shader_generator()".} ## \
## Returns the ShaderGenerator object that will be used by this GSG to
## generate shaders when necessary.

proc `shader_generator=`*(this: GraphicsStateGuardian, shader_generator: ShaderGenerator) {.importcpp: "#->set_shader_generator(#)".} ## \
## Sets the ShaderGenerator object that will be used by this GSG to generate
## shaders when necessary.

func pipe*(this: GraphicsStateGuardian): GraphicsPipe {.importcpp: "#->get_pipe()".} ## \
## Returns the graphics pipe on which this GSG was created.

func max_texture_stages*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_texture_stages()".} ## \
## Returns the maximum number of simultaneous textures that may be applied to
## geometry with multitexturing, as supported by this particular GSG.  If you
## exceed this number, the lowest-priority texture stages will not be applied.
## Use TextureStage::set_priority() to adjust the relative importance of the
## different texture stages.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func max_3d_texture_dimension*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_3d_texture_dimension()".} ## \
## Returns the largest possible texture size in any one dimension for a 3-d
## texture, or -1 if there is no particular limit.  Returns 0 if 3-d textures
## are not supported.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func max_2d_texture_array_layers*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_2d_texture_array_layers()".} ## \
## Returns the largest possible number of pages, or -1 if there is no
## particular limit.  Returns 0 if 2-d texture arrays not supported.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func max_cube_map_dimension*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_cube_map_dimension()".} ## \
## Returns the largest possible texture size in any one dimension for a cube
## map texture, or -1 if there is no particular limit.  Returns 0 if cube map
## textures are not supported.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func max_buffer_texture_size*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_buffer_texture_size()".} ## \
## Returns the largest possible buffer texture size, or -1 if there is no
## particular limit.  Returns 0 if cube map textures are not supported.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func supports_texture_combine*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_texture_combine()".} ## \
## Returns true if this particular GSG can use the TextureStage::M_combine
## mode, which includes all of the texture blend modes specified by
## set_combine_rgb() and/or set_combine_alpha().  If this is false, you must
## limit yourself to using the simpler blend modes.

func supports_texture_saved_result*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_texture_saved_result()".} ## \
## Returns true if this GSG can use the TextureStage::CS_last_saved_result
## source, which allows you to save the result of a TextureStage and re-use it
## for multiple inputs.

func supports_texture_dot3*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_texture_dot3()".} ## \
## Returns true if this GSG can use the TextureStage::CM_dot3_rgb or
## CM_dot3_rgba combine modes.

func supports_3d_texture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_3d_texture()".} ## \
## Returns true if this GSG can render 3-d (volumetric) textures.

func supports_2d_texture_array*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_2d_texture_array()".} ## \
## Returns true if this GSG can render 2-d textures array.

func supports_cube_map*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_cube_map()".} ## \
## Returns true if this GSG can render cube map textures.

func supports_buffer_texture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_buffer_texture()".} ## \
## Returns true if this GSG can render buffer textures.

func supports_cube_map_array*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_cube_map_array()".} ## \
## Returns true if this GSG can render cube map arrays.

func supports_tex_non_pow2*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_tex_non_pow2()".} ## \
## Returns true if this GSG can handle non power of two sized textures.

func supports_compressed_texture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_compressed_texture()".} ## \
## Returns true if this GSG can compress textures as it loads them into
## texture memory, and/or accept pre-compressed textures for storing.

func max_lights*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_lights()".} ## \
## Returns the maximum number of simultaneous lights that may be rendered on
## geometry, or -1 if there is no particular limit.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func max_clip_planes*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_clip_planes()".} ## \
## Returns the maximum number of simultaneous clip planes that may be applied
## to geometry, or -1 if there is no particular limit.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func max_vertex_transforms*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_vertex_transforms()".} ## \
## Returns the maximum number of transform matrices that may be simultaneously
## used to transform any one vertex by the graphics hardware.  If this number
## is 0, then the hardware (or the graphics backend) doesn't support soft-
## skinned vertices (in which case Panda will animate the vertices in
## software).
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func max_vertex_transform_indices*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_vertex_transform_indices()".} ## \
## Returns the maximum number of transforms there may be in a single
## TransformTable for this graphics hardware.  If this number is 0 (but
## get_max_transforms() is nonzero), then the graphics hardware (or API)
## doesn't support indexed transforms, but can support direct transform
## references.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func copy_texture_inverted*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_copy_texture_inverted()".} ## \
## Returns true if this particular GSG has the property that any framebuffer-
## to-texture copy results in a texture that is upside-down and backwards from
## Panda's usual convention; that is, it copies into a texture from the bottom
## up instead of from the top down.
##
## If this is true, then on offscreen GraphicsBuffer created for the purposes
## of rendering into a texture should be created with the invert flag set
## true, to compensate.  Panda will do this automatically if you create an
## offscreen buffer using GraphicsOutput::make_texture_buffer().

func supports_generate_mipmap*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_generate_mipmap()".} ## \
## Returns true if this particular GSG can generate mipmaps for a texture
## automatically, or if they must be generated in software.  If this is true,
## then mipmaps can safely be enabled for rendered textures (e.g.  using the
## MultitexReducer).

func supports_depth_texture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_depth_texture()".} ## \
## Returns true if this particular GSG supports textures whose format is
## F_depth_stencil.  This returns true if the GSG supports GL_DEPTH_COMPONENT
## textures, which are considered a limited but still valid case of
## F_depth_stencil.

func supports_depth_stencil*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_depth_stencil()".} ## \
## Returns true if this particular GSG supports textures whose format is
## F_depth_stencil.  This only returns true if the GSG supports the full
## packed depth-stencil functionality.

func supports_luminance_texture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_luminance_texture()".} ## \
## Returns true if this particular GSG supports luminance textures.

func supports_sampler_objects*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_sampler_objects()".} ## \
## Returns true if this particular GSG supports the use of sampler objects to
## record texture sampling parameters separately from the texture objects.
## This doesn't really affect functionality, but if this is false, it may mean
## that using the same texture with different SamplerState objects will result
## in reduced performance.

func supports_basic_shaders*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_basic_shaders()".} ## \
## Returns true if this particular GSG supports arbfp1+arbvp1 or above.

func supports_geometry_shaders*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_geometry_shaders()".} ## \
## Returns true if this particular GSG supports geometry shaders.

func supports_tessellation_shaders*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_tessellation_shaders()".} ## \
## Returns true if this particular GSG supports tesselation shaders.

func supports_compute_shaders*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_compute_shaders()".} ## \
## Returns true if this particular GSG supports compute shaders.

func supports_glsl*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_glsl()".} ## \
## Returns true if this particular GSG supports GLSL shaders.

func supports_stencil*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_stencil()".} ## \
## Returns true if this particular GSG supports stencil buffers at all.

func supports_two_sided_stencil*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_two_sided_stencil()".} ## \
## Returns true if this particular GSG supports two sided stencil: different
## stencil settings for the front and back side of the same polygon.

func supports_geometry_instancing*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_geometry_instancing()".} ## \
## Returns true if this particular GSG supports hardware geometry instancing:
## the ability to render multiple copies of a model.  In OpenGL, this is done
## using the EXT_draw_instanced extension.

func supports_indirect_draw*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_indirect_draw()".} ## \
## Returns true if this particular GSG supports draw calls for which the
## information comes from a buffer.

func supports_occlusion_query*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_occlusion_query()".} ## \
## Returns true if this GSG supports an occlusion query.  If this is true,
## then begin_occlusion_query() and end_occlusion_query() may be called to
## bracket a sequence of draw_triangles() (or whatever) calls to measure
## pixels that pass the depth test.

func supports_timer_query*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_timer_query()".} ## \
## Returns true if this GSG supports a timer query.

func timer_queries_active*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_timer_queries_active()".} ## \
## Returns true if timer queries are currently enabled on this GSG.

func max_color_targets*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_color_targets()".} ## \
## Returns the maximum number of simultaneous color textures that may be
## attached for render-to-texture, as supported by this particular GSG.  If
## you exceed this number, the lowest-priority render targets will not be
## applied.  Use RenderTarget::set_priority() to adjust the relative
## importance of the different render targets.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func supports_dual_source_blending*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_dual_source_blending()".} ## \
## Returns true if dual source (incoming1_color and incoming1_alpha) blend
## operands are supported by this GSG.

func coordinate_system*(this: GraphicsStateGuardian): CoordinateSystem {.importcpp: "#->get_coordinate_system()".} ## \
## Returns the coordinate system in effect on this particular gsg.  Normally,
## this will be the default coordinate system, but it might be set differently
## at runtime.

proc `coordinate_system=`*(this: GraphicsStateGuardian, cs: CoordinateSystem) {.importcpp: "#->set_coordinate_system(#)".}

func prepared_objects*(this: GraphicsStateGuardian): PreparedGraphicsObjects {.importcpp: "#->get_prepared_objects()".}

func gamma*(this: GraphicsStateGuardian): float32 {.importcpp: "#->get_gamma()".}

proc `gamma=`*(this: GraphicsStateGuardian, gamma: float32): bool {.importcpp: "#->set_gamma(#)".}

func flash_texture*(this: GraphicsStateGuardian): Texture {.importcpp: "#->get_flash_texture()".}

proc `flash_texture=`*(this: GraphicsStateGuardian, tex: Texture) {.importcpp: "#->set_flash_texture(#)".}

func driver_vendor*(this: GraphicsStateGuardian): string {.importcpp: "nimStringFromStdString(#->get_driver_vendor())", header: stringConversionCode.}

func driver_renderer*(this: GraphicsStateGuardian): string {.importcpp: "nimStringFromStdString(#->get_driver_renderer())", header: stringConversionCode.}

func driver_version*(this: GraphicsStateGuardian): string {.importcpp: "nimStringFromStdString(#->get_driver_version())", header: stringConversionCode.}

func driver_version_major*(this: GraphicsStateGuardian): int {.importcpp: "#->get_driver_version_major()".}

func driver_version_minor*(this: GraphicsStateGuardian): int {.importcpp: "#->get_driver_version_minor()".}

func driver_shader_version_major*(this: GraphicsStateGuardian): int {.importcpp: "#->get_driver_shader_version_major()".}

func driver_shader_version_minor*(this: GraphicsStateGuardian): int {.importcpp: "#->get_driver_shader_version_minor()".}

func scene*(this: GraphicsStateGuardian): SceneSetup {.importcpp: "#->get_scene()".}

proc `scene=`*(this: GraphicsStateGuardian, scene_setup: SceneSetup): bool {.importcpp: "#->set_scene(#)".}

func threading_model*(this: GraphicsEngine): GraphicsThreadingModel {.importcpp: "#->get_threading_model()".} ## \
## Returns the threading model that will be applied to future objects.  See
## set_threading_model().

proc `threading_model=`*(this: GraphicsEngine, threading_model: GraphicsThreadingModel) {.importcpp: "#->set_threading_model(#)".} ## \
## Specifies how future objects created via make_gsg(), make_buffer(), and
## make_output() will be threaded.  This does not affect any already-created
## objects.

func render_lock*(this: GraphicsEngine): ReMutex {.importcpp: "#->get_render_lock()".} ## \
## Returns a ReMutex object that is held by the GraphicsEngine during the
## entire call to render_frame().  While you hold this lock you can be
## confident that no part of the frame will be rendered (at least by the app
## thread).

func auto_flip*(this: GraphicsEngine): bool {.importcpp: "#->get_auto_flip()".} ## \
## Returns the current setting for the auto-flip flag.  See set_auto_flip.

proc `auto_flip=`*(this: GraphicsEngine, auto_flip: bool) {.importcpp: "#->set_auto_flip(#)".} ## \
## Set this flag true to indicate the GraphicsEngine should automatically
## cause windows to sync and flip as soon as they have finished drawing,
## rather than waiting for all of the windows to finish drawing first so they
## can flip together.
##
## This only affects the timing of when the flip occurs.  If this is true (the
## default), the flip occurs before render_frame() returns.  If this is false,
## the flip occurs whenever flip_frame() is called, or at the beginning of the
## next call to render_frame(), if flip_frame() is never called.

func portal_cull*(this: GraphicsEngine): bool {.importcpp: "#->get_portal_cull()".} ## \
## Returns the current setting for the portal culling flag.

proc `portal_cull=`*(this: GraphicsEngine, value: bool) {.importcpp: "#->set_portal_cull(#)".} ## \
## Set this flag true to indicate the GraphicsEngine should start portal
## culling

func default_loader*(this: GraphicsEngine): Loader {.importcpp: "#->get_default_loader()".} ## \
## Returns the Loader object that will be assigned to every GSG created with
## this GraphicsEngine.  See GraphicsStateGuardian::set_loader().

proc `default_loader=`*(this: GraphicsEngine, loader: Loader) {.importcpp: "#->set_default_loader(#)".} ## \
## Sets the Loader object that will be assigned to every GSG created with this
## GraphicsEngine.  See GraphicsStateGuardian::set_loader().

func left_eye*(this: StereoDisplayRegion): DisplayRegion {.importcpp: "#->get_left_eye()".} ## \
## Returns a pointer to the left DisplayRegion managed by this stereo object.

func right_eye*(this: StereoDisplayRegion): DisplayRegion {.importcpp: "#->get_right_eye()".} ## \
## Returns a pointer to the right DisplayRegion managed by this stereo object.

func depth_bits*(this: FrameBufferProperties): int {.importcpp: "#.get_depth_bits()".} ## \
## Individual queries.

proc `depth_bits=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_depth_bits(#)".} ## \
## Individual assigners.

func color_bits*(this: FrameBufferProperties): int {.importcpp: "#.get_color_bits()".}

proc `color_bits=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_color_bits(#)".} ## \
## Sets the number of requested color bits as a single number that represents
## the sum of the individual numbers of red, green and blue bits.  Panda won't
## care how the individual bits are divided up.
##
## See also set_rgba_bits, which allows you to specify requirements for the
## individual components.

func red_bits*(this: FrameBufferProperties): int {.importcpp: "#.get_red_bits()".}

proc `red_bits=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_red_bits(#)".}

func green_bits*(this: FrameBufferProperties): int {.importcpp: "#.get_green_bits()".}

proc `green_bits=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_green_bits(#)".}

func blue_bits*(this: FrameBufferProperties): int {.importcpp: "#.get_blue_bits()".}

proc `blue_bits=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_blue_bits(#)".}

func alpha_bits*(this: FrameBufferProperties): int {.importcpp: "#.get_alpha_bits()".}

proc `alpha_bits=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_alpha_bits(#)".}

func stencil_bits*(this: FrameBufferProperties): int {.importcpp: "#.get_stencil_bits()".}

proc `stencil_bits=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_stencil_bits(#)".}

func accum_bits*(this: FrameBufferProperties): int {.importcpp: "#.get_accum_bits()".}

proc `accum_bits=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_accum_bits(#)".}

func aux_rgba*(this: FrameBufferProperties): int {.importcpp: "#.get_aux_rgba()".}

proc `aux_rgba=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_aux_rgba(#)".}

func aux_hrgba*(this: FrameBufferProperties): int {.importcpp: "#.get_aux_hrgba()".}

proc `aux_hrgba=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_aux_hrgba(#)".}

func aux_float*(this: FrameBufferProperties): int {.importcpp: "#.get_aux_float()".}

proc `aux_float=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_aux_float(#)".}

func multisamples*(this: FrameBufferProperties): int {.importcpp: "#.get_multisamples()".}

proc `multisamples=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_multisamples(#)".}

func coverage_samples*(this: FrameBufferProperties): int {.importcpp: "#.get_coverage_samples()".} ## \
## If coverage samples are specified, and there is hardware support, we use
## coverage multisampling.

proc `coverage_samples=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_coverage_samples(#)".} ## \
## If coverage samples are specified, and there is hardware support, we use
## coverage multisampling

func back_buffers*(this: FrameBufferProperties): int {.importcpp: "#.get_back_buffers()".}

proc `back_buffers=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_back_buffers(#)".}

func indexed_color*(this: FrameBufferProperties): bool {.importcpp: "#.get_indexed_color()".}

proc `indexed_color=`*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_indexed_color(#)".}

func rgb_color*(this: FrameBufferProperties): bool {.importcpp: "#.get_rgb_color()".}

proc `rgb_color=`*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_rgb_color(#)".}

func stereo*(this: FrameBufferProperties): bool {.importcpp: "#.get_stereo()".}

proc `stereo=`*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_stereo(#)".}

func force_hardware*(this: FrameBufferProperties): bool {.importcpp: "#.get_force_hardware()".}

proc `force_hardware=`*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_force_hardware(#)".}

func force_software*(this: FrameBufferProperties): bool {.importcpp: "#.get_force_software()".}

proc `force_software=`*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_force_software(#)".}

func srgb_color*(this: FrameBufferProperties): bool {.importcpp: "#.get_srgb_color()".}

proc `srgb_color=`*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_srgb_color(#)".}

func float_color*(this: FrameBufferProperties): bool {.importcpp: "#.get_float_color()".}

proc `float_color=`*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_float_color(#)".}

func float_depth*(this: FrameBufferProperties): bool {.importcpp: "#.get_float_depth()".}

proc `float_depth=`*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_float_depth(#)".}

func properties*(this: GraphicsWindow): WindowProperties {.importcpp: "#->get_properties()".} ## \
## Returns the current properties of the window.

func requested_properties*(this: GraphicsWindow): WindowProperties {.importcpp: "#->get_requested_properties()".} ## \
## Returns the properties of the window that are currently requested.  These
## properties will be applied to the window (if valid) at the next execution
## of process_events().

func rejected_properties*(this: GraphicsWindow): WindowProperties {.importcpp: "#->get_rejected_properties()".} ## \
## Returns the set of properties that have recently been requested, but could
## not be applied to the window for some reason.  This set of properties will
## remain unchanged until they are changed by a new failed request, or
## clear_rejected_properties() is called.

func closed*(this: GraphicsWindow): bool {.importcpp: "#->is_closed()".} ## \
## Returns true if the window has not yet been opened, or has been fully
## closed, false if it is open.  The window is not opened immediately after
## GraphicsEngine::make_output() is called; nor is it closed immediately after
## GraphicsEngine::remove_window() is called.  Either operation may take a
## frame or two.

func window_event*(this: GraphicsWindow): string {.importcpp: "nimStringFromStdString(#->get_window_event())", header: stringConversionCode.} ## \
## Returns the name of the event that is generated when this window is
## modified externally, e.g.  to be resized or closed by the user.  See
## set_window_event().

proc `window_event=`*(this: GraphicsWindow, window_event: string) {.importcpp: "#->set_window_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of the event that is generated when this window is
## modified externally, e.g.  to be resized or closed by the user.
##
## By default, all windows have the same window event unless they are
## explicitly changed.  When the event is generated, it includes one
## parameter: the window itself.

func close_request_event*(this: GraphicsWindow): string {.importcpp: "nimStringFromStdString(#->get_close_request_event())", header: stringConversionCode.} ## \
## Returns the name of the event set via set_close_request_event().  If this
## string is nonempty, then when the user requests to close window, this event
## will be generated instead.  See set_close_request_event().

proc `close_request_event=`*(this: GraphicsWindow, close_request_event: string) {.importcpp: "#->set_close_request_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the event that is triggered when the user requests to close the
## window, e.g.  via alt-F4, or clicking on the close box.
##
## The default for each window is for this event to be the empty string, which
## means the window-close request is handled immediately by Panda (and the
## window will be closed without the app getting a chance to intervene).  If
## you set this to a nonempty string, then the window is not closed, but
## instead the event is thrown.  It is then up to the app to respond
## appropriately, for instance by presenting an "are you sure?"  dialog box,
## and eventually calling close_window() when the user is sure.
##
## It is considered poor form to set this string and then not handle the
## event.  This can frustrate the user by making it difficult for him to
## cleanly shut down the application (and may force the user to hard-kill the
## app, or reboot the machine).

func unexposed_draw*(this: GraphicsWindow): bool {.importcpp: "#->get_unexposed_draw()".} ## \
## See set_unexposed_draw().

proc `unexposed_draw=`*(this: GraphicsWindow, unexposed_draw: bool) {.importcpp: "#->set_unexposed_draw(#)".} ## \
## If this flag is false, the window is redrawn only after it has received a
## recent "unexpose" or "draw" event from the underlying windowing system.  If
## this flag is true, the window is redrawn every frame regardless.  Setting
## this false may prevent the window from redrawing unnecessarily when it is
## hidden, and may play nicer with other windows on the desktop, but may
## adversely affect frame rate even when the window is fully visible; setting
## it true will ensure that the window contents are always current.

func window_handle*(this: GraphicsWindow): WindowHandle {.importcpp: "#->get_window_handle()".} ## \
## Returns the WindowHandle corresponding to this window on the desktop.  This
## is mainly useful for communicating with external libraries.  Use
## window_handle->get_os_handle()->get_handle(), or
## window_handle->get_string_handle(), to get the actual OS-specific window
## handle object, whatever type that might be.

func sync_name*(this: Thread): string {.importcpp: "nimStringFromStdString(#->get_sync_name())", header: stringConversionCode.} ## \
## Returns the sync name of the thread.  This name collects threads into "sync
## groups", which are expected to run synchronously.  This is mainly used for
## the benefit of PStats; threads with the same sync name can be ticked all at
## once via the thread_tick() call.

func pstats_index*(this: Thread): int {.importcpp: "#->get_pstats_index()".} ## \
## Returns the PStats index associated with this thread, or -1 if no index has
## yet been associated with this thread.  This is used internally by the
## PStatClient; you should not need to call this directly.

func python_index*(this: Thread): int {.importcpp: "#->get_python_index()".} ## \
## Returns the Python index associated with this thread, or -1 if no index has
## yet been associated with this thread.  This is used internally by the
## direct.stdpy.thread module; you should not need to call this directly.

func unique_id*(this: Thread): string {.importcpp: "nimStringFromStdString(#->get_unique_id())", header: stringConversionCode.} ## \
## Returns a string that is guaranteed to be unique to this thread, across all
## processes on the machine, during at least the lifetime of this process.

func pipeline_stage*(this: Thread): int {.importcpp: "#->get_pipeline_stage()".} ## \
## Returns the Pipeline stage number associated with this thread.  The default
## stage is 0 if no stage is specified otherwise.  See set_pipeline_stage().

proc `pipeline_stage=`*(this: Thread, pipeline_stage: int) {.importcpp: "#->set_pipeline_stage(#)".} ## \
## Specifies the Pipeline stage number associated with this thread.  The
## default stage is 0 if no stage is specified otherwise.
##
## This must be a value in the range [0 .. pipeline->get_num_stages() - 1].
## It specifies the values that this thread observes for all pipelined data.
## Typically, an application thread will leave this at 0, but a render thread
## may set it to 1 or 2 (to operate on the previous frame's data, or the
## second previous frame's data).

func main_thread*(_: typedesc[Thread]): Thread {.importcpp: "Thread::get_main_thread()", header: "thread.h".} ## \
## Returns a pointer to the "main" Thread object--this is the Thread that
## started the whole process.

func external_thread*(_: typedesc[Thread]): Thread {.importcpp: "Thread::get_external_thread()", header: "thread.h".} ## \
## Returns a pointer to the "external" Thread object--this is a special Thread
## object that corresponds to any thread spawned outside of Panda's threading
## interface.  Note that multiple different threads may share this same
## pointer.

func current_thread*(_: typedesc[Thread]): Thread {.importcpp: "Thread::get_current_thread()", header: "thread.h".} ## \
## Returns a pointer to the currently-executing Thread object.  If this is
## called from the main thread, this will return the same value as
## get_main_thread().
##
## This will always return some valid Thread pointer.  It will never return
## NULL, even if the current thread was spawned outside of Panda's threading
## system, although all non-Panda threads will return the exact same Thread
## pointer.

func current_pipeline_stage*(_: typedesc[Thread]): int {.importcpp: "Thread::get_current_pipeline_stage()", header: "thread.h".} ## \
## Returns the integer pipeline stage associated with the current thread.
## This is the same thing as get_current_thread()->get_pipeline_stage(), but
## it may be faster to retrieve in some contexts.

func threading_supported*(_: typedesc[Thread]): bool {.importcpp: "Thread::is_threading_supported()", header: "thread.h".} ## \
## Returns true if threading support has been compiled in and enabled, or
## false if no threading is available (and Thread::start() will always fail).

func true_threads*(_: typedesc[Thread]): bool {.importcpp: "Thread::is_true_threads()", header: "thread.h".} ## \
## Returns true if a real threading library is available that supports actual
## OS-implemented threads, or false if the only threading we can provide is
## simulated user-space threading.

func simple_threads*(_: typedesc[Thread]): bool {.importcpp: "Thread::is_simple_threads()", header: "thread.h".} ## \
## Returns true if Panda is currently compiled for "simple threads", which is
## to say, cooperative context switching only, reducing the need for quite so
## many critical section protections.  This is not necessarily the opposite of
## "true threads", since one possible implementation of simple threads is via
## true threads with mutex protection to ensure only one runs at a time.

func started*(this: Thread): bool {.importcpp: "#->is_started()".} ## \
## Returns true if the thread has been started, false if it has not, or if
## join() has already been called.

func joinable*(this: Thread): bool {.importcpp: "#->is_joinable()".} ## \
## Returns the value of joinable that was passed to the start() call.

func current_task*(this: Thread): TypedReferenceCount {.importcpp: "#->get_current_task()".} ## \
## Returns the task currently executing on this thread (via the
## AsyncTaskManager), if any, or NULL if the thread is not currently servicing
## a task.

func clock*(this: AsyncTaskManager): ClockObject {.importcpp: "#->get_clock()".} ## \
## Returns the clock pointer used within the AsyncTaskManager.  See
## set_clock().

proc `clock=`*(this: AsyncTaskManager, clock: ClockObject) {.importcpp: "#->set_clock(#)".} ## \
## Replaces the clock pointer used within the AsyncTaskManager.  This is used
## to control when tasks with a set_delay() specified will be scheduled.  It
## can also be ticked automatically each epoch, if set_tick_clock() is true.
##
## The default is the global clock pointer.

func tasks*(this: AsyncTaskManager): AsyncTaskCollection {.importcpp: "#->get_tasks()".} ## \
## Returns the set of tasks that are active or sleeping on the task manager,
## at the time of the call.

func active_tasks*(this: AsyncTaskManager): AsyncTaskCollection {.importcpp: "#->get_active_tasks()".} ## \
## Returns the set of tasks that are active (and not sleeping) on the task
## manager, at the time of the call.

func sleeping_tasks*(this: AsyncTaskManager): AsyncTaskCollection {.importcpp: "#->get_sleeping_tasks()".} ## \
## Returns the set of tasks that are sleeping (and not active) on the task
## manager, at the time of the call.

func next_wake_time*(this: AsyncTaskManager): float64 {.importcpp: "#->get_next_wake_time()".} ## \
## Returns the scheduled time (on the manager's clock) of the next sleeping
## task, on any task chain, to awaken.  Returns -1 if there are no sleeping
## tasks.

func name*(this: Event): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.}

proc `name=`*(this: Event, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.}

func num_transforms*(this: GeomVertexAnimationSpec): int {.importcpp: "#.get_num_transforms()".} ## \
## This is only meaningful for animation_type AT_hardware.  It specifies the
## maximum number of transforms that might be simultaneously applied to any
## one vertex by the data in this format.

func indexed_transforms*(this: GeomVertexAnimationSpec): bool {.importcpp: "#.get_indexed_transforms()".} ## \
## This is only meaningful for animation_type AT_hardware.  If true, it
## indicates that the format uses indexed animation tables.  It is false if
## each vertex will reference the first _num_transforms table entries only.

func parent*(this: InternalName): InternalName {.importcpp: "#->get_parent()".} ## \
## Return the parent of this InternalName.  All names have a parent, except
## the root name.

func name*(this: InternalName): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the complete name represented by the InternalName and all of its
## parents.

func basename*(this: InternalName): string {.importcpp: "nimStringFromStdString(#->get_basename())", header: stringConversionCode.} ## \
## Return the name represented by just this particular InternalName object,
## ignoring its parents names.  This is everything after the rightmost dot.

func registered*(this: GeomVertexArrayFormat): bool {.importcpp: "#->is_registered()".} ## \
## Returns true if this format has been registered, false if it has not.  It
## may not be used for a Geom until it has been registered, but once
## registered, it may no longer be modified.

func stride*(this: GeomVertexArrayFormat): int {.importcpp: "#->get_stride()".} ## \
## Returns the total number of bytes reserved in the array for each vertex.

proc `stride=`*(this: GeomVertexArrayFormat, stride: int) {.importcpp: "#->set_stride(#)".} ## \
## Changes the total number of bytes reserved in the array for each vertex.
## You may not reduce this below get_total_bytes(), but you may increase it
## arbitrarily.

func pad_to*(this: GeomVertexArrayFormat): int {.importcpp: "#->get_pad_to()".} ## \
## Returns the byte divisor to which the data record must be padded to meet
## hardware limitations.  For instance, if this is 4, the stride will be
## automatically rounded up to the next multiple of 4 bytes.  This value is
## automatically increased as needed to ensure the individual numeric
## components in the array are word-aligned.

proc `pad_to=`*(this: GeomVertexArrayFormat, pad_to: int) {.importcpp: "#->set_pad_to(#)".} ## \
## Explicitly sets the byte divisor to which the data record must be padded to
## meet hardware limitations.  See get_pad_to().  Normally it is not necessary
## to call this unless you have some specific requirements for row-to-row data
## alignment.  Note that this value may be automatically increased at each
## subsequent call to add_column().

func divisor*(this: GeomVertexArrayFormat): int {.importcpp: "#->get_divisor()".} ## \
## Returns the divisor attribute for the data in this array.  If 0, it
## contains per-vertex data.  If 1, it contains per-instance data.  If higher
## than 1, the read row is advanced for each n instances.

proc `divisor=`*(this: GeomVertexArrayFormat, divisor: int) {.importcpp: "#->set_divisor(#)".} ## \
## Set this to 0 to indicate that this array contains per-vertex data, or to 1
## to indicate that it contains per-instance data.  If higher than 1, the read
## row is advanced for each n instances.

func total_bytes*(this: GeomVertexArrayFormat): int {.importcpp: "#->get_total_bytes()".} ## \
## Returns the total number of bytes used by the data types within the format,
## including gaps between elements.

func registered*(this: GeomVertexFormat): bool {.importcpp: "#->is_registered()".} ## \
## Returns true if this format has been registered, false if it has not.  It
## may not be used for a Geom until it has been registered, but once
## registered, it may no longer be modified.

func animation*(this: GeomVertexFormat): GeomVertexAnimationSpec {.importcpp: "#->get_animation()".} ## \
## Returns the GeomVertexAnimationSpec that indicates how this format's
## vertices are set up for animation.

proc `animation=`*(this: GeomVertexFormat, animation: GeomVertexAnimationSpec) {.importcpp: "#->set_animation(#)".} ## \
## Resets the GeomVertexAnimationSpec that indicates how this format's
## vertices are set up for animation.  You should also, of course, change the
## columns in the tables accordingly.
##
## This may not be called once the format has been registered.

func save_file*(_: typedesc[VertexDataPage]): VertexDataSaveFile {.importcpp: "VertexDataPage::get_save_file()", header: "vertexDataPage.h".} ## \
## Returns the global VertexDataSaveFile that will be used to save vertex data
## buffers to disk when necessary.

func array_format*(this: GeomVertexArrayData): GeomVertexArrayFormat {.importcpp: "#->get_array_format()".} ## \
## Returns the format object that describes this array.

func data_size_bytes*(this: GeomVertexArrayData): clonglong {.importcpp: "#->get_data_size_bytes()".} ## \
## Returns the number of bytes stored in the array.

func modified*(this: GeomVertexArrayData): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the array vertex data is modified.

func array_format*(this: GeomVertexArrayDataHandle): GeomVertexArrayFormat {.importcpp: "#->get_array_format()".}

func data_size_bytes*(this: GeomVertexArrayDataHandle): clonglong {.importcpp: "#->get_data_size_bytes()".}

func modified*(this: GeomVertexArrayDataHandle): UpdateSeq {.importcpp: "#->get_modified()".}

func registered*(this: TransformTable): bool {.importcpp: "#->is_registered()".} ## \
## Returns true if this table has been registered.  Once it has been
## registered, the set of transforms in a TransformTable may not be further
## modified; but it must be registered before it can be assigned to a Geom.

func modified*(this: TransformTable, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number that's guaranteed to change at least when any
## VertexTransforms in the table change.  (However, this is only true for a
## registered table.  An unregistered table may or may not reflect an update
## here when a VertexTransform changes.)

func modified*(this: TransformTable): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number that's guaranteed to change at least when any
## VertexTransforms in the table change.  (However, this is only true for a
## registered table.  An unregistered table may or may not reflect an update
## here when a VertexTransform changes.)

func modified*(this: TransformBlend, current_thread: Thread): UpdateSeq {.importcpp: "#.get_modified(#)".} ## \
## Returns a counter which is guaranteed to increment at least as often as the
## result of get_blend() changes.

func modified*(this: TransformBlend): UpdateSeq {.importcpp: "#.get_modified()".} ## \
## Returns a counter which is guaranteed to increment at least as often as the
## result of get_blend() changes.

func modified*(this: TransformBlendTable, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a counter which is guaranteed to increment at least when any
## TransformBlends within the table have changed.

func modified*(this: TransformBlendTable): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a counter which is guaranteed to increment at least when any
## TransformBlends within the table have changed.

func num_transforms*(this: TransformBlendTable): int {.importcpp: "#->get_num_transforms()".} ## \
## Returns the number of unique VertexTransform objects represented in the
## table.  This will correspond to the size of the TransformTable object that
## would represent the same table.  This is also the same limit reflected by
## GraphicsStateGuardian::get_max_vertex_transform_indices().

func max_simultaneous_transforms*(this: TransformBlendTable): int {.importcpp: "#->get_max_simultaneous_transforms()".} ## \
## Returns the maximum number of unique VertexTransform objects that are
## applied to any one vertex simultaneously.  This is the same limit reflected
## by GraphicsStateGuardian::get_max_vertex_transforms().

func rows*(this: TransformBlendTable): SparseArray {.importcpp: "#->get_rows()".} ## \
## Returns the subset of rows (vertices) in the associated GeomVertexData that
## this TransformBlendTable actually affects.

proc `rows=`*(this: TransformBlendTable, rows: SparseArray) {.importcpp: "#->set_rows(#)".} ## \
## Specifies the subset of rows (vertices) in the associated GeomVertexData
## that this TransformBlendTable actually affects.

func modified*(this: SliderTable, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number that's guaranteed to change at least when any
## VertexSliders in the table change.  (However, this is only true for a
## registered table.  An unregistered table may or may not reflect an update
## here when a VertexSlider changes.)

func modified*(this: SliderTable): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number that's guaranteed to change at least when any
## VertexSliders in the table change.  (However, this is only true for a
## registered table.  An unregistered table may or may not reflect an update
## here when a VertexSlider changes.)

func name*(this: GeomVertexData): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the name passed to the constructor, if any.  This name is reported
## on the PStats graph for vertex computations.

proc `name=`*(this: GeomVertexData, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of the vertex data.  This name is reported on the PStats
## graph for vertex computations.

func format*(this: GeomVertexData): GeomVertexFormat {.importcpp: "#->get_format()".} ## \
## Returns a pointer to the GeomVertexFormat structure that defines this data.

proc `format=`*(this: GeomVertexData, format: GeomVertexFormat) {.importcpp: "#->set_format(#)".} ## \
## Changes the format of the vertex data.  If the data is not empty, this will
## implicitly change every row to match the new format.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

func transform_table*(this: GeomVertexData): TransformTable {.importcpp: "#->get_transform_table()".} ## \
## Returns a const pointer to the TransformTable assigned to this data.
## Vertices within the table will index into this table to indicate their
## dynamic skinning information; this table is used when the vertex animation
## is to be performed by the graphics hardware (but also see
## get_transform_blend_table()).
##
## This will return NULL if the vertex data does not have a TransformTable
## assigned (which implies the vertices will not be animated by the graphics
## hardware).

proc `transform_table=`*(this: GeomVertexData, table: TransformTable) {.importcpp: "#->set_transform_table(#)".} ## \
## Replaces the TransformTable on this vertex data with the indicated table.
## The length of this table should be consistent with the maximum table index
## assigned to the vertices under the "transform_index" name.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

func slider_table*(this: GeomVertexData): SliderTable {.importcpp: "#->get_slider_table()".} ## \
## Returns a const pointer to the SliderTable assigned to this data.  Vertices
## within the vertex data will look up their morph offsets, if any, within
## this table.
##
## This will return NULL if the vertex data does not have a SliderTable
## assigned.

proc `slider_table=`*(this: GeomVertexData, table: SliderTable) {.importcpp: "#->set_slider_table(#)".} ## \
## Replaces the SliderTable on this vertex data with the indicated table.
## There should be an entry in this table for each kind of morph offset
## defined in the vertex data.
##
## The SliderTable object must have been registered prior to setting it on the
## GeomVertexData.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

func num_bytes*(this: GeomVertexData): int {.importcpp: "#->get_num_bytes()".} ## \
## Returns the total number of bytes consumed by the different arrays of the
## vertex data.

func modified*(this: GeomVertexData, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the vertex data is modified.

func modified*(this: GeomVertexData): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the vertex data is modified.

func data_size_bytes*(this: BufferContext): clonglong {.importcpp: "#.get_data_size_bytes()".} ## \
## Returns the number of bytes previously reported for the data object.  This
## is used to track changes in the data object's allocated size; if it changes
## from this, we need to create a new buffer.  This is also used to track
## memory utilization in PStats.

func modified*(this: BufferContext): UpdateSeq {.importcpp: "#.get_modified()".} ## \
## Returns the UpdateSeq that was recorded the last time mark_loaded() was
## called.

func active*(this: BufferContext): bool {.importcpp: "#.get_active()".} ## \
## Returns the active flag associated with this object.  An object is
## considered "active" if it was rendered in the current frame.

func resident*(this: BufferContext): bool {.importcpp: "#.get_resident()".} ## \
## Returns the resident flag associated with this object.  An object is
## considered "resident" if it appears to be resident in texture memory.

func geom_rendering*(this: GeomPrimitive): int {.importcpp: "#->get_geom_rendering()".} ## \
## Returns the set of GeomRendering bits that represent the rendering
## properties required to properly render this primitive.

func num_bytes*(this: GeomPrimitive): int {.importcpp: "#->get_num_bytes()".} ## \
## Returns the number of bytes consumed by the primitive and its index
## table(s).

func data_size_bytes*(this: GeomPrimitive): int {.importcpp: "#->get_data_size_bytes()".} ## \
## Returns the number of bytes stored in the vertices array.

func modified*(this: GeomPrimitive): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the vertex index array is modified.

func index_stride*(this: GeomPrimitive): int {.importcpp: "#->get_index_stride()".} ## \
## A convenience function to return the gap between successive index numbers,
## in bytes, of the index data.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

func strip_cut_index*(this: GeomPrimitive): int {.importcpp: "#->get_strip_cut_index()".} ## \
## If relevant, returns the index value that may be used in some cases to
## signify the end of a primitive.  This is typically the highest value that
## the numeric type can store.

func mins*(this: GeomPrimitive): GeomVertexArrayData {.importcpp: "#->get_mins()".} ## \
## Returns a const pointer to the primitive mins array so application code can
## read it directly.  Do not attempt to modify the returned array; use
## set_minmax() for this.
##
## Note that simple primitive types, like triangles, do not have a mins array.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

func maxs*(this: GeomPrimitive): GeomVertexArrayData {.importcpp: "#->get_maxs()".} ## \
## Returns a const pointer to the primitive maxs array so application code can
## read it directly.  Do not attempt to modify the returned array; use
## set_minmax().
##
## Note that simple primitive types, like triangles, do not have a maxs array.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

func num_vertices_per_primitive*(this: GeomPrimitive): int {.importcpp: "#->get_num_vertices_per_primitive()".} ## \
## If the primitive type is a simple type in which all primitives have the
## same number of vertices, like triangles, returns the number of vertices per
## primitive.  If the primitive type is a more complex type in which different
## primitives might have different numbers of vertices, for instance a
## triangle strip, returns 0.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

func min_num_vertices_per_primitive*(this: GeomPrimitive): int {.importcpp: "#->get_min_num_vertices_per_primitive()".} ## \
## Returns the minimum number of vertices that must be added before
## close_primitive() may legally be called.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

func num_unused_vertices_per_primitive*(this: GeomPrimitive): int {.importcpp: "#->get_num_unused_vertices_per_primitive()".} ## \
## Returns the number of vertices that are added between primitives that
## aren't, strictly speaking, part of the primitives themselves.  This is
## used, for instance, to define degenerate triangles to connect otherwise
## disconnected triangle strips.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

func name*(this: TextureStage): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the name of this texture stage

proc `name=`*(this: TextureStage, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of this texture stage

func sort*(this: TextureStage): int {.importcpp: "#->get_sort()".} ## \
## Returns the sort order of this texture stage.

proc `sort=`*(this: TextureStage, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Changes the order in which the texture associated with this stage is
## rendered relative to the other texture stages.  When geometry is rendered
## with multiple textures, the textures are rendered in order from the lowest
## sort number to the highest sort number.
##
## Also see set_priority(), which is used to select the most important
## textures for rendering when some must be omitted because of hardware
## limitations.

func priority*(this: TextureStage): int {.importcpp: "#->get_priority()".} ## \
## Returns the priority associated with this stage.
##
## This is specially helpful for cards that do not support more than n stages
## of multi-texturing.

proc `priority=`*(this: TextureStage, priority: int) {.importcpp: "#->set_priority(#)".} ## \
## Changes the relative importance of the texture associated with this stage
## relative to the other texture stages that are applied simultaneously.
##
## This is unrelated to set_sort(), which controls the order in which multiple
## textures are applied.  The priority number is used to decide which of the
## requested textures are to be selected for rendering when more textures are
## requested than the hardware will support.  The highest-priority n textures
## are selected for rendering, and then rendered in order by their sort
## factor.

func texcoord_name*(this: TextureStage): InternalName {.importcpp: "#->get_texcoord_name()".} ## \
## See set_texcoord_name.  The default is InternalName::get_texcoord().

proc `texcoord_name=`*(this: TextureStage, name: InternalName) {.importcpp: "#->set_texcoord_name(#)".} ## \
## Indicate which set of UV's this texture stage will use.  Geometry may have
## any number of associated UV sets, each of which must have a unique name.

proc `texcoord_name=`*(this: TextureStage, texcoord_name: string) {.importcpp: "#->set_texcoord_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Indicate which set of UV's this texture stage will use.  Geometry may have
## any number of associated UV sets, each of which must have a unique name.

func tangent_name*(this: TextureStage): InternalName {.importcpp: "#->get_tangent_name()".} ## \
## Returns the set of tangents this texture stage will use.  This is the same
## as get_texcoord_name(), except that the first part is "tangent".

func binormal_name*(this: TextureStage): InternalName {.importcpp: "#->get_binormal_name()".} ## \
## Returns the set of binormals this texture stage will use.  This is the same
## as get_binormal_name(), except that the first part is "binormal".

func color*(this: TextureStage): LColor {.importcpp: "#->get_color()".} ## \
## return the color for this stage

proc `color=`*(this: TextureStage, color: LColor) {.importcpp: "#->set_color(#)".} ## \
## Set the color for this stage

func rgb_scale*(this: TextureStage): int {.importcpp: "#->get_rgb_scale()".} ## \
## See set_rgb_scale().

proc `rgb_scale=`*(this: TextureStage, rgb_scale: int) {.importcpp: "#->set_rgb_scale(#)".} ## \
## Sets an additional factor that will scale all three r, g, b components
## after the texture has been applied.  This is used only when the mode is
## CM_combine.
##
## The only legal values are 1, 2, or 4.

func alpha_scale*(this: TextureStage): int {.importcpp: "#->get_alpha_scale()".} ## \
## See set_alpha_scale().

proc `alpha_scale=`*(this: TextureStage, alpha_scale: int) {.importcpp: "#->set_alpha_scale(#)".} ## \
## Sets an additional factor that will scale the alpha component after the
## texture has been applied.  This is used only when the mode is CM_combine.
##
## The only legal values are 1, 2, or 4.

func saved_result*(this: TextureStage): bool {.importcpp: "#->get_saved_result()".} ## \
## Returns the current setting of the saved_result flag.  See
## set_saved_result().

proc `saved_result=`*(this: TextureStage, saved_result: bool) {.importcpp: "#->set_saved_result(#)".} ## \
## Sets the saved_result flag.  When this is true, the output of this stage
## will be supplied as the "last_saved_result" source for any future stages,
## until the next TextureStage with a saved_result set true is encountered.
##
## This can be used to reuse the results of this texture stage as input to
## more than one stage later in the pipeline.
##
## The last texture in the pipeline (the one with the highest sort value)
## should not have this flag set.

func tex_view_offset*(this: TextureStage): int {.importcpp: "#->get_tex_view_offset()".} ## \
## Returns the current setting of the tex_view_offset.  See
## set_tex_view_offset().

proc `tex_view_offset=`*(this: TextureStage, tex_view_offset: int) {.importcpp: "#->set_tex_view_offset(#)".} ## \
## Sets the tex_view_offset value.  This is used only when a special multiview
## texture is bound to the TextureStage, and it selects the particular view of
## the texture that is to be used.
##
## This value is added to the similar parameter on DisplayRegion to derive the
## final texture view index that is selected for rendering.

func default*(_: typedesc[TextureStage]): TextureStage {.importcpp: "TextureStage::get_default()", header: "textureStage.h".} ## \
## Returns the default TextureStage that will be used for all texturing that
## does not name a particular stage.  This generally handles the normal
## single-texture case.

func geom_rendering*(this: Geom): int {.importcpp: "#->get_geom_rendering()".} ## \
## Returns the set of GeomRendering bits that represent the rendering
## properties required to properly render this Geom.

func num_bytes*(this: Geom): int {.importcpp: "#->get_num_bytes()".} ## \
## Returns the number of bytes consumed by the geom and its primitives (but
## not including its vertex table).

func modified*(this: Geom, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## any of the primitives in the Geom is modified, or the set of primitives is
## modified.  However, this does not include modifications to the vertex data,
## which should be tested separately.

func modified*(this: Geom): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## any of the primitives in the Geom is modified, or the set of primitives is
## modified.  However, this does not include modifications to the vertex data,
## which should be tested separately.

func geom*(this: GeomContext): Geom {.importcpp: "#.get_geom()".}

func anisotropic_degree*(this: SamplerState): int {.importcpp: "#.get_anisotropic_degree()".} ## \
## Returns the degree of anisotropic filtering that should be applied to the
## texture.  This value may return 0, indicating the default value; see also
## get_effective_anisotropic_degree.

proc `anisotropic_degree=`*(this: SamplerState, anisotropic_degree: int) {.importcpp: "#.set_anisotropic_degree(#)".} ## \
## Specifies the level of anisotropic filtering to apply to the SamplerState.
## Set this 0 to indicate the default value, which is specified in the
## SamplerState-anisotropic-degree config variable.
##
## To explicitly disable anisotropic filtering, set this value to 1.  To
## explicitly enable anisotropic filtering, set it to a value higher than 1;
## larger numbers indicate greater degrees of filtering.

func effective_anisotropic_degree*(this: SamplerState): int {.importcpp: "#.get_effective_anisotropic_degree()".} ## \
## Returns the degree of anisotropic filtering that should be applied to the
## texture.  This value will normally not return 0, unless there is an error
## in the config file.

func border_color*(this: SamplerState): LColor {.importcpp: "#.get_border_color()".} ## \
## Returns the solid color of the texture's border.  Some OpenGL
## implementations use a border for tiling textures; in Panda, it is only used
## for specifying the clamp color.

proc `border_color=`*(this: SamplerState, color: LColor) {.importcpp: "#.set_border_color(#)".} ## \
## Specifies the solid color of the SamplerState's border.  Some OpenGL
## implementations use a border for tiling SamplerStates; in Panda, it is only
## used for specifying the clamp color.

func min_lod*(this: SamplerState): float32 {.importcpp: "#.get_min_lod()".} ## \
## Returns the minimum level of detail that will be observed when sampling
## this texture.

proc `min_lod=`*(this: SamplerState, min_lod: float32) {.importcpp: "#.set_min_lod(#)".} ## \
## Sets the minimum level of detail that will be used when sampling this
## texture.  This may be a negative value.

func max_lod*(this: SamplerState): float32 {.importcpp: "#.get_max_lod()".} ## \
## Returns the maximum level of detail that will be observed when sampling
## this texture.

proc `max_lod=`*(this: SamplerState, max_lod: float32) {.importcpp: "#.set_max_lod(#)".} ## \
## Sets the maximum level of detail that will be used when sampling this
## texture.  This may exceed the number of mipmap levels that the texture has.

func lod_bias*(this: SamplerState): float32 {.importcpp: "#.get_lod_bias()".} ## \
## Returns the bias that will be added to the texture level of detail when
## sampling this texture.

proc `lod_bias=`*(this: SamplerState, lod_bias: float32) {.importcpp: "#.set_lod_bias(#)".} ## \
## Sets the value that will be added to the level of detail when sampling the
## texture.  This may be a negative value, although some graphics hardware may
## not support the use of negative LOD values.

func change_event*(this: Lens): string {.importcpp: "nimStringFromStdString(#->get_change_event())", header: stringConversionCode.} ## \
## Returns the name of the event that will be generated whenever any
## properties of this particular Lens have changed.

proc `change_event=`*(this: Lens, event: string) {.importcpp: "#->set_change_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the name of the event that will be generated whenever any properties
## of the Lens have changed.  If this is not set for a particular lens, no
## event will be generated.
##
## The event is thrown with one parameter, the lens itself.  This can be used
## to automatically track changes to camera fov, etc.  in the application.

func coordinate_system*(this: Lens): CoordinateSystem {.importcpp: "#->get_coordinate_system()".} ## \
## Returns the coordinate system that all 3-d computations are performed
## within for this Lens.  Normally, this is CS_default.

proc `coordinate_system=`*(this: Lens, cs: CoordinateSystem) {.importcpp: "#->set_coordinate_system(#)".} ## \
## Specifies the coordinate system that all 3-d computations are performed
## within for this Lens.  Normally, this is CS_default.

func film_size*(this: Lens): LVecBase2 {.importcpp: "#->get_film_size()".} ## \
## Returns the horizontal and vertical film size of the virtual film.  See
## set_film_size().

proc `film_size=`*(this: Lens, film_size: LVecBase2) {.importcpp: "#->set_film_size(#)".} ## \
## Sets the size and shape of the "film" within the lens.  This both
## establishes the units used by calls like set_focal_length(), and
## establishes the aspect ratio of the frame.
##
## In a physical camera, the field of view of a lens is determined by the
## lens' focal length and by the size of the film area exposed by the lens.
## For instance, a 35mm camera exposes a rectangle on the film about 24mm x
## 36mm, which means a 50mm lens gives about a 40-degree horizontal field of
## view.
##
## In the virtual camera, you may set the film size to any units here, and
## specify a focal length in the same units to simulate the same effect.  Or,
## you may ignore this parameter, and specify the field of view and aspect
## ratio of the lens directly.

proc `film_size=`*(this: Lens, width: float32) {.importcpp: "#->set_film_size(#)".} ## \
## Sets the horizontal size of the film without changing its shape.  The
## aspect ratio remains unchanged; this computes the vertical size of the film
## to automatically maintain the aspect ratio.

proc `film_size=`*(this: Lens, width: float32, height: float32) {.importcpp: "#->set_film_size(#, #)".} ## \
## Sets the size and shape of the "film" within the lens.  This both
## establishes the units used by calls like set_focal_length(), and
## establishes the aspect ratio of the frame.
##
## In a physical camera, the field of view of a lens is determined by the
## lens' focal length and by the size of the film area exposed by the lens.
## For instance, a 35mm camera exposes a rectangle on the film about 24mm x
## 36mm, which means a 50mm lens gives about a 40-degree horizontal field of
## view.
##
## In the virtual camera, you may set the film size to any units here, and
## specify a focal length in the same units to simulate the same effect.  Or,
## you may ignore this parameter, and specify the field of view and aspect
## ratio of the lens directly.

func film_offset*(this: Lens): LVector2 {.importcpp: "#->get_film_offset()".} ## \
## Returns the horizontal and vertical offset amounts of this Lens.  See
## set_film_offset().

proc `film_offset=`*(this: Lens, film_offset: LVecBase2) {.importcpp: "#->set_film_offset(#)".} ## \
## Sets the horizontal and vertical offset amounts of this Lens.  These are
## both in the same units specified in set_film_size().
##
## This can be used to establish an off-axis lens.

proc `film_offset=`*(this: Lens, x: float32, y: float32) {.importcpp: "#->set_film_offset(#, #)".} ## \
## Sets the horizontal and vertical offset amounts of this Lens.  These are
## both in the same units specified in set_film_size().
##
## This can be used to establish an off-axis lens.

func focal_length*(this: Lens): float32 {.importcpp: "#->get_focal_length()".} ## \
## Returns the focal length of the lens.  This may have been set explicitly by
## a previous call to set_focal_length(), or it may be computed based on the
## lens' fov and film_size.  For certain kinds of lenses, the focal length has
## no meaning.

proc `focal_length=`*(this: Lens, focal_length: float32) {.importcpp: "#->set_focal_length(#)".} ## \
## Sets the focal length of the lens.  This may adjust the field-of-view
## correspondingly, and is an alternate way to specify field of view.
##
## For certain kinds of lenses (e.g.  OrthographicLens), the focal length has
## no meaning.

func fov*(this: Lens): LVecBase2 {.importcpp: "#->get_fov()".} ## \
## Returns the horizontal and vertical film size of the virtual film.  See
## set_fov().

proc `fov=`*(this: Lens, fov: LVecBase2) {.importcpp: "#->set_fov(#)".} ## \
## Sets the field of view of the lens in both dimensions.  This establishes
## both the field of view and the aspect ratio of the lens.  This is one way
## to specify the field of view of a lens; set_focal_length() is another way.
##
## For certain kinds of lenses (like OrthographicLens), the field of view has
## no meaning.

proc `fov=`*(this: Lens, fov: float32) {.importcpp: "#->set_fov(#)".} ## \
## Sets the horizontal field of view of the lens without changing the aspect
## ratio.  The vertical field of view is adjusted to maintain the same aspect
## ratio.

proc `fov=`*(this: Lens, hfov: float32, vfov: float32) {.importcpp: "#->set_fov(#, #)".} ## \
## Sets the field of view of the lens in both dimensions.  This establishes
## both the field of view and the aspect ratio of the lens.  This is one way
## to specify the field of view of a lens; set_focal_length() is another way.
##
## For certain kinds of lenses (like OrthoLens), the field of view has no
## meaning.

func min_fov*(this: Lens): float32 {.importcpp: "#->get_min_fov()".} ## \
## Returns the field of view of the narrowest dimension of the window.  See
## set_min_fov().

proc `min_fov=`*(this: Lens, min_fov: float32) {.importcpp: "#->set_min_fov(#)".} ## \
## Sets the field of view of the smallest dimension of the window.  If the
## window is wider than it is tall, this specifies the vertical field of view;
## if it is taller than it is wide, this specifies the horizontal field of
## view.
##
## In many cases, this is preferable to setting either the horizontal or
## vertical field of view explicitly.  Setting this parameter means that
## pulling the window wider will widen the field of view, which is usually
## what you expect to happen.

func aspect_ratio*(this: Lens): float32 {.importcpp: "#->get_aspect_ratio()".} ## \
## Returns the aspect ratio of the Lens.  This is determined based on the
## indicated film size; see set_film_size().

proc `aspect_ratio=`*(this: Lens, aspect_ratio: float32) {.importcpp: "#->set_aspect_ratio(#)".} ## \
## Sets the aspect ratio of the lens.  This is the ratio of the height to the
## width of the generated image.  Setting this overrides the two-parameter fov
## or film size setting.

func near*(this: Lens): float32 {.importcpp: "#->get_near()".} ## \
## Returns the position of the near plane (or cylinder, sphere, whatever).

proc `near=`*(this: Lens, near_distance: float32) {.importcpp: "#->set_near(#)".} ## \
## Defines the position of the near plane (or cylinder, sphere, whatever).
## Points closer to the lens than this may not be rendered.

func far*(this: Lens): float32 {.importcpp: "#->get_far()".} ## \
## Returns the position of the far plane (or cylinder, sphere, whatever).

proc `far=`*(this: Lens, far_distance: float32) {.importcpp: "#->set_far(#)".} ## \
## Defines the position of the far plane (or cylinder, sphere, whatever).
## Points farther from the lens than this may not be rendered.

func view_hpr*(this: Lens): LVecBase3 {.importcpp: "#->get_view_hpr()".} ## \
## Returns the direction in which the lens is facing.

proc `view_hpr=`*(this: Lens, view_hpr: LVecBase3) {.importcpp: "#->set_view_hpr(#)".} ## \
## Sets the direction in which the lens is facing.  Normally, this is down the
## forward axis (usually the Y axis), but it may be rotated.  This is only one
## way of specifying the rotation; you may also specify an explicit vector in
## which to look, or you may give a complete transformation matrix.

proc `view_hpr=`*(this: Lens, h: float32, p: float32, r: float32) {.importcpp: "#->set_view_hpr(#, #, #)".} ## \
## Sets the direction in which the lens is facing.  Normally, this is down the
## forward axis (usually the Y axis), but it may be rotated.  This is only one
## way of specifying the rotation; you may also specify an explicit vector in
## which to look, or you may give a complete transformation matrix.

func nodal_point*(this: Lens): LPoint3 {.importcpp: "#->get_nodal_point()".} ## \
## Returns the center point of the lens: the point from which the lens is
## viewing.

func interocular_distance*(this: Lens): float32 {.importcpp: "#->get_interocular_distance()".} ## \
## See set_interocular_distance().

proc `interocular_distance=`*(this: Lens, interocular_distance: float32) {.importcpp: "#->set_interocular_distance(#)".} ## \
## Sets the distance between the left and right eyes of a stereo camera.  This
## distance is used to apply a stereo effect when the lens is rendered on a
## stereo display region.  It only has an effect on a PerspectiveLens.
##
## The left eye and the right eye are each offset along the X axis by half of
## this distance, so that this parameter specifies the total distance between
## them.
##
## Also see set_convergence_distance(), which relates.

func convergence_distance*(this: Lens): float32 {.importcpp: "#->get_convergence_distance()".} ## \
## See set_convergence_distance().

proc `convergence_distance=`*(this: Lens, convergence_distance: float32) {.importcpp: "#->set_convergence_distance(#)".} ## \
## Sets the distance between between the camera plane and the point in the
## distance that the left and right eyes are both looking at.  This distance
## is used to apply a stereo effect when the lens is rendered on a stereo
## display region.  It only has an effect on a PerspectiveLens.
##
## This parameter must be greater than 0, but may be as large as you like.  It
## controls the distance at which the two stereo images will appear to
## converge, which is a normal property of stereo vision.  Normally this
## should be set to the distance from the camera to the area of interest in
## your scene.  Anything beyond this distance will appear to go into the
## screen, and anything closer will appear to come out of the screen.  If you
## want to simulate parallel stereo, set this to infinity.
##
## Note that this creates an off-axis frustum, which means that the lenses are
## still pointing in the same direction, which is usually more desirable than
## the more naive toe-in approach, where the two lenses are simply tilted
## toward each other.
##
## Prior to Panda3D 1.9.0, the convergence was being calculated incorrectly.
## It has since been corrected.  To restore the legacy behavior you can set
## the stereo-lens-old-convergence variable to true.
##
## Also see set_interocular_distance(), which relates.

func view_mat*(this: Lens): LMatrix4 {.importcpp: "#->get_view_mat()".} ## \
## Returns the direction in which the lens is facing.

proc `view_mat=`*(this: Lens, view_mat: LMatrix4) {.importcpp: "#->set_view_mat(#)".} ## \
## Sets an arbitrary transformation on the lens.  This replaces the individual
## transformation components like set_view_hpr().
##
## Setting a transformation here will have a slightly different effect than
## putting one on the LensNode that contains this lens.  In particular,
## lighting and other effects computations will still be performed on the lens
## in its untransformed (facing forward) position, but the actual projection
## matrix will be transformed by this matrix.

func keystone*(this: Lens): LVecBase2 {.importcpp: "#->get_keystone()".} ## \
## Returns the keystone correction specified for the lens.

proc `keystone=`*(this: Lens, keystone: LVecBase2) {.importcpp: "#->set_keystone(#)".} ## \
## Indicates the ratio of keystone correction to perform on the lens, in each
## of three axes.  This will build a special non-affine scale factor into the
## projection matrix that will compensate for keystoning of a projected image;
## this can be used to compensate for a projector that for physical reasons
## cannot be aimed directly at its screen.
##
## The default value is taken from the default-keystone Config variable.  0, 0
## indicates no keystone correction; specify a small value (usually in the
## range -1 .. 1) in either the x or y position to generate a keystone
## correction in that axis.

func base_color*(this: Material): LColor {.importcpp: "#->get_base_color()".} ## \
## Returns the base_color color setting, if it has been set.  If neither the
## base color nor the metallic have been set, this returns the diffuse color.

proc `base_color=`*(this: Material, color: LColor) {.importcpp: "#->set_base_color(#)".} ## \
## Specifies the base color of the material.  In conjunction with
## set_metallic, this is an alternate way to specify the color of a material.
## For dielectrics, this will determine the value of the diffuse color, and
## for metals, this will determine the value of the specular color.
##
## Setting this will clear an explicit specular, diffuse or ambient color
## assignment.
##
## If this is not set, the object color will be used.

func ambient*(this: Material): LColor {.importcpp: "#->get_ambient()".} ## \
## Returns the ambient color setting, if it has been set.  Returns (0,0,0,0)
## if the ambient color has not been set.

proc `ambient=`*(this: Material, color: LColor) {.importcpp: "#->set_ambient(#)".} ## \
## Specifies the ambient color setting of the material.  This will be the
## multiplied by any ambient lights in effect on the material to set its base
## color.
##
## This is the color of the object as it appears in the absence of direct
## light.
##
## If this is not set, the object color will be used.

func diffuse*(this: Material): LColor {.importcpp: "#->get_diffuse()".} ## \
## Returns the diffuse color setting, if it has been set.  Returns (1,1,1,1)
## if the diffuse color has not been set.

proc `diffuse=`*(this: Material, color: LColor) {.importcpp: "#->set_diffuse(#)".} ## \
## Specifies the diffuse color setting of the material.  This will be
## multiplied by any lights in effect on the material to get the color in the
## parts of the object illuminated by the lights.
##
## This is the primary color of an object; the color of the object as it
## appears in direct light, in the absence of highlights.
##
## If this is not set, the object color will be used.

func specular*(this: Material): LColor {.importcpp: "#->get_specular()".} ## \
## Returns the specular color setting, if it has been set.  Returns (0,0,0,0)
## if the specular color has not been set.

proc `specular=`*(this: Material, color: LColor) {.importcpp: "#->set_specular(#)".} ## \
## Specifies the specular color setting of the material.  This will be
## multiplied by any lights in effect on the material to compute the color of
## specular highlights on the object.
##
## This is the highlight color of an object: the color of small highlight
## reflections.
##
## If this is not set, the specular color is taken from the index of
## refraction, which is 1 by default (meaning no specular reflections are
## generated).

func emission*(this: Material): LColor {.importcpp: "#->get_emission()".} ## \
## Returns the emission color setting, if it has been set.  Returns (0,0,0,0)
## if the emission color has not been set.

proc `emission=`*(this: Material, color: LColor) {.importcpp: "#->set_emission(#)".} ## \
## Specifies the emission color setting of the material.  This is the color of
## the object as it appears in the absence of any light whatsover, including
## ambient light.  It is as if the object is glowing by this color (although
## of course it will not illuminate neighboring objects).
##
## If this is not set, the object will not glow by its own light and will only
## appear visible in the presence of one or more lights.

func shininess*(this: Material): float32 {.importcpp: "#->get_shininess()".} ## \
## Returns the shininess exponent of the material.

proc `shininess=`*(this: Material, shininess: float32) {.importcpp: "#->set_shininess(#)".} ## \
## Sets the shininess exponent of the material.  This controls the size of the
## specular highlight spot.  In general, larger number produce a smaller
## specular highlight, which makes the object appear shinier.  Smaller numbers
## produce a larger highlight, which makes the object appear less shiny.
##
## This is usually in the range 0..128.
##
## Setting a shininess value removes any previous roughness assignment.

func roughness*(this: Material): float32 {.importcpp: "#->get_roughness()".} ## \
## Returns the roughness previously specified by set_roughness.  If none was
## previously set, this value is computed from the shininess value.

proc `roughness=`*(this: Material, roughness: float32) {.importcpp: "#->set_roughness(#)".} ## \
## Sets the roughness exponent of the material, where 0 is completely shiny
## (infinite shininess), and 1 is a completely dull object (0 shininess).
## This is a different, more perceptually intuitive way of controlling the
## size of the specular spot, and more commonly used in physically-based
## rendering.
##
## Setting a roughness recalculates the shininess value.

func metallic*(this: Material): float32 {.importcpp: "#->get_metallic()".} ## \
## Returns the metallic setting, if it has been set.  Returns 0 if it has not
## been set.

proc `metallic=`*(this: Material, metallic: float32) {.importcpp: "#->set_metallic(#)".} ## \
## Sets the metallic setting of the material, which is is used for physically-
## based rendering models.  This is usually 0 for dielectric materials and 1
## for metals.  It really does not make sense to set this to a value other
## than 0 or 1, but it is nonetheless a float for compatibility with tools
## that allow setting this to values other than 0 or 1.

func refractive_index*(this: Material): float32 {.importcpp: "#->get_refractive_index()".} ## \
## Returns the index of refraction, or 1 if none has been set for this
## material.

proc `refractive_index=`*(this: Material, refractive_index: float32) {.importcpp: "#->set_refractive_index(#)".} ## \
## Sets the index of refraction of the material, which is used to determine
## the specular color in absence of an explicit specular color assignment.
## This is usually 1.5 for dielectric materials.  It is not very useful for
## metals, since they cannot be described as easily with a single number.
##
## Should be 1 or higher.  The default is 1.

func local*(this: Material): bool {.importcpp: "#->get_local()".} ## \
## Returns the local viewer flag.  Set set_local().

proc `local=`*(this: Material, local: bool) {.importcpp: "#->set_local(#)".} ## \
## Sets the local viewer flag.  Set this true to enable camera-relative
## specular highlights, or false to use orthogonal specular highlights.  The
## default value is true.  Applications that use orthogonal projection should
## specify false.

func twoside*(this: Material): bool {.importcpp: "#->get_twoside()".} ## \
## Returns the state of the two-sided lighting flag.  See set_twoside().

proc `twoside=`*(this: Material, twoside: bool) {.importcpp: "#->set_twoside(#)".} ## \
## Set this true to enable two-sided lighting.  When two-sided lighting is on,
## both sides of a polygon will be lit by this material.  The default is for
## two-sided lighting to be off, in which case only the front surface is lit.

func user_mat*(this: MatrixLens): LMatrix4 {.importcpp: "#->get_user_mat()".} ## \
## Returns the explicit projection matrix as set by the user.  This does not
## include transforms on the lens or film (e.g.  a film offset or view hpr).

proc `user_mat=`*(this: MatrixLens, user_mat: LMatrix4) {.importcpp: "#->set_user_mat(#)".} ## \
## Explicitly specifies the projection matrix.  This matrix should convert X
## and Y to the range [-film_size/2, film_size/2], where (-fs/2,-fs/2) is the
## lower left corner of the screen and (fs/2, fs/2) is the upper right.  Z
## should go to the range [-1, 1], where -1 is the near plane and 1 is the far
## plane.  Note that this is a left-handed Y-up coordinate system.
##
## The default film_size for a MatrixLens is 2, so the default range is [-1,
## 1] for both X and Y.  This is consistent with the GL conventions for
## projection matrices.

func texture*(this: ParamTextureSampler): Texture {.importcpp: "#->get_texture()".} ## \
## Retrieves the texture stored in the parameter.

func sampler*(this: ParamTextureSampler): SamplerState {.importcpp: "#->get_sampler()".} ## \
## Retrieves the sampler state stored in the parameter.

func texture*(this: ParamTextureImage): Texture {.importcpp: "#->get_texture()".} ## \
## Retrieves the texture stored in the parameter.

func read_access*(this: ParamTextureImage): bool {.importcpp: "#->has_read_access()".} ## \
## Returns true if this image should be bound with read access enabled.

func write_access*(this: ParamTextureImage): bool {.importcpp: "#->has_write_access()".} ## \
## Returns true if this image should be bound with write access enabled.

func bind_level*(this: ParamTextureImage): int {.importcpp: "#->get_bind_level()".} ## \
## Returns the image level that should be bound.

func bind_layer*(this: ParamTextureImage): int {.importcpp: "#->get_bind_layer()".} ## \
## Returns the image layer that should be bound.  This is undefined if
## get_bind_layered() returns false.

func texture*(this: TextureReloadRequest): Texture {.importcpp: "#->get_texture()".} ## \
## Returns the Texture object associated with this asynchronous
## TextureReloadRequest.

func shader*(this: ShaderContext): Shader {.importcpp: "#.get_shader()".}

func video_width*(this: VideoTexture): int {.importcpp: "#->get_video_width()".} ## \
## Returns the width in texels of the source video stream.  This is not
## necessarily the width of the actual texture, since the texture may have
## been expanded to raise it to a power of 2.

func video_height*(this: VideoTexture): int {.importcpp: "#->get_video_height()".} ## \
## Returns the height in texels of the source video stream.  This is not
## necessarily the height of the actual texture, since the texture may have
## been expanded to raise it to a power of 2.

func x*(this: LVecBase2f): float32 {.importcpp: "#.get_x()".}

proc `x=`*(this: LVecBase2f, value: float32) {.importcpp: "#.set_x(#)".}

func y*(this: LVecBase2f): float32 {.importcpp: "#.get_y()".}

proc `y=`*(this: LVecBase2f, value: float32) {.importcpp: "#.set_y(#)".}

func x*(this: LVecBase2d): float64 {.importcpp: "#.get_x()".}

proc `x=`*(this: LVecBase2d, value: float64) {.importcpp: "#.set_x(#)".}

func y*(this: LVecBase2d): float64 {.importcpp: "#.get_y()".}

proc `y=`*(this: LVecBase2d, value: float64) {.importcpp: "#.set_y(#)".}

func x*(this: LVecBase2i): int {.importcpp: "#.get_x()".}

proc `x=`*(this: LVecBase2i, value: int) {.importcpp: "#.set_x(#)".}

func y*(this: LVecBase2i): int {.importcpp: "#.get_y()".}

proc `y=`*(this: LVecBase2i, value: int) {.importcpp: "#.set_y(#)".}

func x*(this: LVecBase3f): float32 {.importcpp: "#.get_x()".}

proc `x=`*(this: LVecBase3f, value: float32) {.importcpp: "#.set_x(#)".}

func y*(this: LVecBase3f): float32 {.importcpp: "#.get_y()".}

proc `y=`*(this: LVecBase3f, value: float32) {.importcpp: "#.set_y(#)".}

func z*(this: LVecBase3f): float32 {.importcpp: "#.get_z()".}

proc `z=`*(this: LVecBase3f, value: float32) {.importcpp: "#.set_z(#)".}

func xy*(this: LVecBase3f): LVecBase2f {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

func xz*(this: LVecBase3f): LVecBase2f {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

func yz*(this: LVecBase3f): LVecBase2f {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

func x*(this: LVecBase3d): float64 {.importcpp: "#.get_x()".}

proc `x=`*(this: LVecBase3d, value: float64) {.importcpp: "#.set_x(#)".}

func y*(this: LVecBase3d): float64 {.importcpp: "#.get_y()".}

proc `y=`*(this: LVecBase3d, value: float64) {.importcpp: "#.set_y(#)".}

func z*(this: LVecBase3d): float64 {.importcpp: "#.get_z()".}

proc `z=`*(this: LVecBase3d, value: float64) {.importcpp: "#.set_z(#)".}

func xy*(this: LVecBase3d): LVecBase2d {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

func xz*(this: LVecBase3d): LVecBase2d {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

func yz*(this: LVecBase3d): LVecBase2d {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

func x*(this: LVecBase3i): int {.importcpp: "#.get_x()".}

proc `x=`*(this: LVecBase3i, value: int) {.importcpp: "#.set_x(#)".}

func y*(this: LVecBase3i): int {.importcpp: "#.get_y()".}

proc `y=`*(this: LVecBase3i, value: int) {.importcpp: "#.set_y(#)".}

func z*(this: LVecBase3i): int {.importcpp: "#.get_z()".}

proc `z=`*(this: LVecBase3i, value: int) {.importcpp: "#.set_z(#)".}

func xy*(this: LVecBase3i): LVecBase2i {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

func xz*(this: LVecBase3i): LVecBase2i {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

func yz*(this: LVecBase3i): LVecBase2i {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

func xy*(this: LVector3f): LVector2f {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

func xz*(this: LVector3f): LVector2f {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

func yz*(this: LVector3f): LVector2f {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

func xy*(this: LVector3d): LVector2d {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

func xz*(this: LVector3d): LVector2d {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

func yz*(this: LVector3d): LVector2d {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

func xy*(this: LVector3i): LVector2i {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

func xz*(this: LVector3i): LVector2i {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

func yz*(this: LVector3i): LVector2i {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

func xy*(this: LPoint3f): LPoint2f {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

func xz*(this: LPoint3f): LPoint2f {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

func yz*(this: LPoint3f): LPoint2f {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

func xy*(this: LPoint3d): LPoint2d {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

func xz*(this: LPoint3d): LPoint2d {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

func yz*(this: LPoint3d): LPoint2d {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

func xy*(this: LPoint3i): LPoint2i {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

func xz*(this: LPoint3i): LPoint2i {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

func yz*(this: LPoint3i): LPoint2i {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

func x*(this: LVecBase4f): float32 {.importcpp: "#.get_x()".}

proc `x=`*(this: LVecBase4f, value: float32) {.importcpp: "#.set_x(#)".}

func y*(this: LVecBase4f): float32 {.importcpp: "#.get_y()".}

proc `y=`*(this: LVecBase4f, value: float32) {.importcpp: "#.set_y(#)".}

func z*(this: LVecBase4f): float32 {.importcpp: "#.get_z()".}

proc `z=`*(this: LVecBase4f, value: float32) {.importcpp: "#.set_z(#)".}

func xyz*(this: LVecBase4f): LVecBase3f {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

func xy*(this: LVecBase4f): LVecBase2f {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

func x*(this: LVecBase4d): float64 {.importcpp: "#.get_x()".}

proc `x=`*(this: LVecBase4d, value: float64) {.importcpp: "#.set_x(#)".}

func y*(this: LVecBase4d): float64 {.importcpp: "#.get_y()".}

proc `y=`*(this: LVecBase4d, value: float64) {.importcpp: "#.set_y(#)".}

func z*(this: LVecBase4d): float64 {.importcpp: "#.get_z()".}

proc `z=`*(this: LVecBase4d, value: float64) {.importcpp: "#.set_z(#)".}

func xyz*(this: LVecBase4d): LVecBase3d {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

func xy*(this: LVecBase4d): LVecBase2d {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

func x*(this: LVecBase4i): int {.importcpp: "#.get_x()".}

proc `x=`*(this: LVecBase4i, value: int) {.importcpp: "#.set_x(#)".}

func y*(this: LVecBase4i): int {.importcpp: "#.get_y()".}

proc `y=`*(this: LVecBase4i, value: int) {.importcpp: "#.set_y(#)".}

func z*(this: LVecBase4i): int {.importcpp: "#.get_z()".}

proc `z=`*(this: LVecBase4i, value: int) {.importcpp: "#.set_z(#)".}

func xyz*(this: LVecBase4i): LVecBase3i {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

func xy*(this: LVecBase4i): LVecBase2i {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

func xyz*(this: LVector4f): LVector3f {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

func xy*(this: LVector4f): LVector2f {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

func xyz*(this: LVector4d): LVector3d {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

func xy*(this: LVector4d): LVector2d {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

func xyz*(this: LVector4i): LVector3i {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

func xy*(this: LVector4i): LVector2i {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

func xyz*(this: LPoint4f): LPoint3f {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

func xy*(this: LPoint4f): LPoint2f {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

func xyz*(this: LPoint4d): LPoint3d {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

func xy*(this: LPoint4d): LPoint2d {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

func xyz*(this: LPoint4i): LPoint3i {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

func xy*(this: LPoint4i): LPoint2i {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

func min*(this: FiniteBoundingVolume): LPoint3 {.importcpp: "#->get_min()".}

func max*(this: FiniteBoundingVolume): LPoint3 {.importcpp: "#->get_max()".}

func volume*(this: FiniteBoundingVolume): float32 {.importcpp: "#->get_volume()".}

func plane*(this: BoundingPlane): LPlane {.importcpp: "#->get_plane()".}

func center*(this: BoundingSphere): LPoint3 {.importcpp: "#->get_center()".}

proc `center=`*(this: BoundingSphere, center: LPoint3) {.importcpp: "#->set_center(#)".} ## \
## Sets the center point of the sphere.

func radius*(this: BoundingSphere): float32 {.importcpp: "#->get_radius()".}

proc `radius=`*(this: BoundingSphere, radius: float32) {.importcpp: "#->set_radius(#)".} ## \
## Sets the radius of the sphere.

func plane*(this: Triangulator3): LPlaned {.importcpp: "#.get_plane()".} ## \
## Returns the plane of the polygon.  This is only available after calling
## triangulate().

func xyz_curve*(this: ParametricCurveCollection): ParametricCurve {.importcpp: "#->get_xyz_curve()".} ## \
## Returns the first XYZ curve in the collection, if any, or NULL if there are
## none.

func hpr_curve*(this: ParametricCurveCollection): ParametricCurve {.importcpp: "#->get_hpr_curve()".} ## \
## Returns the first HPR curve in the collection, if any, or NULL if there are
## none.

func default_curve*(this: ParametricCurveCollection): ParametricCurve {.importcpp: "#->get_default_curve()".} ## \
## If there is an XYZ curve in the collection, returns it; otherwise, returns
## the first curve whose type is unspecified.  Returns NULL if no curve meets
## the criteria.

func max_t*(this: ParametricCurveCollection): float32 {.importcpp: "#->get_max_t()".} ## \
## Returns the maximum T value associated with the *last* curve in the
## collection.  Normally, this will be either the XYZ or HPR curve, or a
## timewarp curve.

func u_order*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_u_order()".} ## \
## Returns the order of the surface in the U direction as set by a previous
## call to set_u_order().

proc `u_order=`*(this: NurbsSurfaceEvaluator, u_order: int) {.importcpp: "#->set_u_order(#)".} ## \
## Sets the order of the surface in the U direction.  This resets the knot
## vector to the default knot vector for the number of vertices.
##
## The order must be 1, 2, 3, or 4, and the value is one more than the degree
## of the surface.

func v_order*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_v_order()".} ## \
## Returns the order of the surface in the V direction as set by a previous
## call to set_v_order().

proc `v_order=`*(this: NurbsSurfaceEvaluator, v_order: int) {.importcpp: "#->set_v_order(#)".} ## \
## Sets the order of the surface in the V direction.  This resets the knot
## vector to the default knot vector for the number of vertices.
##
## The order must be 1, 2, 3, or 4, and the value is one more than the degree
## of the surface.

func curve*(this: RopeNode): NurbsCurveEvaluator {.importcpp: "#->get_curve()".} ## \
## Returns the curve represented by the RopeNode.

proc `curve=`*(this: RopeNode, curve: NurbsCurveEvaluator) {.importcpp: "#->set_curve(#)".} ## \
## Sets the particular curve represented by the RopeNode.

func uv_direction*(this: RopeNode): bool {.importcpp: "#->get_uv_direction()".} ## \
## Returns true if the rope runs down the U coordinate of the texture, or
## false if it runs down the V coordinate.

proc `uv_direction=`*(this: RopeNode, u_dominant: bool) {.importcpp: "#->set_uv_direction(#)".} ## \
## Specify true to vary the U coordinate down the length of the rope, or false
## to vary the V coordinate.

func uv_scale*(this: RopeNode): float32 {.importcpp: "#->get_uv_scale()".} ## \
## Returns the scaling factor to apply to generated UV's for the rope.

proc `uv_scale=`*(this: RopeNode, scale: float32) {.importcpp: "#->set_uv_scale(#)".} ## \
## Specifies an additional scaling factor to apply to generated UV's along the
## rope.  This scale factor is applied in whichever direction is along the
## rope, as specified by set_uv_direction().

func tube_up*(this: RopeNode): LVector3 {.importcpp: "#->get_tube_up()".} ## \
## Returns the normal vector used to control the "top" of the curve, when
## RenderMode is RM_tube.  See set_tube_up().

proc `tube_up=`*(this: RopeNode, tube_up: LVector3) {.importcpp: "#->set_tube_up(#)".} ## \
## Specifies a normal vector, generally perpendicular to the main axis of the
## starting point of the curve, that controls the "top" of the curve, when
## RenderMode is RM_tube.  This is used to orient the vertices that make up
## the tube.  If this vector is too nearly parallel with the starting
## direction of the curve, there may be a tendency for the whole tube to
## gimble-lock around its primary axis.

func use_vertex_color*(this: RopeNode): bool {.importcpp: "#->get_use_vertex_color()".} ## \
## Returns the "use vertex color" flag.  See set_use_vertex_color().

proc `use_vertex_color=`*(this: RopeNode, flag: bool) {.importcpp: "#->set_use_vertex_color(#)".} ## \
## Sets the "use vertex color" flag.  When this is true, the R, G, B, A vertex
## color is assumed to be stored as the dimensions n + 0, n + 1, n + 2, n + 3,
## respectively, of the extended vertex values, where n is the value returned
## by get_vertex_color_dimension().  Use
## NurbsCurveEvaluator::set_extended_vertex() to set these values.

func vertex_color_dimension*(_: typedesc[RopeNode]): int {.importcpp: "RopeNode::get_vertex_color_dimension()", header: "ropeNode.h".} ## \
## Returns the numeric extended dimension in which the color components should
## be found.  See NurbsCurveEvaluator::set_extended_vertex().
##
## The color components will be expected at (n, n + 1, n + 2, n + 3).

func num_subdiv*(this: RopeNode): int {.importcpp: "#->get_num_subdiv()".} ## \
## Returns the number of subdivisions per cubic segment to draw.  See
## set_num_subdiv().

proc `num_subdiv=`*(this: RopeNode, num_subdiv: int) {.importcpp: "#->set_num_subdiv(#)".} ## \
## Specifies the number of subdivisions per cubic segment (that is, per unique
## knot value) to draw in a fixed uniform tesselation of the curve.

func num_slices*(this: RopeNode): int {.importcpp: "#->get_num_slices()".} ## \
## Returns the number of radial subdivisions to make if RenderMode is RM_tube.
## It is ignored in the other render modes.  See set_num_slices().

proc `num_slices=`*(this: RopeNode, num_slices: int) {.importcpp: "#->set_num_slices(#)".} ## \
## Specifies the number of radial subdivisions to make if RenderMode is
## RM_tube.  It is ignored in the other render modes.
##
## Increasing this number increases the roundness of a cross-section of the
## tube.  The minimum value for a dimensional tube is 3; setting it to 2 will
## get you a thin piece of tape (which is similar to RM_billboard, except it
## won't rotate to face the camera).

func use_vertex_thickness*(this: RopeNode): bool {.importcpp: "#->get_use_vertex_thickness()".} ## \
## Returns the "use vertex thickness" flag.  See set_use_vertex_thickness().

proc `use_vertex_thickness=`*(this: RopeNode, flag: bool) {.importcpp: "#->set_use_vertex_thickness(#)".} ## \
## Sets the "use vertex thickness" flag.  When this is true, the vertex
## thickness is assumed to be stored as the dimension
## get_vertex_thickness_dimension(), of the extended vertex values.  Use
## NurbsCurveEvaluator::set_extended_vertex() to set these values.
##
## In this mode, the overall thickness is also applied as a scale to the
## vertex thickness.  Not all render modes support vertex thickness.

func vertex_thickness_dimension*(_: typedesc[RopeNode]): int {.importcpp: "RopeNode::get_vertex_thickness_dimension()", header: "ropeNode.h".} ## \
## Returns the numeric extended dimension in which the thickness component
## should be found.  See NurbsCurveEvaluator::set_extended_vertex().

func thickness*(this: RopeNode): float32 {.importcpp: "#->get_thickness()".} ## \
## Returns the thickness of the rope.  See set_thickness().

proc `thickness=`*(this: RopeNode, thickness: float32) {.importcpp: "#->set_thickness(#)".} ## \
## Specifies the thickness of the rope, in pixels or in spatial units,
## depending on the render mode.  See set_render_mode().
##
## The thickness may also be specified on a per-vertex basis.  See
## set_use_vertex_thickness().

func matrix*(this: RopeNode): LMatrix4 {.importcpp: "#->get_matrix()".} ## \
## Returns the optional matrix which is used to transform each control vertex
## after it has been transformed into the RopeNode's coordinate space, but
## before the polygon vertices are generated.

proc `matrix=`*(this: RopeNode, matrix: LMatrix4) {.importcpp: "#->set_matrix(#)".} ## \
## Specifies an optional matrix which is used to transform each control vertex
## after it has been transformed into the RopeNode's coordinate space, but
## before the polygon vertices are generated.

func name*(this: PNMFileType): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.}

func suggested_extension*(this: PNMFileType): string {.importcpp: "nimStringFromStdString(#.get_suggested_extension())", header: stringConversionCode.} ## \
## Returns a suitable filename extension (without a leading dot) to suggest
## for files of this type, or empty string if no suggestions are available.

func num_channels*(this: PNMImageHeader): int {.importcpp: "#.get_num_channels()".} ## \
## Returns the number of channels in the image.

func maxval*(this: PNMImageHeader): int {.importcpp: "#.get_maxval()".} ## \
## Returns the maximum channel value allowable for any pixel in this image;
## for instance, 255 for a typical 8-bit-per-channel image.  A pixel with this
## value is full on.

func color_space*(this: PNMImageHeader): ColorSpace {.importcpp: "#.get_color_space()".} ## \
## Returns the color space that the image is encoded in, or CS_unspecified if
## unknown.

func size*(this: PNMImageHeader): LVecBase2i {.importcpp: "#.get_size()".} ## \
## Returns the number of pixels in each direction.  This is one more than the
## largest allowable coordinates.

func comment*(this: PNMImageHeader): string {.importcpp: "nimStringFromStdString(#.get_comment())", header: stringConversionCode.} ## \
## Gets the user comment from the file.

proc `comment=`*(this: PNMImageHeader, comment: string) {.importcpp: "#.set_comment(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Writes a user comment string to the image (header).

func valid*(this: PfmFile): bool {.importcpp: "#.is_valid()".}

func scale*(this: PfmFile): float32 {.importcpp: "#.get_scale()".} ## \
## The "scale" is reported in the pfm header and is probably meaningless.

proc `scale=`*(this: PfmFile, scale: float32) {.importcpp: "#.set_scale(#)".} ## \
## The "scale" is reported in the pfm header and is probably meaningless.

func pen*(this: PNMPainter): PNMBrush {.importcpp: "#.get_pen()".} ## \
## Returns the current pen.  See set_pen().

proc `pen=`*(this: PNMPainter, pen: PNMBrush) {.importcpp: "#.set_pen(#)".} ## \
## Specifies a PNMBrush that will be used for drawing lines and edges.  If the
## brush is a bitmap brush, its image will be smeared pixelwise along the
## line.
##
## Unlike the PNMImage passed to the constructor, the PNMPainter will take
## ownership of the pen.  It is not necessary to keep a separate pointer to
## it.

func fill*(this: PNMPainter): PNMBrush {.importcpp: "#.get_fill()".} ## \
## Returns the current fill brush.  See set_fill().

proc `fill=`*(this: PNMPainter, fill: PNMBrush) {.importcpp: "#.set_fill(#)".} ## \
## Specifies a PNMBrush that will be used for filling in the interiors of
## objects.  If the brush is a bitmap brush, its image will be tiled
## throughout the space.
##
## Unlike the PNMImage passed to the constructor, the PNMPainter will take
## ownership of the fill brush.  It is not necessary to keep a separate
## pointer to it.

func character*(this: TextGlyph): int {.importcpp: "#->get_character()".} ## \
## Returns the Unicode value that corresponds to the character this glyph
## represents.

func state*(this: TextGlyph): RenderState {.importcpp: "#->get_state()".} ## \
## Returns the state in which the glyph should be rendered.

func advance*(this: TextGlyph): float32 {.importcpp: "#->get_advance()".} ## \
## Returns the distance by which the character pointer should be advanced
## after placing this character; i.e.  the approximate width the character
## takes up on the line.

func valid*(this: TextFont): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the font is valid and ready to use, false otherwise.

func line_height*(this: TextFont): float32 {.importcpp: "#->get_line_height()".} ## \
## Returns the number of units high each line of text is.

proc `line_height=`*(this: TextFont, line_height: float32) {.importcpp: "#->set_line_height(#)".} ## \
## Changes the number of units high each line of text is.

func space_advance*(this: TextFont): float32 {.importcpp: "#->get_space_advance()".} ## \
## Returns the number of units wide a space is.

proc `space_advance=`*(this: TextFont, space_advance: float32) {.importcpp: "#->set_space_advance(#)".} ## \
## Changes the number of units wide a space is.

func page*(this: DynamicTextGlyph): DynamicTextPage {.importcpp: "#->get_page()".} ## \
## Returns the DynamicTextPage that this glyph is on.

func point_size*(this: DynamicTextFont): float32 {.importcpp: "#->get_point_size()".} ## \
## Returns the point size of the font.

proc `point_size=`*(this: DynamicTextFont, point_size: float32): bool {.importcpp: "#->set_point_size(#)".} ## \
## Sets the point size of the font.  This controls the apparent size of the
## font onscreen.  By convention, a 10 point font is about 1 screen unit high.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

func pixels_per_unit*(this: DynamicTextFont): float32 {.importcpp: "#->get_pixels_per_unit()".} ## \
## Returns the resolution of the texture map.  See set_pixels_per_unit().

proc `pixels_per_unit=`*(this: DynamicTextFont, pixels_per_unit: float32): bool {.importcpp: "#->set_pixels_per_unit(#)".} ## \
## Set the resolution of the texture map, and hence the clarity of the
## resulting font.  This sets the number of pixels in the texture map that are
## used for each onscreen unit.
##
## Setting this number larger results in an easier to read font, but at the
## cost of more texture memory.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

func scale_factor*(this: DynamicTextFont): float32 {.importcpp: "#->get_scale_factor()".} ## \
## Returns the antialiasing scale factor.  See set_scale_factor().

proc `scale_factor=`*(this: DynamicTextFont, scale_factor: float32): bool {.importcpp: "#->set_scale_factor(#)".} ## \
## Sets the factor by which the font is rendered larger by the FreeType
## library before being filtered down to its actual size in the texture as
## specified by set_pixels_per_unit().  This may be set to a number larger
## than 1.0 to improve the font's antialiasing (since FreeType doesn't really
## do a swell job of antialiasing by itself).  There is some performance
## implication for setting this different than 1.0, but it is probably small.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

func native_antialias*(this: DynamicTextFont): bool {.importcpp: "#->get_native_antialias()".} ## \
## Returns whether Freetype's built-in antialias mode is enabled.  See
## set_native_antialias().

proc `native_antialias=`*(this: DynamicTextFont, native_antialias: bool) {.importcpp: "#->set_native_antialias(#)".} ## \
## Sets whether the Freetype library's built-in antialias mode is enabled.
## There are two unrelated ways to achieve antialiasing: with Freetype's
## native antialias mode, and with the use of a scale_factor greater than one.
## By default, both modes are enabled.
##
## At low resolutions, some fonts may do better with one mode or the other.
## In general, Freetype's native antialiasing will produce less blurry
## results, but may introduce more artifacts.

func font_pixel_size*(this: DynamicTextFont): int {.importcpp: "#->get_font_pixel_size()".} ## \
## This is used to report whether the requested pixel size is being only
## approximated by a fixed-pixel-size font.  This returns 0 in the normal
## case, in which a scalable font is used, or the fixed-pixel-size font has
## exactly the requested pixel size.
##
## If this returns non-zero, it is the pixel size of the font that we are
## using to approximate our desired size.

func texture_margin*(this: DynamicTextFont): int {.importcpp: "#->get_texture_margin()".} ## \
## Returns the number of pixels of padding that is added around the border of
## each glyph in the texture map.  See set_texture_margin().

proc `texture_margin=`*(this: DynamicTextFont, texture_margin: int) {.importcpp: "#->set_texture_margin(#)".} ## \
## Sets the number of pixels of padding that is added around the border of
## each glyph before adding it to the texture map.  This reduces the bleed in
## from neighboring glyphs in the texture map.

func poly_margin*(this: DynamicTextFont): float32 {.importcpp: "#->get_poly_margin()".} ## \
## Returns the number of pixels of padding that is included around each glyph
## in the generated polygons.  See set_poly_margin().

proc `poly_margin=`*(this: DynamicTextFont, poly_margin: float32) {.importcpp: "#->set_poly_margin(#)".} ## \
## Sets the number of pixels of padding that is included around each glyph in
## the generated polygons.  This helps prevent the edges of the glyphs from
## being cut off at small minifications.  It is not related to the amount of
## extra pixels reserved in the texture map (but it should be set somewhat
## smaller than this number, which is controlled by set_texture_margin(), to
## prevent bleed-in from neighboring letters in the texture).

func page_size*(this: DynamicTextFont): LVecBase2i {.importcpp: "#->get_page_size()".} ## \
## Returns the size of the textures that are created for the DynamicTextFont.
## See set_page_size().

proc `page_size=`*(this: DynamicTextFont, page_size: LVecBase2i) {.importcpp: "#->set_page_size(#)".} ## \
## Sets the x, y size of the textures that are created for the
## DynamicTextFont.

proc `page_size=`*(this: DynamicTextFont, x_size: int, y_size: int) {.importcpp: "#->set_page_size(#, #)".} ## \
## Sets the x, y size of the textures that are created for the
## DynamicTextFont.

func anisotropic_degree*(this: DynamicTextFont): int {.importcpp: "#->get_anisotropic_degree()".} ## \
## Returns the current anisotropic degree for textures created for this font.
## See set_anisotropic_degree().

proc `anisotropic_degree=`*(this: DynamicTextFont, anisotropic_degree: int) {.importcpp: "#->set_anisotropic_degree(#)".} ## \
## Enables or disables anisotropic filtering on the textures created for this
## font.  The default value is specified by the text-anisotropic-degree
## variable.  See Texture::set_anisotropic_degree().

func fg*(this: DynamicTextFont): LColor {.importcpp: "#->get_fg()".} ## \
## Returns the color of the foreground pixels of the font as they are rendered
## into the font texture.  See set_fg().

proc `fg=`*(this: DynamicTextFont, fg: LColor) {.importcpp: "#->set_fg(#)".} ## \
## Changes the color of the foreground pixels of the font as they are rendered
## into the font texture.  The default is (1, 1, 1, 1), or opaque white, which
## allows text created with the font to be colored individually.  Normally,
## you would not change this unless you really need a particular color effect
## to appear in the font itself.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

func bg*(this: DynamicTextFont): LColor {.importcpp: "#->get_bg()".} ## \
## Returns the color of the background pixels of the font as they are rendered
## into the font texture.  See set_bg().

proc `bg=`*(this: DynamicTextFont, bg: LColor) {.importcpp: "#->set_bg(#)".} ## \
## Changes the color of the background pixels of the font as they are rendered
## into the font texture.  The default is (1, 1, 1, 0), or transparent white,
## which allows text created with the font to be colored individually.  (Note
## that it should not generally be (0, 0, 0, 0), which would tend to bleed
## into the foreground color, unless you have also specified a outline color
## of (0, 0, 0, 1)) .
##
## Normally, you would not change this unless you really need a particular
## color effect to appear in the font itself.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

func model*(this: TextGraphic): NodePath {.importcpp: "#.get_model()".} ## \
## Returns the NodePath associated with the graphic, that renders the desired
## image.

proc `model=`*(this: TextGraphic, model: NodePath) {.importcpp: "#.set_model(#)".} ## \
## Changes the NodePath associated with the graphic.  This NodePath should
## contain geometry that will render the desired graphic image.

func frame*(this: TextGraphic): LVecBase4 {.importcpp: "#.get_frame()".} ## \
## Returns the frame specified for the graphic.  This is the amount of space
## that will be reserved for the graphic when it is embedded in a text
## paragraph, in the form (left, right, bottom, top).
##
## The actual graphic, as rendered by the NodePath specified via set_model(),
## should more or less fit within this rectangle.  It is not required to fit
## completely within it, but if it does not, it may visually overlap with
## nearby text.

proc `frame=`*(this: TextGraphic, frame: LVecBase4) {.importcpp: "#.set_frame(#)".} ## \
## Specifies the (left, right, bottom, top) bounding frame for the graphic.
## See get_frame().

proc `frame=`*(this: TextGraphic, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#.set_frame(#, #, #, #)".} ## \
## Specifies the (left, right, bottom, top) bounding frame for the graphic.
## See get_frame().

func instance_flag*(this: TextGraphic): bool {.importcpp: "#.get_instance_flag()".} ## \
## Returns the instance_flag.  See set_instance_flag().

proc `instance_flag=`*(this: TextGraphic, instance_flag: bool) {.importcpp: "#.set_instance_flag(#)".} ## \
## Sets the instance_flag.  When this is true, the graphic is directly
## instanced to the scene graph whenever it appears; when it is false, the
## graphic is copied.  The default is false, which is best for most
## applications.  You might need to set it true for special kinds of
## "graphics" like interactive elements, for instance a PGEntry.

func max_rows*(this: TextAssembler): int {.importcpp: "#.get_max_rows()".} ## \
## If max_rows is greater than zero, no more than max_rows will be accepted.
## Text beyond that will be truncated.

proc `max_rows=`*(this: TextAssembler, max_rows: int) {.importcpp: "#.set_max_rows(#)".} ## \
## If max_rows is greater than zero, no more than max_rows will be accepted.
## Text beyond that will be truncated.
##
## Setting this will not truncate text immediately.  You must follow this up
## with a call to set_wtext() to truncate the existing text.

func dynamic_merge*(this: TextAssembler): bool {.importcpp: "#.get_dynamic_merge()".} ## \
## Returns the dynamic_merge flag.  See TextNode::set_flatten_flags().

proc `dynamic_merge=`*(this: TextAssembler, dynamic_merge: bool) {.importcpp: "#.set_dynamic_merge(#)".} ## \
## Sets the dynamic_merge flag.  See TextNode::set_flatten_flags().

func multiline_mode*(this: TextAssembler): bool {.importcpp: "#.get_multiline_mode()".} ## \
## Returns the multline_mode flag.  See TextNode::set_multiline_mode().

proc `multiline_mode=`*(this: TextAssembler, flag: bool) {.importcpp: "#.set_multiline_mode(#)".} ## \
## Sets the multiline mode flag.  Set the multiline mode to allow text to
## wrap.  It defaults to true.

func properties*(this: TextAssembler): TextProperties {.importcpp: "#.get_properties()".} ## \
## Returns the default TextProperties that are applied to the text in the
## absence of any nested property change sequences.

func properties*(this: TextAssembler, n: int): TextProperties {.importcpp: "#.get_properties(#)".} ## \
## Returns the TextProperties in effect for the object at the indicated
## position in the pre-wordwrapped string.

func properties*(this: TextAssembler, r: int, c: int): TextProperties {.importcpp: "#.get_properties(#, #)".} ## \
## Returns the TextProperties in effect for the object at the indicated
## position in the indicated row.

proc `properties=`*(this: TextAssembler, properties: TextProperties) {.importcpp: "#.set_properties(#)".} ## \
## Specifies the default TextProperties that are applied to the text in the
## absence of any nested property change sequences.

func button_down_event*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_button_down_event())", header: stringConversionCode.} ## \
## Returns the button_down_event that has been set on this ButtonThrower.  See
## set_button_down_event().

proc `button_down_event=`*(this: ButtonThrower, button_down_event: string) {.importcpp: "#->set_button_down_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the generic event that is generated (if any) each time a key or
## button is depressed.  Unlike the specific events that are unique to each
## key, this same event name is used for *all* button events, and the name of
## the button pressed (possibly with modifier prefixes) will be sent as a
## parameter.
##
## If this string is empty, no event is generated.  It is possible to generate
## both generic events and specific events for the same button.
##
## See also set_keystroke_event().

func button_up_event*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_button_up_event())", header: stringConversionCode.} ## \
## Returns the button_up_event that has been set on this ButtonThrower.  See
## set_button_up_event().

proc `button_up_event=`*(this: ButtonThrower, button_up_event: string) {.importcpp: "#->set_button_up_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the generic event that is generated (if any) each time a key or
## button is released.  See set_button_down_event().

func button_repeat_event*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_button_repeat_event())", header: stringConversionCode.} ## \
## Returns the button_repeat_event that has been set on this ButtonThrower.
## See set_button_repeat_event().

proc `button_repeat_event=`*(this: ButtonThrower, button_repeat_event: string) {.importcpp: "#->set_button_repeat_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the generic event that is generated (if any) repeatedly while a
## key or button is held down.  Unlike the specific events that are unique to
## each key, this same event name is used for *all* button events, and the
## name of the button pressed (possibly with modifier prefixes) will be sent
## as a parameter.
##
## If this string is empty, no event is generated.  It is possible to generate
## both generic events and specific events for the same button.
##
## See also set_keystroke_event().

func keystroke_event*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_keystroke_event())", header: stringConversionCode.} ## \
## Returns the keystroke_event that has been set on this ButtonThrower.  See
## set_keystroke_event().

proc `keystroke_event=`*(this: ButtonThrower, keystroke_event: string) {.importcpp: "#->set_keystroke_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the event that is generated (if any) for each keystroke that is
## received.  A keystroke is different than a button event: it represents the
## semantic meaning of the sequence of keys that have been pressed.  For
## instance, pressing shift and 4 together will generate the button event
## "shift-4", but it will generate the keystroke "$".
##
## If a key is held down, keyrepeat will cause the same keystroke event to be
## generated repeatedly.  This is different from the corresponding down event,
## which will only be generated once, followed by a number of button repeat
## events.
##
## This event is generated with a single wstring parameter, which is a one-
## character string that contains the keystroke generated.  If this event
## string is empty, no event is generated.
##
## See also set_button_down_event().

func candidate_event*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_candidate_event())", header: stringConversionCode.} ## \
## Returns the candidate_event that has been set on this ButtonThrower.  See
## set_candidate_event().

proc `candidate_event=`*(this: ButtonThrower, candidate_event: string) {.importcpp: "#->set_candidate_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the event that is generated (if any) for each IME candidate
## string event received.  Events of this nature are received only when the
## user is entering data using a Microsoft Input Method Editor, typically used
## for Asian languages such as Japanese or Korean.
##
## If you are designing a typing user interface, you should track this event
## to support the use of the IME.  In response to this event, you should
## display the candidate string in the entry box, with the appropriate
## sections highlighted, so the user can scroll through the available choices.
##
## This event is generated with four parameters, in order: the candidate
## string, the character at which to start the highlight, the character at
## which to end the highlight, and the current cursor position.

func move_event*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_move_event())", header: stringConversionCode.} ## \
## Returns the move_event that has been set on this ButtonThrower.  See
## set_move_event().

proc `move_event=`*(this: ButtonThrower, move_event: string) {.importcpp: "#->set_move_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the event that is generated (if any) each time the mouse is moved
## within the window.

func raw_button_down_event*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_raw_button_down_event())", header: stringConversionCode.} ## \
## Returns the raw_button_down_event that has been set on this ButtonThrower.
## See set_raw_button_down_event().

proc `raw_button_down_event=`*(this: ButtonThrower, raw_button_down_event: string) {.importcpp: "#->set_raw_button_down_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Like set_button_down_event, but uses the raw, untransformed scan key from
## the operating system.  This uses buttons that are independent of the user's
## selected keyboard layout.

func raw_button_up_event*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_raw_button_up_event())", header: stringConversionCode.} ## \
## Returns the raw_button_up_event that has been set on this ButtonThrower.
## See set_raw_button_up_event().

proc `raw_button_up_event=`*(this: ButtonThrower, raw_button_up_event: string) {.importcpp: "#->set_raw_button_up_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the generic event that is generated (if any) each time a key or
## button is released.  See set_raw_button_down_event().

func prefix*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_prefix())", header: stringConversionCode.} ## \
## Returns the prefix that has been set on this ButtonThrower.  See
## set_prefix().

proc `prefix=`*(this: ButtonThrower, prefix: string) {.importcpp: "#->set_prefix(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the prefix which is prepended to all specific event names (that is,
## event names generated from the button name itself, as opposed to the
## generic event names like set_button_down_event) thrown by this object.

func specific_flag*(this: ButtonThrower): bool {.importcpp: "#->get_specific_flag()".} ## \
## Returns the flag that indicates whether specific events should be
## generated.  See set_specific_flag().

proc `specific_flag=`*(this: ButtonThrower, specific_flag: bool) {.importcpp: "#->set_specific_flag(#)".} ## \
## Sets the flag that indicates whether specific events (events prefixed by
## set_prefix, and based on the event name) should be generated at all.  This
## is true by default, but may be disabled if you are only interested in the
## generic events (for instance, events like set_button_down_event).

func time_flag*(this: ButtonThrower): bool {.importcpp: "#->get_time_flag()".} ## \
## Returns the flag that indicates whether the time of the button event should
## be passed as a parameter.

proc `time_flag=`*(this: ButtonThrower, time_flag: bool) {.importcpp: "#->set_time_flag(#)".} ## \
## Sets the flag that indicates whether the time of the button event should be
## passed as a parameter or not.  When this is true, an additional parameter
## is generated on each event (before all the parameters named by
## add_parameter) that consists of a single double value, and reflects the
## time the button was pressed or released, as a value from
## ClockObject::get_global_clock().

func modifier_buttons*(this: ButtonThrower): ModifierButtons {.importcpp: "#->get_modifier_buttons()".} ## \
## Returns the set of ModifierButtons that the ButtonThrower will consider
## important enough to prepend the event name with.  Normally, this set will
## be empty, and the ButtonThrower will therefore ignore all ModifierButtons
## attached to the key events, but if one or more buttons have been added to
## this set, and those modifier buttons are set on the button event, then the
## event name will be prepended with the names of the modifier buttons.

proc `modifier_buttons=`*(this: ButtonThrower, mods: ModifierButtons) {.importcpp: "#->set_modifier_buttons(#)".} ## \
## Changes the set of ModifierButtons that the ButtonThrower will consider
## important enough to prepend the event name with.  Normally, this set will
## be empty, and the ButtonThrower will therefore ignore all ModifierButtons
## attached to the key events, but if one or more buttons have been added to
## this set, then the event name will be prepended with the names of the
## modifier buttons.
##
## It is recommended that you change this setting by first calling
## get_modifier_buttons(), making adjustments, and passing the new value to
## set_modifier_buttons().  This way the current state of the modifier buttons
## will not be lost.

func throw_buttons_active*(this: ButtonThrower): bool {.importcpp: "#->get_throw_buttons_active()".} ## \
## Returns the flag that indicates whether the ButtonThrower will only process
## events for the explicitly named buttons or not.  See
## set_throw_buttons_active().

proc `throw_buttons_active=`*(this: ButtonThrower, flag: bool) {.importcpp: "#->set_throw_buttons_active(#)".} ## \
## Sets the flag that indicates whether the ButtonThrower will only process
## events for the explicitly named buttons or not.  Normally this is false,
## meaning all buttons are processed; set it true to indicate that only some
## buttons should be processed.  See add_throw_button().

func frame*(this: MouseWatcherRegion): LVecBase4 {.importcpp: "#->get_frame()".}

proc `frame=`*(this: MouseWatcherRegion, frame: LVecBase4) {.importcpp: "#->set_frame(#)".}

proc `frame=`*(this: MouseWatcherRegion, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_frame(#, #, #, #)".}

func area*(this: MouseWatcherRegion): float32 {.importcpp: "#->get_area()".} ## \
## Returns the area of the rectangular region.

func sort*(this: MouseWatcherRegion): int {.importcpp: "#->get_sort()".} ## \
## Returns the current sorting order of this region.  See set_sort().

proc `sort=`*(this: MouseWatcherRegion, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Changes the sorting order of this particular region.  The sorting order is
## used to resolve conflicts in the case of overlapping region; the region
## with the highest sort value will be preferred, and between regions of the
## same sort value, the smallest region will be preferred.  The default
## sorting order, if none is explicitly specified, is 0.

func active*(this: MouseWatcherRegion): bool {.importcpp: "#->get_active()".} ## \
## Returns whether the region is active or not.  See set_active().

proc `active=`*(this: MouseWatcherRegion, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets whether the region is active or not.  If it is not active, the
## MouseWatcher will never consider the mouse to be over the region.  The
## region might still receive keypress events if its set_keyboard() flag is
## true.

func keyboard*(this: MouseWatcherRegion): bool {.importcpp: "#->get_keyboard()".} ## \
## Returns whether the region is interested in global keyboard events; see
## set_keyboard().

proc `keyboard=`*(this: MouseWatcherRegion, keyboard: bool) {.importcpp: "#->set_keyboard(#)".} ## \
## Sets whether the region is interested in global keyboard events.  If this
## is true, then any keyboard button events will be passed to press() and
## release() regardless of the position of the mouse onscreen; otherwise,
## these events will only be passed if the mouse is over the region.

func suppress_flags*(this: MouseWatcherRegion): int {.importcpp: "#->get_suppress_flags()".} ## \
## Returns the current suppress_flags.  See set_suppress_flags().

proc `suppress_flags=`*(this: MouseWatcherRegion, suppress_flags: int) {.importcpp: "#->set_suppress_flags(#)".} ## \
## Sets which events are suppressed when the mouse is over the region.  This
## is the union of zero or more various SF_* values.  Normally, this is 0,
## indicating that no events are suppressed.
##
## If you set this to a non-zero value, for instance SF_mouse_position, then
## the mouse position will not be sent along the data graph when the mouse is
## over this particular region.

func sorted*(this: MouseWatcherBase): bool {.importcpp: "#.is_sorted()".} ## \
## Returns true if the group has already been sorted, false otherwise.

func seq*(this: UpdateSeq): int {.importcpp: "#.get_seq()".} ## \
## Returns the internal integer value associated with the UpdateSeq.  Useful
## for debugging only.

func source_pathname*(this: BamCacheRecord): Filename {.importcpp: "#->get_source_pathname()".} ## \
## Returns the full pathname to the source file that originally generated this
## cache request.  In some cases, for instance in the case of a of a multipage
## texture like "cube_#.png", this may not not a true filename on disk.

func cache_filename*(this: BamCacheRecord): Filename {.importcpp: "#->get_cache_filename()".} ## \
## Returns the name of the cache file as hashed from the source_pathname.
## This will be relative to the root of the cache directory, and it will not
## include any suffixes that may be appended to resolve hash conflicts.

func source_timestamp*(this: BamCacheRecord): int {.importcpp: "#->get_source_timestamp()".} ## \
## Returns the file timestamp of the original source file that generated this
## cache record, if available.  In some cases the original file timestamp is
## not available, and this will return 0.

func recorded_time*(this: BamCacheRecord): int {.importcpp: "#->get_recorded_time()".} ## \
## Returns the time at which this particular record was recorded or updated.

func data*(this: BamCacheRecord): TypedWritable {.importcpp: "#->get_data()".} ## \
## Returns a pointer to the data stored in the record, or NULL if there is no
## data.  The pointer is not removed from the record.

proc `data=`*(this: BamCacheRecord, `ptr`: TypedWritable) {.importcpp: "#->set_data(#)".} ## \
## This variant on set_data() is provided to easily pass objects deriving from
## TypedWritable.

proc `data=`*(this: BamCacheRecord, `ptr`: TypedWritable, ref_ptr: ReferenceCount) {.importcpp: "#->set_data(#, #)".} ## \
## Stores a new data object on the record.  You should pass the same pointer
## twice, to both parameters; this allows the C++ typecasting to automatically
## convert the pointer into both a TypedWritable and a ReferenceCount pointer,
## so that the BamCacheRecord object can reliably manage the reference counts.
##
## You may pass 0 or NULL as the second parameter.  If you do this, the
## BamCacheRecord will not manage the object's reference count; it will be up
## to you to ensure the object is not deleted during the lifetime of the
## BamCacheRecord object.

proc `data=`*(this: BamCacheRecord, `ptr`: TypedWritable, dummy: int) {.importcpp: "#->set_data(#, #)".} ## \
## This variant on set_data() is provided just to allow Python code to pass a
## 0 as the second parameter.

proc `data=`*(this: BamCacheRecord, `ptr`: TypedWritableReferenceCount) {.importcpp: "#->set_data(#)".} ## \
## This variant on set_data() is provided to easily pass objects deriving from
## TypedWritableReferenceCount.

func active*(this: BamCache): bool {.importcpp: "#.get_active()".} ## \
## Returns true if the BamCache is currently active, false if it is not.
## "active" means that the cache should be consulted automatically on loads,
## "not active" means that objects should be loaded directly without
## consulting the cache.
##
## This represents the global flag.  Also see the individual cache_models,
## cache_textures, cache_compressed_textures flags.

proc `active=`*(this: BamCache, flag: bool) {.importcpp: "#.set_active(#)".} ## \
## Changes the state of the active flag.  "active" means that the cache should
## be consulted automatically on loads, "not active" means that objects should
## be loaded directly without consulting the cache.
##
## This represents the global flag.  Also see the individual cache_models,
## cache_textures, cache_compressed_textures flags.

func cache_models*(this: BamCache): bool {.importcpp: "#.get_cache_models()".} ## \
## Returns whether model files (e.g.  egg files and bam files) will be stored
## in the cache, as bam files.
##
## This also returns false if get_active() is false.

proc `cache_models=`*(this: BamCache, flag: bool) {.importcpp: "#.set_cache_models(#)".} ## \
## Indicates whether model files (e.g.  egg files and bam files) will be
## stored in the cache, as bam files.

func cache_textures*(this: BamCache): bool {.importcpp: "#.get_cache_textures()".} ## \
## Returns whether texture files (e.g.  egg files and bam files) will be
## stored in the cache, as txo files.
##
## This also returns false if get_active() is false.

proc `cache_textures=`*(this: BamCache, flag: bool) {.importcpp: "#.set_cache_textures(#)".} ## \
## Indicates whether texture files will be stored in the cache, as
## uncompressed txo files.

func cache_compressed_textures*(this: BamCache): bool {.importcpp: "#.get_cache_compressed_textures()".} ## \
## Returns whether compressed texture files will be stored in the cache, as
## compressed txo files.  See set_cache_compressed_textures().
##
## This also returns false if get_active() is false.

proc `cache_compressed_textures=`*(this: BamCache, flag: bool) {.importcpp: "#.set_cache_compressed_textures(#)".} ## \
## Indicates whether compressed texture files will be stored in the cache, as
## compressed txo files.  The compressed data may either be generated in-CPU,
## via the squish library, or it may be extracted from the GSG after the
## texture has been loaded.
##
## This may be set in conjunction with set_cache_textures(), or independently
## of it.  If set_cache_textures() is true and this is false, all textures
## will be cached in their uncompressed form.  If set_cache_textures() is
## false and this is true, only compressed textures will be cached, and they
## will be cached in their compressed form.  If both are true, all textures
## will be cached, in their uncompressed or compressed form appropriately.

func cache_compiled_shaders*(this: BamCache): bool {.importcpp: "#.get_cache_compiled_shaders()".} ## \
## Returns whether compiled shader programs will be stored in the cache, as
## binary .txo files.  See set_cache_compiled_shaders().
##
## This also returns false if get_active() is false.

proc `cache_compiled_shaders=`*(this: BamCache, flag: bool) {.importcpp: "#.set_cache_compiled_shaders(#)".} ## \
## Indicates whether compiled shader programs will be stored in the cache, as
## binary .sho files.  This may not be supported by all shader languages or
## graphics renderers.

func root*(this: BamCache): Filename {.importcpp: "#.get_root()".} ## \
## Returns the current root pathname of the cache.  See set_root().

proc `root=`*(this: BamCache, root: Filename) {.importcpp: "#.set_root(#)".} ## \
## Changes the current root pathname of the cache.  This specifies where the
## cache files are stored on disk.  This should name a directory that is on a
## disk local to the machine (not on a network-mounted disk), for instance,
## tmp/panda-cache or /c/panda-cache.
##
## If the directory does not already exist, it will be created as a result of
## this call.

func flush_time*(this: BamCache): int {.importcpp: "#.get_flush_time()".} ## \
## Returns the time in seconds between automatic flushes of the cache index.

proc `flush_time=`*(this: BamCache, flush_time: int) {.importcpp: "#.set_flush_time(#)".} ## \
## Specifies the time in seconds between automatic flushes of the cache index.

func cache_max_kbytes*(this: BamCache): int {.importcpp: "#.get_cache_max_kbytes()".} ## \
## Returns the maximum size, in kilobytes, which the cache is allowed to grow
## to.  See set_cache_max_kbytes().

proc `cache_max_kbytes=`*(this: BamCache, max_kbytes: int) {.importcpp: "#.set_cache_max_kbytes(#)".} ## \
## Specifies the maximum size, in kilobytes, which the cache is allowed to
## grow to.  If a newly cached file would exceed this size, an older file is
## removed from the cache.
##
## Note that in the case of multiple different processes simultaneously
## operating on the same cache directory, the actual cache size may slightly
## exceed this value from time to time due to latency in checking between the
## processes.

func read_only*(this: BamCache): bool {.importcpp: "#.get_read_only()".} ## \
## Returns true if the cache is in read-only mode.  Normally, the cache starts
## in read-write mode.  It can put itself into read-only mode automatically if
## it discovers that it does not have write access to the cache.

proc `read_only=`*(this: BamCache, ro: bool) {.importcpp: "#.set_read_only(#)".} ## \
## Can be used to put the cache in read-only mode, or take it out of read-only
## mode.  Note that if you put it into read-write mode, and it discovers that
## it does not have write access, it will put itself right back into read-only
## mode.

func flags*(this: LoaderOptions): int {.importcpp: "#.get_flags()".}

proc `flags=`*(this: LoaderOptions, flags: int) {.importcpp: "#.set_flags(#)".}

func texture_flags*(this: LoaderOptions): int {.importcpp: "#.get_texture_flags()".}

proc `texture_flags=`*(this: LoaderOptions, flags: int) {.importcpp: "#.set_texture_flags(#)".}

func texture_num_views*(this: LoaderOptions): int {.importcpp: "#.get_texture_num_views()".} ## \
## See set_texture_num_views().

proc `texture_num_views=`*(this: LoaderOptions, num_views: int) {.importcpp: "#.set_texture_num_views(#)".} ## \
## Specifies the expected number of views to load for the texture.  This is
## ignored unless TF_multiview is included in texture_flags.  This must be
## specified when loading a 3-d multiview texture or 2-d texture array, in
## which case it is used to differentiate z levels from separate views; it
## may be zero in the case of 2-d textures or cube maps, in which case the
## number of views can be inferred from the number of images found on disk.

func auto_texture_scale*(this: LoaderOptions): AutoTextureScale {.importcpp: "#.get_auto_texture_scale()".} ## \
## See set_auto_texture_scale().

proc `auto_texture_scale=`*(this: LoaderOptions, scale: AutoTextureScale) {.importcpp: "#.set_auto_texture_scale(#)".} ## \
## Set this flag to ATS_none, ATS_up, ATS_down, or ATS_pad to control how a
## texture is scaled from disk when it is subsequently loaded.  Set it to
## ATS_unspecified to restore the default behavior.

func source*(this: BamReader): DatagramGenerator {.importcpp: "#.get_source()".} ## \
## Returns the current source of the BamReader as set by set_source() or the
## constructor.

proc `source=`*(this: BamReader, source: DatagramGenerator) {.importcpp: "#.set_source(#)".} ## \
## Changes the source of future datagrams for this BamReader.  This also
## implicitly calls init() if it has not already been called.

func filename*(this: BamReader): Filename {.importcpp: "#.get_filename()".} ## \
## If a BAM is a file, then the BamReader should contain the name of the file.
## This enables the reader to interpret pathnames in the BAM as relative to
## the directory containing the BAM.

func loader_options*(this: BamReader): LoaderOptions {.importcpp: "#.get_loader_options()".} ## \
## Returns the LoaderOptions passed to the loader when the model was
## requested, if any.

proc `loader_options=`*(this: BamReader, options: LoaderOptions) {.importcpp: "#.set_loader_options(#)".} ## \
## Specifies the LoaderOptions for this BamReader.

func file_stdfloat_double*(this: BamReader): bool {.importcpp: "#.get_file_stdfloat_double()".} ## \
## Returns true if the file stores all "standard" floats as 64-bit doubles, or
## false if they are 32-bit floats.  This is determined by the compilation
## flags of the version of Panda that generated this file.

func target*(this: BamWriter): DatagramSink {.importcpp: "#.get_target()".} ## \
## Returns the current target of the BamWriter as set by set_target() or the
## constructor.

proc `target=`*(this: BamWriter, target: DatagramSink) {.importcpp: "#.set_target(#)".} ## \
## Changes the destination of future datagrams written by the BamWriter.  This
## also implicitly calls init() if it has not already been called.

func filename*(this: BamWriter): Filename {.importcpp: "#.get_filename()".} ## \
## If a BAM is a file, then the BamWriter should contain the name of the file.
## This enables the writer to convert pathnames in the BAM to relative to the
## directory containing the BAM.

func file_stdfloat_double*(this: BamWriter): bool {.importcpp: "#.get_file_stdfloat_double()".} ## \
## Returns true if the file will store all "standard" floats as 64-bit
## doubles, or false if they are 32-bit floats.  This isn't runtime settable;
## it's based on the compilation flags of the version of Panda that generated
## this file.

func root_node*(this: BamWriter): TypedWritable {.importcpp: "#.get_root_node()".} ## \
## Returns the root node of the part of the scene graph we are currently
## writing out.  This is used for determining what to make NodePaths relative
## to.

proc `root_node=`*(this: BamWriter, root_node: TypedWritable) {.importcpp: "#.set_root_node(#)".} ## \
## Sets the root node of the part of the scene graph we are currently writing
## out.  NodePaths written to this bam file will be relative to this node.

func index*(this: ButtonHandle): int {.importcpp: "#.get_index()".} ## \
## Returns the integer index associated with this ButtonHandle.  Each
## different ButtonHandle will have a different index.  However, you probably
## shouldn't be using this method; you should just treat the ButtonHandles as
## opaque classes.  This is provided for the convenience of non-C++ scripting
## languages to build a hashtable of ButtonHandles.

func name*(this: ButtonHandle): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the button.

func ascii_equivalent*(this: ButtonHandle): char {.importcpp: "#.get_ascii_equivalent()".} ## \
## Returns the character code associated with the button, or '\0' if no ASCII
## code was associated.

func alias*(this: ButtonHandle): ButtonHandle {.importcpp: "#.get_alias()".} ## \
## Returns the alias (alternate name) associated with the button, if any, or
## ButtonHandle::none() if the button has no alias.
##
## Each button is allowed to have one alias, and multiple different buttons
## can refer to the same alias.  The alias should be the more general name for
## the button, for instance, shift is an alias for lshift, but not vice-versa.

func frame_time*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->get_frame_time(#)".} ## \
## Returns the time in seconds as of the last time tick() was called
## (typically, this will be as of the start of the current frame).
##
## This is generally the kind of time you want to ask for in most rendering
## and animation contexts, since it's important that all of the animation for
## a given frame remains in sync with each other.

func frame_time*(this: ClockObject): float64 {.importcpp: "#->get_frame_time()".} ## \
## Returns the time in seconds as of the last time tick() was called
## (typically, this will be as of the start of the current frame).
##
## This is generally the kind of time you want to ask for in most rendering
## and animation contexts, since it's important that all of the animation for
## a given frame remains in sync with each other.

proc `frame_time=`*(this: ClockObject, time: float64, current_thread: Thread) {.importcpp: "#->set_frame_time(#, #)".} ## \
## Changes the time as reported for the current frame to the indicated time.
## Normally, the way to adjust the frame time is via tick(); this function is
## provided only for occasional special adjustments.

proc `frame_time=`*(this: ClockObject, time: float64) {.importcpp: "#->set_frame_time(#)".} ## \
## Changes the time as reported for the current frame to the indicated time.
## Normally, the way to adjust the frame time is via tick(); this function is
## provided only for occasional special adjustments.

func real_time*(this: ClockObject): float64 {.importcpp: "#->get_real_time()".} ## \
## Returns the actual number of seconds elapsed since the ClockObject was
## created, or since it was last reset.  This is useful for doing real timing
## measurements, e.g.  for performance statistics.
##
## This returns the most precise timer we have for short time intervals, but
## it may tend to drift over the long haul.  If more accurate timekeeping is
## needed over a long period of time, use get_long_time() instead.

proc `real_time=`*(this: ClockObject, time: float64) {.importcpp: "#->set_real_time(#)".} ## \
## Resets the clock to the indicated time.  This changes only the real time of
## the clock as reported by get_real_time(), but does not immediately change
## the time reported by get_frame_time()--that will change after the next call
## to tick().  Also see reset(), set_frame_time(), and set_frame_count().

func long_time*(this: ClockObject): float64 {.importcpp: "#->get_long_time()".} ## \
## Returns the actual number of seconds elapsed since the ClockObject was
## created, or since it was last reset.
##
## This is similar to get_real_time(), except that it uses the most accurate
## counter we have over a long period of time, and so it is less likely to
## drift.  However, it may not be very precise for measuring short intervals.
## On Windows, for instace, this is only accurate to within about 55
## milliseconds.

func frame_count*(this: ClockObject, current_thread: Thread): int {.importcpp: "#->get_frame_count(#)".} ## \
## Returns the number of times tick() has been called since the ClockObject
## was created, or since it was last reset.  This is generally the number of
## frames that have been rendered.

func frame_count*(this: ClockObject): int {.importcpp: "#->get_frame_count()".} ## \
## Returns the number of times tick() has been called since the ClockObject
## was created, or since it was last reset.  This is generally the number of
## frames that have been rendered.

proc `frame_count=`*(this: ClockObject, frame_count: int, current_thread: Thread) {.importcpp: "#->set_frame_count(#, #)".} ## \
## Resets the number of frames counted to the indicated number.  Also see
## reset(), set_real_time(), and set_frame_time().

proc `frame_count=`*(this: ClockObject, frame_count: int) {.importcpp: "#->set_frame_count(#)".} ## \
## Resets the number of frames counted to the indicated number.  Also see
## reset(), set_real_time(), and set_frame_time().

func dt*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->get_dt(#)".} ## \
## Returns the elapsed time for the previous frame: the number of seconds
## elapsed between the last two calls to tick().

func dt*(this: ClockObject): float64 {.importcpp: "#->get_dt()".} ## \
## Returns the elapsed time for the previous frame: the number of seconds
## elapsed between the last two calls to tick().

proc `dt=`*(this: ClockObject, dt: float64) {.importcpp: "#->set_dt(#)".} ## \
## In non-real-time mode, sets the number of seconds that should appear to
## elapse between frames.  In forced mode or limited mode, sets our target dt.
## In normal mode, this has no effect.
##
## Also see set_frame_rate(), which is a different way to specify the same
## quantity.

func max_dt*(this: ClockObject): float64 {.importcpp: "#->get_max_dt()".} ## \
## Returns the current maximum allowable time elapsed between any two frames.
## See set_max_dt().

proc `max_dt=`*(this: ClockObject, max_dt: float64) {.importcpp: "#->set_max_dt(#)".} ## \
## Sets a limit on the value returned by get_dt().  If this value is less than
## zero, no limit is imposed; otherwise, this is the maximum value that will
## ever be returned by get_dt(), regardless of how much time has actually
## elapsed between frames.
##
## This limit is only imposed in real-time mode; in non-real-time mode, the dt
## is fixed anyway and max_dt is ignored.
##
## This is generally used to guarantee reasonable behavior even in the
## presence of a very slow or chuggy frame rame.

func degrade_factor*(this: ClockObject): float64 {.importcpp: "#->get_degrade_factor()".} ## \
## In degrade mode, returns the ratio by which the performance is degraded.  A
## value of 2.0 causes the clock to be slowed down by a factor of two
## (reducing performance to 1/2 what would be otherwise).
##
## This has no effect if mode is not M_degrade.

proc `degrade_factor=`*(this: ClockObject, degrade_factor: float64) {.importcpp: "#->set_degrade_factor(#)".} ## \
## In degrade mode, sets the ratio by which the performance is degraded.  A
## value of 2.0 causes the clock to be slowed down by a factor of two
## (reducing performance to 1/2 what would be otherwise).
##
## This has no effect if mode is not M_degrade.

func average_frame_rate_interval*(this: ClockObject): float64 {.importcpp: "#->get_average_frame_rate_interval()".} ## \
## Returns the interval of time (in seconds) over which
## get_average_frame_rate() averages the number of frames per second to
## compute the frame rate.

proc `average_frame_rate_interval=`*(this: ClockObject, time: float64) {.importcpp: "#->set_average_frame_rate_interval(#)".} ## \
## Specifies the interval of time (in seconds) over which
## get_average_frame_rate() averages the number of frames per second to
## compute the frame rate.  Changing this does not necessarily immediately
## change the result of get_average_frame_rate(), until this interval of time
## has elapsed again.
##
## Setting this to zero disables the computation of get_average_frame_rate().

func average_frame_rate*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->get_average_frame_rate(#)".} ## \
## Returns the average frame rate in number of frames per second over the last
## get_average_frame_rate_interval() seconds.  This measures the virtual frame
## rate if the clock is in M_non_real_time mode.

func average_frame_rate*(this: ClockObject): float64 {.importcpp: "#->get_average_frame_rate()".} ## \
## Returns the average frame rate in number of frames per second over the last
## get_average_frame_rate_interval() seconds.  This measures the virtual frame
## rate if the clock is in M_non_real_time mode.

func max_frame_duration*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->get_max_frame_duration(#)".} ## \
## Returns the maximum frame duration over the last
## get_average_frame_rate_interval() seconds.

func max_frame_duration*(this: ClockObject): float64 {.importcpp: "#->get_max_frame_duration()".} ## \
## Returns the maximum frame duration over the last
## get_average_frame_rate_interval() seconds.

func x*(this: PointerData): float64 {.importcpp: "#.get_x()".}

func y*(this: PointerData): float64 {.importcpp: "#.get_y()".}

func in_window*(this: PointerData): bool {.importcpp: "#.get_in_window()".} ## \
## If this returns false, the pointer is not currently present in the window
## and the values returned by get_x() and get_y() may not be meaningful.

func value*(this: ParamTypedRefCount): TypedReferenceCount {.importcpp: "#->get_value()".} ## \
## Retrieves the value stored in the parameter.

func dls_pathname*(_: typedesc[AudioManager]): Filename {.importcpp: "AudioManager::get_dls_pathname()", header: "audioManager.h".}

func click_prefix*(_: typedesc[PGButton]): string {.importcpp: "nimStringFromStdString(PGButton::get_click_prefix())", header: stringConversionCode.} ## \
## Returns the prefix that is used to define the click event for all
## PGButtons.  The click event is the concatenation of this string followed by
## get_id().

func host_name*(_: typedesc[ConnectionManager]): string {.importcpp: "nimStringFromStdString(ConnectionManager::get_host_name())", header: "connectionManager.h".} ## \
## Returns the name of this particular machine on the network, if available,
## or the empty string if the hostname cannot be determined.

proc get_total_alloc*(_: typedesc[NeverFreeMemory]): clonglong {.importcpp: "NeverFreeMemory::get_total_alloc()", header: "neverFreeMemory.h".} ## \
## Returns the total number of bytes consumed by all the pages allocated
## internally by this object.

proc get_total_used*(_: typedesc[NeverFreeMemory]): clonglong {.importcpp: "NeverFreeMemory::get_total_used()", header: "neverFreeMemory.h".} ## \
## Returns the total number of bytes requested by the application in calls to
## NeverFreeMemory::alloc().

proc get_total_unused*(_: typedesc[NeverFreeMemory]): clonglong {.importcpp: "NeverFreeMemory::get_total_unused()", header: "neverFreeMemory.h".} ## \
## Returns the difference between get_total_alloc() and get_total_used().
## This represents bytes in allocated pages that have not (yet) been used by
## the application.

proc initTypeHandle*(): TypeHandle {.importcpp: "TypeHandle()".}

proc initTypeHandle*(param0: TypeHandle): TypeHandle {.importcpp: "TypeHandle(#)".}

proc `==`*(this: TypeHandle, other: TypeHandle): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: TypeHandle, other: TypeHandle): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: TypeHandle, other: TypeHandle): bool {.importcpp: "#.operator <(#)".}

proc `<=`*(this: TypeHandle, other: TypeHandle): bool {.importcpp: "#.operator <=(#)".}

proc `>`*(this: TypeHandle, other: TypeHandle): bool {.importcpp: "#.operator >(#)".}

proc `>=`*(this: TypeHandle, other: TypeHandle): bool {.importcpp: "#.operator >=(#)".}

proc compare_to*(this: TypeHandle, other: TypeHandle): int {.importcpp: "#.compare_to(#)".} ## \
## Sorts TypeHandles arbitrarily (according to <, >, etc.).  Returns a number
## less than 0 if this type sorts before the other one, greater than zero if
## it sorts after, 0 if they are equivalent.

proc get_hash*(this: TypeHandle): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a hash code suitable for phash_map.

proc get_name*(this: TypeHandle, `object`: TypedObject): string {.importcpp: "nimStringFromStdString(#.get_name(#))", header: stringConversionCode.} ## \
## Returns the name of the type.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc get_name*(this: TypeHandle): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the type.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc is_derived_from*(this: TypeHandle, parent: TypeHandle, `object`: TypedObject): bool {.importcpp: "#.is_derived_from(#, #)".} ## \
## Returns true if this type is derived from the indicated type, false
## otherwise.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc is_derived_from*(this: TypeHandle, parent: TypeHandle): bool {.importcpp: "#.is_derived_from(#)".} ## \
## Returns true if this type is derived from the indicated type, false
## otherwise.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc get_num_parent_classes*(this: TypeHandle, `object`: TypedObject): int {.importcpp: "#.get_num_parent_classes(#)".} ## \
## Returns the number of parent classes that this type is known to have.  This
## may then be used to index into get_parent_class().  The result will be 0 if
## this class does not inherit from any other classes, 1 if normal, single
## inheritance is in effect, or greater than one if multiple inheritance is in
## effect.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc get_num_parent_classes*(this: TypeHandle): int {.importcpp: "#.get_num_parent_classes()".} ## \
## Returns the number of parent classes that this type is known to have.  This
## may then be used to index into get_parent_class().  The result will be 0 if
## this class does not inherit from any other classes, 1 if normal, single
## inheritance is in effect, or greater than one if multiple inheritance is in
## effect.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc get_parent_class*(this: TypeHandle, index: int): TypeHandle {.importcpp: "#.get_parent_class(#)".} ## \
## Returns the nth parent class of this type.  The index should be in the
## range 0 <= index < get_num_parent_classes().

proc get_num_child_classes*(this: TypeHandle, `object`: TypedObject): int {.importcpp: "#.get_num_child_classes(#)".} ## \
## Returns the number of child classes that this type is known to have.  This
## may then be used to index into get_child_class().
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc get_num_child_classes*(this: TypeHandle): int {.importcpp: "#.get_num_child_classes()".} ## \
## Returns the number of child classes that this type is known to have.  This
## may then be used to index into get_child_class().
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc get_child_class*(this: TypeHandle, index: int): TypeHandle {.importcpp: "#.get_child_class(#)".} ## \
## Returns the nth child class of this type.  The index should be in the range
## 0 <= index < get_num_child_classes().

proc get_parent_towards*(this: TypeHandle, ancestor: TypeHandle, `object`: TypedObject): TypeHandle {.importcpp: "#.get_parent_towards(#, #)".} ## \
## Returns the parent class that is in a direct line of inheritance to the
## indicated ancestor class.  This is useful in the presence of multiple
## inheritance to try to determine what properties an unknown type may have.
##
## The return value is TypeHandle::none() if the type does not inherit from
## the ancestor.  If ancestor is the same as this type, the return value is
## this type.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc get_parent_towards*(this: TypeHandle, ancestor: TypeHandle): TypeHandle {.importcpp: "#.get_parent_towards(#)".} ## \
## Returns the parent class that is in a direct line of inheritance to the
## indicated ancestor class.  This is useful in the presence of multiple
## inheritance to try to determine what properties an unknown type may have.
##
## The return value is TypeHandle::none() if the type does not inherit from
## the ancestor.  If ancestor is the same as this type, the return value is
## this type.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc get_index*(this: TypeHandle): int {.importcpp: "#.get_index()".} ## \
## Returns the integer index associated with this TypeHandle.  Each different
## TypeHandle will have a different index.  However, you probably shouldn't be
## using this method; you should just treat the TypeHandles as opaque classes.
## This is provided for the convenience of non-C++ scripting languages to
## build a hashtable of TypeHandles.

proc output*(this: TypeHandle, `out`: ostream) {.importcpp: "#.output(#)".}

proc none*(_: typedesc[TypeHandle]): TypeHandle {.importcpp: "TypeHandle::none()", header: "typeHandle.h".}

proc `typecast bool`*(this: TypeHandle): bool {.importcpp: "#.operator typecast bool()".}

proc register_dynamic_type*(this: TypeRegistry, name: string): TypeHandle {.importcpp: "#.register_dynamic_type(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Registers a new type on-the-fly, presumably at runtime.  A new TypeHandle
## is returned if the typename was not seen before; otherwise the same
## TypeHandle that was last used for this typename is returned.

proc record_derivation*(this: TypeRegistry, child: TypeHandle, parent: TypeHandle) {.importcpp: "#.record_derivation(#, #)".} ## \
## Records that the type referenced by child inherits directly from the type
## referenced by parent.  In the event of multiple inheritance, this should be
## called once for each parent class.

proc record_alternate_name*(this: TypeRegistry, `type`: TypeHandle, name: string) {.importcpp: "#.record_alternate_name(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Indicates an alternate name for the same type.  This is particularly useful
## when a type has changed names, since the type is stored in a Bam file by
## name; setting the original name as the alternate will allow the type to be
## correctly read from old Bam files.

proc find_type*(this: TypeRegistry, name: string): TypeHandle {.importcpp: "#.find_type(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Looks for a previously-registered type of the given name.  Returns its
## TypeHandle if it exists, or TypeHandle::none() if there is no such type.

proc find_type_by_id*(this: TypeRegistry, id: int): TypeHandle {.importcpp: "#.find_type_by_id(#)".} ## \
## Looks for a previously-registered type with the given id number (as
## returned by TypeHandle::get_index()). Returns its TypeHandle if it exists,
## or TypeHandle::none() if there is no such type.

proc get_name*(this: TypeRegistry, `type`: TypeHandle, `object`: TypedObject): string {.importcpp: "nimStringFromStdString(#.get_name(#, #))", header: stringConversionCode.} ## \
## Returns the name of the indicated type.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc is_derived_from*(this: TypeRegistry, child: TypeHandle, base: TypeHandle, child_object: TypedObject): bool {.importcpp: "#.is_derived_from(#, #, #)".} ## \
## Returns true if the first type is derived from the second type, false
## otherwise.
##
## The "child_object" pointer is an optional pointer to the TypedObject class
## that owns the child TypeHandle.  It is only used in case the TypeHandle is
## inadvertently undefined.
##
## This function definition follows the definitions for look_up() and
## freshen_derivations() just to maximize the chance the the compiler will be
## able to inline the above functions.  Yeah, a compiler shouldn't care, but
## there's a big different between "shouldn't" and "doesn't".

proc get_num_typehandles*(this: TypeRegistry): int {.importcpp: "#.get_num_typehandles()".} ## \
## Returns the total number of unique TypeHandles in the system.

proc get_typehandle*(this: TypeRegistry, n: int): TypeHandle {.importcpp: "#.get_typehandle(#)".} ## \
## Returns the nth TypeHandle in the system.  See get_num_typehandles().

proc get_num_root_classes*(this: TypeRegistry): int {.importcpp: "#.get_num_root_classes()".} ## \
## Returns the number of root classes--that is, classes that do not inherit
## from any other classes--known in the system.

proc get_root_class*(this: TypeRegistry, n: int): TypeHandle {.importcpp: "#.get_root_class(#)".} ## \
## Returns the nth root class in the system.  See get_num_root_classes().

proc get_num_parent_classes*(this: TypeRegistry, child: TypeHandle, child_object: TypedObject): int {.importcpp: "#.get_num_parent_classes(#, #)".} ## \
## Returns the number of parent classes that the indicated type is known to
## have.  This may then be used to index into get_parent_class().  The result
## will be 0 if this class does not inherit from any other classes, 1 if
## normal, single inheritance is in effect, or greater than one if multiple
## inheritance is in effect.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc get_parent_class*(this: TypeRegistry, child: TypeHandle, index: int): TypeHandle {.importcpp: "#.get_parent_class(#, #)".} ## \
## Returns the nth parent class of this type.  The index should be in the
## range 0 <= index < get_num_parent_classes().

proc get_num_child_classes*(this: TypeRegistry, child: TypeHandle, child_object: TypedObject): int {.importcpp: "#.get_num_child_classes(#, #)".} ## \
## Returns the number of child classes that the indicated type is known to
## have.  This may then be used to index into get_child_class().
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc get_child_class*(this: TypeRegistry, child: TypeHandle, index: int): TypeHandle {.importcpp: "#.get_child_class(#, #)".} ## \
## Returns the nth child class of this type.  The index should be in the range
## 0 <= index < get_num_child_classes().

proc get_parent_towards*(this: TypeRegistry, child: TypeHandle, base: TypeHandle, child_object: TypedObject): TypeHandle {.importcpp: "#.get_parent_towards(#, #, #)".} ## \
## Returns the parent of the indicated child class that is in a direct line of
## inheritance to the indicated ancestor class.  This is useful in the
## presence of multiple inheritance to try to determine what properties an
## unknown type may have.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc reregister_types*(_: typedesc[TypeRegistry]) {.importcpp: "TypeRegistry::reregister_types()", header: "typeRegistry.h".} ## \
## Walks through the TypeRegistry tree and makes sure that each type that was
## previously registered is *still* registered.  This seems to get broken in
## certain circumstances when compiled against libc5--it is as if the static
## initializer stomps on the _type_handle values of each class after they've
## been registered.

proc write*(this: TypeRegistry, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Makes an attempt to format the entire TypeRegistry in a nice way that shows
## the derivation tree as intelligently as possible.

proc initTypeRegistry*(param0: TypeRegistry): TypeRegistry {.importcpp: "TypeRegistry(#)".}

proc get_type*(this: TypedObject): TypeHandle {.importcpp: "#->get_type()".} ## \
## Derived classes should override this function to return get_class_type().

proc get_type_index*(this: TypedObject): int {.importcpp: "#->get_type_index()".} ## \
## Returns the internal index number associated with this object's TypeHandle,
## a unique number for each different type.  This is equivalent to
## get_type().get_index().

proc is_of_type*(this: TypedObject, handle: TypeHandle): bool {.importcpp: "#->is_of_type(#)".} ## \
## Returns true if the current object is or derives from the indicated type.

proc is_exact_type*(this: TypedObject, handle: TypeHandle): bool {.importcpp: "#->is_exact_type(#)".} ## \
## Returns true if the current object is the indicated type exactly.

proc get_class_type*(_: typedesc[TypedObject]): TypeHandle {.importcpp: "TypedObject::get_class_type()", header: "typedObject.h".}

proc get*(this: istream): int {.importcpp: "#.get()".}

proc tellg*(this: istream): clonglong {.importcpp: "#.tellg()".}

proc seekg*(this: istream, pos: clonglong) {.importcpp: "#.seekg(#)".}

converter upcast_to_istream*(this: iostream): istream {.importcpp: "#.upcast_to_istream()".}

proc put*(this: ostream, c: char) {.importcpp: "#.put(#)".}

proc flush*(this: ostream) {.importcpp: "#.flush()".}

proc tellp*(this: ostream): clonglong {.importcpp: "#.tellp()".}

proc seekp*(this: ostream, pos: clonglong) {.importcpp: "#.seekp(#)".}

converter upcast_to_ostream*(this: iostream): ostream {.importcpp: "#.upcast_to_ostream()".}

proc flush*(this: iostream) {.importcpp: "#.flush()".}

proc initfstream*(): fstream {.importcpp: "fstream()".}

proc close*(this: fstream) {.importcpp: "#.close()".}

proc initifstream*(): ifstream {.importcpp: "ifstream()".}

proc close*(this: ifstream) {.importcpp: "#.close()".}

proc initofstream*(): ofstream {.importcpp: "ofstream()".}

proc close*(this: ofstream) {.importcpp: "#.close()".}

proc initIFileStream*(): IFileStream {.importcpp: "IFileStream()".}

proc initIFileStream*(filename: string): IFileStream {.importcpp: "IFileStream(nimStringToStdString(#))", header: stringConversionCode.}

proc open*(this: IFileStream, filename: string) {.importcpp: "#.open(nimStringToStdString(#))", header: stringConversionCode.}

proc close*(this: IFileStream) {.importcpp: "#.close()".}

proc initOFileStream*(): OFileStream {.importcpp: "OFileStream()".}

proc initOFileStream*(filename: string): OFileStream {.importcpp: "OFileStream(nimStringToStdString(#))", header: stringConversionCode.}

proc open*(this: OFileStream, filename: string) {.importcpp: "#.open(nimStringToStdString(#))", header: stringConversionCode.}

proc close*(this: OFileStream) {.importcpp: "#.close()".}

proc initFileStream*(): FileStream {.importcpp: "FileStream()".}

proc initFileStream*(filename: string): FileStream {.importcpp: "FileStream(nimStringToStdString(#))", header: stringConversionCode.}

proc open*(this: FileStream, filename: string) {.importcpp: "#.open(nimStringToStdString(#))", header: stringConversionCode.}

proc close*(this: FileStream) {.importcpp: "#.close()".}

proc initTextEncoder*(): TextEncoder {.importcpp: "TextEncoder()".}

proc initTextEncoder*(copy: TextEncoder): TextEncoder {.importcpp: "TextEncoder(#)".}

proc clear_text*(this: TextEncoder) {.importcpp: "#.clear_text()".} ## \
## Removes the text from the TextEncoder.

proc has_text*(this: TextEncoder): bool {.importcpp: "#.has_text()".}

proc make_upper*(this: TextEncoder) {.importcpp: "#.make_upper()".} ## \
## Adjusts the text stored within the encoder to all uppercase letters
## (preserving accent marks correctly).

proc make_lower*(this: TextEncoder) {.importcpp: "#.make_lower()".} ## \
## Adjusts the text stored within the encoder to all lowercase letters
## (preserving accent marks correctly).

proc append_unicode_char*(this: TextEncoder, character: int) {.importcpp: "#.append_unicode_char(#)".} ## \
## Appends a single character to the end of the stored text.  This may be a
## wide character, up to 16 bits in Unicode.

proc get_num_chars*(this: TextEncoder): clonglong {.importcpp: "#.get_num_chars()".} ## \
## Returns the number of characters in the stored text.  This is a count of
## wide characters, after the string has been decoded according to
## set_encoding().

proc get_unicode_char*(this: TextEncoder, index: clonglong): int {.importcpp: "#.get_unicode_char(#)".} ## \
## Returns the Unicode value of the nth character in the stored text.  This
## may be a wide character (greater than 255), after the string has been
## decoded according to set_encoding().

proc set_unicode_char*(this: TextEncoder, index: clonglong, character: int) {.importcpp: "#.set_unicode_char(#, #)".} ## \
## Sets the Unicode value of the nth character in the stored text.  This may
## be a wide character (greater than 255), after the string has been decoded
## according to set_encoding().

proc get_encoded_char*(this: TextEncoder, index: clonglong): string {.importcpp: "nimStringFromStdString(#.get_encoded_char(#))", header: stringConversionCode.} ## \
## Returns the nth char of the stored text, as a one-, two-, or three-byte
## encoded string.

proc get_text_as_ascii*(this: TextEncoder): string {.importcpp: "nimStringFromStdString(#.get_text_as_ascii())", header: stringConversionCode.} ## \
## Returns the text associated with the node, converted as nearly as possible
## to a fully-ASCII representation.  This means replacing accented letters
## with their unaccented ASCII equivalents.
##
## It is possible that some characters in the string cannot be converted to
## ASCII.  (The string may involve symbols like the copyright symbol, for
## instance, or it might involve letters in some other alphabet such as Greek
## or Cyrillic, or even Latin letters like thorn or eth that are not part of
## the ASCII character set.)  In this case, as much of the string as possible
## will be converted to ASCII, and the nonconvertible characters will remain
## encoded in the encoding specified by set_encoding().

proc unicode_isalpha*(_: typedesc[TextEncoder], character: int): bool {.importcpp: "TextEncoder::unicode_isalpha(#)", header: "textEncoder.h".} ## \
## Returns true if the indicated character is an alphabetic letter, false
## otherwise.  This is akin to ctype's isalpha(), extended to Unicode.

proc unicode_isdigit*(_: typedesc[TextEncoder], character: int): bool {.importcpp: "TextEncoder::unicode_isdigit(#)", header: "textEncoder.h".} ## \
## Returns true if the indicated character is a numeric digit, false
## otherwise.  This is akin to ctype's isdigit(), extended to Unicode.

proc unicode_ispunct*(_: typedesc[TextEncoder], character: int): bool {.importcpp: "TextEncoder::unicode_ispunct(#)", header: "textEncoder.h".} ## \
## Returns true if the indicated character is a punctuation mark, false
## otherwise.  This is akin to ctype's ispunct(), extended to Unicode.

proc unicode_islower*(_: typedesc[TextEncoder], character: int): bool {.importcpp: "TextEncoder::unicode_islower(#)", header: "textEncoder.h".} ## \
## Returns true if the indicated character is a lowercase letter, false
## otherwise.  This is akin to ctype's islower(), extended to Unicode.

proc unicode_isupper*(_: typedesc[TextEncoder], character: int): bool {.importcpp: "TextEncoder::unicode_isupper(#)", header: "textEncoder.h".} ## \
## Returns true if the indicated character is an uppercase letter, false
## otherwise.  This is akin to ctype's isupper(), extended to Unicode.

proc unicode_isspace*(_: typedesc[TextEncoder], character: int): bool {.importcpp: "TextEncoder::unicode_isspace(#)", header: "textEncoder.h".} ## \
## Returns true if the indicated character is a whitespace letter, false
## otherwise.  This is akin to ctype's isspace(), extended to Unicode.

proc unicode_toupper*(_: typedesc[TextEncoder], character: int): int {.importcpp: "TextEncoder::unicode_toupper(#)", header: "textEncoder.h".} ## \
## Returns the uppercase equivalent of the given Unicode character.  This is
## akin to ctype's toupper(), extended to Unicode.

proc unicode_tolower*(_: typedesc[TextEncoder], character: int): int {.importcpp: "TextEncoder::unicode_tolower(#)", header: "textEncoder.h".} ## \
## Returns the uppercase equivalent of the given Unicode character.  This is
## akin to ctype's tolower(), extended to Unicode.

proc upper*(_: typedesc[TextEncoder], source: string): string {.importcpp: "nimStringFromStdString(TextEncoder::upper(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Converts the string to uppercase, assuming the string is encoded in the
## default encoding.

proc lower*(_: typedesc[TextEncoder], source: string): string {.importcpp: "nimStringFromStdString(TextEncoder::lower(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Converts the string to lowercase, assuming the string is encoded in the
## default encoding.

proc set_wtext*(this: TextEncoder, wtext: string) {.importcpp: "#.set_wtext(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the text that is stored in the encoder.  Subsequent calls to
## get_wtext() will return this same string, while get_text() will return the
## encoded version of the string.

proc get_wtext*(this: TextEncoder): string {.importcpp: "nimStringFromStdString(#.get_wtext())", header: stringConversionCode.} ## \
## Returns the text associated with the TextEncoder, as a wide-character
## string.

proc append_wtext*(this: TextEncoder, text: string) {.importcpp: "#.append_wtext(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Appends the indicates string to the end of the stored wide-character text.

proc get_wtext_as_ascii*(this: TextEncoder): string {.importcpp: "nimStringFromStdString(#.get_wtext_as_ascii())", header: stringConversionCode.} ## \
## Returns the text associated with the node, converted as nearly as possible
## to a fully-ASCII representation.  This means replacing accented letters
## with their unaccented ASCII equivalents.
##
## It is possible that some characters in the string cannot be converted to
## ASCII.  (The string may involve symbols like the copyright symbol, for
## instance, or it might involve letters in some other alphabet such as Greek
## or Cyrillic, or even Latin letters like thorn or eth that are not part of
## the ASCII character set.)  In this case, as much of the string as possible
## will be converted to ASCII, and the nonconvertible characters will remain
## in their original form.

proc is_wtext*(this: TextEncoder): bool {.importcpp: "#.is_wtext()".} ## \
## Returns true if any of the characters in the string returned by get_wtext()
## are out of the range of an ASCII character (and, therefore, get_wtext()
## should be called in preference to get_text()).

proc initFilename*(): Filename {.importcpp: "Filename()".} ## \
## Creates an empty Filename.

proc initFilename*(dirname: Filename, basename: Filename): Filename {.importcpp: "Filename(#, #)".} ## \
## This constructor composes the filename out of a directory part and a
## basename part.  It will insert an intervening '/' if necessary.

proc text_filename*(_: typedesc[Filename], filename: Filename): Filename {.importcpp: "Filename::text_filename(#)", header: "filename.h".} ## \
## Static constructors to explicitly create a filename that refers to a text
## or binary file.  This is in lieu of calling set_text() or set_binary() or
## set_type().

proc text_filename*(_: typedesc[Filename], filename: string): Filename {.importcpp: "Filename::text_filename(nimStringToStdString(#))", header: stringConversionCode.}

proc binary_filename*(_: typedesc[Filename], filename: Filename): Filename {.importcpp: "Filename::binary_filename(#)", header: "filename.h".}

proc binary_filename*(_: typedesc[Filename], filename: string): Filename {.importcpp: "Filename::binary_filename(nimStringToStdString(#))", header: stringConversionCode.}

proc dso_filename*(_: typedesc[Filename], filename: string): Filename {.importcpp: "Filename::dso_filename(nimStringToStdString(#))", header: stringConversionCode.}

proc executable_filename*(_: typedesc[Filename], filename: string): Filename {.importcpp: "Filename::executable_filename(nimStringToStdString(#))", header: stringConversionCode.}

proc pattern_filename*(_: typedesc[Filename], filename: string): Filename {.importcpp: "Filename::pattern_filename(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Constructs a filename that represents a sequence of numbered files.  See
## set_pattern().

proc from_os_specific*(_: typedesc[Filename], os_specific: string): Filename {.importcpp: "Filename::from_os_specific(nimStringToStdString(#))", header: stringConversionCode.} ## \
## This named constructor returns a Panda-style filename (that is, using
## forward slashes, and no drive letter) based on the supplied filename string
## that describes a filename in the local system conventions (for instance, on
## Windows, it may use backslashes or begin with a drive letter and a colon).
##
## Use this function to create a Filename from an externally-given filename
## string.  Use to_os_specific() again later to reconvert it back to the local
## operating system's conventions.
##
## This function will do the right thing even if the filename is partially
## local conventions and partially Panda conventions; e.g.  some backslashes
## and some forward slashes.

proc from_os_specific_w*(_: typedesc[Filename], os_specific: string): Filename {.importcpp: "Filename::from_os_specific_w(nimStringToStdString(#))", header: stringConversionCode.} ## \
## The wide-string variant of from_os_specific(). Returns a new Filename,
## converted from an os-specific wide-character string.

proc expand_from*(_: typedesc[Filename], user_string: string): Filename {.importcpp: "Filename::expand_from(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the same thing as from_os_specific(), but embedded environment
## variable references (e.g.  "$DMODELS/foo.txt") are expanded out.  It also
## automatically elevates the file to its true case if needed.

proc temporary*(_: typedesc[Filename], dirname: string, prefix: string, suffix: string): Filename {.importcpp: "Filename::temporary(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Generates a temporary filename within the indicated directory, using the
## indicated prefix.  If the directory is empty, a system-defined directory is
## chosen instead.
##
## The generated filename did not exist when the Filename checked, but since
## it does not specifically create the file, it is possible that another
## process could simultaneously create a file by the same name.

proc temporary*(_: typedesc[Filename], dirname: string, prefix: string): Filename {.importcpp: "Filename::temporary(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Generates a temporary filename within the indicated directory, using the
## indicated prefix.  If the directory is empty, a system-defined directory is
## chosen instead.
##
## The generated filename did not exist when the Filename checked, but since
## it does not specifically create the file, it is possible that another
## process could simultaneously create a file by the same name.

proc get_home_directory*(_: typedesc[Filename]): Filename {.importcpp: "Filename::get_home_directory()", header: "filename.h".} ## \
## Returns a path to the user's home directory, if such a thing makes sense in
## the current OS, or to the nearest equivalent.  This may or may not be
## directly writable by the application.

proc get_temp_directory*(_: typedesc[Filename]): Filename {.importcpp: "Filename::get_temp_directory()", header: "filename.h".} ## \
## Returns a path to a system-defined temporary directory.

proc get_user_appdata_directory*(_: typedesc[Filename]): Filename {.importcpp: "Filename::get_user_appdata_directory()", header: "filename.h".} ## \
## Returns a path to a system-defined directory appropriate for creating a
## subdirectory for storing application-specific data, specific to the current
## user.

proc get_common_appdata_directory*(_: typedesc[Filename]): Filename {.importcpp: "Filename::get_common_appdata_directory()", header: "filename.h".} ## \
## Returns a path to a system-defined directory appropriate for creating a
## subdirectory for storing application-specific data, common to all users.

proc `typecast`*(this: Filename): string {.importcpp: "nimStringFromStdString(#.operator typecast())", header: stringConversionCode.} ## \
## And retrieval is by any of the classic string operations.

proc c_str*(this: Filename): string {.importcpp: "nimStringFromStdString(#.c_str())", header: stringConversionCode.}

proc empty*(this: Filename): bool {.importcpp: "#.empty()".}

proc length*(this: Filename): clonglong {.importcpp: "#.length()".}

proc `[]`*(this: Filename, n: clonglong): char {.importcpp: "#.operator [](#)".}

proc substr*(this: Filename, begin: clonglong): string {.importcpp: "nimStringFromStdString(#.substr(#))", header: stringConversionCode.}

proc substr*(this: Filename, begin: clonglong, `end`: clonglong): string {.importcpp: "nimStringFromStdString(#.substr(#, #))", header: stringConversionCode.}

proc `+=`*(this: Filename, other: string): Filename {.importcpp: "#.operator +=(nimStringToStdString(#))", header: stringConversionCode.}

proc `+`*(this: Filename, other: string): Filename {.importcpp: "#.operator +(nimStringToStdString(#))", header: stringConversionCode.}

proc `/`*(this: Filename, other: Filename): Filename {.importcpp: "#.operator /(#)".}

proc get_fullpath*(this: Filename): string {.importcpp: "nimStringFromStdString(#.get_fullpath())", header: stringConversionCode.} ## \
## Returns the entire filename: directory, basename, extension.  This is the
## same thing returned by the string typecast operator.

proc get_fullpath_w*(this: Filename): string {.importcpp: "nimStringFromStdString(#.get_fullpath_w())", header: stringConversionCode.} ## \
## Returns the entire filename as a wide-character string.

proc get_dirname*(this: Filename): string {.importcpp: "nimStringFromStdString(#.get_dirname())", header: stringConversionCode.} ## \
## Returns the directory part of the filename.  This is everything in the
## filename up to, but not including the rightmost slash.

proc get_basename*(this: Filename): string {.importcpp: "nimStringFromStdString(#.get_basename())", header: stringConversionCode.} ## \
## Returns the basename part of the filename.  This is everything in the
## filename after the rightmost slash, including any extensions.

proc get_fullpath_wo_extension*(this: Filename): string {.importcpp: "nimStringFromStdString(#.get_fullpath_wo_extension())", header: stringConversionCode.} ## \
## Returns the full filename--directory and basename parts--except for the
## extension.

proc get_basename_wo_extension*(this: Filename): string {.importcpp: "nimStringFromStdString(#.get_basename_wo_extension())", header: stringConversionCode.} ## \
## Returns the basename part of the filename, without the file extension.

proc get_extension*(this: Filename): string {.importcpp: "nimStringFromStdString(#.get_extension())", header: stringConversionCode.} ## \
## Returns the file extension.  This is everything after the rightmost dot, if
## there is one, or the empty string if there is not.

proc set_fullpath*(this: Filename, s: string) {.importcpp: "#.set_fullpath(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the entire filename: directory, basename, extension.  This can
## also be achieved with the assignment operator.

proc set_dirname*(this: Filename, s: string) {.importcpp: "#.set_dirname(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the directory part of the filename.  This is everything in the
## filename up to, but not including the rightmost slash.

proc set_basename*(this: Filename, s: string) {.importcpp: "#.set_basename(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the basename part of the filename.  This is everything in the
## filename after the rightmost slash, including any extensions.

proc set_fullpath_wo_extension*(this: Filename, s: string) {.importcpp: "#.set_fullpath_wo_extension(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the full filename--directory and basename parts--except for the
## extension.

proc set_basename_wo_extension*(this: Filename, s: string) {.importcpp: "#.set_basename_wo_extension(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the basename part of the filename, without the file extension.

proc set_extension*(this: Filename, s: string) {.importcpp: "#.set_extension(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the file extension.  This is everything after the rightmost dot,
## if there is one, or the empty string if there is not.

proc set_binary*(this: Filename) {.importcpp: "#.set_binary()".} ## \
## Setting these flags appropriately is helpful when opening or searching
## for a file; it helps the Filename resolve OS-specific conventions (for
## instance, that dynamic library names should perhaps be changed from .so
## to .dll).

proc set_text*(this: Filename) {.importcpp: "#.set_text()".} ## \
## Indicates that the filename represents a text file.  This is primarily
## relevant to the read_file() and write_file() methods, so they can set the
## appropriate flags to the OS.

proc is_binary*(this: Filename): bool {.importcpp: "#.is_binary()".} ## \
## Returns true if the Filename has been indicated to represent a binary file
## via a previous call to set_binary().  It is possible that neither
## is_binary() nor is_text() will be true, if neither set_binary() nor
## set_text() was ever called.

proc is_text*(this: Filename): bool {.importcpp: "#.is_text()".} ## \
## Returns true if the Filename has been indicated to represent a text file
## via a previous call to set_text().  It is possible that neither is_binary()
## nor is_text() will be true, if neither set_binary() nor set_text() was ever
## called.

proc is_binary_or_text*(this: Filename): bool {.importcpp: "#.is_binary_or_text()".} ## \
## Returns true either is_binary() or is_text() is true; that is, that the
## filename has been specified as either binary or text.  If this is false,
## the filename has not been specified.

proc set_pattern*(this: Filename, pattern: bool) {.importcpp: "#.set_pattern(#)".} ## \
## Sets the flag indicating whether this is a filename pattern.  When this is
## true, the filename is understood to be a placeholder for a numbered
## sequence of filename, such as an image sequence.  In this case, a sequence
## of one or more hash characters ("#") should appear in the filename string;
## these characters will be filled in with the corresponding number (or more)
## of digits representing the sequence number.  Sequence numbers always begin
## counting at 0.
##
## When this is true, methods like has_hash() and get_hash_to_end() and
## get_filename_index() may be called.  Methods like is_exists() will
## implicitly test for existance of filename sequence 0.

proc get_pattern*(this: Filename): bool {.importcpp: "#.get_pattern()".} ## \
## Returns the flag indicating whether this is a filename pattern.  See
## set_pattern().

proc has_hash*(this: Filename): bool {.importcpp: "#.has_hash()".} ## \
## Returns true if the filename is indicated to be a filename pattern (that
## is, set_pattern(true) was called), and the filename pattern did include a
## sequence of hash marks, or false if it was not a filename pattern or did
## not include hash marks.  If this is true, then get_filename_index() will
## return a different filename each time.

proc get_filename_index*(this: Filename, index: int): Filename {.importcpp: "#.get_filename_index(#)".} ## \
## If the pattern flag is set for this Filename and the filename string
## actually includes a sequence of hash marks, then this returns a new
## Filename with the sequence of hash marks replaced by the indicated index
## number.
##
## If the pattern flag is not set for this Filename or it does not contain a
## sequence of hash marks, this quietly returns the original filename.

proc get_hash_to_end*(this: Filename): string {.importcpp: "nimStringFromStdString(#.get_hash_to_end())", header: stringConversionCode.} ## \
## Returns the part of the filename beginning at the hash sequence (if any),
## and continuing to the end of the filename.

proc set_hash_to_end*(this: Filename, s: string) {.importcpp: "#.set_hash_to_end(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the part of the filename from the beginning of the hash sequence
## to the end of the filename.

proc standardize*(this: Filename) {.importcpp: "#.standardize()".} ## \
## Converts the filename to standard form by replacing consecutive slashes
## with a single slash, removing a trailing slash if present, and backing up
## over .. sequences within the filename where possible.

proc is_local*(this: Filename): bool {.importcpp: "#.is_local()".} ## \
## Returns true if the filename is local, e.g.  does not begin with a slash,
## or false if the filename is fully specified from the root.

proc is_fully_qualified*(this: Filename): bool {.importcpp: "#.is_fully_qualified()".} ## \
## Returns true if the filename is fully qualified, e.g.  begins with a slash.
## This is almost, but not quite, the same thing as !is_local().  It's not
## exactly the same because a special case is made for filenames that begin
## with a single dot followed by a slash--these are considered to be fully
## qualified (they are explicitly relative to the current directory, and do
## not refer to a filename on a search path somewhere).

proc make_absolute*(this: Filename) {.importcpp: "#.make_absolute()".} ## \
## Converts the filename to a fully-qualified pathname from the root (if it is
## a relative pathname), and then standardizes it (see standardize()).
##
## This is sometimes a little problematic, since it may convert the file to
## its 'true' absolute pathname, which could be an ugly NFS-named file,
## irrespective of symbolic links (e.g.
## .automount/dimbo/root/usr2/fit/people/drose instead of /fit/people/drose);
## besides being ugly, filenames like this may not be consistent across
## multiple different platforms.

proc make_absolute*(this: Filename, start_directory: Filename) {.importcpp: "#.make_absolute(#)".} ## \
## Converts the filename to a fully-qualified filename from the root (if it is
## a relative filename), and then standardizes it (see standardize()).  This
## flavor accepts a specific starting directory that the filename is known to
## be relative to.

proc make_canonical*(this: Filename): bool {.importcpp: "#.make_canonical()".} ## \
## Converts this filename to a canonical name by replacing the directory part
## with the fully-qualified directory part.  This is done by changing to that
## directory and calling getcwd().
##
## This has the effect of (a) converting relative paths to absolute paths (but
## see make_absolute() if this is the only effect you want), and (b) always
## resolving a given directory name to the same string, even if different
## symbolic links are traversed, and (c) changing nice symbolic-link paths
## like fit/people/drose to ugly NFS automounter names like
## hosts/dimbo/usr2/fit/people/drose.  This can be troubling, but sometimes
## this is exactly what you want, particularly if you're about to call
## make_relative_to() between two filenames.
##
## The return value is true if successful, or false on failure (usually
## because the directory name does not exist or cannot be chdir'ed into).

proc make_true_case*(this: Filename): bool {.importcpp: "#.make_true_case()".} ## \
## On a case-insensitive operating system (e.g.  Windows), this method looks
## up the file in the file system and resets the Filename to represent the
## actual case of the file as it exists on the disk.  The return value is true
## if the file exists and the conversion can be made, or false if there is
## some error.
##
## On a case-sensitive operating system, this method does nothing and always
## returns true.
##
## An empty filename is considered to exist in this case.

proc to_os_specific*(this: Filename): string {.importcpp: "nimStringFromStdString(#.to_os_specific())", header: stringConversionCode.} ## \
## Converts the filename from our generic Unix-like convention (forward
## slashes starting with the root at '/') to the corresponding filename in the
## local operating system (slashes in the appropriate direction, starting with
## the root at C:\, for instance).  Returns the string representing the
## converted filename, but does not change the Filename itself.
##
## See also from_os_specific().

proc to_os_specific_w*(this: Filename): string {.importcpp: "nimStringFromStdString(#.to_os_specific_w())", header: stringConversionCode.} ## \
## The wide-string variant on to_os_specific().

proc to_os_generic*(this: Filename): string {.importcpp: "nimStringFromStdString(#.to_os_generic())", header: stringConversionCode.} ## \
## This is similar to to_os_specific(), but it is designed to generate a
## filename that can be understood on as many platforms as possible.  Since
## Windows can usually understand a forward-slash-delimited filename, this
## means it does the same thing as to_os_specific(), but it uses forward
## slashes instead of backslashes.
##
## This method has a pretty limited use; it should generally be used for
## writing file references to a file that might be read on any operating
## system.

proc to_os_short_name*(this: Filename): string {.importcpp: "nimStringFromStdString(#.to_os_short_name())", header: stringConversionCode.} ## \
## This works like to_os_generic(), but it returns the "short name" version of
## the filename, if it exists, or the original filename otherwise.
##
## On Windows platforms, this returns the 8.3 filename version of the given
## filename, if the file exists, and the same thing as to_os_specific()
## otherwise.  On non-Windows platforms, this always returns the same thing as
## to_os_specific().

proc to_os_long_name*(this: Filename): string {.importcpp: "nimStringFromStdString(#.to_os_long_name())", header: stringConversionCode.} ## \
## This is the opposite of to_os_short_name(): it returns the "long name" of
## the filename, if the filename exists.  On non-Windows platforms, this
## returns the same thing as to_os_specific().

proc exists*(this: Filename): bool {.importcpp: "#.exists()".} ## \
## Returns true if the filename exists on the disk, false otherwise.  If the
## type is indicated to be executable, this also tests that the file has
## execute permission.

proc is_regular_file*(this: Filename): bool {.importcpp: "#.is_regular_file()".} ## \
## Returns true if the filename exists and is the name of a regular file (i.e.
## not a directory or device), false otherwise.

proc is_writable*(this: Filename): bool {.importcpp: "#.is_writable()".} ## \
## Returns true if the filename exists and is either a directory or a regular
## file that can be written to, or false otherwise.

proc is_directory*(this: Filename): bool {.importcpp: "#.is_directory()".} ## \
## Returns true if the filename exists and is a directory name, false
## otherwise.

proc is_executable*(this: Filename): bool {.importcpp: "#.is_executable()".} ## \
## Returns true if the filename exists and is executable

proc compare_timestamps*(this: Filename, other: Filename, this_missing_is_old: bool, other_missing_is_old: bool): int {.importcpp: "#.compare_timestamps(#, #, #)".} ## \
## Returns a number less than zero if the file named by this object is older
## than the given file, zero if they have the same timestamp, or greater than
## zero if this one is newer.
##
## If this_missing_is_old is true, it indicates that a missing file will be
## treated as if it were older than any other file; otherwise, a missing file
## will be treated as if it were newer than any other file.  Similarly for
## other_missing_is_old.

proc compare_timestamps*(this: Filename, other: Filename, this_missing_is_old: bool): int {.importcpp: "#.compare_timestamps(#, #)".} ## \
## Returns a number less than zero if the file named by this object is older
## than the given file, zero if they have the same timestamp, or greater than
## zero if this one is newer.
##
## If this_missing_is_old is true, it indicates that a missing file will be
## treated as if it were older than any other file; otherwise, a missing file
## will be treated as if it were newer than any other file.  Similarly for
## other_missing_is_old.

proc compare_timestamps*(this: Filename, other: Filename): int {.importcpp: "#.compare_timestamps(#)".} ## \
## Returns a number less than zero if the file named by this object is older
## than the given file, zero if they have the same timestamp, or greater than
## zero if this one is newer.
##
## If this_missing_is_old is true, it indicates that a missing file will be
## treated as if it were older than any other file; otherwise, a missing file
## will be treated as if it were newer than any other file.  Similarly for
## other_missing_is_old.

proc get_timestamp*(this: Filename): int {.importcpp: "#.get_timestamp()".} ## \
## Returns a time_t value that represents the time the file was last modified,
## to within whatever precision the operating system records this information
## (on a Windows95 system, for instance, this may only be accurate to within 2
## seconds).
##
## If the timestamp cannot be determined, either because it is not supported
## by the operating system or because there is some error (such as file not
## found), returns 0.

proc get_access_timestamp*(this: Filename): int {.importcpp: "#.get_access_timestamp()".} ## \
## Returns a time_t value that represents the time the file was last accessed,
## if this information is available.  See also get_timestamp(), which returns
## the last modification time.

proc get_file_size*(this: Filename): clonglong {.importcpp: "#.get_file_size()".} ## \
## Returns the size of the file in bytes, or 0 if there is an error.

proc resolve_filename*(this: Filename, searchpath: DSearchPath, default_extension: string): bool {.importcpp: "#.resolve_filename(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Searches the given search path for the filename.  If it is found, updates
## the filename to the full pathname found and returns true; otherwise,
## returns false.

proc resolve_filename*(this: Filename, searchpath: DSearchPath): bool {.importcpp: "#.resolve_filename(#)".} ## \
## Searches the given search path for the filename.  If it is found, updates
## the filename to the full pathname found and returns true; otherwise,
## returns false.

proc make_relative_to*(this: Filename, directory: Filename, allow_backups: bool): bool {.importcpp: "#.make_relative_to(#, #)".} ## \
## Adjusts this filename, which must be a fully-specified pathname beginning
## with a slash, to make it a relative filename, relative to the fully-
## specified directory indicated (which must also begin with, and may or may
## not end with, a slash--a terminating slash is ignored).
##
## This only performs a string comparsion, so it may be wise to call
## make_canonical() on both filenames before calling make_relative_to().
##
## If allow_backups is false, the filename will only be adjusted to be made
## relative if it is already somewhere within or below the indicated
## directory.  If allow_backups is true, it will be adjusted in all cases,
## even if this requires putting a series of .. characters before the filename
## --unless it would have to back all the way up to the root.
##
## Returns true if the file was adjusted, false if it was not.

proc make_relative_to*(this: Filename, directory: Filename): bool {.importcpp: "#.make_relative_to(#)".} ## \
## Adjusts this filename, which must be a fully-specified pathname beginning
## with a slash, to make it a relative filename, relative to the fully-
## specified directory indicated (which must also begin with, and may or may
## not end with, a slash--a terminating slash is ignored).
##
## This only performs a string comparsion, so it may be wise to call
## make_canonical() on both filenames before calling make_relative_to().
##
## If allow_backups is false, the filename will only be adjusted to be made
## relative if it is already somewhere within or below the indicated
## directory.  If allow_backups is true, it will be adjusted in all cases,
## even if this requires putting a series of .. characters before the filename
## --unless it would have to back all the way up to the root.
##
## Returns true if the file was adjusted, false if it was not.

proc find_on_searchpath*(this: Filename, searchpath: DSearchPath): int {.importcpp: "#.find_on_searchpath(#)".} ## \
## Performs the reverse of the resolve_filename() operation: assuming that the
## current filename is fully-specified pathname (i.e.  beginning with '/'),
## look on the indicated search path for a directory under which the file can
## be found.  When found, adjust the Filename to be relative to the indicated
## directory name.
##
## Returns the index of the directory on the searchpath at which the file was
## found, or -1 if it was not found.

proc open_read*(this: Filename, stream: pifstream): bool {.importcpp: "#.open_read(#)".} ## \
## Opens the indicated pifstream for reading the file, if possible.  Returns
## true if successful, false otherwise.  This requires the setting of the
## set_text()/set_binary() flags to open the file appropriately as indicated;
## it is an error to call open_read() without first calling one of set_text()
## or set_binary().

proc open_read*(this: Filename, stream: ifstream): bool {.importcpp: "#.open_read(#)".} ## \
## Opens the indicated ifstream for reading the file, if possible.  Returns
## true if successful, false otherwise.  This requires the setting of the
## set_text()/set_binary() flags to open the file appropriately as indicated;
## it is an error to call open_read() without first calling one of set_text()
## or set_binary().

proc open_write*(this: Filename, stream: pofstream, truncate: bool): bool {.importcpp: "#.open_write(#, #)".} ## \
## Opens the indicated pifstream for writing the file, if possible.  Returns
## true if successful, false otherwise.  This requires the setting of the
## set_text()/set_binary() flags to open the file appropriately as indicated;
## it is an error to call open_read() without first calling one of set_text()
## or set_binary().
##
## If truncate is true, the file is truncated to zero length upon opening it,
## if it already exists.  Otherwise, the file is kept at its original length.

proc open_write*(this: Filename, stream: pofstream): bool {.importcpp: "#.open_write(#)".} ## \
## Opens the indicated pifstream for writing the file, if possible.  Returns
## true if successful, false otherwise.  This requires the setting of the
## set_text()/set_binary() flags to open the file appropriately as indicated;
## it is an error to call open_read() without first calling one of set_text()
## or set_binary().
##
## If truncate is true, the file is truncated to zero length upon opening it,
## if it already exists.  Otherwise, the file is kept at its original length.

proc open_write*(this: Filename, stream: ofstream, truncate: bool): bool {.importcpp: "#.open_write(#, #)".} ## \
## Opens the indicated ifstream for writing the file, if possible.  Returns
## true if successful, false otherwise.  This requires the setting of the
## set_text()/set_binary() flags to open the file appropriately as indicated;
## it is an error to call open_read() without first calling one of set_text()
## or set_binary().
##
## If truncate is true, the file is truncated to zero length upon opening it,
## if it already exists.  Otherwise, the file is kept at its original length.

proc open_write*(this: Filename, stream: ofstream): bool {.importcpp: "#.open_write(#)".} ## \
## Opens the indicated ifstream for writing the file, if possible.  Returns
## true if successful, false otherwise.  This requires the setting of the
## set_text()/set_binary() flags to open the file appropriately as indicated;
## it is an error to call open_read() without first calling one of set_text()
## or set_binary().
##
## If truncate is true, the file is truncated to zero length upon opening it,
## if it already exists.  Otherwise, the file is kept at its original length.

proc open_append*(this: Filename, stream: pofstream): bool {.importcpp: "#.open_append(#)".} ## \
## Opens the indicated pifstream for writing the file, if possible.  Returns
## true if successful, false otherwise.  This requires the setting of the
## set_text()/set_binary() flags to open the file appropriately as indicated;
## it is an error to call open_read() without first calling one of set_text()
## or set_binary().

proc open_append*(this: Filename, stream: ofstream): bool {.importcpp: "#.open_append(#)".} ## \
## Opens the indicated ofstream for writing the file, if possible.  Returns
## true if successful, false otherwise.  This requires the setting of the
## set_text()/set_binary() flags to open the file appropriately as indicated;
## it is an error to call open_read() without first calling one of set_text()
## or set_binary().

proc open_read_write*(this: Filename, stream: pfstream, truncate: bool): bool {.importcpp: "#.open_read_write(#, #)".} ## \
## Opens the indicated fstream for read/write access to the file, if possible.
## Returns true if successful, false otherwise.  This requires the setting of
## the set_text()/set_binary() flags to open the file appropriately as
## indicated; it is an error to call open_read_write() without first calling
## one of set_text() or set_binary().

proc open_read_write*(this: Filename, stream: pfstream): bool {.importcpp: "#.open_read_write(#)".} ## \
## Opens the indicated fstream for read/write access to the file, if possible.
## Returns true if successful, false otherwise.  This requires the setting of
## the set_text()/set_binary() flags to open the file appropriately as
## indicated; it is an error to call open_read_write() without first calling
## one of set_text() or set_binary().

proc open_read_write*(this: Filename, stream: fstream, truncate: bool): bool {.importcpp: "#.open_read_write(#, #)".} ## \
## Opens the indicated fstream for read/write access to the file, if possible.
## Returns true if successful, false otherwise.  This requires the setting of
## the set_text()/set_binary() flags to open the file appropriately as
## indicated; it is an error to call open_read_write() without first calling
## one of set_text() or set_binary().

proc open_read_write*(this: Filename, stream: fstream): bool {.importcpp: "#.open_read_write(#)".} ## \
## Opens the indicated fstream for read/write access to the file, if possible.
## Returns true if successful, false otherwise.  This requires the setting of
## the set_text()/set_binary() flags to open the file appropriately as
## indicated; it is an error to call open_read_write() without first calling
## one of set_text() or set_binary().

proc open_read_append*(this: Filename, stream: pfstream): bool {.importcpp: "#.open_read_append(#)".} ## \
## Opens the indicated pfstream for reading and writing the file, if possible;
## writes are appended to the end of the file.  Returns true if successful,
## false otherwise.  This requires the setting of the set_text()/set_binary()
## flags to open the file appropriately as indicated; it is an error to call
## open_read() without first calling one of set_text() or set_binary().

proc open_read_append*(this: Filename, stream: fstream): bool {.importcpp: "#.open_read_append(#)".} ## \
## Opens the indicated ifstream for reading and writing the file, if possible;
## writes are appended to the end of the file.  Returns true if successful,
## false otherwise.  This requires the setting of the set_text()/set_binary()
## flags to open the file appropriately as indicated; it is an error to call
## open_read() without first calling one of set_text() or set_binary().

proc chdir*(this: Filename): bool {.importcpp: "#.chdir()".} ## \
## Changes directory to the specified location.  Returns true if successful,
## false if failure.

proc touch*(this: Filename): bool {.importcpp: "#.touch()".} ## \
## Updates the modification time of the file to the current time.  If the file
## does not already exist, it will be created.  Returns true if successful,
## false if there is an error.

proc unlink*(this: Filename): bool {.importcpp: "#.unlink()".} ## \
## Permanently deletes the file associated with the filename, if possible.
## Returns true if successful, false if failure (for instance, because the
## file did not exist, or because permissions were inadequate).

proc rename_to*(this: Filename, other: Filename): bool {.importcpp: "#.rename_to(#)".} ## \
## Renames the file to the indicated new filename.  If the new filename is in
## a different directory, this will perform a move.  Returns true if
## successful, false on failure.

proc copy_to*(this: Filename, other: Filename): bool {.importcpp: "#.copy_to(#)".} ## \
## Copies the file to the indicated new filename, by reading the contents and
## writing it to the new file.  Returns true if successful, false on failure.
## The copy is always binary, regardless of the filename settings.

proc make_dir*(this: Filename): bool {.importcpp: "#.make_dir()".} ## \
## Creates all the directories in the path to the file specified in the
## filename, except for the basename itself.  This assumes that the Filename
## contains the name of a file, not a directory name; it ensures that the
## directory containing the file exists.
##
## However, if the filename ends in a slash, it assumes the Filename
## represents the name of a directory, and creates all the paths.

proc mkdir*(this: Filename): bool {.importcpp: "#.mkdir()".} ## \
## Creates the directory named by this filename.  Unlike make_dir(), this
## assumes that the Filename contains the directory name itself.  Also, parent
## directories are not automatically created; this function fails if any
## parent directory is missing.

proc rmdir*(this: Filename): bool {.importcpp: "#.rmdir()".} ## \
## The inverse of mkdir(): this removes the directory named by this Filename,
## if it is in fact a directory.

proc `==`*(this: Filename, other: string): bool {.importcpp: "#.operator ==(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Comparison operators are handy.

proc `!=`*(this: Filename, other: string): bool {.importcpp: "#.operator !=(nimStringToStdString(#))", header: stringConversionCode.}

proc `<`*(this: Filename, other: string): bool {.importcpp: "#.operator <(nimStringToStdString(#))", header: stringConversionCode.}

proc compare_to*(this: Filename, other: Filename): int {.importcpp: "#.compare_to(#)".}

proc get_hash*(this: Filename): int {.importcpp: "#.get_hash()".} ## \
## Returns a hash code that attempts to be mostly unique for different
## Filenames.

proc output*(this: Filename, `out`: ostream) {.importcpp: "#.output(#)".}

proc get_class_type*(_: typedesc[Filename]): TypeHandle {.importcpp: "Filename::get_class_type()", header: "filename.h".}

proc get_version_string*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_version_string())", header: stringConversionCode.} ## \
## Returns the current version of Panda, expressed as a string, e.g.  "1.0.0".
## The string will end in the letter "c" if this build does not represent an
## official version.

proc get_package_version_string*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_package_version_string())", header: stringConversionCode.} ## \
## Returns the version of the Panda3D distributable package that provides this
## build of Panda.
##
## When the currently-executing version of Panda was loaded from a
## distributable package, such as via the browser plugin, then this string
## will be nonempty and will contain the corresponding version string.  You
## can build applications that use this particular version of Panda by
## requesting it in the pdef file, using "panda3d", this version string, and
## the download host provided by get_package_host_url().
##
## If this string is empty, then the currently-executing Panda was built
## independently, and is not part of a distributable package.
##
## This string is set explicitly at compilation time.  Normally, it should be
## set to a nonempty string only when building a Panda3D package for
## distribution.

proc get_package_host_url*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_package_host_url())", header: stringConversionCode.} ## \
## Returns the URL of the download server that provides the Panda3D
## distributable package currently running.  This can be used, along with the
## get_package_version_string(), to uniquely identify the running version of
## Panda among distributable Panda versions.
##
## See get_package_version_string() for more information.
##
## This string is set explicitly at compilation time.  Normally, it should be
## set to a nonempty string only when building a Panda3D package for
## distribution.

proc get_p3d_coreapi_version_string*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_p3d_coreapi_version_string())", header: stringConversionCode.} ## \
## Returns the current version of Panda's Core API, expressed as a string of
## dot-delimited integers.  There are usually four integers in this version,
## but this is not guaranteed.
##
## The Core API is used during the runtime (plugin) environment only.  This
## may be the empty string if the current version of Panda is not built to
## provide a particular Core API, which will be the normal case in a
## development SDK.  However, you should not use this method to determine
## whether you are running in a runtime environment or not.

proc get_major_version*(_: typedesc[PandaSystem]): int {.importcpp: "PandaSystem::get_major_version()", header: "pandaSystem.h".} ## \
## Returns the major version number of the current version of Panda.  This is
## the first number of the dotted triple returned by get_version_string().  It
## changes very rarely.

proc get_minor_version*(_: typedesc[PandaSystem]): int {.importcpp: "PandaSystem::get_minor_version()", header: "pandaSystem.h".} ## \
## Returns the minor version number of the current version of Panda.  This is
## the second number of the dotted triple returned by get_version_string().
## It changes with each release that introduces new features.

proc get_sequence_version*(_: typedesc[PandaSystem]): int {.importcpp: "PandaSystem::get_sequence_version()", header: "pandaSystem.h".} ## \
## Returns the sequence version number of the current version of Panda.  This
## is the third number of the dotted triple returned by get_version_string().
## It changes with bugfix updates and very minor feature updates.

proc is_official_version*(_: typedesc[PandaSystem]): bool {.importcpp: "PandaSystem::is_official_version()", header: "pandaSystem.h".} ## \
## Returns true if current version of Panda claims to be an "official"
## version, that is, one that was compiled by an official distributor of Panda
## using a specific version of the panda source tree.  If this is true, there
## will not be a "c" at the end of the version string returned by
## get_version_string().
##
## Note that we must take the distributor's word for it here.

proc get_memory_alignment*(_: typedesc[PandaSystem]): int {.importcpp: "PandaSystem::get_memory_alignment()", header: "pandaSystem.h".} ## \
## Returns the memory alignment that Panda's allocators are using.

proc get_distributor*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_distributor())", header: stringConversionCode.} ## \
## Returns the string defined by the distributor of this version of Panda, or
## "homebuilt" if this version was built directly from the sources by the end-
## user.  This is a completely arbitrary string.

proc get_compiler*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_compiler())", header: stringConversionCode.} ## \
## Returns a string representing the compiler that was used to generate this
## version of Panda, if it is available, or "unknown" if it is not.

proc get_build_date*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_build_date())", header: stringConversionCode.} ## \
## Returns a string representing the date and time at which this version of
## Panda (or at least dtool) was compiled, if available.

proc get_git_commit*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_git_commit())", header: stringConversionCode.} ## \
## Returns a string representing the git commit hash that this source tree is
## based on, or the empty string if it has not been specified at build time.

proc get_platform*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_platform())", header: stringConversionCode.} ## \
## Returns a string representing the runtime platform that we are currently
## running on.  This will be something like "win32" or "osx_i386" or
## "linux_amd64".

proc has_system*(this: PandaSystem, system: string): bool {.importcpp: "#.has_system(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if the current version of Panda claims to have the indicated
## subsystem installed, false otherwise.  The set of available subsystems is
## implementation defined.

proc get_num_systems*(this: PandaSystem): clonglong {.importcpp: "#.get_num_systems()".} ## \
## Returns the number of Panda subsystems that have registered themselves.
## This can be used with get_system() to iterate through the entire list of
## available Panda subsystems.

proc get_system*(this: PandaSystem, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_system(#))", header: stringConversionCode.} ## \
## Returns the nth Panda subsystem that has registered itself.  This list will
## be sorted in alphabetical order.

proc get_system_tag*(this: PandaSystem, system: string, tag: string): string {.importcpp: "nimStringFromStdString(#.get_system_tag(nimStringToStdString(#), nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Returns the value associated with the indicated tag for the given system.
## This provides a standard way to query each subsystem's advertised
## capabilities.  The set of tags and values are per-system and
## implementation-defined.
##
## The return value is the empty string if the indicated system is undefined
## or if does not define the indicated tag.

proc add_system*(this: PandaSystem, system: string) {.importcpp: "#.add_system(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Intended for use by each subsystem to register itself at startup.

proc set_system_tag*(this: PandaSystem, system: string, tag: string, value: string) {.importcpp: "#.set_system_tag(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Intended for use by each subsystem to register its set of capabilities at
## startup.

proc heap_trim*(this: PandaSystem, pad: clonglong): bool {.importcpp: "#.heap_trim(#)".} ## \
## Attempts to release memory back to the system, if possible.  The pad
## argument is the minimum amount of unused memory to keep in the heap
## (against future allocations).  Any memory above that may be released to the
## system, reducing the memory size of this process.  There is no guarantee
## that any memory may be released.
##
## Returns true if any memory was actually released, false otherwise.

proc output*(this: PandaSystem, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: PandaSystem, `out`: ostream) {.importcpp: "#.write(#)".}

proc get_global_ptr*(_: typedesc[PandaSystem]): PandaSystem {.importcpp: "PandaSystem::get_global_ptr()", header: "pandaSystem.h".} ## \
## Returns the global PandaSystem object.

proc get_class_type*(_: typedesc[PandaSystem]): TypeHandle {.importcpp: "PandaSystem::get_class_type()", header: "pandaSystem.h".}

proc initDSearchPath*(): DSearchPath {.importcpp: "DSearchPath()".}

proc initDSearchPath*(copy: DSearchPath): DSearchPath {.importcpp: "DSearchPath(#)".}

proc initDSearchPath*(directory: Filename): DSearchPath {.importcpp: "DSearchPath(#)".}

proc initDSearchPath*(path: string, separator: string): DSearchPath {.importcpp: "DSearchPath(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc initDSearchPath*(path: string): DSearchPath {.importcpp: "DSearchPath(nimStringToStdString(#))", header: stringConversionCode.}

proc clear*(this: DSearchPath) {.importcpp: "#.clear()".} ## \
## Removes all the directories from the search list.

proc append_directory*(this: DSearchPath, directory: Filename) {.importcpp: "#.append_directory(#)".} ## \
## Adds a new directory to the end of the search list.

proc prepend_directory*(this: DSearchPath, directory: Filename) {.importcpp: "#.prepend_directory(#)".} ## \
## Adds a new directory to the front of the search list.

proc append_path*(this: DSearchPath, path: DSearchPath) {.importcpp: "#.append_path(#)".} ## \
## Adds all of the directories listed in the search path to the end of the
## search list.

proc append_path*(this: DSearchPath, path: string, separator: string) {.importcpp: "#.append_path(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds all of the directories listed in the search path to the end of the
## search list.

proc append_path*(this: DSearchPath, path: string) {.importcpp: "#.append_path(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds all of the directories listed in the search path to the end of the
## search list.

proc prepend_path*(this: DSearchPath, path: DSearchPath) {.importcpp: "#.prepend_path(#)".} ## \
## Adds all of the directories listed in the search path to the beginning of
## the search list.

proc is_empty*(this: DSearchPath): bool {.importcpp: "#.is_empty()".} ## \
## Returns true if the search list is empty, false otherwise.

proc get_num_directories*(this: DSearchPath): clonglong {.importcpp: "#.get_num_directories()".} ## \
## Returns the number of directories on the search list.

proc get_directory*(this: DSearchPath, n: clonglong): Filename {.importcpp: "#.get_directory(#)".} ## \
## Returns the nth directory on the search list.

proc find_file*(this: DSearchPath, filename: Filename): Filename {.importcpp: "#.find_file(#)".} ## \
## Searches all the directories in the search list for the indicated file, in
## order.  Returns the full matching pathname of the first match if found, or
## the empty string if not found.

proc search_path*(_: typedesc[DSearchPath], filename: Filename, path: string, separator: string): Filename {.importcpp: "DSearchPath::search_path(#, nimStringToStdString(#), nimStringToStdString(#))", header: "dSearchPath.h".} ## \
## A quick-and-easy way to search a searchpath for a file when you don't feel
## like building or keeping around a DSearchPath object.  This simply
## constructs a temporary DSearchPath based on the indicated path string, and
## searches that.

proc search_path*(_: typedesc[DSearchPath], filename: Filename, path: string): Filename {.importcpp: "DSearchPath::search_path(#, nimStringToStdString(#))", header: "dSearchPath.h".} ## \
## A quick-and-easy way to search a searchpath for a file when you don't feel
## like building or keeping around a DSearchPath object.  This simply
## constructs a temporary DSearchPath based on the indicated path string, and
## searches that.

proc output*(this: DSearchPath, `out`: ostream, separator: string) {.importcpp: "#.output(#, nimStringToStdString(#))", header: stringConversionCode.}

proc output*(this: DSearchPath, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: DSearchPath, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: DSearchPath, `out`: ostream) {.importcpp: "#.write(#)".}

proc has_environment_variable*(_: typedesc[ExecutionEnvironment], `var`: string): bool {.importcpp: "ExecutionEnvironment::has_environment_variable(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if the indicated environment variable is defined.

proc get_environment_variable*(_: typedesc[ExecutionEnvironment], `var`: string): string {.importcpp: "nimStringFromStdString(ExecutionEnvironment::get_environment_variable(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Returns the definition of the indicated environment variable, or the empty
## string if the variable is undefined.

proc set_environment_variable*(_: typedesc[ExecutionEnvironment], `var`: string, value: string) {.importcpp: "ExecutionEnvironment::set_environment_variable(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the definition of the indicated environment variable.

proc shadow_environment_variable*(_: typedesc[ExecutionEnvironment], `var`: string, value: string) {.importcpp: "ExecutionEnvironment::shadow_environment_variable(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the apparent definition of the indicated environment variable by
## masking it within this class with a new value.  This does not change the
## actual environment variable, but future calls to get_environment_variable()
## will return this new value.

proc clear_shadow*(_: typedesc[ExecutionEnvironment], `var`: string) {.importcpp: "ExecutionEnvironment::clear_shadow(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes a value set by a previous call to shadow_environment_variable(),
## and lets the actual value of the variable show again.

proc expand_string*(_: typedesc[ExecutionEnvironment], str: string): string {.importcpp: "nimStringFromStdString(ExecutionEnvironment::expand_string(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Reads the string, looking for environment variable names marked by a $.
## Expands all such variable names.  A repeated dollar sign ($$) is mapped to
## a single dollar sign.
##
## Returns the expanded string.

proc get_num_args*(_: typedesc[ExecutionEnvironment]): clonglong {.importcpp: "ExecutionEnvironment::get_num_args()", header: "executionEnvironment.h".} ## \
## Returns the number of command-line arguments available, not counting arg 0,
## the binary name.

proc get_arg*(_: typedesc[ExecutionEnvironment], n: clonglong): string {.importcpp: "nimStringFromStdString(ExecutionEnvironment::get_arg(#))", header: stringConversionCode.} ## \
## Returns the nth command-line argument.  The index n must be in the range [0
## .. get_num_args()).  The first parameter, n == 0, is the first actual
## parameter, not the binary name.

proc get_binary_name*(_: typedesc[ExecutionEnvironment]): string {.importcpp: "nimStringFromStdString(ExecutionEnvironment::get_binary_name())", header: stringConversionCode.} ## \
## Returns the name of the binary executable that started this program, if it
## can be determined.

proc get_dtool_name*(_: typedesc[ExecutionEnvironment]): string {.importcpp: "nimStringFromStdString(ExecutionEnvironment::get_dtool_name())", header: stringConversionCode.} ## \
## Returns the name of the libdtool DLL that is used in this program, if it
## can be determined.

proc set_binary_name*(_: typedesc[ExecutionEnvironment], name: string) {.importcpp: "ExecutionEnvironment::set_binary_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Do not use.

proc set_dtool_name*(_: typedesc[ExecutionEnvironment], name: string) {.importcpp: "ExecutionEnvironment::set_dtool_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Do not use.

proc get_cwd*(_: typedesc[ExecutionEnvironment]): Filename {.importcpp: "ExecutionEnvironment::get_cwd()", header: "executionEnvironment.h".} ## \
## Returns the name of the current working directory.

proc initExecutionEnvironment*(param0: ExecutionEnvironment): ExecutionEnvironment {.importcpp: "ExecutionEnvironment(#)".}

proc initGlobPattern*(copy: GlobPattern): GlobPattern {.importcpp: "GlobPattern(#)".}

proc initGlobPattern*(pattern: string): GlobPattern {.importcpp: "GlobPattern(nimStringToStdString(#))", header: stringConversionCode.}

proc initGlobPattern*(): GlobPattern {.importcpp: "GlobPattern()".}

proc `==`*(this: GlobPattern, other: GlobPattern): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: GlobPattern, other: GlobPattern): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: GlobPattern, other: GlobPattern): bool {.importcpp: "#.operator <(#)".}

proc set_pattern*(this: GlobPattern, pattern: string) {.importcpp: "#.set_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the pattern string that the GlobPattern object matches.

proc get_pattern*(this: GlobPattern): string {.importcpp: "nimStringFromStdString(#.get_pattern())", header: stringConversionCode.} ## \
## Returns the pattern string that the GlobPattern object matches.

proc set_case_sensitive*(this: GlobPattern, case_sensitive: bool) {.importcpp: "#.set_case_sensitive(#)".} ## \
## Sets whether the match is case sensitive (true) or case insensitive
## (false).  The default is case sensitive.

proc get_case_sensitive*(this: GlobPattern): bool {.importcpp: "#.get_case_sensitive()".} ## \
## Returns whether the match is case sensitive (true) or case insensitive
## (false).  The default is case sensitive.

proc set_nomatch_chars*(this: GlobPattern, nomatch_chars: string) {.importcpp: "#.set_nomatch_chars(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies a set of characters that are not matched by * or ?.

proc get_nomatch_chars*(this: GlobPattern): string {.importcpp: "nimStringFromStdString(#.get_nomatch_chars())", header: stringConversionCode.} ## \
## Returns the set of characters that are not matched by * or ?.

proc matches*(this: GlobPattern, candidate: string): bool {.importcpp: "#.matches(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if the candidate string matches the pattern, false otherwise.

proc matches_file*(this: GlobPattern, candidate: Filename): bool {.importcpp: "#.matches_file(#)".} ## \
## Treats the GlobPattern as a filename pattern, and returns true if the given
## filename matches the pattern.  Unlike matches(), this will not match slash
## characters for single asterisk characters, and it will ignore path
## components that only contain a dot.

proc output*(this: GlobPattern, `out`: ostream) {.importcpp: "#.output(#)".}

proc has_glob_characters*(this: GlobPattern): bool {.importcpp: "#.has_glob_characters()".} ## \
## Returns true if the pattern includes any special globbing characters, or
## false if it is just a literal string.

proc get_const_prefix*(this: GlobPattern): string {.importcpp: "nimStringFromStdString(#.get_const_prefix())", header: stringConversionCode.} ## \
## Returns the initial part of the pattern before the first glob character.
## Since many glob patterns begin with a sequence of static characters and end
## with one or more glob characters, this can be used to optimized searches
## through sorted indices.

proc initLineStream*(): LineStream {.importcpp: "LineStream()".}

proc is_text_available*(this: LineStream): bool {.importcpp: "#.is_text_available()".} ## \
## Returns true if there is at least one line of text (or even a partial line)
## available in the LineStream object.  If this returns true, the line may
## then be retrieved via get_line().

proc get_line*(this: LineStream): string {.importcpp: "nimStringFromStdString(#.get_line())", header: stringConversionCode.} ## \
## Extracts and returns the next line (or partial line) of text available in
## the LineStream object.  Once the line has been extracted, you may call
## has_newline() to determine whether or not there was an explicit newline
## character written following this line.

proc has_newline*(this: LineStream): bool {.importcpp: "#.has_newline()".} ## \
## Returns true if the line of text most recently returned by get_line() was
## written out with a terminating newline, or false if a newline character has
## not yet been written to the LineStream.

proc initConfigFlags*(): ConfigFlags {.importcpp: "ConfigFlags()".}

proc initConfigFlags*(param0: ConfigFlags): ConfigFlags {.importcpp: "ConfigFlags(#)".}

proc get_default_page*(_: typedesc[ConfigPage]): ConfigPage {.importcpp: "ConfigPage::get_default_page()", header: "configPage.h".} ## \
## Returns a pointer to the global "default page".  This is the ConfigPage
## that lists all variables' original default values.

proc get_local_page*(_: typedesc[ConfigPage]): ConfigPage {.importcpp: "ConfigPage::get_local_page()", header: "configPage.h".} ## \
## Returns a pointer to the global "local page".  This is the ConfigPage that
## lists the locally-assigned values for any variables in the world that have
## such a local assignment.

proc get_name*(this: ConfigPage): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the page.  If the page was loaded from a .prc file,
## this is usually the filename.

proc is_special*(this: ConfigPage): bool {.importcpp: "#.is_special()".} ## \
## Returns true if this is the special "default" or "local" page, or false if
## it is an ordinary page, e.g.  an implicit page loaded from a prc file at
## startup, or an explicit page created by
## ConfigPageManager::make_explicit_page().

proc is_implicit*(this: ConfigPage): bool {.importcpp: "#.is_implicit()".} ## \
## Returns true if the page was loaded by implicitly searching the config path
## on startup, or false if it was explicitly loaded by dynamic code after
## initial startup.

proc set_sort*(this: ConfigPage, sort: int) {.importcpp: "#.set_sort(#)".} ## \
## Changes the explicit sort order of this particular ConfigPage.  Lower-
## numbered pages supercede higher-numbered pages.  Initially, all explicitly-
## loaded pages have sort value 0, and implicitly-loaded pages (found on disk)
## have sort value 10; you may set an individual page higher or lower to
## influence its priority relative to other pages.

proc get_sort*(this: ConfigPage): int {.importcpp: "#.get_sort()".} ## \
## Returns the explicit sort order of this particular ConfigPage.  See
## set_sort().

proc get_page_seq*(this: ConfigPage): int {.importcpp: "#.get_page_seq()".} ## \
## Returns the sequence number of the page.
##
## Sequence numbers for a particular class (implicit vs.  explicit) of pages
## are assigned as each page is loaded; each page is given a higher sequence
## number than all the pages loaded before it.
##
## The implicit_load pages, which are discovered in the file system
## automatically, have a different set of sequence numbers than the explicit
## pages.

proc get_trust_level*(this: ConfigPage): int {.importcpp: "#.get_trust_level()".} ## \
## Returns the trust level associated with this page.  An untrusted page is
## trust level 0; if the page was loaded from a signed .prc file, its trust
## level is the index number of the certificate that signed it.  Generally, a
## higher trust level value represents a greater level of trust.

proc set_trust_level*(this: ConfigPage, trust_level: int) {.importcpp: "#.set_trust_level(#)".} ## \
## Explicitly sets the trust level on this particular page.  Note that any
## subsequent changes to the page, or to any variable declarations on it, will
## reset the trust level to zero.

proc get_signature*(this: ConfigPage): string {.importcpp: "nimStringFromStdString(#.get_signature())", header: stringConversionCode.} ## \
## Returns the raw binary signature that was found in the prc file, if any.
## This method is probably not terribly useful for most applications.

proc clear*(this: ConfigPage) {.importcpp: "#.clear()".} ## \
## Removes all of the declarations from the page.

proc read_prc*(this: ConfigPage, `in`: istream): bool {.importcpp: "#.read_prc(#)".} ## \
## Reads the contents of a complete prc file, as returned by the indicated
## istream, into the current page file.  Returns true on success, or false on
## some I/O error.
##
## This is a low-level interface.  Normally you do not need to call it
## directly.  See the global functions load_prc_file() and unload_prc_file(),
## defined in panda/src/putil, for a higher-level interface.

proc read_encrypted_prc*(this: ConfigPage, `in`: istream, password: string): bool {.importcpp: "#.read_encrypted_prc(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Automatically decrypts and reads the stream, given the indicated password.
## Note that if the password is incorrect, the result may be garbage.

proc make_declaration*(this: ConfigPage, variable: ConfigVariableCore, value: string): ConfigDeclaration {.importcpp: "#.make_declaration(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds the indicated variable/value pair as a new declaration on the page.

proc make_declaration*(this: ConfigPage, variable: string, value: string): ConfigDeclaration {.importcpp: "#.make_declaration(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds the indicated variable/value pair as a new declaration on the page.

proc delete_declaration*(this: ConfigPage, decl: ConfigDeclaration): bool {.importcpp: "#.delete_declaration(#)".} ## \
## Removes the indicated declaration from the page and deletes it.  Returns
## true if the declaration is successfully removed, false if it was not on the
## page.

proc get_num_declarations*(this: ConfigPage): clonglong {.importcpp: "#.get_num_declarations()".} ## \
## Returns the number of declarations on the page.

proc get_declaration*(this: ConfigPage, n: clonglong): ConfigDeclaration {.importcpp: "#.get_declaration(#)".} ## \
## Returns the nth declaration on the page.

proc modify_declaration*(this: ConfigPage, n: clonglong): ConfigDeclaration {.importcpp: "#.modify_declaration(#)".} ## \
## Returns a modifiable pointer to the nth declaration on the page.  Any
## modifications will appear in the output, if the page is written out with
## ConfigPage::write().

proc get_variable_name*(this: ConfigPage, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_variable_name(#))", header: stringConversionCode.} ## \
## Returns the variable named by the nth declaration on the page.

proc get_string_value*(this: ConfigPage, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_string_value(#))", header: stringConversionCode.} ## \
## Returns the value assigned by the nth declaration on the page.

proc is_variable_used*(this: ConfigPage, n: clonglong): bool {.importcpp: "#.is_variable_used(#)".} ## \
## Returns true if the nth active variable on the page has been used by code,
## false otherwise.

proc get_page*(this: ConfigDeclaration): ConfigPage {.importcpp: "#.get_page()".} ## \
## Returns the page on which this declaration can be found.

proc get_variable*(this: ConfigDeclaration): ConfigVariableCore {.importcpp: "#.get_variable()".} ## \
## Returns the variable that this declaration names.  This variable may or may
## not have been defined by the time the declaration is read.

proc get_name*(this: ConfigVariableCore): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the variable.

proc is_used*(this: ConfigVariableCore): bool {.importcpp: "#.is_used()".} ## \
## Returns true if the variable has been referenced by a ConfigVariable
## somewhere in code, false otherwise.

proc get_description*(this: ConfigVariableCore): string {.importcpp: "nimStringFromStdString(#.get_description())", header: stringConversionCode.} ## \
## Returns the brief description of this variable, if it has been defined.

proc get_flags*(this: ConfigVariableCore): int {.importcpp: "#.get_flags()".} ## \
## Returns the flags value as set by set_flags().  This includes the trust
## level and some other settings.  See the individual methods is_closed(),
## get_trust_level(), etc.  to pull out the semantic meaning of these flags
## individually.

proc is_closed*(this: ConfigVariableCore): bool {.importcpp: "#.is_closed()".} ## \
## Returns true if the variable is not trusted by any prc file (and hence
## cannot be modified from its compiled-in default value), or false for the
## normal case, in which the variable can be modified by any prc file at or
## above its trust level (see get_trust_level()).
##
## This value only has effect in a release build (specifically, when
## PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).

proc get_trust_level*(this: ConfigVariableCore): int {.importcpp: "#.get_trust_level()".} ## \
## Returns the minimum trust_level a prc file must demonstrate in order to
## redefine the value for this variable.  Arguably, this should be called the
## "mistrust level", since the larger the value, the more suspicious we are of
## prc files.  This value is not used if is_closed() returns true, which
## indicates no file may be trusted.
##
## This value only has effect in a release build (specifically, when
## PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).

proc is_dynamic*(this: ConfigVariableCore): bool {.importcpp: "#.is_dynamic()".} ## \
## Returns true if the variable was indicated as "dynamic" by its constructor,
## indicating that its name was dynamically generated, possibly from a large
## pool, and it should not be listed along with the other variables.

proc get_default_value*(this: ConfigVariableCore): ConfigDeclaration {.importcpp: "#.get_default_value()".} ## \
## Returns the default variable specified for this variable.  If the variable
## has not yet been defined, this will return NULL.

proc set_flags*(this: ConfigVariableCore, flags: int) {.importcpp: "#.set_flags(#)".} ## \
## Specifies the trust level of this variable.  See get_flags().  It is not an
## error to call this multiple times, but if the value changes once
## get_declaration() has been called, a warning is printed.

proc set_description*(this: ConfigVariableCore, description: string) {.importcpp: "#.set_description(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the one-line description of this variable.  See
## get_description().  It is not an error to call this multiple times, but if
## the value changes once get_declaration() has been called, a warning is
## printed.

proc set_default_value*(this: ConfigVariableCore, default_value: string) {.importcpp: "#.set_default_value(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the default value for this variable if it is not defined in any
## prc file.

proc set_used*(this: ConfigVariableCore) {.importcpp: "#.set_used()".} ## \
## Marks that the variable has been "declared" by a ConfigVariable.

proc make_local_value*(this: ConfigVariableCore): ConfigDeclaration {.importcpp: "#.make_local_value()".} ## \
## Creates a new local value for this variable, if there is not already one
## specified.  This will shadow any values defined in the various .prc files.
##
## If there is already a local value defined for this variable, simply returns
## that one.
##
## Use clear_local_value() to remove the local value definition.

proc clear_local_value*(this: ConfigVariableCore): bool {.importcpp: "#.clear_local_value()".} ## \
## Removes the local value defined for this variable, and allows its value to
## be once again retrieved from the .prc files.
##
## Returns true if the value was successfully removed, false if it did not
## exist in the first place.

proc has_local_value*(this: ConfigVariableCore): bool {.importcpp: "#.has_local_value()".} ## \
## Returns true if this variable's value has been shadowed by a local
## assignment (as created via make_local_value()), or false otherwise.

proc has_value*(this: ConfigVariableCore): bool {.importcpp: "#.has_value()".} ## \
## Returns true if this variable has an explicit value, either from a prc file
## or locally set, or false if variable has its default value.

proc get_num_declarations*(this: ConfigVariableCore): clonglong {.importcpp: "#.get_num_declarations()".} ## \
## Returns the number of declarations that contribute to this variable's
## value.  If the variable has been defined, this will always be at least 1
## (for the default value, at least).

proc get_declaration*(this: ConfigVariableCore, n: clonglong): ConfigDeclaration {.importcpp: "#.get_declaration(#)".} ## \
## Returns the nth declarations that contributes to this variable's value.
## The declarations are arranged in order such that earlier declarations
## shadow later declarations; thus, get_declaration(0) is always defined and
## always returns the current value of the variable.

proc get_num_references*(this: ConfigVariableCore): clonglong {.importcpp: "#.get_num_references()".} ## \
## Returns the number of prc files that reference this variable.  This is not
## exactly the same as the number of declarations; see get_reference().

proc get_reference*(this: ConfigVariableCore, n: clonglong): ConfigDeclaration {.importcpp: "#.get_reference(#)".} ## \
## Returns the nth declaration in a prc file that references this variable.
## This is similar, but not identical to, get_declaration().  The difference
## is that this will list *only* true references in a prc file, and will not
## list default values or locally-assigned values; it also will list even the
## untrusted files.

proc get_num_trusted_references*(this: ConfigVariableCore): clonglong {.importcpp: "#.get_num_trusted_references()".} ## \
## Returns the number of trusted prc files that reference this variable.  See
## also get_num_references().

proc get_trusted_reference*(this: ConfigVariableCore, n: clonglong): ConfigDeclaration {.importcpp: "#.get_trusted_reference(#)".} ## \
## Returns the nth declaration in a trusted prc file that references this
## variable.  This is similar, but not identical to, get_declaration().  The
## difference is that this will list *only* true references in a prc file, and
## will not list default values or locally-assigned values.
##
## This is also similar to get_reference(), except that it only lists the
## trusted declarations, omitting the untrusted ones.

proc get_num_unique_references*(this: ConfigVariableCore): clonglong {.importcpp: "#.get_num_unique_references()".} ## \
## Returns the number of trusted, unique (by string value) values there exist
## for this variable.

proc get_unique_reference*(this: ConfigVariableCore, n: clonglong): ConfigDeclaration {.importcpp: "#.get_unique_reference(#)".} ## \
## Returns the nth trusted, unique value for this variable.  This is similar
## to get_trusted_reference(), except that duplicate values are removed.

proc output*(this: ConfigVariableCore, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: ConfigVariableCore, `out`: ostream) {.importcpp: "#.write(#)".}

proc get_string_value*(this: ConfigDeclaration): string {.importcpp: "nimStringFromStdString(#.get_string_value())", header: stringConversionCode.} ## \
## Returns the value assigned to this variable.  This is the original one-line
## text defined for the variable in the .prc file (or passed to
## ConfigPage::make_declaration()).

proc set_string_value*(this: ConfigDeclaration, value: string) {.importcpp: "#.set_string_value(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the value assigned to this variable.

proc get_num_words*(this: ConfigDeclaration): clonglong {.importcpp: "#.get_num_words()".} ## \
## Returns the number of words in the declaration's value.  A word is defined
## as a sequence of non-whitespace characters delimited by whitespace.

proc has_string_word*(this: ConfigDeclaration, n: clonglong): bool {.importcpp: "#.has_string_word(#)".} ## \
## Returns true if the declaration's value has a valid string value for the
## nth word.  This is really the same thing as asking if there are at least n
## words in the value.

proc has_bool_word*(this: ConfigDeclaration, n: clonglong): bool {.importcpp: "#.has_bool_word(#)".} ## \
## Returns true if the declaration's value has a valid boolean value for the
## nth word.

proc has_int_word*(this: ConfigDeclaration, n: clonglong): bool {.importcpp: "#.has_int_word(#)".} ## \
## Returns true if the declaration's value has a valid integer value for the
## nth word.

proc has_int64_word*(this: ConfigDeclaration, n: clonglong): bool {.importcpp: "#.has_int64_word(#)".} ## \
## Returns true if the declaration's value has a valid int64 value for the nth
## word.

proc has_double_word*(this: ConfigDeclaration, n: clonglong): bool {.importcpp: "#.has_double_word(#)".} ## \
## Returns true if the declaration's value has a valid integer value for the
## nth word.

proc get_string_word*(this: ConfigDeclaration, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_string_word(#))", header: stringConversionCode.} ## \
## Returns the string value of the nth word of the declaration's value, or
## empty string if there is no nth value.  See also has_string_word().

proc get_bool_word*(this: ConfigDeclaration, n: clonglong): bool {.importcpp: "#.get_bool_word(#)".} ## \
## Returns the boolean value of the nth word of the declaration's value, or
## false if there is no nth value.  See also has_bool_word().

proc get_int_word*(this: ConfigDeclaration, n: clonglong): int {.importcpp: "#.get_int_word(#)".} ## \
## Returns the integer value of the nth word of the declaration's value, or 0
## if there is no nth value.  See also has_int_word().

proc get_int64_word*(this: ConfigDeclaration, n: clonglong): clonglong {.importcpp: "#.get_int64_word(#)".} ## \
## Returns the int64 value of the nth word of the declaration's value, or 0 if
## there is no nth value.  See also has_int64_word().

proc get_double_word*(this: ConfigDeclaration, n: clonglong): float64 {.importcpp: "#.get_double_word(#)".} ## \
## Returns the integer value of the nth word of the declaration's value, or 0
## if there is no nth value.  See also has_double_word().

proc set_string_word*(this: ConfigDeclaration, n: clonglong, value: string) {.importcpp: "#.set_string_word(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the nth word to the indicated value without affecting the other
## words.

proc set_bool_word*(this: ConfigDeclaration, n: clonglong, value: bool) {.importcpp: "#.set_bool_word(#, #)".} ## \
## Changes the nth word to the indicated value without affecting the other
## words.

proc set_int_word*(this: ConfigDeclaration, n: clonglong, value: int) {.importcpp: "#.set_int_word(#, #)".} ## \
## Changes the nth word to the indicated value without affecting the other
## words.

proc set_int64_word*(this: ConfigDeclaration, n: clonglong, value: clonglong) {.importcpp: "#.set_int64_word(#, #)".} ## \
## Changes the nth word to the indicated value without affecting the other
## words.

proc set_double_word*(this: ConfigDeclaration, n: clonglong, value: float64) {.importcpp: "#.set_double_word(#, #)".} ## \
## Changes the nth word to the indicated value without affecting the other
## words.

proc get_filename_value*(this: ConfigDeclaration): Filename {.importcpp: "#.get_filename_value()".} ## \
## Interprets the string value as a filename and returns it, with any
## variables expanded.

proc get_decl_seq*(this: ConfigDeclaration): int {.importcpp: "#.get_decl_seq()".} ## \
## Returns the sequence number of the declaration within the page.  Sequence
## numbers are assigned as each declaration is created; each declaration is
## given a higher sequence number than all the declarations created in the
## page before it.

proc output*(this: ConfigDeclaration, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: ConfigDeclaration, `out`: ostream) {.importcpp: "#.write(#)".}

proc output*(this: ConfigPage, `out`: ostream) {.importcpp: "#.output(#)".}

proc output_brief_signature*(this: ConfigPage, `out`: ostream) {.importcpp: "#.output_brief_signature(#)".} ## \
## Outputs the first few hex digits of the signature.

proc write*(this: ConfigPage, `out`: ostream) {.importcpp: "#.write(#)".}

proc initNotify*(): Notify {.importcpp: "Notify()".}

proc initNotify*(param0: Notify): Notify {.importcpp: "Notify(#)".}

proc set_ostream_ptr*(this: Notify, ostream_ptr: ostream, delete_later: bool) {.importcpp: "#.set_ostream_ptr(#, #)".} ## \
## Changes the ostream that all subsequent Notify messages will be written to.
## If the previous ostream was set with delete_later = true, this will delete
## the previous ostream.  If ostream_ptr is NULL, this resets the default to
## cerr.

proc get_ostream_ptr*(this: Notify): ostream {.importcpp: "#.get_ostream_ptr()".} ## \
## Returns the system-wide ostream for all Notify messages.

proc clear_assert_handler*(this: Notify) {.importcpp: "#.clear_assert_handler()".} ## \
## Removes the installed assert handler and restores default behavior of
## nassertr() and nassertv().

proc has_assert_handler*(this: Notify): bool {.importcpp: "#.has_assert_handler()".} ## \
## Returns true if a user assert handler has been installed, false otherwise.

proc get_assert_handler*(this: Notify) {.importcpp: "#.get_assert_handler()".} ## \
## Returns a pointer to the user-installed assert handler, if one was
## installed, or NULL otherwise.

proc has_assert_failed*(this: Notify): bool {.importcpp: "#.has_assert_failed()".} ## \
## Returns true if an assertion test has failed (and not been ignored) since
## the last call to clear_assert_failed().
##
## When an assertion test fails, the assert handler may decide either to
## abort, return, or ignore the assertion.  Naturally, if it decides to abort,
## this flag is irrelevant.  If it chooses to ignore the assertion, the flag
## is not set.  However, if the assert handler chooses to return out of the
## function (the normal case), it will also set this flag to indicate that an
## assertion failure has occurred.
##
## This will also be the behavior in the absence of a user-defined assert
## handler.

proc get_assert_error_message*(this: Notify): string {.importcpp: "nimStringFromStdString(#.get_assert_error_message())", header: stringConversionCode.} ## \
## Returns the error message that corresponds to the assertion that most
## recently failed.

proc clear_assert_failed*(this: Notify) {.importcpp: "#.clear_assert_failed()".} ## \
## Resets the assert_failed flag that is set whenever an assertion test fails.
## See has_assert_failed().

proc get_top_category*(this: Notify): NotifyCategory {.importcpp: "#.get_top_category()".} ## \
## Returns the topmost Category in the hierarchy.  This may be used to
## traverse the hierarchy of available Categories.

proc get_category*(this: Notify, fullname: string): NotifyCategory {.importcpp: "#.get_category(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Finds or creates a new Category given the fullname of the Category.  This
## name should be a sequence of colon-separated names of parent Categories,
## ending in the basename of this Category, e.g.  display:glxdisplay.  This is
## a shorthand way to define a Category when a pointer to its parent is not
## handy.

proc get_category*(this: Notify, basename: string, parent_category: NotifyCategory): NotifyCategory {.importcpp: "#.get_category(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Finds or creates a new Category given the basename of the category and its
## parent in the category hierarchy.  The parent pointer may be NULL to
## indicate this is a top-level Category.

proc get_category*(this: Notify, basename: string, parent_fullname: string): NotifyCategory {.importcpp: "#.get_category(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Finds or creates a new Category given the basename of the category and the
## fullname of its parent.  This is another way to create a category when you
## don't have a pointer to its parent handy, but you know the name of its
## parent.  If the parent Category does not already exist, it will be created.

proc null*(_: typedesc[Notify]): ostream {.importcpp: "Notify::null()", header: "notify.h".} ## \
## A convenient way to get an ostream that doesn't do anything.  Returned by
## Category::out() when a particular Category and/or Severity is disabled.

proc write_string*(_: typedesc[Notify], str: string) {.importcpp: "Notify::write_string(nimStringToStdString(#))", header: stringConversionCode.} ## \
## A convenient way for scripting languages, which may know nothing about
## ostreams, to write to Notify.  This writes a single string, followed by an
## implicit newline, to the Notify output stream.

proc loaded_implicit_pages*(this: ConfigPageManager): bool {.importcpp: "#.loaded_implicit_pages()".} ## \
## Returns true if the implicit `*.prc` files have already been loaded, false
## otherwise.  Normally this will only be false briefly before startup.

proc load_implicit_pages*(this: ConfigPageManager) {.importcpp: "#.load_implicit_pages()".} ## \
## Searches the PRC_DIR and/or PRC_PATH directories for `*.prc` files and loads
## them in as pages.  This is normally called automatically at startup time,
## when the first variable's value is referenced.  See also
## reload_implicit_pages().

proc reload_implicit_pages*(this: ConfigPageManager) {.importcpp: "#.reload_implicit_pages()".} ## \
## Searches the PRC_DIR and/or PRC_PATH directories for *.prc files and loads
## them in as pages.
##
## This may be called after startup, to force the system to re-read all of the
## implicit prc files.

proc get_search_path*(this: ConfigPageManager): DSearchPath {.importcpp: "#.get_search_path()".} ## \
## Returns the search path used to locate implicit .prc files.  This is
## determined by the PRC_DIR and PRC_PATH environment variables.  The object
## returned by this method may be modified to change the path at runtime, and
## then reload_implicit_pages() called.

proc get_num_prc_patterns*(this: ConfigPageManager): clonglong {.importcpp: "#.get_num_prc_patterns()".} ## \
## Returns the number of patterns, like `*.prc`, that are compiled in that
## will be searched for as default config filenames.  Normally there is only
## one pattern, and it is `*.prc`, but others may be specified with the
## PRC_FILENAME variable in Config.pp.

proc get_prc_pattern*(this: ConfigPageManager, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_prc_pattern(#))", header: stringConversionCode.} ## \
## Returns the nth filename pattern that will be considered a match as a valid
## config file.  See get_num_prc_patterns().

proc get_num_prc_encrypted_patterns*(this: ConfigPageManager): clonglong {.importcpp: "#.get_num_prc_encrypted_patterns()".} ## \
## Returns the number of patterns, like `*.pre`, that are compiled in that
## will be searched for as special config files that are understood to be
## encrypted.

proc get_prc_encrypted_pattern*(this: ConfigPageManager, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_prc_encrypted_pattern(#))", header: stringConversionCode.} ## \
## Returns the nth filename pattern that will be considered a match as a valid
## encrypted config file.  See get_num_prc_encrypted_patterns().

proc get_num_prc_executable_patterns*(this: ConfigPageManager): clonglong {.importcpp: "#.get_num_prc_executable_patterns()".} ## \
## Returns the number of patterns, like `*.exe`, that are compiled in that
## will be searched for as special config files that are to be executed as a
## program, and their output taken to be input.  This is normally empty.

proc get_prc_executable_pattern*(this: ConfigPageManager, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_prc_executable_pattern(#))", header: stringConversionCode.} ## \
## Returns the nth filename pattern that will be considered a match as a valid
## executable-style config file.  See get_num_prc_executable_patterns().

proc make_explicit_page*(this: ConfigPageManager, name: string): ConfigPage {.importcpp: "#.make_explicit_page(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates and returns a new, empty ConfigPage.  This page will be stacked on
## top of any pages that were created before; it may shadow variable
## declarations that are defined in previous pages.

proc delete_explicit_page*(this: ConfigPageManager, page: ConfigPage): bool {.importcpp: "#.delete_explicit_page(#)".} ## \
## Removes a previously-constructed ConfigPage from the set of active pages,
## and deletes it.  The ConfigPage object is no longer valid after this call.
## Returns true if the page is successfully deleted, or false if it was
## unknown (which should never happen if the page was legitimately
## constructed).

proc get_num_implicit_pages*(this: ConfigPageManager): clonglong {.importcpp: "#.get_num_implicit_pages()".} ## \
## Returns the current number of implicitly-loaded ConfigPages in the world.
## These represent files that were automatically discovered on the disk as
## .prc files.

proc get_implicit_page*(this: ConfigPageManager, n: clonglong): ConfigPage {.importcpp: "#.get_implicit_page(#)".} ## \
## Returns the nth implicit ConfigPage in the world.  See
## get_num_implicit_pages().

proc get_num_explicit_pages*(this: ConfigPageManager): clonglong {.importcpp: "#.get_num_explicit_pages()".} ## \
## Returns the current number of explicitly-loaded ConfigPages in the world.
## These represent pages that were loaded dynamically at runtime by explicit
## calls to ConfigPageManager::make_explicit_page().

proc get_explicit_page*(this: ConfigPageManager, n: clonglong): ConfigPage {.importcpp: "#.get_explicit_page(#)".} ## \
## Returns the nth explicit ConfigPage in the world.  See
## get_num_explicit_pages().

proc output*(this: ConfigPageManager, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: ConfigPageManager, `out`: ostream) {.importcpp: "#.write(#)".}

proc get_global_ptr*(_: typedesc[ConfigPageManager]): ConfigPageManager {.importcpp: "ConfigPageManager::get_global_ptr()", header: "configPageManager.h".}

proc make_variable*(this: ConfigVariableManager, name: string): ConfigVariableCore {.importcpp: "#.make_variable(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates and returns a new, undefined ConfigVariableCore with the indicated
## name; or if a variable with this name has already been created, returns
## that one instead.

proc get_num_variables*(this: ConfigVariableManager): clonglong {.importcpp: "#.get_num_variables()".} ## \
## Returns the current number of active ConfigVariableCores in the world.

proc get_variable*(this: ConfigVariableManager, n: clonglong): ConfigVariableCore {.importcpp: "#.get_variable(#)".} ## \
## Returns the nth active ConfigVariableCore in the world.

proc get_variable_name*(this: ConfigVariableManager, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_variable_name(#))", header: stringConversionCode.} ## \
## Returns the name of the nth active ConfigVariable in the list.

proc is_variable_used*(this: ConfigVariableManager, n: clonglong): bool {.importcpp: "#.is_variable_used(#)".} ## \
## Returns true if the nth active ConfigVariable in the list has been used by
## code, false otherwise.

proc output*(this: ConfigVariableManager, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: ConfigVariableManager, `out`: ostream) {.importcpp: "#.write(#)".}

proc write_prc_variables*(this: ConfigVariableManager, `out`: ostream) {.importcpp: "#.write_prc_variables(#)".} ## \
## Writes all of the prc-set config variables, as they appear in a prc file
## somewhere, one per line, very concisely.  This lists the dominant value in
## the prc file; it does not list shadowed values, and it does not list
## locally-set values.
##
## This is mainly intended for generating a hash of the input config file
## state.

proc list_unused_variables*(this: ConfigVariableManager) {.importcpp: "#.list_unused_variables()".} ## \
## Writes a list of all the variables that have been defined in a prc file
## without having been declared somewhere in code.

proc list_variables*(this: ConfigVariableManager) {.importcpp: "#.list_variables()".} ## \
## Writes a list of all the variables that have been declared somewhere in
## code, along with a brief description.

proc list_dynamic_variables*(this: ConfigVariableManager) {.importcpp: "#.list_dynamic_variables()".} ## \
## Writes a list of all the "dynamic" variables that have been declared
## somewhere in code, along with a brief description.  This is a (usually
## large) list of config variables that are declared with a generated variable
## name.

proc get_global_ptr*(_: typedesc[ConfigVariableManager]): ConfigVariableManager {.importcpp: "ConfigVariableManager::get_global_ptr()", header: "configVariableManager.h".}

proc get_name*(this: ConfigVariableBase): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the variable.

proc get_description*(this: ConfigVariableBase): string {.importcpp: "nimStringFromStdString(#.get_description())", header: stringConversionCode.} ## \
## Returns the brief description of this variable, if it has been defined.

proc get_flags*(this: ConfigVariableBase): int {.importcpp: "#.get_flags()".} ## \
## Returns the flags value as set by set_flags().  This includes the trust
## level and some other settings.  See the individual methods is_closed(),
## get_trust_level(), etc.  to pull out the semantic meaning of these flags
## individually.

proc is_closed*(this: ConfigVariableBase): bool {.importcpp: "#.is_closed()".} ## \
## Returns true if the variable is not trusted by any prc file (and hence
## cannot be modified from its compiled-in default value), or false for the
## normal case, in which the variable can be modified by any prc file at or
## above its trust level (see get_trust_level()).
##
## This value only has effect in a release build (specifically, when
## PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).

proc get_trust_level*(this: ConfigVariableBase): int {.importcpp: "#.get_trust_level()".} ## \
## Returns the minimum trust_level a prc file must demonstrate in order to
## redefine the value for this variable.  Arguably, this should be called the
## "mistrust level", since the larger the value, the more suspicious we are of
## prc files.  This value is not used if is_closed() returns true, which
## indicates no file may be trusted.
##
## This value only has effect in a release build (specifically, when
## PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).

proc is_dynamic*(this: ConfigVariableBase): bool {.importcpp: "#.is_dynamic()".} ## \
## Returns true if the variable was indicated as "dynamic" by its constructor,
## indicating that its name was dynamically generated, possibly from a large
## pool, and it should not be listed along with the other variables.

proc clear_local_value*(this: ConfigVariableBase): bool {.importcpp: "#.clear_local_value()".} ## \
## Removes the local value defined for this variable, and allows its value to
## be once again retrieved from the .prc files.
##
## Returns true if the value was successfully removed, false if it did not
## exist in the first place.

proc has_local_value*(this: ConfigVariableBase): bool {.importcpp: "#.has_local_value()".} ## \
## Returns true if this variable's value has been shadowed by a local
## assignment (as created via make_local_value()), or false otherwise.

proc has_value*(this: ConfigVariableBase): bool {.importcpp: "#.has_value()".} ## \
## Returns true if this variable has an explicit value, either from a prc file
## or locally set, or false if variable has its default value.

proc output*(this: ConfigVariableBase, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: ConfigVariableBase, `out`: ostream) {.importcpp: "#.write(#)".}

proc initConfigVariable*(param0: ConfigVariable): ConfigVariable {.importcpp: "ConfigVariable(#)".}

proc initConfigVariable*(name: string): ConfigVariable {.importcpp: "ConfigVariable(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Use this constructor to make a ConfigVariable of an unspecified type.
## Usually you'd want to do this just to reference a previously-defined
## ConfigVariable of a specific type, without having to know what type it is.

proc get_string_value*(this: ConfigVariable): string {.importcpp: "nimStringFromStdString(#.get_string_value())", header: stringConversionCode.} ## \
## Returns the toplevel value of the variable, formatted as a string.

proc set_string_value*(this: ConfigVariable, value: string) {.importcpp: "#.set_string_value(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the value assigned to this variable.  This creates a local value
## that shadows any values defined in the .prc files, until
## clear_local_value() is called.

proc clear_value*(this: ConfigVariable) {.importcpp: "#.clear_value()".} ## \
## Removes the value assigned to this variable, and lets its original value
## (as read from the prc files) show through.

proc get_num_words*(this: ConfigVariable): clonglong {.importcpp: "#.get_num_words()".} ## \
## Returns the number of words in the variable's value.  A word is defined as
## a sequence of non-whitespace characters delimited by whitespace.

proc initConfigVariableBool*(param0: ConfigVariableBool): ConfigVariableBool {.importcpp: "ConfigVariableBool(#)".}

proc initConfigVariableBool*(name: string): ConfigVariableBool {.importcpp: "ConfigVariableBool(nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableBool*(name: string, default_value: bool, description: string, flags: int): ConfigVariableBool {.importcpp: "ConfigVariableBool(nimStringToStdString(#), #, nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableBool*(name: string, default_value: bool, description: string): ConfigVariableBool {.importcpp: "ConfigVariableBool(nimStringToStdString(#), #, nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableBool*(name: string, default_value: bool): ConfigVariableBool {.importcpp: "ConfigVariableBool(nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableBool*(name: string, default_value: string, description: string, flags: int): ConfigVariableBool {.importcpp: "ConfigVariableBool(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableBool*(name: string, default_value: string, description: string): ConfigVariableBool {.importcpp: "ConfigVariableBool(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableBool*(name: string, default_value: string): ConfigVariableBool {.importcpp: "ConfigVariableBool(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc `typecast bool`*(this: ConfigVariableBool): bool {.importcpp: "#.operator typecast bool()".}

proc size*(this: ConfigVariableBool): clonglong {.importcpp: "#.size()".} ## \
## Returns the number of unique words in the variable.

proc `[]`*(this: ConfigVariableBool, n: clonglong): bool {.importcpp: "#.operator [](#)".}

proc set_value*(this: ConfigVariableBool, value: bool) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

proc get_value*(this: ConfigVariableBool): bool {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc get_default_value*(this: ConfigVariableBool): bool {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

proc get_word*(this: ConfigVariableBool, n: clonglong): bool {.importcpp: "#.get_word(#)".} ## \
## Returns the variable's nth value.

proc set_word*(this: ConfigVariableBool, n: clonglong, value: bool) {.importcpp: "#.set_word(#, #)".} ## \
## Reassigns the variable's nth value.  This makes a local copy of the
## variable's overall value.

proc initConfigVariableDouble*(param0: ConfigVariableDouble): ConfigVariableDouble {.importcpp: "ConfigVariableDouble(#)".}

proc initConfigVariableDouble*(name: string): ConfigVariableDouble {.importcpp: "ConfigVariableDouble(nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableDouble*(name: string, default_value: float64, description: string, flags: int): ConfigVariableDouble {.importcpp: "ConfigVariableDouble(nimStringToStdString(#), #, nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableDouble*(name: string, default_value: float64, description: string): ConfigVariableDouble {.importcpp: "ConfigVariableDouble(nimStringToStdString(#), #, nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableDouble*(name: string, default_value: float64): ConfigVariableDouble {.importcpp: "ConfigVariableDouble(nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableDouble*(name: string, default_value: string, description: string, flags: int): ConfigVariableDouble {.importcpp: "ConfigVariableDouble(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableDouble*(name: string, default_value: string, description: string): ConfigVariableDouble {.importcpp: "ConfigVariableDouble(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableDouble*(name: string, default_value: string): ConfigVariableDouble {.importcpp: "ConfigVariableDouble(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc `typecast double`*(this: ConfigVariableDouble): float64 {.importcpp: "#.operator typecast double()".}

proc size*(this: ConfigVariableDouble): clonglong {.importcpp: "#.size()".} ## \
## Returns the number of unique words in the variable.

proc `[]`*(this: ConfigVariableDouble, n: clonglong): float64 {.importcpp: "#.operator [](#)".}

proc set_value*(this: ConfigVariableDouble, value: float64) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

proc get_value*(this: ConfigVariableDouble): float64 {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc get_default_value*(this: ConfigVariableDouble): float64 {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

proc get_word*(this: ConfigVariableDouble, n: clonglong): float64 {.importcpp: "#.get_word(#)".} ## \
## Returns the variable's nth value.

proc set_word*(this: ConfigVariableDouble, n: clonglong, value: float64) {.importcpp: "#.set_word(#, #)".} ## \
## Reassigns the variable's nth value.  This makes a local copy of the
## variable's overall value.

proc initConfigVariableFilename*(param0: ConfigVariableFilename): ConfigVariableFilename {.importcpp: "ConfigVariableFilename(#)".}

proc initConfigVariableFilename*(name: string): ConfigVariableFilename {.importcpp: "ConfigVariableFilename(nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableFilename*(name: string, default_value: Filename, description: string, flags: int): ConfigVariableFilename {.importcpp: "ConfigVariableFilename(nimStringToStdString(#), #, nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableFilename*(name: string, default_value: Filename, description: string): ConfigVariableFilename {.importcpp: "ConfigVariableFilename(nimStringToStdString(#), #, nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableFilename*(name: string, default_value: Filename): ConfigVariableFilename {.importcpp: "ConfigVariableFilename(nimStringToStdString(#), #)", header: stringConversionCode.}

proc `typecast`*(this: ConfigVariableFilename): Filename {.importcpp: "#.operator typecast()".}

proc c_str*(this: ConfigVariableFilename): string {.importcpp: "nimStringFromStdString(#.c_str())", header: stringConversionCode.} ## \
## These methods help the ConfigVariableFilename act like a Filename object.

proc empty*(this: ConfigVariableFilename): bool {.importcpp: "#.empty()".}

proc length*(this: ConfigVariableFilename): clonglong {.importcpp: "#.length()".}

proc `[]`*(this: ConfigVariableFilename, n: clonglong): char {.importcpp: "#.operator [](#)".}

proc get_fullpath*(this: ConfigVariableFilename): string {.importcpp: "nimStringFromStdString(#.get_fullpath())", header: stringConversionCode.} ## \
## Returns the entire filename: directory, basename, extension.  This is the
## same thing returned by the string typecast operator, so this function is a
## little redundant.

proc get_dirname*(this: ConfigVariableFilename): string {.importcpp: "nimStringFromStdString(#.get_dirname())", header: stringConversionCode.} ## \
## Returns the directory part of the filename.  This is everything in the
## filename up to, but not including the rightmost slash.

proc get_basename*(this: ConfigVariableFilename): string {.importcpp: "nimStringFromStdString(#.get_basename())", header: stringConversionCode.} ## \
## Returns the basename part of the filename.  This is everything in the
## filename after the rightmost slash, including any extensions.

proc get_fullpath_wo_extension*(this: ConfigVariableFilename): string {.importcpp: "nimStringFromStdString(#.get_fullpath_wo_extension())", header: stringConversionCode.} ## \
## Returns the full filename--directory and basename parts--except for the
## extension.

proc get_basename_wo_extension*(this: ConfigVariableFilename): string {.importcpp: "nimStringFromStdString(#.get_basename_wo_extension())", header: stringConversionCode.} ## \
## Returns the basename part of the filename, without the file extension.

proc get_extension*(this: ConfigVariableFilename): string {.importcpp: "nimStringFromStdString(#.get_extension())", header: stringConversionCode.} ## \
## Returns the file extension.  This is everything after the rightmost dot, if
## there is one, or the empty string if there is not.

proc `==`*(this: ConfigVariableFilename, other: Filename): bool {.importcpp: "#.operator ==(#)".} ## \
## Comparison operators are handy.

proc `!=`*(this: ConfigVariableFilename, other: Filename): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: ConfigVariableFilename, other: Filename): bool {.importcpp: "#.operator <(#)".}

proc set_value*(this: ConfigVariableFilename, value: Filename) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

proc get_value*(this: ConfigVariableFilename): Filename {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc get_default_value*(this: ConfigVariableFilename): Filename {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

proc get_word*(this: ConfigVariableFilename, n: clonglong): Filename {.importcpp: "#.get_word(#)".} ## \
## Returns the variable's nth value.

proc set_word*(this: ConfigVariableFilename, n: clonglong, value: Filename) {.importcpp: "#.set_word(#, #)".} ## \
## Reassigns the variable's nth value.  This makes a local copy of the
## variable's overall value.

proc initConfigVariableInt*(param0: ConfigVariableInt): ConfigVariableInt {.importcpp: "ConfigVariableInt(#)".}

proc initConfigVariableInt*(name: string): ConfigVariableInt {.importcpp: "ConfigVariableInt(nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableInt*(name: string, default_value: int, description: string, flags: int): ConfigVariableInt {.importcpp: "ConfigVariableInt(nimStringToStdString(#), #, nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableInt*(name: string, default_value: int, description: string): ConfigVariableInt {.importcpp: "ConfigVariableInt(nimStringToStdString(#), #, nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableInt*(name: string, default_value: int): ConfigVariableInt {.importcpp: "ConfigVariableInt(nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableInt*(name: string, default_value: string, description: string, flags: int): ConfigVariableInt {.importcpp: "ConfigVariableInt(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableInt*(name: string, default_value: string, description: string): ConfigVariableInt {.importcpp: "ConfigVariableInt(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableInt*(name: string, default_value: string): ConfigVariableInt {.importcpp: "ConfigVariableInt(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc `typecast int`*(this: ConfigVariableInt): int {.importcpp: "#.operator typecast int()".}

proc size*(this: ConfigVariableInt): clonglong {.importcpp: "#.size()".} ## \
## Returns the number of unique words in the variable.

proc `[]`*(this: ConfigVariableInt, n: clonglong): int {.importcpp: "#.operator [](#)".}

proc set_value*(this: ConfigVariableInt, value: int) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

proc get_value*(this: ConfigVariableInt): int {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc get_default_value*(this: ConfigVariableInt): int {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

proc get_word*(this: ConfigVariableInt, n: clonglong): int {.importcpp: "#.get_word(#)".} ## \
## Returns the variable's nth value.

proc set_word*(this: ConfigVariableInt, n: clonglong, value: int) {.importcpp: "#.set_word(#, #)".} ## \
## Reassigns the variable's nth value.  This makes a local copy of the
## variable's overall value.

proc initConfigVariableInt64*(param0: ConfigVariableInt64): ConfigVariableInt64 {.importcpp: "ConfigVariableInt64(#)".}

proc initConfigVariableInt64*(name: string): ConfigVariableInt64 {.importcpp: "ConfigVariableInt64(nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableInt64*(name: string, default_value: clonglong, description: string, flags: int): ConfigVariableInt64 {.importcpp: "ConfigVariableInt64(nimStringToStdString(#), #, nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableInt64*(name: string, default_value: clonglong, description: string): ConfigVariableInt64 {.importcpp: "ConfigVariableInt64(nimStringToStdString(#), #, nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableInt64*(name: string, default_value: clonglong): ConfigVariableInt64 {.importcpp: "ConfigVariableInt64(nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableInt64*(name: string, default_value: string, description: string, flags: int): ConfigVariableInt64 {.importcpp: "ConfigVariableInt64(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableInt64*(name: string, default_value: string, description: string): ConfigVariableInt64 {.importcpp: "ConfigVariableInt64(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableInt64*(name: string, default_value: string): ConfigVariableInt64 {.importcpp: "ConfigVariableInt64(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc `typecast int64_t`*(this: ConfigVariableInt64): clonglong {.importcpp: "#.operator typecast int64_t()".}

proc size*(this: ConfigVariableInt64): clonglong {.importcpp: "#.size()".} ## \
## Returns the number of unique words in the variable.

proc `[]`*(this: ConfigVariableInt64, n: clonglong): clonglong {.importcpp: "#.operator [](#)".}

proc set_value*(this: ConfigVariableInt64, value: clonglong) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

proc get_value*(this: ConfigVariableInt64): clonglong {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc get_default_value*(this: ConfigVariableInt64): clonglong {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

proc get_word*(this: ConfigVariableInt64, n: clonglong): clonglong {.importcpp: "#.get_word(#)".} ## \
## Returns the variable's nth value.

proc set_word*(this: ConfigVariableInt64, n: clonglong, value: clonglong) {.importcpp: "#.set_word(#, #)".} ## \
## Reassigns the variable's nth value.  This makes a local copy of the
## variable's overall value.

proc initConfigVariableList*(param0: ConfigVariableList): ConfigVariableList {.importcpp: "ConfigVariableList(#)".}

proc initConfigVariableList*(name: string, description: string, flags: int): ConfigVariableList {.importcpp: "ConfigVariableList(nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableList*(name: string, description: string): ConfigVariableList {.importcpp: "ConfigVariableList(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableList*(name: string): ConfigVariableList {.importcpp: "ConfigVariableList(nimStringToStdString(#))", header: stringConversionCode.}

proc get_num_values*(this: ConfigVariableList): clonglong {.importcpp: "#.get_num_values()".} ## \
## Returns the number of values in the variable.

proc get_string_value*(this: ConfigVariableList, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_string_value(#))", header: stringConversionCode.} ## \
## Returns the nth value of the variable.

proc get_num_unique_values*(this: ConfigVariableList): clonglong {.importcpp: "#.get_num_unique_values()".} ## \
## Returns the number of unique values in the variable.

proc get_unique_value*(this: ConfigVariableList, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_unique_value(#))", header: stringConversionCode.} ## \
## Returns the nth unique value of the variable.

proc size*(this: ConfigVariableList): clonglong {.importcpp: "#.size()".} ## \
## Returns the number of unique values of the variable.

proc `[]`*(this: ConfigVariableList, n: clonglong): string {.importcpp: "nimStringFromStdString(#.operator [](#))", header: stringConversionCode.}

proc output*(this: ConfigVariableList, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: ConfigVariableList, `out`: ostream) {.importcpp: "#.write(#)".}

proc initConfigVariableSearchPath*(name: string, default_value: DSearchPath, description: string, flags: int): ConfigVariableSearchPath {.importcpp: "ConfigVariableSearchPath(nimStringToStdString(#), #, nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableSearchPath*(name: string, default_value: DSearchPath, description: string): ConfigVariableSearchPath {.importcpp: "ConfigVariableSearchPath(nimStringToStdString(#), #, nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableSearchPath*(name: string, description: string, flags: int): ConfigVariableSearchPath {.importcpp: "ConfigVariableSearchPath(nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableSearchPath*(name: string, description: string): ConfigVariableSearchPath {.importcpp: "ConfigVariableSearchPath(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableSearchPath*(name: string): ConfigVariableSearchPath {.importcpp: "ConfigVariableSearchPath(nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableSearchPath*(name: string, default_value: string, description: string, flags: int): ConfigVariableSearchPath {.importcpp: "ConfigVariableSearchPath(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableSearchPath*(name: string, default_value: string, description: string): ConfigVariableSearchPath {.importcpp: "ConfigVariableSearchPath(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc `typecast DSearchPath`*(this: ConfigVariableSearchPath): DSearchPath {.importcpp: "#.operator typecast DSearchPath()".}

proc get_value*(this: ConfigVariableSearchPath): DSearchPath {.importcpp: "#.get_value()".}

proc get_default_value*(this: ConfigVariableSearchPath): DSearchPath {.importcpp: "#.get_default_value()".}

proc clear_local_value*(this: ConfigVariableSearchPath): bool {.importcpp: "#.clear_local_value()".} ## \
## Removes all the directories locally added to the search list, and restores
## it to its original form.

proc clear*(this: ConfigVariableSearchPath) {.importcpp: "#.clear()".} ## \
## Removes all the directories locally added to the search list, and restores
## it to its original form.

proc append_directory*(this: ConfigVariableSearchPath, directory: Filename) {.importcpp: "#.append_directory(#)".} ## \
## Adds a new directory to the end of the search list.

proc prepend_directory*(this: ConfigVariableSearchPath, directory: Filename) {.importcpp: "#.prepend_directory(#)".} ## \
## Adds a new directory to the front of the search list.

proc append_path*(this: ConfigVariableSearchPath, path: DSearchPath) {.importcpp: "#.append_path(#)".} ## \
## Adds all of the directories listed in the search path to the end of the
## search list.

proc append_path*(this: ConfigVariableSearchPath, path: string, separator: string) {.importcpp: "#.append_path(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds all of the directories listed in the search path to the end of the
## search list.

proc append_path*(this: ConfigVariableSearchPath, path: string) {.importcpp: "#.append_path(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds all of the directories listed in the search path to the end of the
## search list.

proc prepend_path*(this: ConfigVariableSearchPath, path: DSearchPath) {.importcpp: "#.prepend_path(#)".} ## \
## Adds all of the directories listed in the search path to the beginning of
## the search list.

proc is_empty*(this: ConfigVariableSearchPath): bool {.importcpp: "#.is_empty()".} ## \
## Returns true if the search list is empty, false otherwise.

proc get_num_directories*(this: ConfigVariableSearchPath): clonglong {.importcpp: "#.get_num_directories()".} ## \
## Returns the number of directories on the search list.

proc get_directory*(this: ConfigVariableSearchPath, n: clonglong): Filename {.importcpp: "#.get_directory(#)".} ## \
## Returns the nth directory on the search list.

proc find_file*(this: ConfigVariableSearchPath, filename: Filename): Filename {.importcpp: "#.find_file(#)".} ## \
## Searches all the directories in the search list for the indicated file, in
## order.  Returns the full matching pathname of the first match if found, or
## the empty string if not found.

proc output*(this: ConfigVariableSearchPath, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: ConfigVariableSearchPath, `out`: ostream) {.importcpp: "#.write(#)".}

proc initConfigVariableString*(param0: ConfigVariableString): ConfigVariableString {.importcpp: "ConfigVariableString(#)".}

proc initConfigVariableString*(name: string): ConfigVariableString {.importcpp: "ConfigVariableString(nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableString*(name: string, default_value: string, description: string, flags: int): ConfigVariableString {.importcpp: "ConfigVariableString(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableString*(name: string, default_value: string, description: string): ConfigVariableString {.importcpp: "ConfigVariableString(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableString*(name: string, default_value: string): ConfigVariableString {.importcpp: "ConfigVariableString(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc `typecast`*(this: ConfigVariableString): string {.importcpp: "nimStringFromStdString(#.operator typecast())", header: stringConversionCode.}

proc c_str*(this: ConfigVariableString): string {.importcpp: "nimStringFromStdString(#.c_str())", header: stringConversionCode.} ## \
## These methods help the ConfigVariableString act like a C++ string object.

proc empty*(this: ConfigVariableString): bool {.importcpp: "#.empty()".}

proc length*(this: ConfigVariableString): clonglong {.importcpp: "#.length()".}

proc `[]`*(this: ConfigVariableString, n: clonglong): char {.importcpp: "#.operator [](#)".}

proc `==`*(this: ConfigVariableString, other: string): bool {.importcpp: "#.operator ==(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Comparison operators are handy.

proc `!=`*(this: ConfigVariableString, other: string): bool {.importcpp: "#.operator !=(nimStringToStdString(#))", header: stringConversionCode.}

proc `<`*(this: ConfigVariableString, other: string): bool {.importcpp: "#.operator <(nimStringToStdString(#))", header: stringConversionCode.}

proc set_value*(this: ConfigVariableString, value: string) {.importcpp: "#.set_value(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reassigns the variable's local value.

proc get_value*(this: ConfigVariableString): string {.importcpp: "nimStringFromStdString(#.get_value())", header: stringConversionCode.} ## \
## Returns the variable's value.

proc get_default_value*(this: ConfigVariableString): string {.importcpp: "nimStringFromStdString(#.get_default_value())", header: stringConversionCode.} ## \
## Returns the variable's default value.

proc get_word*(this: ConfigVariableString, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_word(#))", header: stringConversionCode.} ## \
## Returns the variable's nth value.

proc set_word*(this: ConfigVariableString, n: clonglong, value: string) {.importcpp: "#.set_word(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reassigns the variable's nth value.  This makes a local copy of the
## variable's overall value.

converter upcast_to_ConfigFlags*(this: NotifyCategory): ConfigFlags {.importcpp: "#.upcast_to_ConfigFlags()".}

proc get_fullname*(this: NotifyCategory): string {.importcpp: "nimStringFromStdString(#.get_fullname())", header: stringConversionCode.}

proc get_basename*(this: NotifyCategory): string {.importcpp: "nimStringFromStdString(#.get_basename())", header: stringConversionCode.}

proc get_severity*(this: NotifyCategory): NotifySeverity {.importcpp: "#.get_severity()".}

proc set_severity*(this: NotifyCategory, severity: NotifySeverity) {.importcpp: "#.set_severity(#)".} ## \
## Sets the severity level of messages that will be reported from this
## Category.  This allows any message of this severity level or higher.

proc is_on*(this: NotifyCategory, severity: NotifySeverity): bool {.importcpp: "#.is_on(#)".} ## \
## Returns true if messages of the indicated severity level ought to be
## reported for this Category.

proc is_spam*(this: NotifyCategory): bool {.importcpp: "#.is_spam()".} ## \
## When NOTIFY_DEBUG is not defined, the categories will never be set to
## "spam" or "debug" severities, and these methods are redefined to be
## static to make it more obvious to the compiler.  However, we still want
## to present a consistent interface to our scripting language, so during
## the interrogate pass (that is, when CPPPARSER is defined), we still
## pretend they're nonstatic.

proc is_debug*(this: NotifyCategory): bool {.importcpp: "#.is_debug()".} ## \
## A shorthand way to write is_on(NS_debug).

proc is_info*(this: NotifyCategory): bool {.importcpp: "#.is_info()".} ## \
## A shorthand way to write is_on(NS_info).

proc is_warning*(this: NotifyCategory): bool {.importcpp: "#.is_warning()".} ## \
## A shorthand way to write is_on(NS_warning).

proc is_error*(this: NotifyCategory): bool {.importcpp: "#.is_error()".} ## \
## A shorthand way to write is_on(NS_error).

proc is_fatal*(this: NotifyCategory): bool {.importcpp: "#.is_fatal()".} ## \
## A shorthand way to write is_on(NS_fatal).

proc spam*(this: NotifyCategory, prefix: bool): ostream {.importcpp: "#.spam(#)".} ## \
## A shorthand way to write out(NS_spam).

proc spam*(this: NotifyCategory): ostream {.importcpp: "#.spam()".} ## \
## A shorthand way to write out(NS_spam).

proc debug*(this: NotifyCategory, prefix: bool): ostream {.importcpp: "#.debug(#)".} ## \
## A shorthand way to write out(NS_debug).

proc debug*(this: NotifyCategory): ostream {.importcpp: "#.debug()".} ## \
## A shorthand way to write out(NS_debug).

proc info*(this: NotifyCategory, prefix: bool): ostream {.importcpp: "#.info(#)".} ## \
## A shorthand way to write out(NS_info).

proc info*(this: NotifyCategory): ostream {.importcpp: "#.info()".} ## \
## A shorthand way to write out(NS_info).

proc warning*(this: NotifyCategory, prefix: bool): ostream {.importcpp: "#.warning(#)".} ## \
## A shorthand way to write out(NS_warning).

proc warning*(this: NotifyCategory): ostream {.importcpp: "#.warning()".} ## \
## A shorthand way to write out(NS_warning).

proc error*(this: NotifyCategory, prefix: bool): ostream {.importcpp: "#.error(#)".} ## \
## A shorthand way to write out(NS_error).

proc error*(this: NotifyCategory): ostream {.importcpp: "#.error()".} ## \
## A shorthand way to write out(NS_error).

proc fatal*(this: NotifyCategory, prefix: bool): ostream {.importcpp: "#.fatal(#)".} ## \
## A shorthand way to write out(NS_fatal).

proc fatal*(this: NotifyCategory): ostream {.importcpp: "#.fatal()".} ## \
## A shorthand way to write out(NS_fatal).

proc get_num_children*(this: NotifyCategory): clonglong {.importcpp: "#.get_num_children()".} ## \
## Returns the number of child Categories of this particular Category.

proc get_child*(this: NotifyCategory, i: clonglong): NotifyCategory {.importcpp: "#.get_child(#)".} ## \
## Returns the nth child Category of this particular Category.

proc set_server_delta*(_: typedesc[NotifyCategory], delta: int) {.importcpp: "NotifyCategory::set_server_delta(#)", header: "notifyCategory.h".} ## \
## Sets a global delta (in seconds) between the local time and the server's
## time, for the purpose of synchronizing the time stamps in the log messages
## of the client with that of a known server.

proc initNotifyCategory*(param0: NotifyCategory): NotifyCategory {.importcpp: "NotifyCategory(#)".}

proc initIDecryptStream*(): IDecryptStream {.importcpp: "IDecryptStream()".}

proc initIDecryptStream*(source: istream, owns_source: bool, password: string): IDecryptStream {.importcpp: "IDecryptStream(#, #, nimStringToStdString(#))", header: stringConversionCode.}

proc open*(this: IDecryptStream, source: istream, owns_source: bool, password: string): IDecryptStream {.importcpp: "#.open(#, #, nimStringToStdString(#))", header: stringConversionCode.}

proc close*(this: IDecryptStream): IDecryptStream {.importcpp: "#.close()".} ## \
## Resets the EncryptStream to empty, but does not actually close the source
## istream unless owns_source was true.

proc get_algorithm*(this: IDecryptStream): string {.importcpp: "nimStringFromStdString(#.get_algorithm())", header: stringConversionCode.} ## \
## Returns the encryption algorithm that was read from the stream.

proc get_key_length*(this: IDecryptStream): int {.importcpp: "#.get_key_length()".} ## \
## Returns the encryption key length, in bits, that was read from the stream.

proc get_iteration_count*(this: IDecryptStream): int {.importcpp: "#.get_iteration_count()".} ## \
## Returns the value that was was read from the stream.

proc initOEncryptStream*(): OEncryptStream {.importcpp: "OEncryptStream()".}

proc initOEncryptStream*(dest: ostream, owns_dest: bool, password: string): OEncryptStream {.importcpp: "OEncryptStream(#, #, nimStringToStdString(#))", header: stringConversionCode.}

proc open*(this: OEncryptStream, dest: ostream, owns_dest: bool, password: string): OEncryptStream {.importcpp: "#.open(#, #, nimStringToStdString(#))", header: stringConversionCode.}

proc close*(this: OEncryptStream): OEncryptStream {.importcpp: "#.close()".} ## \
## Resets the EncryptStream to empty, but does not actually close the dest
## ostream unless owns_dest was true.

proc set_algorithm*(this: OEncryptStream, algorithm: string) {.importcpp: "#.set_algorithm(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the encryption algorithm that should be used for future calls to
## open().  The default is whatever is specified by the encryption-algorithm
## config variable.  The complete set of available algorithms is defined by
## the current version of OpenSSL.
##
## If an invalid algorithm is specified, there is no immediate error return
## code, but open() will fail.

proc set_key_length*(this: OEncryptStream, key_length: int) {.importcpp: "#.set_key_length(#)".} ## \
## Specifies the length of the key, in bits, that should be used to encrypt
## the stream in future calls to open().  The default is whatever is specified
## by the encryption-key-length config variable.
##
## If an invalid key_length for the chosen algorithm is specified, there is no
## immediate error return code, but open() will fail.

proc set_iteration_count*(this: OEncryptStream, iteration_count: int) {.importcpp: "#.set_iteration_count(#)".} ## \
## Specifies the number of times to repeatedly hash the key before writing it
## to the stream in future calls to open().  Its purpose is to make it
## computationally more expensive for an attacker to search the key space
## exhaustively.  This should be a multiple of 1,000 and should not exceed
## about 65 million; the value 0 indicates just one application of the hashing
## algorithm.
##
## The default is whatever is specified by the encryption-iteration-count
## config variable.

proc initStreamReader*(copy: StreamReader): StreamReader {.importcpp: "StreamReader(#)".} ## \
## The copy constructor does not copy ownership of the stream.

proc initStreamReader*(`in`: istream, owns_stream: bool): StreamReader {.importcpp: "StreamReader(#, #)".} ## \
## If owns_stream is true, the stream pointer will be deleted when the
## StreamReader destructs.

proc get_istream*(this: StreamReader): istream {.importcpp: "#.get_istream()".} ## \
## Returns the stream in use.

proc get_bool*(this: StreamReader): bool {.importcpp: "#.get_bool()".} ## \
## Extracts a boolean value.

proc get_int8*(this: StreamReader): char {.importcpp: "#.get_int8()".} ## \
## Extracts a signed 8-bit integer.

proc get_uint8*(this: StreamReader): char {.importcpp: "#.get_uint8()".} ## \
## Extracts an unsigned 8-bit integer.

proc get_int16*(this: StreamReader): int {.importcpp: "#.get_int16()".} ## \
## Extracts a signed 16-bit integer.

proc get_int32*(this: StreamReader): int {.importcpp: "#.get_int32()".} ## \
## Extracts a signed 32-bit integer.

proc get_int64*(this: StreamReader): clonglong {.importcpp: "#.get_int64()".} ## \
## Extracts a signed 64-bit integer.

proc get_uint16*(this: StreamReader): int {.importcpp: "#.get_uint16()".} ## \
## Extracts an unsigned 16-bit integer.

proc get_uint32*(this: StreamReader): int {.importcpp: "#.get_uint32()".} ## \
## Extracts an unsigned 32-bit integer.

proc get_uint64*(this: StreamReader): clonglong {.importcpp: "#.get_uint64()".} ## \
## Extracts an unsigned 64-bit integer.

proc get_float32*(this: StreamReader): float32 {.importcpp: "#.get_float32()".} ## \
## Extracts a 32-bit single-precision floating-point number.  Since this kind
## of float is not necessarily portable across different architectures,
## special care is required.

proc get_float64*(this: StreamReader): float64 {.importcpp: "#.get_float64()".} ## \
## Extracts a 64-bit floating-point number.

proc get_be_int16*(this: StreamReader): int {.importcpp: "#.get_be_int16()".} ## \
## Extracts a signed big-endian 16-bit integer.

proc get_be_int32*(this: StreamReader): int {.importcpp: "#.get_be_int32()".} ## \
## Extracts a signed big-endian 32-bit integer.

proc get_be_int64*(this: StreamReader): clonglong {.importcpp: "#.get_be_int64()".} ## \
## Extracts a signed big-endian 64-bit integer.

proc get_be_uint16*(this: StreamReader): int {.importcpp: "#.get_be_uint16()".} ## \
## Extracts an unsigned big-endian 16-bit integer.

proc get_be_uint32*(this: StreamReader): int {.importcpp: "#.get_be_uint32()".} ## \
## Extracts an unsigned big-endian 32-bit integer.

proc get_be_uint64*(this: StreamReader): clonglong {.importcpp: "#.get_be_uint64()".} ## \
## Extracts an unsigned big-endian 64-bit integer.

proc get_be_float32*(this: StreamReader): float32 {.importcpp: "#.get_be_float32()".} ## \
## Extracts a 32-bit single-precision big-endian floating-point number.  Since
## this kind of float is not necessarily portable across different
## architectures, special care is required.

proc get_be_float64*(this: StreamReader): float64 {.importcpp: "#.get_be_float64()".} ## \
## Extracts a 64-bit big-endian floating-point number.

proc get_string*(this: StreamReader): string {.importcpp: "nimStringFromStdString(#.get_string())", header: stringConversionCode.} ## \
## Extracts a variable-length string.

proc get_string32*(this: StreamReader): string {.importcpp: "nimStringFromStdString(#.get_string32())", header: stringConversionCode.} ## \
## Extracts a variable-length string with a 32-bit length field.

proc get_z_string*(this: StreamReader): string {.importcpp: "nimStringFromStdString(#.get_z_string())", header: stringConversionCode.} ## \
## Extracts a variable-length string, as a NULL-terminated string.

proc get_fixed_string*(this: StreamReader, size: clonglong): string {.importcpp: "nimStringFromStdString(#.get_fixed_string(#))", header: stringConversionCode.} ## \
## Extracts a fixed-length string.  However, if a zero byte occurs within the
## string, it marks the end of the string.

proc skip_bytes*(this: StreamReader, size: clonglong) {.importcpp: "#.skip_bytes(#)".} ## \
## Skips over the indicated number of bytes in the stream.

proc initStreamWriter*(copy: StreamWriter): StreamWriter {.importcpp: "StreamWriter(#)".} ## \
## The copy constructor does not copy ownership of the stream.

proc initStreamWriter*(`out`: ostream, owns_stream: bool): StreamWriter {.importcpp: "StreamWriter(#, #)".}

proc get_ostream*(this: StreamWriter): ostream {.importcpp: "#.get_ostream()".} ## \
## Returns the stream in use.

proc add_bool*(this: StreamWriter, value: bool) {.importcpp: "#.add_bool(#)".} ## \
## Adds a boolean value to the stream.

proc add_int8*(this: StreamWriter, value: char) {.importcpp: "#.add_int8(#)".} ## \
## Adds a signed 8-bit integer to the stream.

proc add_uint8*(this: StreamWriter, value: char) {.importcpp: "#.add_uint8(#)".} ## \
## Adds an unsigned 8-bit integer to the stream.

proc add_int16*(this: StreamWriter, value: int) {.importcpp: "#.add_int16(#)".} ## \
## Adds a signed 16-bit integer to the stream.

proc add_int32*(this: StreamWriter, value: int) {.importcpp: "#.add_int32(#)".} ## \
## Adds a signed 32-bit integer to the stream.

proc add_int64*(this: StreamWriter, value: clonglong) {.importcpp: "#.add_int64(#)".} ## \
## Adds a signed 64-bit integer to the stream.

proc add_uint16*(this: StreamWriter, value: int) {.importcpp: "#.add_uint16(#)".} ## \
## Adds an unsigned 16-bit integer to the stream.

proc add_uint32*(this: StreamWriter, value: int) {.importcpp: "#.add_uint32(#)".} ## \
## Adds an unsigned 32-bit integer to the stream.

proc add_uint64*(this: StreamWriter, value: clonglong) {.importcpp: "#.add_uint64(#)".} ## \
## Adds an unsigned 64-bit integer to the stream.

proc add_float32*(this: StreamWriter, value: float32) {.importcpp: "#.add_float32(#)".} ## \
## Adds a 32-bit single-precision floating-point number to the stream.  Since
## this kind of float is not necessarily portable across different
## architectures, special care is required.

proc add_float64*(this: StreamWriter, value: float64) {.importcpp: "#.add_float64(#)".} ## \
## Adds a 64-bit floating-point number to the stream.

proc add_be_int16*(this: StreamWriter, value: int) {.importcpp: "#.add_be_int16(#)".} ## \
## Adds a signed 16-bit big-endian integer to the streamWriter.

proc add_be_int32*(this: StreamWriter, value: int) {.importcpp: "#.add_be_int32(#)".} ## \
## Adds a signed 32-bit big-endian integer to the streamWriter.

proc add_be_int64*(this: StreamWriter, value: clonglong) {.importcpp: "#.add_be_int64(#)".} ## \
## Adds a signed 64-bit big-endian integer to the streamWriter.

proc add_be_uint16*(this: StreamWriter, value: int) {.importcpp: "#.add_be_uint16(#)".} ## \
## Adds an unsigned 16-bit big-endian integer to the streamWriter.

proc add_be_uint32*(this: StreamWriter, value: int) {.importcpp: "#.add_be_uint32(#)".} ## \
## Adds an unsigned 32-bit big-endian integer to the streamWriter.

proc add_be_uint64*(this: StreamWriter, value: clonglong) {.importcpp: "#.add_be_uint64(#)".} ## \
## Adds an unsigned 64-bit big-endian integer to the streamWriter.

proc add_be_float32*(this: StreamWriter, value: float32) {.importcpp: "#.add_be_float32(#)".} ## \
## Adds a 32-bit single-precision big-endian floating-point number to the
## stream.  Since this kind of float is not necessarily portable across
## different architectures, special care is required.

proc add_be_float64*(this: StreamWriter, value: float64) {.importcpp: "#.add_be_float64(#)".} ## \
## Adds a 64-bit big-endian floating-point number to the streamWriter.

proc add_string*(this: StreamWriter, str: string) {.importcpp: "#.add_string(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a variable-length string to the stream.  This actually adds a count
## followed by n bytes.

proc add_string32*(this: StreamWriter, str: string) {.importcpp: "#.add_string32(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a variable-length string to the stream, using a 32-bit length field.

proc add_z_string*(this: StreamWriter, str: string) {.importcpp: "#.add_z_string(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a variable-length string to the stream, as a NULL-terminated string.

proc add_fixed_string*(this: StreamWriter, str: string, size: clonglong) {.importcpp: "#.add_fixed_string(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Adds a fixed-length string to the stream.  If the string given is less than
## the requested size, this will pad the string out with zeroes; if it is
## greater than the requested size, this will silently truncate the string.

proc pad_bytes*(this: StreamWriter, size: clonglong) {.importcpp: "#.pad_bytes(#)".} ## \
## Adds the indicated number of zero bytes to the stream.

proc flush*(this: StreamWriter) {.importcpp: "#.flush()".} ## \
## Calls flush() on the underlying stream.

proc write*(this: StreamWriter, str: string) {.importcpp: "#.write(nimStringToStdString(#))", header: stringConversionCode.} ## \
## A synonym of append_data().  This is useful when assigning the StreamWriter
## to sys.stderr and/or sys.stdout in Python.

proc acquire*(this: StreamWrapperBase) {.importcpp: "#.acquire()".} ## \
## Acquires the internal lock.
##
## User code should call this to take temporary possession of the stream and
## perform direct I/O operations on it, for instance to make several
## sequential atomic reads.  You may not call any of the StreamWrapper methods
## while the lock is held, other than release().
##
## Use with extreme caution!  This is a very low-level, non-recursive lock.
## You must call acquire() only once, and you must later call release()
## exactly once.  Failing to do so may result in a hard deadlock with no
## available debugging features.

proc release*(this: StreamWrapperBase) {.importcpp: "#.release()".} ## \
## Releases the internal lock.  Must be called exactly once following a call
## to acquire().  See the cautions with acquire().

converter upcast_to_StreamWrapperBase*(this: IStreamWrapper): StreamWrapperBase {.importcpp: "#.upcast_to_StreamWrapperBase()".}

proc initIStreamWrapper*(stream: istream): IStreamWrapper {.importcpp: "IStreamWrapper(#)".}

proc get_istream*(this: IStreamWrapper): istream {.importcpp: "#.get_istream()".} ## \
## Returns the istream this object is wrapping.

converter upcast_to_StreamWrapperBase*(this: OStreamWrapper): StreamWrapperBase {.importcpp: "#.upcast_to_StreamWrapperBase()".}

proc initOStreamWrapper*(stream: ostream): OStreamWrapper {.importcpp: "OStreamWrapper(#)".}

proc get_ostream*(this: OStreamWrapper): ostream {.importcpp: "#.get_ostream()".} ## \
## Returns the ostream this object is wrapping.

converter upcast_to_IStreamWrapper*(this: StreamWrapper): IStreamWrapper {.importcpp: "#.upcast_to_IStreamWrapper()".}

converter upcast_to_OStreamWrapper*(this: StreamWrapper): OStreamWrapper {.importcpp: "#.upcast_to_OStreamWrapper()".}

proc initStreamWrapper*(stream: iostream): StreamWrapper {.importcpp: "StreamWrapper(#)".}

proc get_iostream*(this: StreamWrapper): iostream {.importcpp: "#.get_iostream()".} ## \
## Returns the iostream this object is wrapping.

proc receive_datagram*(this: SSReader, dg: Datagram): bool {.importcpp: "#.receive_datagram(#)".} ## \
## Receives a datagram over the socket by expecting a little-endian 16-bit
## byte count as a prefix.  If the socket stream is non-blocking, may return
## false if the data is not available; otherwise, returns false only if the
## socket closes.

proc is_closed*(this: SSReader): bool {.importcpp: "#.is_closed()".}

proc close*(this: SSReader) {.importcpp: "#.close()".}

proc set_tcp_header_size*(this: SSReader, tcp_header_size: int) {.importcpp: "#.set_tcp_header_size(#)".} ## \
## Sets the header size for datagrams.  At the present, legal values for this
## are 0, 2, or 4; this specifies the number of bytes to use encode the
## datagram length at the start of each TCP datagram.  Sender and receiver
## must independently agree on this.

proc get_tcp_header_size*(this: SSReader): int {.importcpp: "#.get_tcp_header_size()".} ## \
## Returns the header size for datagrams.  See set_tcp_header_size().

proc send_datagram*(this: SSWriter, dg: Datagram): bool {.importcpp: "#.send_datagram(#)".} ## \
## Transmits the indicated datagram over the socket by prepending it with a
## little-endian 16-bit byte count.  Does not return until the data is sent or
## the connection is closed, even if the socket stream is non-blocking.

proc is_closed*(this: SSWriter): bool {.importcpp: "#.is_closed()".}

proc close*(this: SSWriter) {.importcpp: "#.close()".}

proc set_collect_tcp*(this: SSWriter, collect_tcp: bool) {.importcpp: "#.set_collect_tcp(#)".} ## \
## Enables or disables "collect-tcp" mode.  In this mode, individual TCP
## packets are not sent immediately, but rather they are collected together
## and accumulated to be sent periodically as one larger TCP packet.  This
## cuts down on overhead from the TCP/IP protocol, especially if many small
## packets need to be sent on the same connection, but it introduces
## additional latency (since packets must be held before they can be sent).
##
## See set_collect_tcp_interval() to specify the interval of time for which to
## hold packets before sending them.
##
## If you enable this mode, you may also need to periodically call
## consider_flush() to flush the queue if no packets have been sent recently.

proc get_collect_tcp*(this: SSWriter): bool {.importcpp: "#.get_collect_tcp()".} ## \
## Returns the current setting of "collect-tcp" mode.  See set_collect_tcp().

proc set_collect_tcp_interval*(this: SSWriter, interval: float64) {.importcpp: "#.set_collect_tcp_interval(#)".} ## \
## Specifies the interval in time, in seconds, for which to hold TCP packets
## before sending all of the recently received packets at once.  This only has
## meaning if "collect-tcp" mode is enabled; see set_collect_tcp().

proc get_collect_tcp_interval*(this: SSWriter): float64 {.importcpp: "#.get_collect_tcp_interval()".} ## \
## Returns the interval in time, in seconds, for which to hold TCP packets
## before sending all of the recently received packets at once.  This only has
## meaning if "collect-tcp" mode is enabled; see set_collect_tcp().

proc set_tcp_header_size*(this: SSWriter, tcp_header_size: int) {.importcpp: "#.set_tcp_header_size(#)".} ## \
## Sets the header size for datagrams.  At the present, legal values for this
## are 0, 2, or 4; this specifies the number of bytes to use encode the
## datagram length at the start of each TCP datagram.  Sender and receiver
## must independently agree on this.

proc get_tcp_header_size*(this: SSWriter): int {.importcpp: "#.get_tcp_header_size()".} ## \
## Returns the header size for datagrams.  See set_tcp_header_size().

proc consider_flush*(this: SSWriter): bool {.importcpp: "#.consider_flush()".} ## \
## Sends the most recently queued data if enough time has elapsed.  This only
## has meaning if set_collect_tcp() has been set to true.

proc flush*(this: SSWriter): bool {.importcpp: "#.flush()".} ## \
## Sends the most recently queued data now.  This only has meaning if
## set_collect_tcp() has been set to true.

converter upcast_to_istream*(this: ISocketStream): istream {.importcpp: "#.upcast_to_istream()".}

converter upcast_to_SSReader*(this: ISocketStream): SSReader {.importcpp: "#.upcast_to_SSReader()".}

proc is_closed*(this: ISocketStream): bool {.importcpp: "#.is_closed()".}

proc close*(this: ISocketStream) {.importcpp: "#.close()".}

converter upcast_to_ostream*(this: OSocketStream): ostream {.importcpp: "#.upcast_to_ostream()".}

converter upcast_to_SSWriter*(this: OSocketStream): SSWriter {.importcpp: "#.upcast_to_SSWriter()".}

proc is_closed*(this: OSocketStream): bool {.importcpp: "#.is_closed()".}

proc close*(this: OSocketStream) {.importcpp: "#.close()".}

proc flush*(this: OSocketStream): bool {.importcpp: "#.flush()".} ## \
## Sends the most recently queued data now.  This only has meaning if
## set_collect_tcp() has been set to true.

converter upcast_to_iostream*(this: SocketStream): iostream {.importcpp: "#.upcast_to_iostream()".}

converter upcast_to_SSReader*(this: SocketStream): SSReader {.importcpp: "#.upcast_to_SSReader()".}

converter upcast_to_SSWriter*(this: SocketStream): SSWriter {.importcpp: "#.upcast_to_SSWriter()".}

proc is_closed*(this: SocketStream): bool {.importcpp: "#.is_closed()".}

proc close*(this: SocketStream) {.importcpp: "#.close()".}

proc set_tcp_header_size*(this: SocketStream, tcp_header_size: int) {.importcpp: "#.set_tcp_header_size(#)".} ## \
## Sets the header size for datagrams.  At the present, legal values for this
## are 0, 2, or 4; this specifies the number of bytes to use encode the
## datagram length at the start of each TCP datagram.  Sender and receiver
## must independently agree on this.

proc get_tcp_header_size*(this: SocketStream): int {.importcpp: "#.get_tcp_header_size()".} ## \
## Returns the header size for datagrams.  See set_tcp_header_size().

proc flush*(this: SocketStream): bool {.importcpp: "#.flush()".} ## \
## Sends the most recently queued data now.  This only has meaning if
## set_collect_tcp() has been set to true.

proc initURLSpec*(): URLSpec {.importcpp: "URLSpec()".}

proc initURLSpec*(param0: URLSpec): URLSpec {.importcpp: "URLSpec(#)".}

proc initURLSpec*(url: URLSpec, path: Filename): URLSpec {.importcpp: "URLSpec(#, #)".} ## \
## Creates a URLSpec by appending a path to the end of the old URLSpec,
## inserting an intervening forward slash if necessary.

proc initURLSpec*(url: string, server_name_expected: bool): URLSpec {.importcpp: "URLSpec(nimStringToStdString(#), #)", header: stringConversionCode.}

proc initURLSpec*(url: string): URLSpec {.importcpp: "URLSpec(nimStringToStdString(#))", header: stringConversionCode.}

proc `==`*(this: URLSpec, other: URLSpec): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: URLSpec, other: URLSpec): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: URLSpec, other: URLSpec): bool {.importcpp: "#.operator <(#)".}

proc compare_to*(this: URLSpec, other: URLSpec): int {.importcpp: "#.compare_to(#)".} ## \
## Returns a number less than zero if this URLSpec sorts before the other one,
## greater than zero if it sorts after, or zero if they are equivalent.

proc get_hash*(this: URLSpec): clonglong {.importcpp: "#.get_hash()".}

proc has_scheme*(this: URLSpec): bool {.importcpp: "#.has_scheme()".} ## \
## Returns true if the URL specifies a scheme (e.g.  "http:"), false
## otherwise.

proc has_authority*(this: URLSpec): bool {.importcpp: "#.has_authority()".} ## \
## Returns true if the URL specifies an authority (this includes username,
## server, and/or port), false otherwise.

proc has_username*(this: URLSpec): bool {.importcpp: "#.has_username()".} ## \
## Returns true if the URL specifies a username (and/or password), false
## otherwise.

proc has_server*(this: URLSpec): bool {.importcpp: "#.has_server()".} ## \
## Returns true if the URL specifies a server name, false otherwise.

proc has_port*(this: URLSpec): bool {.importcpp: "#.has_port()".} ## \
## Returns true if the URL specifies a port number, false otherwise.

proc has_path*(this: URLSpec): bool {.importcpp: "#.has_path()".} ## \
## Returns true if the URL includes a path specification (that is, the
## particular filename on the server to retrieve), false otherwise.

proc has_query*(this: URLSpec): bool {.importcpp: "#.has_query()".} ## \
## Returns true if the URL includes a query specification, false otherwise.

proc get_scheme*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_scheme())", header: stringConversionCode.} ## \
## Returns the scheme specified by the URL, or empty string if no scheme is
## specified.

proc get_authority*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_authority())", header: stringConversionCode.} ## \
## Returns the authority specified by the URL (this includes username, server,
## and/or port), or empty string if no authority is specified.

proc get_username*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_username())", header: stringConversionCode.} ## \
## Returns the username specified by the URL, if any.  This might also include
## a password, e.g.  "username:password", although putting a password on the
## URL is probably a bad idea.

proc get_server*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_server())", header: stringConversionCode.} ## \
## Returns the server name specified by the URL, if any.  In case of an IPv6
## address, does not include the enclosing brackets.

proc get_port_str*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_port_str())", header: stringConversionCode.} ## \
## Returns the port specified by the URL as a string, or the empty string if
## no port is specified.  Compare this with get_port(), which returns a
## default port number if no port is specified.

proc get_port*(this: URLSpec): int {.importcpp: "#.get_port()".} ## \
## Returns the port number specified by the URL, or the default port if not
## specified.

proc get_server_and_port*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_server_and_port())", header: stringConversionCode.} ## \
## Returns a string consisting of the server name, followed by a colon,
## followed by the port number.  If the port number is not explicitly given in
## the URL, this string will include the implicit port number.
## If the server is an IPv6 address, it will be enclosed in square brackets.

proc is_default_port*(this: URLSpec): bool {.importcpp: "#.is_default_port()".} ## \
## Returns true if the port number encoded in this URL is the default port
## number for the scheme (or if there is no port number), or false if it is a
## nonstandard port.

proc get_default_port_for_scheme*(_: typedesc[URLSpec], scheme: string): int {.importcpp: "URLSpec::get_default_port_for_scheme(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the default port number for the indicated scheme, or 0 if there is
## no known default.

proc get_path*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_path())", header: stringConversionCode.} ## \
## Returns the path specified by the URL, or "/" if no path is specified.

proc get_query*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_query())", header: stringConversionCode.} ## \
## Returns the query specified by the URL, or empty string if no query is
## specified.

proc get_path_and_query*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_path_and_query())", header: stringConversionCode.} ## \
## Returns the path (or "/" if no path is specified), followed by the query if
## it is specified.

proc is_ssl*(this: URLSpec): bool {.importcpp: "#.is_ssl()".} ## \
## Returns true if the URL's scheme specifies an SSL-secured protocol such as
## https, or false otherwise.

proc get_url*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_url())", header: stringConversionCode.} ## \
## Returns the complete URL specification.

proc set_scheme*(this: URLSpec, scheme: string) {.importcpp: "#.set_scheme(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the scheme part of the URL specification.

proc set_authority*(this: URLSpec, authority: string) {.importcpp: "#.set_authority(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the authority part of the URL specification.  This includes the
## username, server, and port.

proc set_username*(this: URLSpec, username: string) {.importcpp: "#.set_username(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the username part of the URL specification.

proc set_server*(this: URLSpec, server: string) {.importcpp: "#.set_server(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the server part of the URL specification.
## Unlike set_server_and_port, this method does not require IPv6 addresses to
## be enclosed in square brackets.

proc set_port*(this: URLSpec, port: string) {.importcpp: "#.set_port(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the port part of the URL specification.

proc set_port*(this: URLSpec, port: int) {.importcpp: "#.set_port(#)".} ## \
## Replaces the port part of the URL specification, given a numeric port
## number.

proc set_server_and_port*(this: URLSpec, server_and_port: string) {.importcpp: "#.set_server_and_port(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the server and port parts of the URL specification simultaneously.
## The input string should be of the form "server:port", or just "server" to
## make the port number implicit.
## Any IPv6 address must be enclosed in square brackets.

proc set_path*(this: URLSpec, path: string) {.importcpp: "#.set_path(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the path part of the URL specification.

proc set_query*(this: URLSpec, query: string) {.importcpp: "#.set_query(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the query part of the URL specification.

proc set_url*(this: URLSpec, url: string, server_name_expected: bool) {.importcpp: "#.set_url(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Completely replaces the URL with the indicated string.  If
## server_name_expected is true, it is a hint that an undecorated URL is
## probably a server name, not a local filename.

proc set_url*(this: URLSpec, url: string) {.importcpp: "#.set_url(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Completely replaces the URL with the indicated string.  If
## server_name_expected is true, it is a hint that an undecorated URL is
## probably a server name, not a local filename.

proc `typecast`*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.operator typecast())", header: stringConversionCode.}

proc c_str*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.c_str())", header: stringConversionCode.}

proc empty*(this: URLSpec): bool {.importcpp: "#.empty()".} ## \
## Returns false if the URLSpec is valid (not empty), or true if it is an
## empty string.

proc `typecast bool`*(this: URLSpec): bool {.importcpp: "#.operator typecast bool()".}

proc length*(this: URLSpec): clonglong {.importcpp: "#.length()".}

proc size*(this: URLSpec): clonglong {.importcpp: "#.size()".}

proc `[]`*(this: URLSpec, n: clonglong): char {.importcpp: "#.operator [](#)".}

proc input*(this: URLSpec, `in`: istream): bool {.importcpp: "#.input(#)".}

proc output*(this: URLSpec, `out`: ostream) {.importcpp: "#.output(#)".}

proc quote*(_: typedesc[URLSpec], source: string, safe: string): string {.importcpp: "nimStringFromStdString(URLSpec::quote(nimStringToStdString(#), nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Returns the source string with all "unsafe" characters quoted, making a
## string suitable for placing in a URL.  Letters, digits, and the underscore,
## comma, period, and hyphen characters, as well as any included in the safe
## string, are left alone; all others are converted to hex representation.

proc quote*(_: typedesc[URLSpec], source: string): string {.importcpp: "nimStringFromStdString(URLSpec::quote(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Returns the source string with all "unsafe" characters quoted, making a
## string suitable for placing in a URL.  Letters, digits, and the underscore,
## comma, period, and hyphen characters, as well as any included in the safe
## string, are left alone; all others are converted to hex representation.

proc quote_plus*(_: typedesc[URLSpec], source: string, safe: string): string {.importcpp: "nimStringFromStdString(URLSpec::quote_plus(nimStringToStdString(#), nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Behaves like quote() with the additional behavior of replacing spaces with
## plus signs.

proc quote_plus*(_: typedesc[URLSpec], source: string): string {.importcpp: "nimStringFromStdString(URLSpec::quote_plus(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Behaves like quote() with the additional behavior of replacing spaces with
## plus signs.

proc unquote*(_: typedesc[URLSpec], source: string): string {.importcpp: "nimStringFromStdString(URLSpec::unquote(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Reverses the operation of quote(): converts escaped characters of the form
## "%xx" to their ascii equivalent.

proc unquote_plus*(_: typedesc[URLSpec], source: string): string {.importcpp: "nimStringFromStdString(URLSpec::unquote_plus(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Reverses the operation of quote_plus(): converts escaped characters of the
## form "%xx" to their ascii equivalent, and also converts plus signs to
## spaces.

proc initHTTPEnum*(): HTTPEnum {.importcpp: "HTTPEnum()".}

proc initHTTPEnum*(param0: HTTPEnum): HTTPEnum {.importcpp: "HTTPEnum(#)".}

proc initHTTPDate*(): HTTPDate {.importcpp: "HTTPDate()".}

proc initHTTPDate*(copy: HTTPDate): HTTPDate {.importcpp: "HTTPDate(#)".}

proc initHTTPDate*(format: string): HTTPDate {.importcpp: "HTTPDate(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Decodes the string into a sensible date.  Returns 0 (!is_valid()) if the
## string cannot be correctly decoded.

proc initHTTPDate*(time: int): HTTPDate {.importcpp: "HTTPDate(#)".}

proc now*(_: typedesc[HTTPDate]): HTTPDate {.importcpp: "HTTPDate::now()", header: "hTTPDate.h".} ## \
## Returns an HTTPDate that represents the current time and date.

proc is_valid*(this: HTTPDate): bool {.importcpp: "#.is_valid()".} ## \
## Returns true if the date is meaningful, or false if it is -1 (which
## generally indicates the source string could not be parsed.)

proc get_string*(this: HTTPDate): string {.importcpp: "nimStringFromStdString(#.get_string())", header: stringConversionCode.}

proc get_time*(this: HTTPDate): int {.importcpp: "#.get_time()".} ## \
## Returns the date as a C time_t value.

proc `==`*(this: HTTPDate, other: HTTPDate): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: HTTPDate, other: HTTPDate): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: HTTPDate, other: HTTPDate): bool {.importcpp: "#.operator <(#)".}

proc `>`*(this: HTTPDate, other: HTTPDate): bool {.importcpp: "#.operator >(#)".}

proc compare_to*(this: HTTPDate, other: HTTPDate): int {.importcpp: "#.compare_to(#)".} ## \
## Returns a number less than zero if this HTTPDate sorts before the other
## one, greater than zero if it sorts after, or zero if they are equivalent.

proc `+=`*(this: HTTPDate, seconds: int): HTTPDate {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: HTTPDate, seconds: int): HTTPDate {.importcpp: "#.operator -=(#)".}

proc `+`*(this: HTTPDate, seconds: int): HTTPDate {.importcpp: "#.operator +(#)".}

proc `-`*(this: HTTPDate, other: HTTPDate): int {.importcpp: "#.operator -(#)".}

proc `-`*(this: HTTPDate, seconds: int): HTTPDate {.importcpp: "#.operator -(#)".}

proc input*(this: HTTPDate, `in`: istream): bool {.importcpp: "#.input(#)".}

proc output*(this: HTTPDate, `out`: ostream) {.importcpp: "#.output(#)".}

proc initHTTPCookie*(): HTTPCookie {.importcpp: "HTTPCookie()".} ## \
## Constructs an empty cookie.

proc initHTTPCookie*(param0: HTTPCookie): HTTPCookie {.importcpp: "HTTPCookie(#)".}

proc initHTTPCookie*(format: string, url: URLSpec): HTTPCookie {.importcpp: "HTTPCookie(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Constructs a cookie according to the indicated string, presumably the tag
## of a Set-Cookie header.  There is no way to detect a formatting error in
## the string with this constructor.

proc initHTTPCookie*(name: string, path: string, domain: string): HTTPCookie {.importcpp: "HTTPCookie(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Constructs a cookie with the indicated name, path, and domain values, but
## no other data.  This is most useful for looking up an existing cookie in
## the HTTPClient.

proc set_name*(this: HTTPCookie, name: string) {.importcpp: "#.set_name(nimStringToStdString(#))", header: stringConversionCode.}

proc get_name*(this: HTTPCookie): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the cookie.  This is the key value specified by the
## server.

proc set_value*(this: HTTPCookie, value: string) {.importcpp: "#.set_value(nimStringToStdString(#))", header: stringConversionCode.}

proc get_value*(this: HTTPCookie): string {.importcpp: "nimStringFromStdString(#.get_value())", header: stringConversionCode.} ## \
## Returns the value of the cookie.  This is the arbitrary string associated
## with the cookie's name, as specified by the server.

proc set_domain*(this: HTTPCookie, domain: string) {.importcpp: "#.set_domain(nimStringToStdString(#))", header: stringConversionCode.}

proc get_domain*(this: HTTPCookie): string {.importcpp: "nimStringFromStdString(#.get_domain())", header: stringConversionCode.}

proc set_path*(this: HTTPCookie, path: string) {.importcpp: "#.set_path(nimStringToStdString(#))", header: stringConversionCode.}

proc get_path*(this: HTTPCookie): string {.importcpp: "nimStringFromStdString(#.get_path())", header: stringConversionCode.} ## \
## Returns the prefix of the URL paths on the server for which this cookie
## will be sent.

proc set_expires*(this: HTTPCookie, expires: HTTPDate) {.importcpp: "#.set_expires(#)".}

proc clear_expires*(this: HTTPCookie) {.importcpp: "#.clear_expires()".} ## \
## Removes the expiration date on the cookie.

proc has_expires*(this: HTTPCookie): bool {.importcpp: "#.has_expires()".} ## \
## Returns true if the cookie has an expiration date, false otherwise.

proc get_expires*(this: HTTPCookie): HTTPDate {.importcpp: "#.get_expires()".} ## \
## Returns the expiration date of the cookie if it is set, or an invalid date
## if it is not.

proc set_secure*(this: HTTPCookie, flag: bool) {.importcpp: "#.set_secure(#)".}

proc get_secure*(this: HTTPCookie): bool {.importcpp: "#.get_secure()".} ## \
## Returns true if the server has indicated this is a "secure" cookie which
## should only be sent over an HTTPS channel.

proc `<`*(this: HTTPCookie, other: HTTPCookie): bool {.importcpp: "#.operator <(#)".}

proc update_from*(this: HTTPCookie, other: HTTPCookie) {.importcpp: "#.update_from(#)".} ## \
## Assuming the operator < method, above, has already evaluated these two
## cookies as equal, then assign the remaining values (value, expiration date,
## secure flag) from the indicated cookie.  This is guaranteed not to change
## the ordering of the cookie in a set, and so can be used to update an
## existing cookie within a set with new values.

proc parse_set_cookie*(this: HTTPCookie, format: string, url: URLSpec): bool {.importcpp: "#.parse_set_cookie(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Separates out the parameter/value pairs of the Set-Cookie header and
## assigns the values of the cookie appropriate.  Returns true if the header
## is parsed correctly, false if something is not understood.

proc is_expired*(this: HTTPCookie, now: HTTPDate): bool {.importcpp: "#.is_expired(#)".} ## \
## Returns true if the cookie's expiration date is before the indicated date,
## false otherwise.

proc is_expired*(this: HTTPCookie): bool {.importcpp: "#.is_expired()".} ## \
## Returns true if the cookie's expiration date is before the indicated date,
## false otherwise.

proc matches_url*(this: HTTPCookie, url: URLSpec): bool {.importcpp: "#.matches_url(#)".} ## \
## Returns true if the cookie is appropriate to send with the indicated URL
## request, false otherwise.

proc output*(this: HTTPCookie, `out`: ostream) {.importcpp: "#.output(#)".}

proc newHTTPClient*(): HTTPClient {.importcpp: "new HTTPClient()".}

proc newHTTPClient*(copy: HTTPClient): HTTPClient {.importcpp: "new HTTPClient(#)".}

proc init_random_seed*(_: typedesc[HTTPClient]) {.importcpp: "HTTPClient::init_random_seed()", header: "hTTPClient.h".} ## \
## This may be called once, presumably at the beginning of an application, to
## initialize OpenSSL's random seed.  On Windows, it is particularly important
## to call this at startup if you are going to be performing any https
## operations or otherwise use encryption, since the Windows algorithm for
## getting a random seed takes 2-3 seconds at startup, but can take 30 seconds
## or more after you have opened a 3-D graphics window and started rendering.
##
## There is no harm in calling this method multiple times, or in not calling
## it at all.

proc set_proxy_spec*(this: HTTPClient, proxy_spec: string) {.importcpp: "#->set_proxy_spec(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the complete set of proxies to use for all schemes.  This is
## either a semicolon-delimited set of hostname:ports, or a semicolon-
## delimited set of pairs of the form "scheme=hostname:port", or a
## combination.  Use the keyword DIRECT, or an empty string, to represent a
## direct connection.  A particular scheme and/or proxy host may be listed
## more than once.  This is a convenience function that can be used in place
## of explicit calls to add_proxy() for each scheme/proxy pair.

proc get_proxy_spec*(this: HTTPClient): string {.importcpp: "nimStringFromStdString(#->get_proxy_spec())", header: stringConversionCode.} ## \
## Returns the complete set of proxies to use for all schemes.  This is a
## string of the form specified by set_proxy_spec(), above.  Note that the
## string returned by this function may not be exactly the same as the string
## passed into set_proxy_spec(), since the string is regenerated from the
## internal storage structures and may therefore be reordered.

proc set_direct_host_spec*(this: HTTPClient, direct_host_spec: string) {.importcpp: "#->set_direct_host_spec(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the set of hosts that should be connected to directly, without
## using a proxy.  This is a semicolon-separated list of hostnames that may
## contain wildcard characters ("*").

proc get_direct_host_spec*(this: HTTPClient): string {.importcpp: "nimStringFromStdString(#->get_direct_host_spec())", header: stringConversionCode.} ## \
## Returns the set of hosts that should be connected to directly, without
## using a proxy, as a semicolon-separated list of hostnames that may contain
## wildcard characters ("*").

proc set_try_all_direct*(this: HTTPClient, try_all_direct: bool) {.importcpp: "#->set_try_all_direct(#)".} ## \
## If this is set true, then after a connection attempt through a proxy fails,
## we always try a direct connection, regardless of whether the host is listed
## on the direct_host_spec list.  If this is false, a direct attempt is not
## made when we have a proxy in effect, even if the proxy fails.

proc get_try_all_direct*(this: HTTPClient): bool {.importcpp: "#->get_try_all_direct()".} ## \
## Returns whether a failed connection through a proxy will be followed up by
## a direct connection attempt, false otherwise.

proc clear_proxy*(this: HTTPClient) {.importcpp: "#->clear_proxy()".} ## \
## Resets the proxy spec to empty.  Subsequent calls to add_proxy() may be
## made to build up the set of proxy servers.

proc add_proxy*(this: HTTPClient, scheme: string, proxy: URLSpec) {.importcpp: "#->add_proxy(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Adds the indicated proxy host as a proxy for communications on the given
## scheme.  Usually the scheme is "http" or "https".  It may be the empty
## string to indicate a general proxy.  The proxy string may be the empty URL
## to indicate a direct connection.

proc clear_direct_host*(this: HTTPClient) {.importcpp: "#->clear_direct_host()".} ## \
## Resets the set of direct hosts to empty.  Subsequent calls to
## add_direct_host() may be made to build up the list of hosts that do not
## require a proxy connection.

proc add_direct_host*(this: HTTPClient, hostname: string) {.importcpp: "#->add_direct_host(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds the indicated name to the set of hostnames that are connected to
## directly, without using a proxy.  This name may be either a DNS name or an
## IP address, and it may include the * as a wildcard character.

proc get_proxies_for_url*(this: HTTPClient, url: URLSpec): string {.importcpp: "nimStringFromStdString(#->get_proxies_for_url(#))", header: stringConversionCode.} ## \
## Returns a semicolon-delimited list of proxies, in the order in which they
## should be tried, that are appropriate for the indicated URL.  The keyword
## DIRECT indicates a direct connection should be tried.

proc set_username*(this: HTTPClient, server: string, realm: string, username: string) {.importcpp: "#->set_username(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the username:password string corresponding to a particular server
## and/or realm, when demanded by the server.  Either or both of the server or
## realm may be empty; if so, they match anything.  Also, the server may be
## set to the special string `"*proxy"`, which will match any proxy server.
##
## If the username is set to the empty string, this clears the password for
## the particular server/realm pair.

proc get_username*(this: HTTPClient, server: string, realm: string): string {.importcpp: "nimStringFromStdString(#->get_username(nimStringToStdString(#), nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Returns the username:password string set for this server/realm pair, or
## empty string if nothing has been set.  See set_username().

proc set_cookie*(this: HTTPClient, cookie: HTTPCookie) {.importcpp: "#->set_cookie(#)".} ## \
## Stores the indicated cookie in the client's list of cookies, as if it had
## been received from a server.

proc clear_cookie*(this: HTTPClient, cookie: HTTPCookie): bool {.importcpp: "#->clear_cookie(#)".} ## \
## Removes the cookie with the matching domain/path/name from the client's
## list of cookies.  Returns true if it was removed, false if the cookie was
## not matched.

proc clear_all_cookies*(this: HTTPClient) {.importcpp: "#->clear_all_cookies()".} ## \
## Removes the all stored cookies from the client.

proc has_cookie*(this: HTTPClient, cookie: HTTPCookie): bool {.importcpp: "#->has_cookie(#)".} ## \
## Returns true if there is a cookie in the client matching the given cookie's
## domain/path/name, false otherwise.

proc get_cookie*(this: HTTPClient, cookie: HTTPCookie): HTTPCookie {.importcpp: "#->get_cookie(#)".} ## \
## Looks up and returns the cookie in the client matching the given cookie's
## domain/path/name.  If there is no matching cookie, returns an empty cookie.

proc copy_cookies_from*(this: HTTPClient, other: HTTPClient) {.importcpp: "#->copy_cookies_from(#)".} ## \
## Copies all the cookies from the indicated HTTPClient into this one.
## Existing cookies in this client are not affected, unless they are shadowed
## by the new cookies.

proc write_cookies*(this: HTTPClient, `out`: ostream) {.importcpp: "#->write_cookies(#)".} ## \
## Outputs the complete list of cookies stored on the client, for all domains,
## including the expired cookies (which will normally not be sent back to a
## host).

proc send_cookies*(this: HTTPClient, `out`: ostream, url: URLSpec) {.importcpp: "#->send_cookies(#, #)".} ## \
## Writes to the indicated ostream a "Cookie" header line for sending the
## cookies appropriate to the indicated URL along with an HTTP request.  This
## also removes expired cookies.

proc set_client_certificate_filename*(this: HTTPClient, filename: Filename) {.importcpp: "#->set_client_certificate_filename(#)".} ## \
## Sets the filename of the pem-formatted file that will be read for the
## client public and private keys if an SSL server requests a certificate.
## Either this or set_client_certificate_pem() may be used to specify a client
## certificate.

proc set_client_certificate_pem*(this: HTTPClient, pem: string) {.importcpp: "#->set_client_certificate_pem(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the pem-formatted contents of the certificate that will be parsed for
## the client public and private keys if an SSL server requests a certificate.
## Either this or set_client_certificate_filename() may be used to specify a
## client certificate.

proc set_client_certificate_passphrase*(this: HTTPClient, passphrase: string) {.importcpp: "#->set_client_certificate_passphrase(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the passphrase used to decrypt the private key in the certificate
## named by set_client_certificate_filename() or set_client_certificate_pem().

proc load_client_certificate*(this: HTTPClient): bool {.importcpp: "#->load_client_certificate()".} ## \
## Attempts to load the certificate named by set_client_certificate_filename()
## immediately, and returns true if successful, false otherwise.
##
## Normally this need not be explicitly called, since it will be called
## automatically if the server requests a certificate, but it may be useful to
## determine ahead of time if the certificate can be loaded correctly.

proc add_preapproved_server_certificate_filename*(this: HTTPClient, url: URLSpec, filename: Filename): bool {.importcpp: "#->add_preapproved_server_certificate_filename(#, #)".} ## \
## Adds the certificate defined in the indicated PEM filename as a "pre-
## approved" certificate for the indicated server, defined by the hostname and
## port (only) from the given URL.
##
## If the server offers this particular certificate on a secure connection, it
## will be accepted without question.  This is particularly useful for
## communicating with a server using a known self-signed certificate.
##
## See also the similar add_preapproved_server_certificate_pem(), and the
## weaker add_preapproved_server_certificate_name().

proc add_preapproved_server_certificate_pem*(this: HTTPClient, url: URLSpec, pem: string): bool {.importcpp: "#->add_preapproved_server_certificate_pem(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds the certificate defined in the indicated data string, formatted as a
## PEM block, as a "pre-approved" certificate for the indicated server,
## defined by the hostname and port (only) from the given URL.
##
## If the server offers this particular certificate on a secure connection, it
## will be accepted without question.  This is particularly useful for
## communicating with a server using a known self-signed certificate.
##
## See also the similar add_preapproved_server_certificate_filename(), and the
## weaker add_preapproved_server_certificate_name().

proc add_preapproved_server_certificate_name*(this: HTTPClient, url: URLSpec, name: string): bool {.importcpp: "#->add_preapproved_server_certificate_name(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds the certificate *name* only, as a "pre-approved" certificate name for
## the indicated server, defined by the hostname and port (only) from the
## given URL.
##
## This is a weaker function than
## add_preapproved_server_certificate_filename().  This checks only the
## subject name of the certificate, without checking for a particular
## certificate by key.  This means that a variety of server certificates may
## match the indicated name.
##
## Because this is a weaker verification, it only applies to server
## certificates that are signed by a recognized certificate authority.  Thus,
## it cannot be used to pre-approve self-signed certificates, but it can be
## used to accept a server certificate offered by a different hostname than
## the one in the cert itself.
##
## The certificate name should be formatted in the form
## type0=value0/type1=value1/type2=...

proc clear_preapproved_server_certificates*(this: HTTPClient, url: URLSpec) {.importcpp: "#->clear_preapproved_server_certificates(#)".} ## \
## Removes all preapproved server certificates for the indicated server and
## port.

proc clear_all_preapproved_server_certificates*(this: HTTPClient) {.importcpp: "#->clear_all_preapproved_server_certificates()".} ## \
## Removes all preapproved server certificates for all servers.

proc get_http_version_string*(this: HTTPClient): string {.importcpp: "nimStringFromStdString(#->get_http_version_string())", header: stringConversionCode.} ## \
## Returns the current HTTP version setting as a string, e.g.  "HTTP/1.0" or
## "HTTP/1.1".

proc load_certificates*(this: HTTPClient, filename: Filename): bool {.importcpp: "#->load_certificates(#)".} ## \
## Reads the certificate(s) (delimited by -----BEGIN CERTIFICATE----- and
## -----END CERTIFICATE-----) from the indicated file and makes them known as
## trusted public keys for validating future connections.  Returns true on
## success, false otherwise.

proc set_cipher_list*(this: HTTPClient, cipher_list: string) {.importcpp: "#->set_cipher_list(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the set of ciphers that are to be made available for SSL
## connections.  This is a string as described in the ciphers(1) man page of
## the OpenSSL documentation (or see
## https://www.openssl.org/docs/man1.1.1/man1/ciphers.html ).  If this isn't
## specified, the default is provided by the Config file.  You may also specify
## "DEFAULT" to use the built-in OpenSSL default value.

proc get_cipher_list*(this: HTTPClient): string {.importcpp: "nimStringFromStdString(#->get_cipher_list())", header: stringConversionCode.} ## \
## Returns the set of ciphers as set by set_cipher_list().  See
## set_cipher_list().

proc make_channel*(this: HTTPClient, persistent_connection: bool): HTTPChannel {.importcpp: "#->make_channel(#)".} ## \
## Returns a new HTTPChannel object that may be used for reading multiple
## documents using the same connection, for greater network efficiency than
## calling HTTPClient::get_document() repeatedly (which would force a new
## connection for each document).
##
## Also, HTTPChannel has some additional, less common interface methods than
## the basic interface methods that exist on HTTPClient; if you wish to call
## any of these methods you must first obtain an HTTPChannel.
##
## Pass true for persistent_connection to gain this network efficiency.  If,
## on the other hand, your intention is to use the channel to retrieve only
## one document, then pass false to inform the server that we will be dropping
## the connection after the first document.

proc post_form*(this: HTTPClient, url: URLSpec, body: string): HTTPChannel {.importcpp: "#->post_form(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Posts form data to a particular URL and retrieves the response.  Returns a
## new HTTPChannel object whether the document is successfully read or not;
## you can test is_valid() and get_return_code() to determine whether the
## document was retrieved.

proc get_document*(this: HTTPClient, url: URLSpec): HTTPChannel {.importcpp: "#->get_document(#)".} ## \
## Opens the named document for reading.  Returns a new HTTPChannel object
## whether the document is successfully read or not; you can test is_valid()
## and get_return_code() to determine whether the document was retrieved.

proc get_header*(this: HTTPClient, url: URLSpec): HTTPChannel {.importcpp: "#->get_header(#)".} ## \
## Like get_document(), except only the header associated with the document is
## retrieved.  This may be used to test for existence of the document; it
## might also return the size of the document (if the server gives us this
## information).

proc base64_encode*(_: typedesc[HTTPClient], s: string): string {.importcpp: "nimStringFromStdString(HTTPClient::base64_encode(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Implements HTTPAuthorization::base64_encode().  This is provided here just
## as a convenient place to publish it for access by the scripting language;
## C++ code should probably use HTTPAuthorization directly.

proc base64_decode*(_: typedesc[HTTPClient], s: string): string {.importcpp: "nimStringFromStdString(HTTPClient::base64_decode(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Implements HTTPAuthorization::base64_decode().  This is provided here just
## as a convenient place to publish it for access by the scripting language;
## C++ code should probably use HTTPAuthorization directly.

proc get_global_ptr*(_: typedesc[HTTPClient]): HTTPClient {.importcpp: "HTTPClient::get_global_ptr()", header: "hTTPClient.h".} ## \
## Returns the default global HTTPClient.

proc initHTTPEntityTag*(): HTTPEntityTag {.importcpp: "HTTPEntityTag()".}

proc initHTTPEntityTag*(copy: HTTPEntityTag): HTTPEntityTag {.importcpp: "HTTPEntityTag(#)".}

proc initHTTPEntityTag*(weak: bool, tag: string): HTTPEntityTag {.importcpp: "HTTPEntityTag(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## This constructor accepts an explicit weak flag and a literal (not quoted)
## tag string.

proc initHTTPEntityTag*(text: string): HTTPEntityTag {.importcpp: "HTTPEntityTag(nimStringToStdString(#))", header: stringConversionCode.} ## \
## This constructor accepts a string as formatted from an HTTP server (e.g.
## the tag is quoted, with an optional W/ prefix.)

proc is_weak*(this: HTTPEntityTag): bool {.importcpp: "#.is_weak()".} ## \
## Returns true if the entity tag is marked as "weak". A consistent weak
## entity tag does not guarantee that its resource has not changed in any way,
## but it does promise that the resource has not changed in any semantically
## meaningful way.

proc get_tag*(this: HTTPEntityTag): string {.importcpp: "nimStringFromStdString(#.get_tag())", header: stringConversionCode.} ## \
## Returns the tag as a literal string.

proc get_string*(this: HTTPEntityTag): string {.importcpp: "nimStringFromStdString(#.get_string())", header: stringConversionCode.} ## \
## Returns the entity tag formatted for sending to an HTTP server (the tag is
## quoted, with a conditional W prefix).

proc strong_equiv*(this: HTTPEntityTag, other: HTTPEntityTag): bool {.importcpp: "#.strong_equiv(#)".} ## \
## Returns true if the two tags have "strong" equivalence: they are the same
## tag, and both are "strong".

proc weak_equiv*(this: HTTPEntityTag, other: HTTPEntityTag): bool {.importcpp: "#.weak_equiv(#)".} ## \
## Returns true if the two tags have "weak" equivalence: they are the same
## tag, and one or both may be "weak".

proc `==`*(this: HTTPEntityTag, other: HTTPEntityTag): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: HTTPEntityTag, other: HTTPEntityTag): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: HTTPEntityTag, other: HTTPEntityTag): bool {.importcpp: "#.operator <(#)".}

proc compare_to*(this: HTTPEntityTag, other: HTTPEntityTag): int {.importcpp: "#.compare_to(#)".} ## \
## Returns a number less than zero if this HTTPEntityTag sorts before the
## other one, greater than zero if it sorts after, or zero if they are
## equivalent.

proc output*(this: HTTPEntityTag, `out`: ostream) {.importcpp: "#.output(#)".}

proc initDocumentSpec*(): DocumentSpec {.importcpp: "DocumentSpec()".}

proc initDocumentSpec*(copy: DocumentSpec): DocumentSpec {.importcpp: "DocumentSpec(#)".}

proc initDocumentSpec*(url: URLSpec): DocumentSpec {.importcpp: "DocumentSpec(#)".}

proc initDocumentSpec*(url: string): DocumentSpec {.importcpp: "DocumentSpec(nimStringToStdString(#))", header: stringConversionCode.}

proc `==`*(this: DocumentSpec, other: DocumentSpec): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: DocumentSpec, other: DocumentSpec): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: DocumentSpec, other: DocumentSpec): bool {.importcpp: "#.operator <(#)".}

proc compare_to*(this: DocumentSpec, other: DocumentSpec): int {.importcpp: "#.compare_to(#)".}

proc set_url*(this: DocumentSpec, url: URLSpec) {.importcpp: "#.set_url(#)".} ## \
## Changes the URL of the DocumentSpec without modifying its other properties.
## Normally this would be a strange thing to do, because the tag and date are
## usually strongly associated with the URL.  To get a DocumentSpec pointing
## to a new URL, you would normally create a new DocumentSpec object.

proc get_url*(this: DocumentSpec): URLSpec {.importcpp: "#.get_url()".} ## \
## Retrieves the URL of the DocumentSpec.

proc set_tag*(this: DocumentSpec, tag: HTTPEntityTag) {.importcpp: "#.set_tag(#)".} ## \
## Changes the identity tag associated with the DocumentSpec.

proc has_tag*(this: DocumentSpec): bool {.importcpp: "#.has_tag()".} ## \
## Returns true if an identity tag is associated with the DocumentSpec.

proc get_tag*(this: DocumentSpec): HTTPEntityTag {.importcpp: "#.get_tag()".} ## \
## Returns the identity tag associated with the DocumentSpec, if there is one.
## It is an error to call this if has_tag() returns false.
##
## The identity tag is set by the HTTP server to uniquely refer to a
## particular version of a document.

proc clear_tag*(this: DocumentSpec) {.importcpp: "#.clear_tag()".} ## \
## Removes the identity tag associated with the DocumentSpec, if there is one.

proc set_date*(this: DocumentSpec, date: HTTPDate) {.importcpp: "#.set_date(#)".} ## \
## Changes the last-modified date associated with the DocumentSpec.

proc has_date*(this: DocumentSpec): bool {.importcpp: "#.has_date()".} ## \
## Returns true if a last-modified date is associated with the DocumentSpec.

proc get_date*(this: DocumentSpec): HTTPDate {.importcpp: "#.get_date()".} ## \
## Returns the last-modified date associated with the DocumentSpec, if there
## is one.  It is an error to call this if has_date() returns false.

proc clear_date*(this: DocumentSpec) {.importcpp: "#.clear_date()".} ## \
## Removes the last-modified date associated with the DocumentSpec, if there
## is one.

proc input*(this: DocumentSpec, `in`: istream): bool {.importcpp: "#.input(#)".} ## \
## Can be used to read in the DocumentSpec from a stream generated either by
## output() or write().  Returns true on success, false on failure.

proc output*(this: DocumentSpec, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: DocumentSpec, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: DocumentSpec, `out`: ostream) {.importcpp: "#.write(#)".}

proc get_client*(this: HTTPChannel): HTTPClient {.importcpp: "#->get_client()".} ## \
## Returns the HTTPClient object that owns this channel.

proc is_valid*(this: HTTPChannel): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the last-requested document was successfully retrieved and
## is ready to be read, false otherwise.

proc is_connection_ready*(this: HTTPChannel): bool {.importcpp: "#->is_connection_ready()".} ## \
## Returns true if a connection has been established to the named server in a
## previous call to connect_to() or begin_connect_to(), false otherwise.

proc get_url*(this: HTTPChannel): URLSpec {.importcpp: "#->get_url()".} ## \
## Returns the URL that was used to retrieve the most recent document:
## whatever URL was last passed to get_document() or get_header().  If a
## redirect has transparently occurred, this will return the new, redirected
## URL (the actual URL at which the document was located).

proc get_document_spec*(this: HTTPChannel): DocumentSpec {.importcpp: "#->get_document_spec()".} ## \
## Returns the DocumentSpec associated with the most recent document.  This
## includes its actual URL (following redirects) along with the identity tag
## and last-modified date, if supplied by the server.
##
## This structure may be saved and used to retrieve the same version of the
## document later, or to conditionally retrieve a newer version if it is
## available.

proc get_http_version_string*(this: HTTPChannel): string {.importcpp: "nimStringFromStdString(#->get_http_version_string())", header: stringConversionCode.} ## \
## Returns the HTTP version number returned by the server, formatted as a
## string, e.g.  "HTTP/1.1".

proc get_status_code*(this: HTTPChannel): int {.importcpp: "#->get_status_code()".} ## \
## Returns the HTML return code from the document retrieval request.  This
## will be in the 200 range if the document is successfully retrieved, or some
## other value in the case of an error.
##
## Some proxy errors during an https-over-proxy request would return the same
## status code as a different error that occurred on the host server.  To
## differentiate these cases, status codes that are returned by the proxy
## during the CONNECT phase (except code 407) are incremented by 1000.

proc get_status_string*(this: HTTPChannel): string {.importcpp: "nimStringFromStdString(#->get_status_string())", header: stringConversionCode.} ## \
## Returns the string as returned by the server describing the status code for
## humans.  This may or may not be meaningful.

proc get_www_realm*(this: HTTPChannel): string {.importcpp: "nimStringFromStdString(#->get_www_realm())", header: stringConversionCode.} ## \
## If the document failed to connect because of a 401 (Authorization
## required), this method will return the "realm" returned by the server in
## which the requested document must be authenticated.  This string may be
## presented to the user to request an associated username and password (which
## then should be stored in HTTPClient::set_username()).

proc get_proxy_realm*(this: HTTPChannel): string {.importcpp: "nimStringFromStdString(#->get_proxy_realm())", header: stringConversionCode.} ## \
## If the document failed to connect because of a 407 (Proxy authorization
## required), this method will return the "realm" returned by the proxy.  This
## string may be presented to the user to request an associated username and
## password (which then should be stored in HTTPClient::set_username()).

proc get_redirect*(this: HTTPChannel): URLSpec {.importcpp: "#->get_redirect()".} ## \
## If the document failed with a redirect code (300 series), this will
## generally contain the new URL the server wants us to try.  In many cases,
## the client will automatically follow redirects; if these are successful the
## client will return a successful code and get_redirect() will return empty,
## but get_url() will return the new, redirected URL.

proc get_header_value*(this: HTTPChannel, key: string): string {.importcpp: "nimStringFromStdString(#->get_header_value(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Returns the HTML header value associated with the indicated key, or empty
## string if the key was not defined in the message returned by the server.

proc get_num_redirect_steps*(this: HTTPChannel): int {.importcpp: "#->get_num_redirect_steps()".} ## \
## If the document automatically followed one or more redirects, this will
## return the number of redirects that were automatically followed.  Use
## get_redirect_step() to retrieve each URL in sequence.

proc get_redirect_step*(this: HTTPChannel, n: int): URLSpec {.importcpp: "#->get_redirect_step(#)".} ## \
## Use in conjunction with get_num_redirect_steps() to extract the chain of
## URL's that the channel was automatically redirected through to arrive at
## the final document.

proc set_persistent_connection*(this: HTTPChannel, persistent_connection: bool) {.importcpp: "#->set_persistent_connection(#)".} ## \
## Indicates whether the HTTPChannel should try to keep the connection to the
## server open and reuse that connection for multiple documents, or whether it
## should close the connection and open a new one for each request.  Set this
## true to keep the connections around when possible, false to recycle them.
##
## It makes most sense to set this false when the HTTPChannel will be used
## only once to retrieve a single document, true when you will be using the
## same HTTPChannel object to retrieve multiple documents.

proc get_persistent_connection*(this: HTTPChannel): bool {.importcpp: "#->get_persistent_connection()".} ## \
## Returns whether the HTTPChannel should try to keep the connection to the
## server open and reuse that connection for multiple documents, or whether it
## should close the connection and open a new one for each request.  See
## set_persistent_connection().

proc will_close_connection*(this: HTTPChannel): bool {.importcpp: "#->will_close_connection()".} ## \
## Returns true if the server has indicated it will close the connection after
## this document has been read, or false if it will remain open (and future
## documents may be requested on the same connection).

proc set_allow_proxy*(this: HTTPChannel, allow_proxy: bool) {.importcpp: "#->set_allow_proxy(#)".} ## \
## If this is true (the normal case), the HTTPClient will be consulted for
## information about the proxy to be used for each connection via this
## HTTPChannel.  If this has been set to false by the user, then all
## connections will be made directly, regardless of the proxy settings
## indicated on the HTTPClient.

proc get_allow_proxy*(this: HTTPChannel): bool {.importcpp: "#->get_allow_proxy()".} ## \
## If this is true (the normal case), the HTTPClient will be consulted for
## information about the proxy to be used for each connection via this
## HTTPChannel.  If this has been set to false by the user, then all
## connections will be made directly, regardless of the proxy settings
## indicated on the HTTPClient.

proc set_proxy_tunnel*(this: HTTPChannel, proxy_tunnel: bool) {.importcpp: "#->set_proxy_tunnel(#)".} ## \
## Normally, a proxy is itself asked for ordinary URL's, and the proxy decides
## whether to hand the client a cached version of the document or to contact
## the server for a fresh version.  The proxy may also modify the headers and
## transfer encoding on the way.
##
## If this is set to true, then instead of asking for URL's from the proxy, we
## will ask the proxy to open a connection to the server (for instance, on
## port 80); if the proxy honors this request, then we contact the server
## directly through this connection to retrieve the document.  If the proxy
## does not honor the connect request, then the retrieve operation fails.
##
## SSL connections (e.g.  https), and connections through a Socks proxy, are
## always tunneled, regardless of the setting of this flag.

proc get_proxy_tunnel*(this: HTTPChannel): bool {.importcpp: "#->get_proxy_tunnel()".} ## \
## Returns true if connections always tunnel through a proxy, or false (the
## normal case) if we allow the proxy to serve up documents.  See
## set_proxy_tunnel().

proc set_connect_timeout*(this: HTTPChannel, timeout_seconds: float64) {.importcpp: "#->set_connect_timeout(#)".} ## \
## Sets the maximum length of time, in seconds, that the channel will wait
## before giving up on establishing a TCP connection.
##
## At present, this is used only for the nonblocking interfaces (e.g.
## begin_get_document(), begin_connect_to()), but it is used whether
## set_blocking_connect() is true or false.

proc get_connect_timeout*(this: HTTPChannel): float64 {.importcpp: "#->get_connect_timeout()".} ## \
## Returns the length of time, in seconds, to wait for a new nonblocking
## socket to connect.  See set_connect_timeout().

proc set_blocking_connect*(this: HTTPChannel, blocking_connect: bool) {.importcpp: "#->set_blocking_connect(#)".} ## \
## If this flag is true, a socket connect will block even for nonblocking I/O
## calls like begin_get_document(), begin_connect_to(), etc.  If false, a
## socket connect will not block for nonblocking I/O calls, but will block for
## blocking I/O calls (get_document(), connect_to(), etc.).
##
## Setting this true is useful when you want to use non-blocking I/O once you
## have established the connection, but you don't want to bother with polling
## for the initial connection.  It's also useful when you don't particularly
## care about non-blocking I/O, but you need to respect timeouts like
## connect_timeout and http_timeout.

proc get_blocking_connect*(this: HTTPChannel): bool {.importcpp: "#->get_blocking_connect()".} ## \
## If this flag is true, a socket connect will block even for nonblocking I/O
## calls like begin_get_document(), begin_connect_to(), etc.  If false, a
## socket connect will not block for nonblocking I/O calls, but will block for
## blocking I/O calls (get_document(), connect_to(), etc.).

proc set_http_timeout*(this: HTTPChannel, timeout_seconds: float64) {.importcpp: "#->set_http_timeout(#)".} ## \
## Sets the maximum length of time, in seconds, that the channel will wait for
## the HTTP server to finish sending its response to our request.
##
## The timer starts counting after the TCP connection has been established
## (see set_connect_timeout(), above) and the request has been sent.
##
## At present, this is used only for the nonblocking interfaces (e.g.
## begin_get_document(), begin_connect_to()), but it is used whether
## set_blocking_connect() is true or false.

proc get_http_timeout*(this: HTTPChannel): float64 {.importcpp: "#->get_http_timeout()".} ## \
## Returns the length of time, in seconds, to wait for the HTTP server to
## respond to our request.  See set_http_timeout().

proc set_skip_body_size*(this: HTTPChannel, skip_body_size: clonglong) {.importcpp: "#->set_skip_body_size(#)".} ## \
## Specifies the maximum number of bytes in a received (but unwanted) body
## that will be skipped past, in order to reset to a new request.
##
## That is, if this HTTPChannel requests a file via get_document(), but does
## not call download_to_ram(), download_to_file(), or open_read_body(), and
## instead immediately requests a new file, then the HTTPChannel has a choice
## whether to skip past the unwanted document, or to close the connection and
## open a new one.  If the number of bytes to skip is more than this
## threshold, the connection will be closed; otherwise, the data will simply
## be read and discarded.

proc get_skip_body_size*(this: HTTPChannel): clonglong {.importcpp: "#->get_skip_body_size()".} ## \
## Returns the maximum number of bytes in a received (but unwanted) body that
## will be skipped past, in order to reset to a new request.  See
## set_skip_body_size().

proc set_idle_timeout*(this: HTTPChannel, idle_timeout: float64) {.importcpp: "#->set_idle_timeout(#)".} ## \
## Specifies the amount of time, in seconds, in which a previously-established
## connection is allowed to remain open and unused.  If a previous connection
## has remained unused for at least this number of seconds, it will be closed
## and a new connection will be opened; otherwise, the same connection will be
## reused for the next request (for this particular HTTPChannel).

proc get_idle_timeout*(this: HTTPChannel): float64 {.importcpp: "#->get_idle_timeout()".} ## \
## Returns the amount of time, in seconds, in which an previously-established
## connection is allowed to remain open and unused.  See set_idle_timeout().

proc set_download_throttle*(this: HTTPChannel, download_throttle: bool) {.importcpp: "#->set_download_throttle(#)".} ## \
## Specifies whether nonblocking downloads (via download_to_file() or
## download_to_ram()) will be limited so as not to use all available
## bandwidth.
##
## If this is true, when a download has been started on this channel it will
## be invoked no more frequently than get_max_updates_per_second(), and the
## total bandwidth used by the download will be no more than
## get_max_bytes_per_second().  If this is false, downloads will proceed as
## fast as the server can send the data.
##
## This only has effect on the nonblocking I/O methods like
## begin_get_document(), etc.  The blocking methods like get_document() always
## use as much CPU and bandwidth as they can get.

proc get_download_throttle*(this: HTTPChannel): bool {.importcpp: "#->get_download_throttle()".} ## \
## Returns whether the nonblocking downloads will be bandwidth-limited.  See
## set_download_throttle().

proc set_max_bytes_per_second*(this: HTTPChannel, max_bytes_per_second: float64) {.importcpp: "#->set_max_bytes_per_second(#)".} ## \
## When bandwidth throttling is in effect (see set_download_throttle()), this
## specifies the maximum number of bytes per second that may be consumed by
## this channel.

proc get_max_bytes_per_second*(this: HTTPChannel): float64 {.importcpp: "#->get_max_bytes_per_second()".} ## \
## Returns the maximum number of bytes per second that may be consumed by this
## channel when get_download_throttle() is true.

proc set_max_updates_per_second*(this: HTTPChannel, max_updates_per_second: float64) {.importcpp: "#->set_max_updates_per_second(#)".} ## \
## When bandwidth throttling is in effect (see set_download_throttle()), this
## specifies the maximum number of times per second that run() will attempt to
## do any downloading at all.

proc get_max_updates_per_second*(this: HTTPChannel): float64 {.importcpp: "#->get_max_updates_per_second()".} ## \
## Returns the maximum number of times per second that run() will do anything
## at all, when get_download_throttle() is true.

proc set_content_type*(this: HTTPChannel, content_type: string) {.importcpp: "#->set_content_type(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the Content-Type header, useful for applications that require
## different types of content, such as JSON.

proc get_content_type*(this: HTTPChannel): string {.importcpp: "nimStringFromStdString(#->get_content_type())", header: stringConversionCode.} ## \
## Returns the value of the Content-Type header.

proc set_expected_file_size*(this: HTTPChannel, file_size: clonglong) {.importcpp: "#->set_expected_file_size(#)".} ## \
## This may be called immediately after a call to get_document() or some
## related function to specify the expected size of the document we are
## retrieving, if we happen to know.  This is used as the return value to
## get_file_size() only in the case that the server does not tell us the
## actual file size.

proc get_file_size*(this: HTTPChannel): clonglong {.importcpp: "#->get_file_size()".} ## \
## Returns the size of the file, if it is known.  Returns the value set by
## set_expected_file_size() if the file size is not known, or 0 if this value
## was not set.
##
## If the file is dynamically generated, the size may not be available until a
## read has started (e.g.  open_read_body() has been called); and even then it
## may increase as more of the file is read due to the nature of HTTP/1.1
## requests which can change their minds midstream about how much data they're
## sending you.

proc is_file_size_known*(this: HTTPChannel): bool {.importcpp: "#->is_file_size_known()".} ## \
## Returns true if the size of the file we are currently retrieving was told
## us by the server and thus is reliably known, or false if the size reported
## by get_file_size() represents an educated guess (possibly as set by
## set_expected_file_size(), or as inferred from a chunked transfer encoding
## in progress).

proc get_first_byte_requested*(this: HTTPChannel): clonglong {.importcpp: "#->get_first_byte_requested()".} ## \
## Returns the first byte of the file requested by the request.  This will
## normally be 0 to indicate that the file is being requested from the
## beginning, but if the file was requested via a get_subdocument() call, this
## will contain the first_byte parameter from that call.

proc get_last_byte_requested*(this: HTTPChannel): clonglong {.importcpp: "#->get_last_byte_requested()".} ## \
## Returns the last byte of the file requested by the request.  This will
## normally be 0 to indicate that the file is being requested to its last
## byte, but if the file was requested via a get_subdocument() call, this will
## contain the last_byte parameter from that call.

proc get_first_byte_delivered*(this: HTTPChannel): clonglong {.importcpp: "#->get_first_byte_delivered()".} ## \
## Returns the first byte of the file (that will be) delivered by the server
## in response to the current request.  Normally, this is the same as
## get_first_byte_requested(), but some servers will ignore a subdocument
## request and always return the whole file, in which case this value will be
## 0, regardless of what was requested to get_subdocument().

proc get_last_byte_delivered*(this: HTTPChannel): clonglong {.importcpp: "#->get_last_byte_delivered()".} ## \
## Returns the last byte of the file (that will be) delivered by the server in
## response to the current request.  Normally, this is the same as
## get_last_byte_requested(), but some servers will ignore a subdocument
## request and always return the whole file, in which case this value will be
## 0, regardless of what was requested to get_subdocument().

proc write_headers*(this: HTTPChannel, `out`: ostream) {.importcpp: "#->write_headers(#)".} ## \
## Outputs a list of all headers defined by the server to the indicated output
## stream.

proc reset*(this: HTTPChannel) {.importcpp: "#->reset()".} ## \
## Stops whatever file transaction is currently in progress, closes the
## connection, and resets to begin anew.  You shouldn't ever need to call
## this, since the channel should be able to reset itself cleanly between
## requests, but it is provided in case you are an especially nervous type.
##
## Don't call this after every request unless you set
## set_persistent_connection() to false, since calling reset() rudely closes
## the connection regardless of whether we have told the server we intend to
## keep it open or not.

proc preserve_status*(this: HTTPChannel) {.importcpp: "#->preserve_status()".} ## \
## Preserves the previous status code (presumably a failure) from the previous
## connection attempt.  If the subsequent connection attempt also fails, the
## returned status code will be the better of the previous code and the
## current code.
##
## This can be called to daisy-chain subsequent attempts to download the same
## document from different servers.  After all servers have been attempted,
## the final status code will reflect the attempt that most nearly succeeded.

proc clear_extra_headers*(this: HTTPChannel) {.importcpp: "#->clear_extra_headers()".} ## \
## Resets the extra headers that were previously added via calls to
## send_extra_header().

proc send_extra_header*(this: HTTPChannel, key: string, value: string) {.importcpp: "#->send_extra_header(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies an additional key: value pair that is added into the header sent
## to the server with the next request.  This is passed along with no
## interpretation by the HTTPChannel code.  You may call this repeatedly to
## append multiple headers.
##
## This is persistent for one request only; it must be set again for each new
## request.

proc get_document*(this: HTTPChannel, url: DocumentSpec): bool {.importcpp: "#->get_document(#)".} ## \
## Opens the named document for reading, if available.  Returns true if
## successful, false otherwise.

proc get_subdocument*(this: HTTPChannel, url: DocumentSpec, first_byte: clonglong, last_byte: clonglong): bool {.importcpp: "#->get_subdocument(#, #, #)".} ## \
## Retrieves only the specified byte range of the indicated document.  If
## last_byte is 0, it stands for the last byte of the document.  When a
## subdocument is requested, get_file_size() and get_bytes_downloaded() will
## report the number of bytes of the subdocument, not of the complete
## document.

proc get_header*(this: HTTPChannel, url: DocumentSpec): bool {.importcpp: "#->get_header(#)".} ## \
## Like get_document(), except only the header associated with the document is
## retrieved.  This may be used to test for existence of the document; it
## might also return the size of the document (if the server gives us this
## information).

proc post_form*(this: HTTPChannel, url: DocumentSpec, body: string): bool {.importcpp: "#->post_form(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Posts form data to a particular URL and retrieves the response.

proc put_document*(this: HTTPChannel, url: DocumentSpec, body: string): bool {.importcpp: "#->put_document(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Uploads the indicated body to the server to replace the indicated URL, if
## the server allows this.

proc delete_document*(this: HTTPChannel, url: DocumentSpec): bool {.importcpp: "#->delete_document(#)".} ## \
## Requests the server to remove the indicated URL.

proc get_trace*(this: HTTPChannel, url: DocumentSpec): bool {.importcpp: "#->get_trace(#)".} ## \
## Sends a TRACE message to the server, which should return back the same
## message as the server received it, allowing inspection of proxy hops, etc.

proc connect_to*(this: HTTPChannel, url: DocumentSpec): bool {.importcpp: "#->connect_to(#)".} ## \
## Establish a direct connection to the server and port indicated by the URL,
## but do not issue any HTTP requests.  If successful, the connection may then
## be taken to use for whatever purposes you like by calling get_connection().
##
## This establishes a blocking I/O socket.  Also see begin_connect_to().

proc get_options*(this: HTTPChannel, url: DocumentSpec): bool {.importcpp: "#->get_options(#)".} ## \
## Sends an OPTIONS message to the server, which should query the available
## options, possibly in relation to a specified URL.

proc begin_get_document*(this: HTTPChannel, url: DocumentSpec) {.importcpp: "#->begin_get_document(#)".} ## \
## Begins a non-blocking request to retrieve a given document.  This method
## will return immediately, even before a connection to the server has
## necessarily been established; you must then call run() from time to time
## until the return value of run() is false.  Then you may check is_valid()
## and get_status_code() to determine the status of your request.
##
## If a previous request had been pending, that request is discarded.

proc begin_get_subdocument*(this: HTTPChannel, url: DocumentSpec, first_byte: clonglong, last_byte: clonglong) {.importcpp: "#->begin_get_subdocument(#, #, #)".} ## \
## Begins a non-blocking request to retrieve only the specified byte range of
## the indicated document.  If last_byte is 0, it stands for the last byte of
## the document.  When a subdocument is requested, get_file_size() and
## get_bytes_downloaded() will report the number of bytes of the subdocument,
## not of the complete document.

proc begin_get_header*(this: HTTPChannel, url: DocumentSpec) {.importcpp: "#->begin_get_header(#)".} ## \
## Begins a non-blocking request to retrieve a given header.  See
## begin_get_document() and get_header().

proc begin_post_form*(this: HTTPChannel, url: DocumentSpec, body: string) {.importcpp: "#->begin_post_form(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Posts form data to a particular URL and retrieves the response, all using
## non-blocking I/O.  See begin_get_document() and post_form().
##
## It is important to note that you *must* call run() repeatedly after calling
## this method until run() returns false, and you may not call any other
## document posting or retrieving methods using the HTTPChannel object in the
## interim, or your form data may not get posted.

proc run*(this: HTTPChannel): bool {.importcpp: "#->run()".} ## \
## This must be called from time to time when non-blocking I/O is in use.  It
## checks for data coming in on the socket and writes data out to the socket
## when possible, and does whatever processing is required towards completing
## the current task.
##
## The return value is true if the task is still pending (and run() will need
## to be called again in the future), or false if the current task is
## complete.

proc begin_connect_to*(this: HTTPChannel, url: DocumentSpec) {.importcpp: "#->begin_connect_to(#)".} ## \
## Begins a non-blocking request to establish a direct connection to the
## server and port indicated by the URL.  No HTTP requests will be issued
## beyond what is necessary to establish the connection.  When run() has
## finished, you may call is_connection_ready() to determine if the connection
## was successfully established.
##
## If successful, the connection may then be taken to use for whatever
## purposes you like by calling get_connection().
##
## This establishes a nonblocking I/O socket.  Also see connect_to().

proc open_read_body*(this: HTTPChannel): ISocketStream {.importcpp: "#->open_read_body()".} ## \
## Returns a newly-allocated istream suitable for reading the body of the
## document.  This may only be called immediately after a call to
## get_document() or post_form(), or after a call to run() has returned false.
##
## Note that, in nonblocking mode, the returned stream may report an early
## EOF, even before the actual end of file.  When this happens, you should
## call stream->is_closed() to determine whether you should attempt to read
## some more later.
##
## The user is responsible for passing the returned istream to
## close_read_body() later.

proc close_read_body*(this: HTTPChannel, stream: istream) {.importcpp: "#->close_read_body(#)".} ## \
## Closes a file opened by a previous call to open_read_body().  This really
## just deletes the istream pointer, but it is recommended to use this
## interface instead of deleting it explicitly, to help work around compiler
## issues.

proc download_to_file*(this: HTTPChannel, filename: Filename, subdocument_resumes: bool): bool {.importcpp: "#->download_to_file(#, #)".} ## \
## Specifies the name of a file to download the resulting document to.  This
## should be called immediately after get_document() or begin_get_document()
## or related functions.
##
## In the case of the blocking I/O methods like get_document(), this function
## will download the entire document to the file and return true if it was
## successfully downloaded, false otherwise.
##
## In the case of non-blocking I/O methods like begin_get_document(), this
## function simply indicates an intention to download to the indicated file.
## It returns true if the file can be opened for writing, false otherwise, but
## the contents will not be completely downloaded until run() has returned
## false.  At this time, it is possible that a communications error will have
## left a partial file, so is_download_complete() may be called to test this.
##
## If subdocument_resumes is true and the document in question was previously
## requested as a subdocument (i.e.  get_subdocument() with a first_byte value
## greater than zero), this will automatically seek to the appropriate byte
## within the file for writing the output.  In this case, the file must
## already exist and must have at least first_byte bytes in it.  If
## subdocument_resumes is false, a subdocument will always be downloaded
## beginning at the first byte of the file.

proc download_to_file*(this: HTTPChannel, filename: Filename): bool {.importcpp: "#->download_to_file(#)".} ## \
## Specifies the name of a file to download the resulting document to.  This
## should be called immediately after get_document() or begin_get_document()
## or related functions.
##
## In the case of the blocking I/O methods like get_document(), this function
## will download the entire document to the file and return true if it was
## successfully downloaded, false otherwise.
##
## In the case of non-blocking I/O methods like begin_get_document(), this
## function simply indicates an intention to download to the indicated file.
## It returns true if the file can be opened for writing, false otherwise, but
## the contents will not be completely downloaded until run() has returned
## false.  At this time, it is possible that a communications error will have
## left a partial file, so is_download_complete() may be called to test this.
##
## If subdocument_resumes is true and the document in question was previously
## requested as a subdocument (i.e.  get_subdocument() with a first_byte value
## greater than zero), this will automatically seek to the appropriate byte
## within the file for writing the output.  In this case, the file must
## already exist and must have at least first_byte bytes in it.  If
## subdocument_resumes is false, a subdocument will always be downloaded
## beginning at the first byte of the file.

proc download_to_ram*(this: HTTPChannel, ramfile: Ramfile, subdocument_resumes: bool): bool {.importcpp: "#->download_to_ram(#, #)".} ## \
## Specifies a Ramfile object to download the resulting document to.  This
## should be called immediately after get_document() or begin_get_document()
## or related functions.
##
## In the case of the blocking I/O methods like get_document(), this function
## will download the entire document to the Ramfile and return true if it was
## successfully downloaded, false otherwise.
##
## In the case of non-blocking I/O methods like begin_get_document(), this
## function simply indicates an intention to download to the indicated
## Ramfile.  It returns true if the file can be opened for writing, false
## otherwise, but the contents will not be completely downloaded until run()
## has returned false.  At this time, it is possible that a communications
## error will have left a partial file, so is_download_complete() may be
## called to test this.
##
## If subdocument_resumes is true and the document in question was previously
## requested as a subdocument (i.e.  get_subdocument() with a first_byte value
## greater than zero), this will automatically seek to the appropriate byte
## within the Ramfile for writing the output.  In this case, the Ramfile must
## already have at least first_byte bytes in it.

proc download_to_ram*(this: HTTPChannel, ramfile: Ramfile): bool {.importcpp: "#->download_to_ram(#)".} ## \
## Specifies a Ramfile object to download the resulting document to.  This
## should be called immediately after get_document() or begin_get_document()
## or related functions.
##
## In the case of the blocking I/O methods like get_document(), this function
## will download the entire document to the Ramfile and return true if it was
## successfully downloaded, false otherwise.
##
## In the case of non-blocking I/O methods like begin_get_document(), this
## function simply indicates an intention to download to the indicated
## Ramfile.  It returns true if the file can be opened for writing, false
## otherwise, but the contents will not be completely downloaded until run()
## has returned false.  At this time, it is possible that a communications
## error will have left a partial file, so is_download_complete() may be
## called to test this.
##
## If subdocument_resumes is true and the document in question was previously
## requested as a subdocument (i.e.  get_subdocument() with a first_byte value
## greater than zero), this will automatically seek to the appropriate byte
## within the Ramfile for writing the output.  In this case, the Ramfile must
## already have at least first_byte bytes in it.

proc download_to_stream*(this: HTTPChannel, strm: ostream, subdocument_resumes: bool): bool {.importcpp: "#->download_to_stream(#, #)".} ## \
## Specifies the name of an ostream to download the resulting document to.
## This should be called immediately after get_document() or
## begin_get_document() or related functions.
##
## In the case of the blocking I/O methods like get_document(), this function
## will download the entire document to the file and return true if it was
## successfully downloaded, false otherwise.
##
## In the case of non-blocking I/O methods like begin_get_document(), this
## function simply indicates an intention to download to the indicated file.
## It returns true if the file can be opened for writing, false otherwise, but
## the contents will not be completely downloaded until run() has returned
## false.  At this time, it is possible that a communications error will have
## left a partial file, so is_download_complete() may be called to test this.
##
## If subdocument_resumes is true and the document in question was previously
## requested as a subdocument (i.e.  get_subdocument() with a first_byte value
## greater than zero), this will automatically seek to the appropriate byte
## within the file for writing the output.  In this case, the file must
## already exist and must have at least first_byte bytes in it.  If
## subdocument_resumes is false, a subdocument will always be downloaded
## beginning at the first byte of the file.

proc download_to_stream*(this: HTTPChannel, strm: ostream): bool {.importcpp: "#->download_to_stream(#)".} ## \
## Specifies the name of an ostream to download the resulting document to.
## This should be called immediately after get_document() or
## begin_get_document() or related functions.
##
## In the case of the blocking I/O methods like get_document(), this function
## will download the entire document to the file and return true if it was
## successfully downloaded, false otherwise.
##
## In the case of non-blocking I/O methods like begin_get_document(), this
## function simply indicates an intention to download to the indicated file.
## It returns true if the file can be opened for writing, false otherwise, but
## the contents will not be completely downloaded until run() has returned
## false.  At this time, it is possible that a communications error will have
## left a partial file, so is_download_complete() may be called to test this.
##
## If subdocument_resumes is true and the document in question was previously
## requested as a subdocument (i.e.  get_subdocument() with a first_byte value
## greater than zero), this will automatically seek to the appropriate byte
## within the file for writing the output.  In this case, the file must
## already exist and must have at least first_byte bytes in it.  If
## subdocument_resumes is false, a subdocument will always be downloaded
## beginning at the first byte of the file.

proc get_connection*(this: HTTPChannel): SocketStream {.importcpp: "#->get_connection()".} ## \
## Returns the connection that was established via a previous call to
## connect_to() or begin_connect_to(), or NULL if the connection attempt
## failed or if those methods have not recently been called.
##
## This stream has been allocated from the free store.  It is the user's
## responsibility to delete this pointer when finished with it.

proc get_bytes_downloaded*(this: HTTPChannel): clonglong {.importcpp: "#->get_bytes_downloaded()".} ## \
## Returns the number of bytes downloaded during the last (or current)
## download_to_file() or download_to_ram operation().  This can be used in
## conjunction with get_file_size() to report the percent complete (but be
## careful, since get_file_size() may return 0 if the server has not told us
## the size of the file).

proc get_bytes_requested*(this: HTTPChannel): clonglong {.importcpp: "#->get_bytes_requested()".} ## \
## When download throttling is in effect (set_download_throttle() has been set
## to true) and non-blocking I/O methods (like begin_get_document()) are used,
## this returns the number of bytes "requested" from the server so far: that
## is, the theoretical maximum value for get_bytes_downloaded(), if the server
## has been keeping up with our demand.
##
## If this number is less than get_bytes_downloaded(), then the server has not
## been supplying bytes fast enough to meet our own download throttle rate.
##
## When download throttling is not in effect, or when the blocking I/O methods
## (like get_document(), etc.) are used, this returns 0.

proc is_download_complete*(this: HTTPChannel): bool {.importcpp: "#->is_download_complete()".} ## \
## Returns true when a download_to() or download_to_ram() has executed and the
## file has been fully downloaded.  If this still returns false after
## processing has completed, there was an error in transmission.
##
## Note that simply testing is_download_complete() does not prove that the
## requested document was successfully retrieved--you might have just
## downloaded the "404 not found" stub (for instance) that a server would
## provide in response to some error condition.  You should also check
## is_valid() to prove that the file you expected has been successfully
## retrieved.

proc get_class_type*(_: typedesc[HTTPChannel]): TypeHandle {.importcpp: "HTTPChannel::get_class_type()", header: "hTTPChannel.h".}

proc newHTTPChannel*(param0: HTTPChannel): HTTPChannel {.importcpp: "new HTTPChannel(#)".}

proc initDecompressor*(): Decompressor {.importcpp: "Decompressor()".}

proc initDecompressor*(param0: Decompressor): Decompressor {.importcpp: "Decompressor(#)".}

proc initiate*(this: Decompressor, source_file: Filename): int {.importcpp: "#.initiate(#)".} ## \
## Begins a background decompression of the named file (whose filename must
## end in ".pz") to a new file without the .pz extension.  The source file is
## removed after successful completion.

proc initiate*(this: Decompressor, source_file: Filename, dest_file: Filename): int {.importcpp: "#.initiate(#, #)".} ## \
## Begins a background decompression from the named source file to the named
## destination file.  The source file is removed after successful completion.

proc run*(this: Decompressor): int {.importcpp: "#.run()".} ## \
## Called each frame to do the next bit of work in the background task.
## Returns EU_ok if a chunk is completed but there is more to go, or
## EU_success when we're all done.  Any other return value indicates an error.

proc decompress*(this: Decompressor, source_file: Filename): bool {.importcpp: "#.decompress(#)".} ## \
## Performs a foreground decompression of the named file; does not return
## until the decompression is complete.

proc decompress*(this: Decompressor, source_and_dest_file: Ramfile): bool {.importcpp: "#.decompress(#)".} ## \
## Does an in-memory decompression of the indicated Ramfile.  The decompressed
## contents are written back into the same Ramfile on completion.

proc get_progress*(this: Decompressor): float32 {.importcpp: "#.get_progress()".} ## \
## Returns the ratio through the decompression step in the background.

proc initDownloadDb*(): DownloadDb {.importcpp: "DownloadDb()".} ## \
## Primarily used for testing.

proc initDownloadDb*(param0: DownloadDb): DownloadDb {.importcpp: "DownloadDb(#)".}

proc initDownloadDb*(server_file: Filename, client_file: Filename): DownloadDb {.importcpp: "DownloadDb(#, #)".} ## \
## Create a download db with these client and server dbs

proc initDownloadDb*(server_file: Ramfile, client_file: Filename): DownloadDb {.importcpp: "DownloadDb(#, #)".} ## \
## Create a download db with these client and server dbs

proc output*(this: DownloadDb, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: DownloadDb, `out`: ostream) {.importcpp: "#.write(#)".}

proc write_version_map*(this: DownloadDb, `out`: ostream) {.importcpp: "#.write_version_map(#)".}

proc write_client_db*(this: DownloadDb, file: Filename): bool {.importcpp: "#.write_client_db(#)".} ## \
## Write a database file

proc write_server_db*(this: DownloadDb, file: Filename): bool {.importcpp: "#.write_server_db(#)".}

proc get_client_num_multifiles*(this: DownloadDb): int {.importcpp: "#.get_client_num_multifiles()".}

proc get_server_num_multifiles*(this: DownloadDb): int {.importcpp: "#.get_server_num_multifiles()".}

proc get_client_multifile_name*(this: DownloadDb, index: int): string {.importcpp: "nimStringFromStdString(#.get_client_multifile_name(#))", header: stringConversionCode.}

proc get_server_multifile_name*(this: DownloadDb, index: int): string {.importcpp: "nimStringFromStdString(#.get_server_multifile_name(#))", header: stringConversionCode.}

proc get_client_multifile_size*(this: DownloadDb, mfname: string): int {.importcpp: "#.get_client_multifile_size(nimStringToStdString(#))", header: stringConversionCode.}

proc set_client_multifile_size*(this: DownloadDb, mfname: string, size: int) {.importcpp: "#.set_client_multifile_size(nimStringToStdString(#), #)", header: stringConversionCode.}

proc set_client_multifile_delta_size*(this: DownloadDb, mfname: string, size: int): int {.importcpp: "#.set_client_multifile_delta_size(nimStringToStdString(#), #)", header: stringConversionCode.}

proc get_server_multifile_size*(this: DownloadDb, mfname: string): int {.importcpp: "#.get_server_multifile_size(nimStringToStdString(#))", header: stringConversionCode.}

proc set_server_multifile_size*(this: DownloadDb, mfname: string, size: int) {.importcpp: "#.set_server_multifile_size(nimStringToStdString(#), #)", header: stringConversionCode.}

proc get_client_multifile_phase*(this: DownloadDb, mfname: string): float32 {.importcpp: "#.get_client_multifile_phase(nimStringToStdString(#))", header: stringConversionCode.}

proc get_server_multifile_phase*(this: DownloadDb, mfname: string): float32 {.importcpp: "#.get_server_multifile_phase(nimStringToStdString(#))", header: stringConversionCode.}

proc set_client_multifile_incomplete*(this: DownloadDb, mfname: string) {.importcpp: "#.set_client_multifile_incomplete(nimStringToStdString(#))", header: stringConversionCode.}

proc set_client_multifile_complete*(this: DownloadDb, mfname: string) {.importcpp: "#.set_client_multifile_complete(nimStringToStdString(#))", header: stringConversionCode.}

proc set_client_multifile_decompressed*(this: DownloadDb, mfname: string) {.importcpp: "#.set_client_multifile_decompressed(nimStringToStdString(#))", header: stringConversionCode.}

proc set_client_multifile_extracted*(this: DownloadDb, mfname: string) {.importcpp: "#.set_client_multifile_extracted(nimStringToStdString(#))", header: stringConversionCode.}

proc get_server_num_files*(this: DownloadDb, mfname: string): int {.importcpp: "#.get_server_num_files(nimStringToStdString(#))", header: stringConversionCode.}

proc get_server_file_name*(this: DownloadDb, mfname: string, index: int): string {.importcpp: "nimStringFromStdString(#.get_server_file_name(nimStringToStdString(#), #))", header: stringConversionCode.}

proc client_multifile_exists*(this: DownloadDb, mfname: string): bool {.importcpp: "#.client_multifile_exists(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Queries from the Launcher

proc client_multifile_complete*(this: DownloadDb, mfname: string): bool {.importcpp: "#.client_multifile_complete(nimStringToStdString(#))", header: stringConversionCode.} ## \
## A multifile is complete when it is completely downloaded.  Note: it may
## already be decompressed or extracted and it is still complete

proc client_multifile_decompressed*(this: DownloadDb, mfname: string): bool {.importcpp: "#.client_multifile_decompressed(nimStringToStdString(#))", header: stringConversionCode.}

proc client_multifile_extracted*(this: DownloadDb, mfname: string): bool {.importcpp: "#.client_multifile_extracted(nimStringToStdString(#))", header: stringConversionCode.}

proc get_client_multifile_hash*(this: DownloadDb, mfname: string): HashVal {.importcpp: "#.get_client_multifile_hash(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Return the hash value of the file we are working on

proc set_client_multifile_hash*(this: DownloadDb, mfname: string, val: HashVal) {.importcpp: "#.set_client_multifile_hash(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Set the hash value of file we are working on

proc get_server_multifile_hash*(this: DownloadDb, mfname: string): HashVal {.importcpp: "#.get_server_multifile_hash(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Return the hash value of the server file

proc set_server_multifile_hash*(this: DownloadDb, mfname: string, val: HashVal) {.importcpp: "#.set_server_multifile_hash(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Set the hash value of file we are working on

proc delete_client_multifile*(this: DownloadDb, mfname: string) {.importcpp: "#.delete_client_multifile(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Operations on multifiles

proc add_client_multifile*(this: DownloadDb, server_mfname: string) {.importcpp: "#.add_client_multifile(nimStringToStdString(#))", header: stringConversionCode.}

proc expand_client_multifile*(this: DownloadDb, mfname: string) {.importcpp: "#.expand_client_multifile(nimStringToStdString(#))", header: stringConversionCode.}

proc create_new_server_db*(this: DownloadDb) {.importcpp: "#.create_new_server_db()".} ## \
## Used on the server side makefiles to create a new clean server db

proc server_add_multifile*(this: DownloadDb, mfname: string, phase: float32, size: int, status: int) {.importcpp: "#.server_add_multifile(nimStringToStdString(#), #, #, #)", header: stringConversionCode.}

proc server_add_file*(this: DownloadDb, mfname: string, fname: string) {.importcpp: "#.server_add_file(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc add_version*(this: DownloadDb, name: Filename, hash: HashVal, version: int) {.importcpp: "#.add_version(#, #, #)".} ## \
## Appends a new version of the file onto the end of the list, or changes the
## hash associated with a version previously added.
##
## Note: version numbers start at 1

proc insert_new_version*(this: DownloadDb, name: Filename, hash: HashVal) {.importcpp: "#.insert_new_version(#, #)".} ## \
## Inserts a new version 1 copy of the file, sliding all the other versions up
## by one.

proc has_version*(this: DownloadDb, name: Filename): bool {.importcpp: "#.has_version(#)".} ## \
## Returns true if the indicated file has version information, false
## otherwise.  Some files recorded in the database may not bother to track
## versions.

proc get_num_versions*(this: DownloadDb, name: Filename): int {.importcpp: "#.get_num_versions(#)".} ## \
## Returns the number of versions stored for the indicated file.

proc set_num_versions*(this: DownloadDb, name: Filename, num_versions: int) {.importcpp: "#.set_num_versions(#, #)".} ## \
## Reduces the number of versions of a particular file stored in the ddb by
## throwing away all versions higher than the indicated index.

proc get_version*(this: DownloadDb, name: Filename, hash: HashVal): int {.importcpp: "#.get_version(#, #)".} ## \
## Returns the version number of this particular file, determined by looking
## up the hash generated from the file.  Returns -1 if the version number
## cannot be determined.

proc get_hash*(this: DownloadDb, name: Filename, version: int): HashVal {.importcpp: "#.get_hash(#, #)".} ## \
## Returns the MD5 hash associated with the indicated version of the indicated
## file.

proc check_crc*(name: Filename): int {.importcpp: "check_crc(#)".}

proc check_adler*(name: Filename): int {.importcpp: "check_adler(#)".}

proc initExtractor*(): Extractor {.importcpp: "Extractor()".}

proc set_multifile*(this: Extractor, multifile_name: Filename): bool {.importcpp: "#.set_multifile(#)".} ## \
## Specifies the filename of the Multifile that the Extractor will read.
## Returns true on success, false if the mulifile name is invalid.

proc set_extract_dir*(this: Extractor, extract_dir: Filename) {.importcpp: "#.set_extract_dir(#)".} ## \
## Specifies the directory into which all extracted subfiles will be written.
## Relative paths of subfiles within the Multifile will be written as relative
## paths to this directory.

proc reset*(this: Extractor) {.importcpp: "#.reset()".} ## \
## Interrupts the Extractor in the middle of its business and makes it ready
## to accept a new list of subfiles to extract.

proc request_subfile*(this: Extractor, subfile_name: Filename): bool {.importcpp: "#.request_subfile(#)".} ## \
## Requests a particular subfile to be extracted when step() or run() is
## called.  Returns true if the subfile exists, false otherwise.

proc request_all_subfiles*(this: Extractor): int {.importcpp: "#.request_all_subfiles()".} ## \
## Requests all subfiles in the Multifile to be extracted.  Returns the number
## requested.

proc step*(this: Extractor): int {.importcpp: "#.step()".} ## \
## After all of the requests have been made via request_file() or
## request_all_subfiles(), call step() repeatedly until it stops returning
## EU_ok.
##
## step() extracts the next small unit of data from the Multifile.  Returns
## EU_ok if progress is continuing, EU_error_abort if there is a problem, or
## EU_success when the last piece has been extracted.
##
## Also see run().

proc get_progress*(this: Extractor): float32 {.importcpp: "#.get_progress()".} ## \
## Returns the fraction of the Multifile extracted so far.

proc run*(this: Extractor): bool {.importcpp: "#.run()".} ## \
## A convenience function to extract the Multifile all at once, when you don't
## care about doing it in the background.
##
## First, call request_file() or request_all_files() to specify the files you
## would like to extract, then call run() to do the extraction.  Also see
## step() for when you would like the extraction to happen as a background
## task.

proc initMultiplexStream*(): MultiplexStream {.importcpp: "MultiplexStream()".}

proc add_ostream*(this: MultiplexStream, `out`: ostream, delete_later: bool) {.importcpp: "#.add_ostream(#, #)".} ## \
## Adds the indicated generic ostream to the multiplex output.  The ostream
## will receive whatever data is sent to the pipe.

proc add_ostream*(this: MultiplexStream, `out`: ostream) {.importcpp: "#.add_ostream(#)".} ## \
## Adds the indicated generic ostream to the multiplex output.  The ostream
## will receive whatever data is sent to the pipe.

proc add_standard_output*(this: MultiplexStream) {.importcpp: "#.add_standard_output()".} ## \
## Adds the standard output channel.

proc add_file*(this: MultiplexStream, file: Filename): bool {.importcpp: "#.add_file(#)".} ## \
## Adds the given file to the multiplex output.  The file is opened in append
## mode with line buffering.  Returns false if the file cannot be opened.

proc add_system_debug*(this: MultiplexStream) {.importcpp: "#.add_system_debug()".} ## \
## Adds the system debug output the the multiplex output.  This may map to a
## syslog or some such os-specific output system.  It may do nothing on a
## particular system.
##
## Presently, this maps only to OutputDebugString() on Windows.

proc flush*(this: MultiplexStream) {.importcpp: "#.flush()".} ## \
## Forces out all output that hasn't yet been written.

proc get_class_type*(_: typedesc[VirtualFileHTTP]): TypeHandle {.importcpp: "VirtualFileHTTP::get_class_type()", header: "virtualFileHTTP.h".}

proc newVirtualFileMountHTTP*(root: URLSpec, http: HTTPClient): VirtualFileMountHTTP {.importcpp: "new VirtualFileMountHTTP(#, #)".}

proc newVirtualFileMountHTTP*(root: URLSpec): VirtualFileMountHTTP {.importcpp: "new VirtualFileMountHTTP(#)".}

proc get_http_client*(this: VirtualFileMountHTTP): HTTPClient {.importcpp: "#->get_http_client()".} ## \
## Returns the HTTPClient object that services this mount point.

proc get_root*(this: VirtualFileMountHTTP): URLSpec {.importcpp: "#->get_root()".} ## \
## Returns the URL that represents the root of this mount point.

proc reload_vfs_mount_url*(_: typedesc[VirtualFileMountHTTP]) {.importcpp: "VirtualFileMountHTTP::reload_vfs_mount_url()", header: "virtualFileMountHTTP.h".} ## \
## Reads all of the vfs-mount-url lines in the Config.prc file and replaces
## the mount settings to match them.
##
## This will mount any url's mentioned in the config file, and unmount and
## unmount any url's no longer mentioned in the config file.  Normally, it is
## called automatically at startup, and need not be called again, unless you
## have fiddled with some config settings.

proc get_class_type*(_: typedesc[VirtualFileMountHTTP]): TypeHandle {.importcpp: "VirtualFileMountHTTP::get_class_type()", header: "virtualFileMountHTTP.h".}

proc initPatcher*(): Patcher {.importcpp: "Patcher()".}

proc initPatcher*(param0: Patcher): Patcher {.importcpp: "Patcher(#)".}

proc initPatcher*(buffer: Buffer): Patcher {.importcpp: "Patcher(#)".}

proc initiate*(this: Patcher, patch: Filename, infile: Filename): int {.importcpp: "#.initiate(#, #)".}

proc run*(this: Patcher): int {.importcpp: "#.run()".}

proc get_progress*(this: Patcher): float32 {.importcpp: "#.get_progress()".}

proc initStringStream*(): StringStream {.importcpp: "StringStream()".}

proc clear_data*(this: StringStream) {.importcpp: "#.clear_data()".} ## \
## Empties the buffer.

proc get_data_size*(this: StringStream): clonglong {.importcpp: "#.get_data_size()".} ## \
## Returns the number of characters available to be read from the data stream.

proc is_null*(this: PointerToVoid): bool {.importcpp: "#.is_null()".} ## \
## Returns true if the PointerTo is a NULL pointer, false otherwise.  (Direct
## comparison to a NULL pointer also works.)

proc get_hash*(this: PointerToVoid): clonglong {.importcpp: "#.get_hash()".}

proc is_tracking*(_: typedesc[MemoryUsage]): bool {.importcpp: "MemoryUsage::is_tracking()", header: "memoryUsage.h".} ## \
## Returns true if the MemoryUsage object is currently tracking memory (e.g.
## track-memory-usage is configured #t).

proc is_counting*(_: typedesc[MemoryUsage]): bool {.importcpp: "MemoryUsage::is_counting()", header: "memoryUsage.h".} ## \
## Returns true if the MemoryUsage object is currently at least counting
## memory (e.g.  this is a Windows debug build), even if it's not fully
## tracking it.

proc get_current_cpp_size*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_current_cpp_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes of allocated memory consumed by C++
## objects, not including the memory previously frozen.

proc get_total_cpp_size*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_total_cpp_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes of allocated memory consumed by C++
## objects, including the memory previously frozen.

proc get_panda_heap_single_size*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_panda_heap_single_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes allocated from the heap from code within
## Panda, for individual objects.

proc get_panda_heap_array_size*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_panda_heap_array_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes allocated from the heap from code within
## Panda, for arrays.

proc get_panda_heap_overhead*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_panda_heap_overhead()", header: "memoryUsage.h".} ## \
## Returns the extra bytes allocated from the system that are not immediately
## used for holding allocated objects.  This can only be determined if
## ALTERNATIVE_MALLOC is enabled.

proc get_panda_mmap_size*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_panda_mmap_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes allocated from the virtual memory pool
## from code within Panda.

proc get_external_size*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_external_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes of allocated memory in the heap that
## Panda didn't seem to be responsible for.  This includes a few bytes for
## very low-level objects (like ConfigVariables) that cannot use Panda memory
## tracking because they are so very low-level.
##
## This also includes all of the memory that might have been allocated by a
## high-level interpreter, like Python.
##
## This number is only available if Panda is able to hook into the actual heap
## callback.

proc get_total_size*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_total_size()", header: "memoryUsage.h".} ## \
## Returns the total size of allocated memory consumed by the process, as
## nearly as can be determined.

proc get_num_pointers*(_: typedesc[MemoryUsage]): int {.importcpp: "MemoryUsage::get_num_pointers()", header: "memoryUsage.h".} ## \
## Returns the number of pointers currently active.

proc get_pointers*(_: typedesc[MemoryUsage], result: MemoryUsagePointers) {.importcpp: "MemoryUsage::get_pointers(#)", header: "memoryUsage.h".} ## \
## Fills the indicated MemoryUsagePointers with the set of all pointers
## currently active.

proc get_pointers_of_type*(_: typedesc[MemoryUsage], result: MemoryUsagePointers, `type`: TypeHandle) {.importcpp: "MemoryUsage::get_pointers_of_type(#, #)", header: "memoryUsage.h".} ## \
## Fills the indicated MemoryUsagePointers with the set of all pointers of the
## indicated type currently active.

proc get_pointers_of_age*(_: typedesc[MemoryUsage], result: MemoryUsagePointers, `from`: float64, to: float64) {.importcpp: "MemoryUsage::get_pointers_of_age(#, #, #)", header: "memoryUsage.h".} ## \
## Fills the indicated MemoryUsagePointers with the set of all pointers that
## were allocated within the range of the indicated number of seconds ago.

proc get_pointers_with_zero_count*(_: typedesc[MemoryUsage], result: MemoryUsagePointers) {.importcpp: "MemoryUsage::get_pointers_with_zero_count(#)", header: "memoryUsage.h".} ## \
## Fills the indicated MemoryUsagePointers with the set of all currently
## active pointers (that is, pointers allocated since the last call to
## freeze(), and not yet freed) that have a zero reference count.
##
## Generally, an undeleted pointer with a zero reference count means its
## reference count has never been incremented beyond zero (since once it has
## been incremented, the only way it can return to zero would free the
## pointer).  This may include objects that are allocated statically or on the
## stack, which are never intended to be deleted.  Or, it might represent a
## programmer or compiler error.
##
## This function has the side-effect of incrementing each of their reference
## counts by one, thus preventing them from ever being freed--but since they
## hadn't been freed anyway, probably no additional harm is done.

proc freeze*(_: typedesc[MemoryUsage]) {.importcpp: "MemoryUsage::freeze()", header: "memoryUsage.h".} ## \
## 'Freezes' all pointers currently stored so that they are no longer
## reported; only newly allocate pointers from this point on will appear in
## future information requests.  This makes it easier to differentiate between
## continuous leaks and one-time memory allocations.

proc show_current_types*(_: typedesc[MemoryUsage]) {.importcpp: "MemoryUsage::show_current_types()", header: "memoryUsage.h".} ## \
## Shows the breakdown of types of all of the active pointers.

proc show_trend_types*(_: typedesc[MemoryUsage]) {.importcpp: "MemoryUsage::show_trend_types()", header: "memoryUsage.h".} ## \
## Shows the breakdown of types of all of the pointers allocated and freed
## since the last call to freeze().

proc show_current_ages*(_: typedesc[MemoryUsage]) {.importcpp: "MemoryUsage::show_current_ages()", header: "memoryUsage.h".} ## \
## Shows the breakdown of ages of all of the active pointers.

proc show_trend_ages*(_: typedesc[MemoryUsage]) {.importcpp: "MemoryUsage::show_trend_ages()", header: "memoryUsage.h".} ## \
## Shows the breakdown of ages of all of the pointers allocated and freed
## since the last call to freeze().

proc initMemoryUsage*(param0: MemoryUsage): MemoryUsage {.importcpp: "MemoryUsage(#)".}

proc get_ref_count*(this: ReferenceCount): int {.importcpp: "#->get_ref_count()".} ## \
## Returns the current reference count.

proc unref*(this: ReferenceCount): bool {.importcpp: "#->unref()".} ## \
## Explicitly decrements the reference count.  Note that the object will not
## be implicitly deleted by unref() simply because the reference count drops
## to zero.  (Having a member function delete itself is problematic.) However,
## see the helper function unref_delete().
##
## User code should avoid using ref() and unref() directly, which can result
## in missed reference counts.  Instead, let a PointerTo object manage the
## reference counting automatically.
##
## This function is const, even though it changes the object, because
## generally fiddling with an object's reference count isn't considered part
## of fiddling with the object.  An object might be const in other ways, but
## we still need to accurately count the number of references to it.
##
## The return value is true if the new reference count is nonzero, false if it
## is zero.

proc test_ref_count_integrity*(this: ReferenceCount): bool {.importcpp: "#->test_ref_count_integrity()".} ## \
## Does some easy checks to make sure that the reference count isn't
## completely bogus.  Returns true if ok, false otherwise.

proc test_ref_count_nonzero*(this: ReferenceCount): bool {.importcpp: "#->test_ref_count_nonzero()".} ## \
## Does some easy checks to make sure that the reference count isn't zero, or
## completely bogus.  Returns true if ok, false otherwise.

proc get_class_type*(_: typedesc[ReferenceCount]): TypeHandle {.importcpp: "ReferenceCount::get_class_type()", header: "referenceCount.h".}

proc get_length*(this: Buffer): int {.importcpp: "#->get_length()".}

proc newBuffer*(param0: Buffer): Buffer {.importcpp: "new Buffer(#)".}

proc compress_string*(source: string, compression_level: int): string {.importcpp: "nimStringFromStdString(compress_string(nimStringToStdString(#), #))", header: stringConversionCode.}

proc decompress_string*(source: string): string {.importcpp: "nimStringFromStdString(decompress_string(nimStringToStdString(#)))", header: stringConversionCode.}

proc compress_file*(source: Filename, dest: Filename, compression_level: int): bool {.importcpp: "compress_file(#, #, #)".}

proc decompress_file*(source: Filename, dest: Filename): bool {.importcpp: "decompress_file(#, #)".}

proc compress_stream*(source: istream, dest: ostream, compression_level: int): bool {.importcpp: "compress_stream(#, #, #)".}

proc decompress_stream*(source: istream, dest: ostream): bool {.importcpp: "decompress_stream(#, #)".}

proc copy_stream*(source: istream, dest: ostream): bool {.importcpp: "copy_stream(#, #)".}

proc add_level*(this: PStatCollectorForwardBase, level: float64) {.importcpp: "#->add_level(#)".}

proc get_node_ref_count*(this: NodeReferenceCount): int {.importcpp: "#->get_node_ref_count()".} ## \
## Returns the current reference count.

proc node_ref*(this: NodeReferenceCount) {.importcpp: "#->node_ref()".} ## \
## Explicitly increments the node reference count and the normal reference
## count simultaneously.

proc node_unref*(this: NodeReferenceCount): bool {.importcpp: "#->node_unref()".} ## \
## Explicitly decrements the node reference count and the normal reference
## count simultaneously.
##
## The return value is true if the new reference count is nonzero, false if it
## is zero.

proc test_ref_count_integrity*(this: NodeReferenceCount): bool {.importcpp: "#->test_ref_count_integrity()".} ## \
## Does some easy checks to make sure that the reference count isn't
## completely bogus.

proc node_unref_only*(this: NodeReferenceCount) {.importcpp: "#->node_unref_only()".} ## \
## Decrements the node reference count without affecting the normal reference
## count.  Intended to be called by derived classes only, presumably to
## reimplement node_unref().

proc get_class_type*(_: typedesc[NodeReferenceCount]): TypeHandle {.importcpp: "NodeReferenceCount::get_class_type()", header: "nodeReferenceCount.h".}

proc initDatagram*(): Datagram {.importcpp: "Datagram()".}

proc initDatagram*(copy: Datagram): Datagram {.importcpp: "Datagram(#)".}

proc clear*(this: Datagram) {.importcpp: "#.clear()".} ## \
## Resets the datagram to empty, in preparation for building up a new
## datagram.

proc dump_hex*(this: Datagram, `out`: ostream, indent: int) {.importcpp: "#.dump_hex(#, #)".} ## \
## Writes a representation of the entire datagram contents, as a sequence of
## hex (and ASCII) values.

proc dump_hex*(this: Datagram, `out`: ostream) {.importcpp: "#.dump_hex(#)".} ## \
## Writes a representation of the entire datagram contents, as a sequence of
## hex (and ASCII) values.

proc add_bool*(this: Datagram, value: bool) {.importcpp: "#.add_bool(#)".} ## \
## Adds a boolean value to the datagram.

proc add_int8*(this: Datagram, value: char) {.importcpp: "#.add_int8(#)".} ## \
## Adds a signed 8-bit integer to the datagram.

proc add_uint8*(this: Datagram, value: char) {.importcpp: "#.add_uint8(#)".} ## \
## Adds an unsigned 8-bit integer to the datagram.

proc add_int16*(this: Datagram, value: int) {.importcpp: "#.add_int16(#)".} ## \
## Adds a signed 16-bit integer to the datagram.

proc add_int32*(this: Datagram, value: int) {.importcpp: "#.add_int32(#)".} ## \
## Adds a signed 32-bit integer to the datagram.

proc add_int64*(this: Datagram, value: clonglong) {.importcpp: "#.add_int64(#)".} ## \
## Adds a signed 64-bit integer to the datagram.

proc add_uint16*(this: Datagram, value: int) {.importcpp: "#.add_uint16(#)".} ## \
## Adds an unsigned 16-bit integer to the datagram.

proc add_uint32*(this: Datagram, value: int) {.importcpp: "#.add_uint32(#)".} ## \
## Adds an unsigned 32-bit integer to the datagram.

proc add_uint64*(this: Datagram, value: clonglong) {.importcpp: "#.add_uint64(#)".} ## \
## Adds an unsigned 64-bit integer to the datagram.

proc add_float32*(this: Datagram, value: float32) {.importcpp: "#.add_float32(#)".} ## \
## Adds a 32-bit single-precision floating-point number to the datagram.
## Since this kind of float is not necessarily portable across different
## architectures, special care is required.

proc add_float64*(this: Datagram, value: float64) {.importcpp: "#.add_float64(#)".} ## \
## Adds a 64-bit floating-point number to the datagram.

proc add_stdfloat*(this: Datagram, value: float32) {.importcpp: "#.add_stdfloat(#)".} ## \
## Adds either a 32-bit or a 64-bit floating-point number, according to
## set_stdfloat_double().

proc add_be_int16*(this: Datagram, value: int) {.importcpp: "#.add_be_int16(#)".} ## \
## These functions pack numbers big-endian, in case that's desired.

proc add_be_int32*(this: Datagram, value: int) {.importcpp: "#.add_be_int32(#)".} ## \
## Adds a signed 32-bit big-endian integer to the datagram.

proc add_be_int64*(this: Datagram, value: clonglong) {.importcpp: "#.add_be_int64(#)".} ## \
## Adds a signed 64-bit big-endian integer to the datagram.

proc add_be_uint16*(this: Datagram, value: int) {.importcpp: "#.add_be_uint16(#)".} ## \
## Adds an unsigned 16-bit big-endian integer to the datagram.

proc add_be_uint32*(this: Datagram, value: int) {.importcpp: "#.add_be_uint32(#)".} ## \
## Adds an unsigned 32-bit big-endian integer to the datagram.

proc add_be_uint64*(this: Datagram, value: clonglong) {.importcpp: "#.add_be_uint64(#)".} ## \
## Adds an unsigned 64-bit big-endian integer to the datagram.

proc add_be_float32*(this: Datagram, value: float32) {.importcpp: "#.add_be_float32(#)".} ## \
## Adds a 32-bit single-precision big-endian floating-point number to the
## datagram.

proc add_be_float64*(this: Datagram, value: float64) {.importcpp: "#.add_be_float64(#)".} ## \
## Adds a 64-bit big-endian floating-point number to the datagram.

proc add_string*(this: Datagram, str: string) {.importcpp: "#.add_string(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a variable-length string to the datagram.  This actually adds a count
## followed by n bytes.

proc add_string32*(this: Datagram, str: string) {.importcpp: "#.add_string32(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a variable-length string to the datagram, using a 32-bit length field
## to allow very long strings.

proc add_z_string*(this: Datagram, str: string) {.importcpp: "#.add_z_string(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a variable-length string to the datagram, as a NULL-terminated string.

proc add_fixed_string*(this: Datagram, str: string, size: clonglong) {.importcpp: "#.add_fixed_string(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Adds a fixed-length string to the datagram.  If the string given is less
## than the requested size, this will pad the string out with zeroes; if it is
## greater than the requested size, this will silently truncate the string.

proc add_wstring*(this: Datagram, str: string) {.importcpp: "#.add_wstring(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a variable-length wstring to the datagram.

proc pad_bytes*(this: Datagram, size: clonglong) {.importcpp: "#.pad_bytes(#)".} ## \
## Adds the indicated number of zero bytes to the datagram.

proc get_length*(this: Datagram): clonglong {.importcpp: "#.get_length()".} ## \
## Returns the number of bytes in the datagram.

proc set_stdfloat_double*(this: Datagram, stdfloat_double: bool) {.importcpp: "#.set_stdfloat_double(#)".} ## \
## Changes the stdfloat_double flag, which defines the operation performed by
## add_stdfloat() and DatagramIterator::get_stdfloat().  When this is true,
## add_stdfloat() adds a 64-bit floating-point number; when it is false, it
## adds a 32-bit floating-point number.  The default is based on the
## STDFLOAT_DOUBLE compilation flag.

proc get_stdfloat_double*(this: Datagram): bool {.importcpp: "#.get_stdfloat_double()".} ## \
## Returns the stdfloat_double flag.  See set_stdfloat_double().

proc `==`*(this: Datagram, other: Datagram): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: Datagram, other: Datagram): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: Datagram, other: Datagram): bool {.importcpp: "#.operator <(#)".}

proc output*(this: Datagram, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Write a string representation of this instance to <out>.

proc write*(this: Datagram, `out`: ostream, indent: int) {.importcpp: "#.write(#, #)".} ## \
## Write a string representation of this instance to <out>.

proc write*(this: Datagram, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Write a string representation of this instance to <out>.

proc get_class_type*(_: typedesc[Datagram]): TypeHandle {.importcpp: "Datagram::get_class_type()", header: "datagram.h".}

proc get_datagram*(this: DatagramGenerator, data: Datagram): bool {.importcpp: "#.get_datagram(#)".}

proc save_datagram*(this: DatagramGenerator, info: SubfileInfo): bool {.importcpp: "#.save_datagram(#)".} ## \
## Skips over the next datagram without extracting it, but saves the relevant
## file information in the SubfileInfo object so that its data may be read
## later.  For non-file-based datagram generators, this may mean creating a
## temporary file and copying the contents of the datagram to disk.
##
## Returns true on success, false on failure or if this method is
## unimplemented.

proc is_eof*(this: DatagramGenerator): bool {.importcpp: "#.is_eof()".}

proc is_error*(this: DatagramGenerator): bool {.importcpp: "#.is_error()".}

proc get_filename*(this: DatagramGenerator): Filename {.importcpp: "#.get_filename()".} ## \
## Returns the filename that provides the source for these datagrams, if any,
## or empty string if the datagrams do not originate from a file on disk.

proc get_timestamp*(this: DatagramGenerator): int {.importcpp: "#.get_timestamp()".} ## \
## Returns the on-disk timestamp of the file that was read, at the time it was
## opened, if that is available, or 0 if it is not.

proc get_file*(this: DatagramGenerator): FileReference {.importcpp: "#.get_file()".} ## \
## Returns the FileReference that provides the source for these datagrams, if
## any, or NULL if the datagrams do not originate from a file on disk.

proc get_vfile*(this: DatagramGenerator): VirtualFile {.importcpp: "#.get_vfile()".} ## \
## Returns the VirtualFile that provides the source for these datagrams, if
## any, or NULL if the datagrams do not originate from a VirtualFile.

proc get_file_pos*(this: DatagramGenerator): clonglong {.importcpp: "#.get_file_pos()".} ## \
## Returns the current file position within the data stream, if any, or 0 if
## the file position is not meaningful or cannot be determined.
##
## For DatagramGenerators that return a meaningful file position, this will be
## pointing to the first byte following the datagram returned after a call to
## get_datagram().

proc initDatagramIterator*(): DatagramIterator {.importcpp: "DatagramIterator()".}

proc initDatagramIterator*(datagram: Datagram, offset: clonglong): DatagramIterator {.importcpp: "DatagramIterator(#, #)".}

proc initDatagramIterator*(datagram: Datagram): DatagramIterator {.importcpp: "DatagramIterator(#)".}

proc initDatagramIterator*(param0: DatagramIterator): DatagramIterator {.importcpp: "DatagramIterator(#)".}

proc get_bool*(this: DatagramIterator): bool {.importcpp: "#.get_bool()".} ## \
## Extracts a boolean value.

proc get_int8*(this: DatagramIterator): char {.importcpp: "#.get_int8()".} ## \
## Extracts a signed 8-bit integer.

proc get_uint8*(this: DatagramIterator): char {.importcpp: "#.get_uint8()".} ## \
## Extracts an unsigned 8-bit integer.

proc get_int16*(this: DatagramIterator): int {.importcpp: "#.get_int16()".} ## \
## Extracts a signed 16-bit integer.

proc get_int32*(this: DatagramIterator): int {.importcpp: "#.get_int32()".} ## \
## Extracts a signed 32-bit integer.

proc get_int64*(this: DatagramIterator): clonglong {.importcpp: "#.get_int64()".} ## \
## Extracts a signed 64-bit integer.

proc get_uint16*(this: DatagramIterator): int {.importcpp: "#.get_uint16()".} ## \
## Extracts an unsigned 16-bit integer.

proc get_uint32*(this: DatagramIterator): int {.importcpp: "#.get_uint32()".} ## \
## Extracts an unsigned 32-bit integer.

proc get_uint64*(this: DatagramIterator): clonglong {.importcpp: "#.get_uint64()".} ## \
## Extracts an unsigned 64-bit integer.

proc get_float32*(this: DatagramIterator): float32 {.importcpp: "#.get_float32()".} ## \
## Extracts a 32-bit single-precision floating-point number.

proc get_float64*(this: DatagramIterator): float64 {.importcpp: "#.get_float64()".} ## \
## Extracts a 64-bit floating-point number.

proc get_stdfloat*(this: DatagramIterator): float32 {.importcpp: "#.get_stdfloat()".} ## \
## Extracts either a 32-bit or a 64-bit floating-point number, according to
## Datagram::set_stdfloat_double().

proc get_be_int16*(this: DatagramIterator): int {.importcpp: "#.get_be_int16()".} ## \
## Extracts a signed 16-bit big-endian integer.

proc get_be_int32*(this: DatagramIterator): int {.importcpp: "#.get_be_int32()".} ## \
## Extracts a signed 32-bit big-endian integer.

proc get_be_int64*(this: DatagramIterator): clonglong {.importcpp: "#.get_be_int64()".} ## \
## Extracts a signed 64-bit big-endian integer.

proc get_be_uint16*(this: DatagramIterator): int {.importcpp: "#.get_be_uint16()".} ## \
## Extracts an unsigned 16-bit big-endian integer.

proc get_be_uint32*(this: DatagramIterator): int {.importcpp: "#.get_be_uint32()".} ## \
## Extracts an unsigned 32-bit big-endian integer.

proc get_be_uint64*(this: DatagramIterator): clonglong {.importcpp: "#.get_be_uint64()".} ## \
## Extracts an unsigned 64-bit big-endian integer.

proc get_be_float32*(this: DatagramIterator): float32 {.importcpp: "#.get_be_float32()".} ## \
## Extracts a 32-bit big-endian single-precision floating-point number.

proc get_be_float64*(this: DatagramIterator): float64 {.importcpp: "#.get_be_float64()".} ## \
## Extracts a 64-bit big-endian floating-point number.

proc get_string*(this: DatagramIterator): string {.importcpp: "nimStringFromStdString(#.get_string())", header: stringConversionCode.} ## \
## Extracts a variable-length string.

proc get_string32*(this: DatagramIterator): string {.importcpp: "nimStringFromStdString(#.get_string32())", header: stringConversionCode.} ## \
## Extracts a variable-length string with a 32-bit length field.

proc get_z_string*(this: DatagramIterator): string {.importcpp: "nimStringFromStdString(#.get_z_string())", header: stringConversionCode.} ## \
## Extracts a variable-length string, as a NULL-terminated string.

proc get_fixed_string*(this: DatagramIterator, size: clonglong): string {.importcpp: "nimStringFromStdString(#.get_fixed_string(#))", header: stringConversionCode.} ## \
## Extracts a fixed-length string.  However, if a zero byte occurs within the
## string, it marks the end of the string.

proc get_wstring*(this: DatagramIterator): string {.importcpp: "nimStringFromStdString(#.get_wstring())", header: stringConversionCode.} ## \
## Extracts a variable-length wstring (with a 32-bit length field).

proc skip_bytes*(this: DatagramIterator, size: clonglong) {.importcpp: "#.skip_bytes(#)".} ## \
## Skips over the indicated number of bytes in the datagram.

proc get_remaining_size*(this: DatagramIterator): clonglong {.importcpp: "#.get_remaining_size()".} ## \
## Return the bytes left in the datagram.

proc get_datagram*(this: DatagramIterator): Datagram {.importcpp: "#.get_datagram()".} ## \
## Return the datagram of this iterator.

proc get_current_index*(this: DatagramIterator): clonglong {.importcpp: "#.get_current_index()".} ## \
## Returns the current position within the datagram of the next piece of data
## to extract.

proc output*(this: DatagramIterator, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Write a string representation of this instance to <out>.

proc write*(this: DatagramIterator, `out`: ostream, indent: int) {.importcpp: "#.write(#, #)".} ## \
## Write a string representation of this instance to <out>.

proc write*(this: DatagramIterator, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Write a string representation of this instance to <out>.

proc get_class_type*(_: typedesc[DatagramIterator]): TypeHandle {.importcpp: "DatagramIterator::get_class_type()", header: "datagramIterator.h".}

proc put_datagram*(this: DatagramSink, data: Datagram): bool {.importcpp: "#.put_datagram(#)".}

proc copy_datagram*(this: DatagramSink, result: SubfileInfo, filename: Filename): bool {.importcpp: "#.copy_datagram(#, #)".} ## \
## Copies the file data from the entire indicated file (via the vfs) as the
## next datagram.  This is intended to support potentially very large
## datagrams.
##
## Returns true on success, false on failure or if this method is
## unimplemented.  On true, fills "result" with the information that
## references the copied file, if possible.

proc copy_datagram*(this: DatagramSink, result: SubfileInfo, source: SubfileInfo): bool {.importcpp: "#.copy_datagram(#, #)".} ## \
## Copies the file data from the range of the indicated file (outside of the
## vfs) as the next datagram.  This is intended to support potentially very
## large datagrams.
##
## Returns true on success, false on failure or if this method is
## unimplemented.  On true, fills "result" with the information that
## references the copied file, if possible.

proc is_error*(this: DatagramSink): bool {.importcpp: "#.is_error()".}

proc flush*(this: DatagramSink) {.importcpp: "#.flush()".}

proc get_filename*(this: DatagramSink): Filename {.importcpp: "#.get_filename()".} ## \
## Returns the filename that provides the target for these datagrams, if any,
## or empty string if the datagrams do not get written to a file on disk.

proc get_file*(this: DatagramSink): FileReference {.importcpp: "#.get_file()".} ## \
## Returns the FileReference that provides the target for these datagrams, if
## any, or NULL if the datagrams do not written to a file on disk.

proc get_file_pos*(this: DatagramSink): clonglong {.importcpp: "#.get_file_pos()".} ## \
## Returns the current file position within the data stream, if any, or 0 if
## the file position is not meaningful or cannot be determined.
##
## For DatagramSinks that return a meaningful file position, this will be
## pointing to the first byte following the datagram returned after a call to
## put_datagram().

converter upcast_to_TypedObject*(this: TypedReferenceCount): TypedObject {.importcpp: "((TypedObject *)(#.p()))".}

converter upcast_to_ReferenceCount*(this: TypedReferenceCount): ReferenceCount {.importcpp: "(PT(ReferenceCount)(#))".}

proc get_class_type*(_: typedesc[TypedReferenceCount]): TypeHandle {.importcpp: "TypedReferenceCount::get_class_type()", header: "typedReferenceCount.h".}

proc newFileReference*(param0: FileReference): FileReference {.importcpp: "new FileReference(#)".}

proc newFileReference*(filename: Filename): FileReference {.importcpp: "new FileReference(#)".}

proc get_filename*(this: FileReference): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the filename of the reference.

proc get_class_type*(_: typedesc[FileReference]): TypeHandle {.importcpp: "FileReference::get_class_type()", header: "fileReference.h".}

proc encrypt_string*(source: string, password: string, algorithm: string, key_length: int, iteration_count: int): string {.importcpp: "nimStringFromStdString(encrypt_string(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#), #, #))", header: stringConversionCode.}

proc encrypt_string*(source: string, password: string, algorithm: string, key_length: int): string {.importcpp: "nimStringFromStdString(encrypt_string(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#), #))", header: stringConversionCode.}

proc encrypt_string*(source: string, password: string, algorithm: string): string {.importcpp: "nimStringFromStdString(encrypt_string(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#)))", header: stringConversionCode.}

proc encrypt_string*(source: string, password: string): string {.importcpp: "nimStringFromStdString(encrypt_string(nimStringToStdString(#), nimStringToStdString(#)))", header: stringConversionCode.}

proc decrypt_string*(source: string, password: string): string {.importcpp: "nimStringFromStdString(decrypt_string(nimStringToStdString(#), nimStringToStdString(#)))", header: stringConversionCode.}

proc encrypt_file*(source: Filename, dest: Filename, password: string, algorithm: string, key_length: int, iteration_count: int): bool {.importcpp: "encrypt_file(#, #, nimStringToStdString(#), nimStringToStdString(#), #, #)", header: stringConversionCode.}

proc encrypt_file*(source: Filename, dest: Filename, password: string, algorithm: string, key_length: int): bool {.importcpp: "encrypt_file(#, #, nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc encrypt_file*(source: Filename, dest: Filename, password: string, algorithm: string): bool {.importcpp: "encrypt_file(#, #, nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc encrypt_file*(source: Filename, dest: Filename, password: string): bool {.importcpp: "encrypt_file(#, #, nimStringToStdString(#))", header: stringConversionCode.}

proc decrypt_file*(source: Filename, dest: Filename, password: string): bool {.importcpp: "decrypt_file(#, #, nimStringToStdString(#))", header: stringConversionCode.}

proc encrypt_stream*(source: istream, dest: ostream, password: string, algorithm: string, key_length: int, iteration_count: int): bool {.importcpp: "encrypt_stream(#, #, nimStringToStdString(#), nimStringToStdString(#), #, #)", header: stringConversionCode.}

proc encrypt_stream*(source: istream, dest: ostream, password: string, algorithm: string, key_length: int): bool {.importcpp: "encrypt_stream(#, #, nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc encrypt_stream*(source: istream, dest: ostream, password: string, algorithm: string): bool {.importcpp: "encrypt_stream(#, #, nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc encrypt_stream*(source: istream, dest: ostream, password: string): bool {.importcpp: "encrypt_stream(#, #, nimStringToStdString(#))", header: stringConversionCode.}

proc decrypt_stream*(source: istream, dest: ostream, password: string): bool {.importcpp: "decrypt_stream(#, #, nimStringToStdString(#))", header: stringConversionCode.}

proc error_to_text*(err: ErrorUtilCode): string {.importcpp: "nimStringFromStdString(error_to_text(#))", header: stringConversionCode.}

proc get_write_error*(): int {.importcpp: "get_write_error()".}

proc handle_socket_error*(): string {.importcpp: "nimStringFromStdString(handle_socket_error())", header: stringConversionCode.}

proc get_network_error*(): int {.importcpp: "get_network_error()".}

proc initRamfile*(): Ramfile {.importcpp: "Ramfile()".}

proc initRamfile*(param0: Ramfile): Ramfile {.importcpp: "Ramfile(#)".}

proc seek*(this: Ramfile, pos: clonglong) {.importcpp: "#.seek(#)".} ## \
## Moves the data pointer to the indicated byte position.  It is not an error
## to move the pointer past the end of data.

proc tell*(this: Ramfile): clonglong {.importcpp: "#.tell()".} ## \
## Returns the current data pointer position as a byte offset from the
## beginning of the stream.

proc get_data_size*(this: Ramfile): clonglong {.importcpp: "#.get_data_size()".} ## \
## Returns the size of the entire buffer contents.

proc clear*(this: Ramfile) {.importcpp: "#.clear()".} ## \
## Empties the current buffer contents.

proc initHashVal*(): HashVal {.importcpp: "HashVal()".}

proc initHashVal*(copy: HashVal): HashVal {.importcpp: "HashVal(#)".}

proc `==`*(this: HashVal, other: HashVal): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: HashVal, other: HashVal): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: HashVal, other: HashVal): bool {.importcpp: "#.operator <(#)".}

proc compare_to*(this: HashVal, other: HashVal): int {.importcpp: "#.compare_to(#)".}

proc merge_with*(this: HashVal, other: HashVal) {.importcpp: "#.merge_with(#)".} ## \
## Generates a new HashVal representing the xor of this one and the other one.

proc output_dec*(this: HashVal, `out`: ostream) {.importcpp: "#.output_dec(#)".} ## \
## Outputs the HashVal as four unsigned decimal integers.

proc input_dec*(this: HashVal, `in`: istream) {.importcpp: "#.input_dec(#)".} ## \
## Inputs the HashVal as four unsigned decimal integers.

proc output_hex*(this: HashVal, `out`: ostream) {.importcpp: "#.output_hex(#)".} ## \
## Outputs the HashVal as a 32-digit hexadecimal number.

proc input_hex*(this: HashVal, `in`: istream) {.importcpp: "#.input_hex(#)".} ## \
## Inputs the HashVal as a 32-digit hexadecimal number.

proc output_binary*(this: HashVal, `out`: ostream) {.importcpp: "#.output_binary(#)".} ## \
## Outputs the HashVal as a binary stream of bytes in order.  This is not the
## same order generated by write_stream().

proc input_binary*(this: HashVal, `in`: istream) {.importcpp: "#.input_binary(#)".} ## \
## Inputs the HashVal as a binary stream of bytes in order.  This is not the
## same order expected by read_stream().

proc output*(this: HashVal, `out`: ostream) {.importcpp: "#.output(#)".}

proc as_dec*(this: HashVal): string {.importcpp: "nimStringFromStdString(#.as_dec())", header: stringConversionCode.} ## \
## Returns the HashVal as a string with four decimal numbers.

proc set_from_dec*(this: HashVal, text: string): bool {.importcpp: "#.set_from_dec(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the HashVal from a string with four decimal numbers.  Returns true if
## valid, false otherwise.

proc as_hex*(this: HashVal): string {.importcpp: "nimStringFromStdString(#.as_hex())", header: stringConversionCode.} ## \
## Returns the HashVal as a 32-byte hexadecimal string.

proc set_from_hex*(this: HashVal, text: string): bool {.importcpp: "#.set_from_hex(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the HashVal from a 32-byte hexademical string.  Returns true if
## successful, false otherwise.

proc write_datagram*(this: HashVal, destination: Datagram) {.importcpp: "#.write_datagram(#)".}

proc read_datagram*(this: HashVal, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".}

proc write_stream*(this: HashVal, destination: StreamWriter) {.importcpp: "#.write_stream(#)".}

proc read_stream*(this: HashVal, source: StreamReader) {.importcpp: "#.read_stream(#)".}

proc hash_file*(this: HashVal, filename: Filename): bool {.importcpp: "#.hash_file(#)".} ## \
## Generates the hash value from the indicated file.  Returns true on success,
## false if the file cannot be read.  This method is only defined if we have
## the OpenSSL library (which provides md5 functionality) available.

proc hash_stream*(this: HashVal, stream: istream): bool {.importcpp: "#.hash_stream(#)".} ## \
## Generates the hash value from the indicated file.  Returns true on success,
## false if the file cannot be read.  This method is only defined if we have
## the OpenSSL library (which provides md5 functionality) available.

proc hash_ramfile*(this: HashVal, ramfile: Ramfile) {.importcpp: "#.hash_ramfile(#)".} ## \
## Generates the hash value by hashing the indicated data.  This method is
## only defined if we have the OpenSSL library (which provides md5
## functionality) available.

proc hash_string*(this: HashVal, data: string) {.importcpp: "#.hash_string(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Generates the hash value by hashing the indicated data.  This method is
## only defined if we have the OpenSSL library (which provides md5
## functionality) available.

proc hash_buffer*(this: HashVal, buffer: string, length: int) {.importcpp: "#.hash_buffer(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Generates the hash value by hashing the indicated data.  This method is
## only defined if we have the OpenSSL library (which provides md5
## functionality) available.

proc initMemoryUsagePointers*(): MemoryUsagePointers {.importcpp: "MemoryUsagePointers()".}

proc initMemoryUsagePointers*(param0: MemoryUsagePointers): MemoryUsagePointers {.importcpp: "MemoryUsagePointers(#)".}

proc get_num_pointers*(this: MemoryUsagePointers): clonglong {.importcpp: "#.get_num_pointers()".} ## \
## Returns the number of pointers in the set.

proc get_pointer*(this: MemoryUsagePointers, n: clonglong): ReferenceCount {.importcpp: "#.get_pointer(#)".} ## \
## Returns the nth pointer of the set.

proc get_typed_pointer*(this: MemoryUsagePointers, n: clonglong): TypedObject {.importcpp: "#.get_typed_pointer(#)".} ## \
## Returns the nth pointer of the set, typecast to a TypedObject if possible.
## If the pointer is not a TypedObject or if the cast cannot be made, returns
## nullptr.

proc get_type*(this: MemoryUsagePointers, n: clonglong): TypeHandle {.importcpp: "#.get_type(#)".} ## \
## Returns the actual type of the nth pointer, if it is known.

proc get_type_name*(this: MemoryUsagePointers, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_type_name(#))", header: stringConversionCode.} ## \
## Returns the type name of the nth pointer, if it is known.

proc get_age*(this: MemoryUsagePointers, n: clonglong): float64 {.importcpp: "#.get_age(#)".} ## \
## Returns the age of the nth pointer: the number of seconds elapsed between
## the time it was allocated and the time it was added to this set via a call
## to MemoryUsage::get_pointers().

proc clear*(this: MemoryUsagePointers) {.importcpp: "#.clear()".} ## \
## Empties the set of pointers.

proc output*(this: MemoryUsagePointers, `out`: ostream) {.importcpp: "#.output(#)".}

proc initISubStream*(): ISubStream {.importcpp: "ISubStream()".}

proc initISubStream*(source: IStreamWrapper, start: clonglong, `end`: clonglong): ISubStream {.importcpp: "ISubStream(#, #, #)".}

proc open*(this: ISubStream, source: IStreamWrapper, start: clonglong, `end`: clonglong): ISubStream {.importcpp: "#.open(#, #, #)".} ## \
## Starts the SubStream reading from the indicated source, with the first
## character being the character at position "start" within the source, for
## end - start total characters.  The character at "end" within the source
## will never be read; this will appear to be EOF.
##
## If end is zero, it indicates that the ISubStream will continue until the
## end of the source stream.

proc close*(this: ISubStream): ISubStream {.importcpp: "#.close()".} ## \
## Resets the SubStream to empty, but does not actually close the source
## istream.

proc initOSubStream*(): OSubStream {.importcpp: "OSubStream()".}

proc initOSubStream*(dest: OStreamWrapper, start: clonglong, `end`: clonglong, append: bool): OSubStream {.importcpp: "OSubStream(#, #, #, #)".}

proc initOSubStream*(dest: OStreamWrapper, start: clonglong, `end`: clonglong): OSubStream {.importcpp: "OSubStream(#, #, #)".}

proc open*(this: OSubStream, dest: OStreamWrapper, start: clonglong, `end`: clonglong, append: bool): OSubStream {.importcpp: "#.open(#, #, #, #)".} ## \
## Starts the SubStream reading from the indicated dest, with the first
## character being the character at position "start" within the dest, for end
## - start total characters.  The character at "end" within the dest will
## never be read; this will appear to be EOF.
##
## If end is zero, it indicates that the OSubStream will continue until the
## end of the dest stream.

proc open*(this: OSubStream, dest: OStreamWrapper, start: clonglong, `end`: clonglong): OSubStream {.importcpp: "#.open(#, #, #)".} ## \
## Starts the SubStream reading from the indicated dest, with the first
## character being the character at position "start" within the dest, for end
## - start total characters.  The character at "end" within the dest will
## never be read; this will appear to be EOF.
##
## If end is zero, it indicates that the OSubStream will continue until the
## end of the dest stream.

proc close*(this: OSubStream): OSubStream {.importcpp: "#.close()".} ## \
## Resets the SubStream to empty, but does not actually close the dest
## ostream.

proc initSubStream*(): SubStream {.importcpp: "SubStream()".}

proc initSubStream*(nested: StreamWrapper, start: clonglong, `end`: clonglong, append: bool): SubStream {.importcpp: "SubStream(#, #, #, #)".}

proc initSubStream*(nested: StreamWrapper, start: clonglong, `end`: clonglong): SubStream {.importcpp: "SubStream(#, #, #)".}

proc open*(this: SubStream, nested: StreamWrapper, start: clonglong, `end`: clonglong, append: bool): SubStream {.importcpp: "#.open(#, #, #, #)".} ## \
## Starts the SubStream reading and writing from the indicated nested stream,
## within the indicated range.  "end" is the first character outside of the
## range.
##
## If end is zero, it indicates that the SubStream will continue until the end
## of the nested stream.

proc open*(this: SubStream, nested: StreamWrapper, start: clonglong, `end`: clonglong): SubStream {.importcpp: "#.open(#, #, #)".} ## \
## Starts the SubStream reading and writing from the indicated nested stream,
## within the indicated range.  "end" is the first character outside of the
## range.
##
## If end is zero, it indicates that the SubStream will continue until the end
## of the nested stream.

proc close*(this: SubStream): SubStream {.importcpp: "#.close()".} ## \
## Resets the SubStream to empty, but does not actually close the nested
## ostream.

proc newMultifile*(): Multifile {.importcpp: "new Multifile()".}

proc open_read*(this: Multifile, multifile_name: Filename, offset: clonglong): bool {.importcpp: "#->open_read(#, #)".} ## \
## Opens the named Multifile on disk for reading.  The Multifile index is read
## in, and the list of subfiles becomes available; individual subfiles may
## then be extracted or read, but the list of subfiles may not be modified.
##
## Also see the version of open_read() which accepts an istream.  Returns true
## on success, false on failure.

proc open_read*(this: Multifile, multifile_name: Filename): bool {.importcpp: "#->open_read(#)".} ## \
## Opens the named Multifile on disk for reading.  The Multifile index is read
## in, and the list of subfiles becomes available; individual subfiles may
## then be extracted or read, but the list of subfiles may not be modified.
##
## Also see the version of open_read() which accepts an istream.  Returns true
## on success, false on failure.

proc open_read*(this: Multifile, multifile_stream: IStreamWrapper, owns_pointer: bool, offset: clonglong): bool {.importcpp: "#->open_read(#, #, #)".} ## \
## Opens an anonymous Multifile for reading using an istream.  There must be
## seek functionality via seekg() and tellg() on the istream.
##
## If owns_pointer is true, then the Multifile assumes ownership of the stream
## pointer and will delete it when the multifile is closed, including if this
## function returns false.

proc open_read*(this: Multifile, multifile_stream: IStreamWrapper, owns_pointer: bool): bool {.importcpp: "#->open_read(#, #)".} ## \
## Opens an anonymous Multifile for reading using an istream.  There must be
## seek functionality via seekg() and tellg() on the istream.
##
## If owns_pointer is true, then the Multifile assumes ownership of the stream
## pointer and will delete it when the multifile is closed, including if this
## function returns false.

proc open_read*(this: Multifile, multifile_stream: IStreamWrapper): bool {.importcpp: "#->open_read(#)".} ## \
## Opens an anonymous Multifile for reading using an istream.  There must be
## seek functionality via seekg() and tellg() on the istream.
##
## If owns_pointer is true, then the Multifile assumes ownership of the stream
## pointer and will delete it when the multifile is closed, including if this
## function returns false.

proc open_write*(this: Multifile, multifile_name: Filename): bool {.importcpp: "#->open_write(#)".} ## \
## Opens the named Multifile on disk for writing.  If there already exists a
## file by that name, it is truncated.  The Multifile is then prepared for
## accepting a brand new set of subfiles, which will be written to the
## indicated filename.  Individual subfiles may not be extracted or read.
##
## Also see the version of open_write() which accepts an ostream.  Returns
## true on success, false on failure.

proc open_write*(this: Multifile, multifile_stream: ostream, owns_pointer: bool): bool {.importcpp: "#->open_write(#, #)".} ## \
## Opens an anonymous Multifile for writing using an ostream.  There must be
## seek functionality via seekp() and tellp() on the pstream.
##
## If owns_pointer is true, then the Multifile assumes ownership of the stream
## pointer and will delete it when the multifile is closed, including if this
## function returns false.

proc open_write*(this: Multifile, multifile_stream: ostream): bool {.importcpp: "#->open_write(#)".} ## \
## Opens an anonymous Multifile for writing using an ostream.  There must be
## seek functionality via seekp() and tellp() on the pstream.
##
## If owns_pointer is true, then the Multifile assumes ownership of the stream
## pointer and will delete it when the multifile is closed, including if this
## function returns false.

proc open_read_write*(this: Multifile, multifile_name: Filename): bool {.importcpp: "#->open_read_write(#)".} ## \
## Opens the named Multifile on disk for reading and writing.  If there
## already exists a file by that name, its index is read.  Subfiles may be
## added or removed, and the resulting changes will be written to the named
## file.
##
## Also see the version of open_read_write() which accepts an iostream.
## Returns true on success, false on failure.

proc open_read_write*(this: Multifile, multifile_stream: iostream, owns_pointer: bool): bool {.importcpp: "#->open_read_write(#, #)".} ## \
## Opens an anonymous Multifile for reading and writing using an iostream.
## There must be seek functionality via seekg()/seekp() and tellg()/tellp() on
## the iostream.
##
## If owns_pointer is true, then the Multifile assumes ownership of the stream
## pointer and will delete it when the multifile is closed, including if this
## function returns false.

proc open_read_write*(this: Multifile, multifile_stream: iostream): bool {.importcpp: "#->open_read_write(#)".} ## \
## Opens an anonymous Multifile for reading and writing using an iostream.
## There must be seek functionality via seekg()/seekp() and tellg()/tellp() on
## the iostream.
##
## If owns_pointer is true, then the Multifile assumes ownership of the stream
## pointer and will delete it when the multifile is closed, including if this
## function returns false.

proc close*(this: Multifile) {.importcpp: "#->close()".} ## \
## Closes the Multifile if it is open.  All changes are flushed to disk, and
## the file becomes invalid for further operations until the next call to
## open().

proc get_multifile_name*(this: Multifile): Filename {.importcpp: "#->get_multifile_name()".} ## \
## Returns the filename of the Multifile, if it is available.

proc set_multifile_name*(this: Multifile, multifile_name: Filename) {.importcpp: "#->set_multifile_name(#)".} ## \
## Replaces the filename of the Multifile.  This is primarily used for
## documentation purposes only; changing this name does not open the indicated
## file.  See open_read() or open_write() for that.

proc is_read_valid*(this: Multifile): bool {.importcpp: "#->is_read_valid()".} ## \
## Returns true if the Multifile has been opened for read mode and there have
## been no errors, and individual Subfile contents may be extracted.

proc is_write_valid*(this: Multifile): bool {.importcpp: "#->is_write_valid()".} ## \
## Returns true if the Multifile has been opened for write mode and there have
## been no errors, and Subfiles may be added or removed from the Multifile.

proc needs_repack*(this: Multifile): bool {.importcpp: "#->needs_repack()".} ## \
## Returns true if the Multifile index is suboptimal and should be repacked.
## Call repack() to achieve this.

proc get_timestamp*(this: Multifile): int {.importcpp: "#->get_timestamp()".} ## \
## Returns the modification timestamp of the overall Multifile.  This
## indicates the most recent date at which subfiles were added or removed from
## the Multifile.  Note that it is logically possible for an individual
## subfile to have a more recent timestamp than the overall timestamp.

proc set_timestamp*(this: Multifile, timestamp: int) {.importcpp: "#->set_timestamp(#)".} ## \
## Changes the overall mudification timestamp of the multifile.  Note that this
## will be reset to the current time every time you modify a subfile.
## Only set this if you know what you are doing!

proc set_record_timestamp*(this: Multifile, record_timestamp: bool) {.importcpp: "#->set_record_timestamp(#)".} ## \
## Sets the flag indicating whether timestamps should be recorded within the
## Multifile or not.  The default is true, indicating the Multifile will
## record timestamps for the overall file and also for each subfile.
##
## If this is false, the Multifile will not record timestamps internally.  In
## this case, the return value from get_timestamp() or get_subfile_timestamp()
## will be estimations.
##
## You may want to set this false to minimize the bitwise difference between
## independently-generated Multifiles.

proc get_record_timestamp*(this: Multifile): bool {.importcpp: "#->get_record_timestamp()".} ## \
## Returns the flag indicating whether timestamps should be recorded within
## the Multifile or not.  See set_record_timestamp().

proc set_scale_factor*(this: Multifile, scale_factor: clonglong) {.importcpp: "#->set_scale_factor(#)".} ## \
## Changes the internal scale factor for this Multifile.
##
## This is normally 1, but it may be set to any arbitrary value (greater than
## zero) to support Multifile archives that exceed 4GB, if necessary.
## (Individual subfiles may still not exceed 4GB.)
##
## All addresses within the file are rounded up to the next multiple of
## _scale_factor, and zeros are written to the file to fill the resulting
## gaps.  Then the address is divided by _scale_factor and written out as a
## 32-bit integer.  Thus, setting a scale factor of 2 supports up to 8GB
## files, 3 supports 12GB files, etc.
##
## Calling this function on an already-existing Multifile will have no
## immediate effect until a future call to repack() or close() (or until the
## Multifile is destructed).

proc get_scale_factor*(this: Multifile): clonglong {.importcpp: "#->get_scale_factor()".} ## \
## Returns the internal scale factor for this Multifile.  See
## set_scale_factor().

proc set_encryption_flag*(this: Multifile, flag: bool) {.importcpp: "#->set_encryption_flag(#)".} ## \
## Sets the flag indicating whether subsequently-added subfiles should be
## encrypted before writing them to the multifile.  If true, subfiles will be
## encrypted; if false (the default), they will be written without encryption.
##
## When true, subfiles will be encrypted with the password specified by
## set_encryption_password().  It is possible to apply a different password to
## different files, but the resulting file can't be mounted via VFS.

proc get_encryption_flag*(this: Multifile): bool {.importcpp: "#->get_encryption_flag()".} ## \
## Returns the flag indicating whether subsequently-added subfiles should be
## encrypted before writing them to the multifile.  See set_encryption_flag().

proc set_encryption_password*(this: Multifile, encryption_password: string) {.importcpp: "#->set_encryption_password(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the password that will be used to encrypt subfiles subsequently
## added to the multifile, if the encryption flag is also set true (see
## set_encryption_flag()).
##
## It is possible to apply a different password to different files, but the
## resulting file can't be mounted via VFS.  Changing this value may cause an
## implicit call to flush().

proc get_encryption_password*(this: Multifile): string {.importcpp: "nimStringFromStdString(#->get_encryption_password())", header: stringConversionCode.} ## \
## Returns the password that will be used to encrypt subfiles subsequently
## added to the multifile.  See set_encryption_password().

proc set_encryption_algorithm*(this: Multifile, encryption_algorithm: string) {.importcpp: "#->set_encryption_algorithm(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the encryption algorithm that should be used for future calls to
## add_subfile().  The default is whatever is specified by the encryption-
## algorithm config variable.  The complete set of available algorithms is
## defined by the current version of OpenSSL.
##
## If an invalid algorithm is specified, there is no immediate error return
## code, but flush() will fail and the file will be invalid.
##
## It is possible to apply a different encryption algorithm to different
## files, and unlike the password, this does not interfere with mounting the
## multifile via VFS.  Changing this value may cause an implicit call to
## flush().

proc get_encryption_algorithm*(this: Multifile): string {.importcpp: "nimStringFromStdString(#->get_encryption_algorithm())", header: stringConversionCode.} ## \
## Returns the encryption algorithm that was specified by
## set_encryption_algorithm().

proc set_encryption_key_length*(this: Multifile, encryption_key_length: int) {.importcpp: "#->set_encryption_key_length(#)".} ## \
## Specifies the length of the key, in bits, that should be used to encrypt
## the stream in future calls to add_subfile().  The default is whatever is
## specified by the encryption-key-length config variable.
##
## If an invalid key_length for the chosen algorithm is specified, there is no
## immediate error return code, but flush() will fail and the file will be
## invalid.
##
## It is possible to apply a different key length to different files, and
## unlike the password, this does not interfere with mounting the multifile
## via VFS. Changing this value may cause an implicit call to flush().

proc get_encryption_key_length*(this: Multifile): int {.importcpp: "#->get_encryption_key_length()".} ## \
## Returns the encryption key length, in bits, that was specified by
## set_encryption_key_length().

proc set_encryption_iteration_count*(this: Multifile, encryption_iteration_count: int) {.importcpp: "#->set_encryption_iteration_count(#)".} ## \
## Specifies the number of times to repeatedly hash the key before writing it
## to the stream in future calls to add_subfile().  Its purpose is to make it
## computationally more expensive for an attacker to search the key space
## exhaustively.  This should be a multiple of 1,000 and should not exceed
## about 65 million; the value 0 indicates just one application of the hashing
## algorithm.
##
## The default is whatever is specified by the multifile-encryption-iteration-
## count config variable.
##
## It is possible to apply a different iteration count to different files, and
## unlike the password, this does not interfere with mounting the multifile
## via VFS.  Changing this value causes an implicit call to flush().

proc get_encryption_iteration_count*(this: Multifile): int {.importcpp: "#->get_encryption_iteration_count()".} ## \
## Returns the value that was specified by set_encryption_iteration_count().

proc add_subfile*(this: Multifile, subfile_name: string, filename: Filename, compression_level: int): string {.importcpp: "nimStringFromStdString(#->add_subfile(nimStringToStdString(#), #, #))", header: stringConversionCode.} ## \
## Adds a file on disk as a subfile to the Multifile.  The file named by
## filename will be read and added to the Multifile at the next call to
## flush().  If there already exists a subfile with the indicated name, it is
## replaced without examining its contents (but see also update_subfile).
##
## Either Filename:::set_binary() or set_text() must have been called
## previously to specify the nature of the source file.  If set_text() was
## called, the text flag will be set on the subfile.
##
## Returns the subfile name on success (it might have been modified slightly),
## or empty string on failure.

proc add_subfile*(this: Multifile, subfile_name: string, subfile_data: istream, compression_level: int): string {.importcpp: "nimStringFromStdString(#->add_subfile(nimStringToStdString(#), #, #))", header: stringConversionCode.} ## \
## Adds a file from a stream as a subfile to the Multifile.  The indicated
## istream will be read and its contents added to the Multifile at the next
## call to flush(). The file will be added as a binary subfile.
##
## Note that the istream must remain untouched and unused by any other code
## until flush() is called.  At that time, the Multifile will read the entire
## contents of the istream from the current file position to the end of the
## file.  Subsequently, the Multifile will *not* close or delete the istream.
## It is the caller's responsibility to ensure that the istream pointer does
## not destruct during the lifetime of the Multifile.
##
## Returns the subfile name on success (it might have been modified slightly),
## or empty string on failure.

proc update_subfile*(this: Multifile, subfile_name: string, filename: Filename, compression_level: int): string {.importcpp: "nimStringFromStdString(#->update_subfile(nimStringToStdString(#), #, #))", header: stringConversionCode.} ## \
## Adds a file on disk to the subfile.  If a subfile already exists with the
## same name, its contents are compared byte-for-byte to the disk file, and it
## is replaced only if it is different; otherwise, the multifile is left
## unchanged.
##
## Either Filename:::set_binary() or set_text() must have been called
## previously to specify the nature of the source file.  If set_text() was
## called, the text flag will be set on the subfile.

proc add_signature*(this: Multifile, certificate: Filename, chain: Filename, pkey: Filename, password: string): bool {.importcpp: "#->add_signature(#, #, #, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a new signature to the Multifile.  This signature associates the
## indicated certificate with the current contents of the Multifile.  When the
## Multifile is read later, the signature will still be present only if the
## Multifile is unchanged; any subsequent changes to the Multifile will
## automatically invalidate and remove the signature.
##
## The chain filename may be empty if the certificate does not require an
## authenticating certificate chain (e.g.  because it is self-signed).
##
## The specified private key must match the certificate, and the Multifile
## must be open in read-write mode.  The private key is only used for
## generating the signature; it is not written to the Multifile and cannot be
## retrieved from the Multifile later.  (However, the certificate *can* be
## retrieved from the Multifile later, to identify the entity that created the
## signature.)
##
## This implicitly causes a repack() operation if one is needed.  Returns true
## on success, false on failure.
##
## This flavor of add_signature() reads the certificate and private key from a
## PEM-formatted file, for instance as generated by the openssl command.  If
## the private key file is password-encrypted, the third parameter will be
## used as the password to decrypt it.

proc add_signature*(this: Multifile, certificate: Filename, chain: Filename, pkey: Filename): bool {.importcpp: "#->add_signature(#, #, #)".} ## \
## Adds a new signature to the Multifile.  This signature associates the
## indicated certificate with the current contents of the Multifile.  When the
## Multifile is read later, the signature will still be present only if the
## Multifile is unchanged; any subsequent changes to the Multifile will
## automatically invalidate and remove the signature.
##
## The chain filename may be empty if the certificate does not require an
## authenticating certificate chain (e.g.  because it is self-signed).
##
## The specified private key must match the certificate, and the Multifile
## must be open in read-write mode.  The private key is only used for
## generating the signature; it is not written to the Multifile and cannot be
## retrieved from the Multifile later.  (However, the certificate *can* be
## retrieved from the Multifile later, to identify the entity that created the
## signature.)
##
## This implicitly causes a repack() operation if one is needed.  Returns true
## on success, false on failure.
##
## This flavor of add_signature() reads the certificate and private key from a
## PEM-formatted file, for instance as generated by the openssl command.  If
## the private key file is password-encrypted, the third parameter will be
## used as the password to decrypt it.

proc add_signature*(this: Multifile, composite: Filename, password: string): bool {.importcpp: "#->add_signature(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a new signature to the Multifile.  This signature associates the
## indicated certificate with the current contents of the Multifile.  When the
## Multifile is read later, the signature will still be present only if the
## Multifile is unchanged; any subsequent changes to the Multifile will
## automatically invalidate and remove the signature.
##
## This flavor of add_signature() reads the certificate, private key, and
## certificate chain from the same PEM-formatted file.  It takes the first
## private key found as the intended key, and then uses the first certificate
## found that matches that key as the signing certificate.  Any other
## certificates in the file are taken to be part of the chain.

proc add_signature*(this: Multifile, composite: Filename): bool {.importcpp: "#->add_signature(#)".} ## \
## Adds a new signature to the Multifile.  This signature associates the
## indicated certificate with the current contents of the Multifile.  When the
## Multifile is read later, the signature will still be present only if the
## Multifile is unchanged; any subsequent changes to the Multifile will
## automatically invalidate and remove the signature.
##
## This flavor of add_signature() reads the certificate, private key, and
## certificate chain from the same PEM-formatted file.  It takes the first
## private key found as the intended key, and then uses the first certificate
## found that matches that key as the signing certificate.  Any other
## certificates in the file are taken to be part of the chain.

proc get_num_signatures*(this: Multifile): int {.importcpp: "#->get_num_signatures()".} ## \
## Returns the number of matching signatures found on the Multifile.  These
## signatures may be iterated via get_signature() and related methods.
##
## A signature on this list is guaranteed to match the Multifile contents,
## proving that the Multifile has been unmodified since the signature was
## applied.  However, this does not guarantee that the certificate itself is
## actually from who it says it is from; only that it matches the Multifile
## contents.  See validate_signature_certificate() to authenticate a
## particular certificate.

proc get_signature_subject_name*(this: Multifile, n: int): string {.importcpp: "nimStringFromStdString(#->get_signature_subject_name(#))", header: stringConversionCode.} ## \
## Returns the "subject name" for the nth signature found on the Multifile.
## This is a string formatted according to RFC2253 that should more-or-less
## identify a particular certificate; when paired with the public key (see
## get_signature_public_key()), it can uniquely identify a certificate.  See
## the comments in get_num_signatures().

proc get_signature_friendly_name*(this: Multifile, n: int): string {.importcpp: "nimStringFromStdString(#->get_signature_friendly_name(#))", header: stringConversionCode.} ## \
## Returns a "friendly name" for the nth signature found on the Multifile.
## This attempts to extract out the most meaningful part of the subject name.
## It returns the emailAddress, if it is defined; otherwise, it returns the
## commonName.
##
## See the comments in get_num_signatures().

proc get_signature_public_key*(this: Multifile, n: int): string {.importcpp: "nimStringFromStdString(#->get_signature_public_key(#))", header: stringConversionCode.} ## \
## Returns the public key used for the nth signature found on the Multifile.
## This is encoded in DER form and returned as a string of hex digits.
##
## This can be used, in conjunction with the subject name (see
## get_signature_subject_name()), to uniquely identify a particular
## certificate and its subsequent reissues.  See the comments in
## get_num_signatures().

proc print_signature_certificate*(this: Multifile, n: int, `out`: ostream) {.importcpp: "#->print_signature_certificate(#, #)".} ## \
## Writes the certificate for the nth signature, in user-readable verbose
## form, to the indicated stream.  See the comments in get_num_signatures().

proc write_signature_certificate*(this: Multifile, n: int, `out`: ostream) {.importcpp: "#->write_signature_certificate(#, #)".} ## \
## Writes the certificate for the nth signature, in PEM form, to the indicated
## stream.  See the comments in get_num_signatures().

proc validate_signature_certificate*(this: Multifile, n: int): int {.importcpp: "#->validate_signature_certificate(#)".} ## \
## Checks that the certificate used for the nth signature is a valid,
## authorized certificate with some known certificate authority.  Returns 0 if
## it is valid, -1 if there is some error, or the corresponding OpenSSL error
## code if it is invalid, out-of-date, or self-signed.

proc flush*(this: Multifile): bool {.importcpp: "#->flush()".} ## \
## Writes all contents of the Multifile to disk.  Until flush() is called,
## add_subfile() and remove_subfile() do not actually do anything to disk.  At
## this point, all of the recently-added subfiles are read and their contents
## are added to the end of the Multifile, and the recently-removed subfiles
## are marked gone from the Multifile.
##
## This may result in a suboptimal index.  To guarantee that the index is
## written at the beginning of the file, call repack() instead of flush().
##
## It is not necessary to call flush() explicitly unless you are concerned
## about reading the recently-added subfiles immediately.
##
## Returns true on success, false on failure.

proc repack*(this: Multifile): bool {.importcpp: "#->repack()".} ## \
## Forces a complete rewrite of the Multifile and all of its contents, so that
## its index will appear at the beginning of the file with all of the subfiles
## listed in alphabetical order.  This is considered optimal for reading, and
## is the standard configuration; but it is not essential to do this.
##
## It is only valid to call this if the Multifile was opened using
## open_read_write() and an explicit filename, rather than an iostream.  Also,
## we must have write permission to the directory containing the Multifile.
##
## Returns true on success, false on failure.

proc get_num_subfiles*(this: Multifile): int {.importcpp: "#->get_num_subfiles()".} ## \
## Returns the number of subfiles within the Multifile.  The subfiles may be
## accessed in alphabetical order by iterating through [0 ..
## get_num_subfiles()).

proc find_subfile*(this: Multifile, subfile_name: string): int {.importcpp: "#->find_subfile(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the index of the subfile with the indicated name, or -1 if the
## named subfile is not within the Multifile.

proc has_directory*(this: Multifile, subfile_name: string): bool {.importcpp: "#->has_directory(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if the indicated subfile name is the directory prefix to one
## or more files within the Multifile.  That is, the Multifile contains at
## least one file named "subfile_name/...".

proc remove_subfile*(this: Multifile, index: int) {.importcpp: "#->remove_subfile(#)".} ## \
## Removes the nth subfile from the Multifile.  This will cause all subsequent
## index numbers to decrease by one.  The file will not actually be removed
## from the disk until the next call to flush().
##
## Note that this does not actually remove the data from the indicated
## subfile; it simply removes it from the index.  The Multifile will not be
## reduced in size after this operation, until the next call to repack().

proc remove_subfile*(this: Multifile, subfile_name: string): bool {.importcpp: "#->remove_subfile(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the named subfile from the Multifile, if it exists; returns true if
## successfully removed, or false if it did not exist in the first place.  The
## file will not actually be removed from the disk until the next call to
## flush().
##
## Note that this does not actually remove the data from the indicated
## subfile; it simply removes it from the index.  The Multifile will not be
## reduced in size after this operation, until the next call to repack().

proc get_subfile_name*(this: Multifile, index: int): string {.importcpp: "nimStringFromStdString(#->get_subfile_name(#))", header: stringConversionCode.} ## \
## Returns the name of the nth subfile.

proc get_subfile_length*(this: Multifile, index: int): clonglong {.importcpp: "#->get_subfile_length(#)".} ## \
## Returns the uncompressed data length of the nth subfile.  This might return
## 0 if the subfile has recently been added and flush() has not yet been
## called.

proc get_subfile_timestamp*(this: Multifile, index: int): int {.importcpp: "#->get_subfile_timestamp(#)".} ## \
## Returns the modification time of the nth subfile.  If this is called on an
## older .mf file, which did not store individual timestamps in the file (or
## if get_record_timestamp() is false), this will return the modification time
## of the overall multifile.

proc is_subfile_compressed*(this: Multifile, index: int): bool {.importcpp: "#->is_subfile_compressed(#)".} ## \
## Returns true if the indicated subfile has been compressed when stored
## within the archive, false otherwise.

proc is_subfile_encrypted*(this: Multifile, index: int): bool {.importcpp: "#->is_subfile_encrypted(#)".} ## \
## Returns true if the indicated subfile has been encrypted when stored within
## the archive, false otherwise.

proc is_subfile_text*(this: Multifile, index: int): bool {.importcpp: "#->is_subfile_text(#)".} ## \
## Returns true if the indicated subfile represents text data, or false if it
## represents binary data.  If the file is text data, it may have been
## processed by end-of-line conversion when it was added.  (But the actual
## bits in the multifile will represent the standard Unix end-of-line
## convention, e.g.  \n instead of \r\n.)

proc get_index_end*(this: Multifile): clonglong {.importcpp: "#->get_index_end()".} ## \
## Returns the first byte that is guaranteed to follow any index byte already
## written to disk in the Multifile.
##
## This number is largely meaningless in many cases, but if needs_repack() is
## false, and the file is flushed, this will indicate the number of bytes in
## the header + index.  Everything at this byte position and later will be
## actual data.

proc get_subfile_internal_start*(this: Multifile, index: int): clonglong {.importcpp: "#->get_subfile_internal_start(#)".} ## \
## Returns the starting byte position within the Multifile at which the
## indicated subfile begins.  This may be used, with
## get_subfile_internal_length(), for low-level access to the subfile, but
## usually it is better to use open_read_subfile() instead (which
## automatically decrypts and/or uncompresses the subfile data).

proc get_subfile_internal_length*(this: Multifile, index: int): clonglong {.importcpp: "#->get_subfile_internal_length(#)".} ## \
## Returns the number of bytes the indicated subfile consumes within the
## archive.  For compressed subfiles, this will generally be smaller than
## get_subfile_length(); for encrypted (but noncompressed) subfiles, it may be
## slightly different, for noncompressed and nonencrypted subfiles, it will be
## equal.

proc open_read_subfile*(this: Multifile, index: int): istream {.importcpp: "#->open_read_subfile(#)".} ## \
## Returns an istream that may be used to read the indicated subfile.  You may
## seek() within this istream to your heart's content; even though it will be
## a reference to the already-opened pfstream of the Multifile itself, byte 0
## appears to be the beginning of the subfile and EOF appears to be the end of
## the subfile.
##
## The returned istream will have been allocated via new; you should pass the
## pointer to close_read_subfile() when you are finished with it to delete it
## and release its resources.
##
## Any future calls to repack() or close() (or the Multifile destructor) will
## invalidate all currently open subfile pointers.
##
## The return value will be NULL if the stream cannot be opened for some
## reason.

proc close_read_subfile*(_: typedesc[Multifile], stream: istream) {.importcpp: "Multifile::close_read_subfile(#)", header: "multifile.h".} ## \
## Closes a file opened by a previous call to open_read_subfile().  This
## really just deletes the istream pointer, but it is recommended to use this
## interface instead of deleting it explicitly, to help work around compiler
## issues.

proc extract_subfile*(this: Multifile, index: int, filename: Filename): bool {.importcpp: "#->extract_subfile(#, #)".} ## \
## Extracts the nth subfile into a file with the given name.

proc extract_subfile_to*(this: Multifile, index: int, `out`: ostream): bool {.importcpp: "#->extract_subfile_to(#, #)".} ## \
## Extracts the nth subfile to the indicated ostream.

proc compare_subfile*(this: Multifile, index: int, filename: Filename): bool {.importcpp: "#->compare_subfile(#, #)".} ## \
## Performs a byte-for-byte comparison of the indicated file on disk with the
## nth subfile.  Returns true if the files are equivalent, or false if they
## are different (or the file is missing).
##
## If Filename::set_binary() or set_text() has already been called, it
## specifies the nature of the source file.  If this is different from the
## text flag of the subfile, the comparison will always return false.  If this
## has not been specified, it will be set from the text flag of the subfile.

proc output*(this: Multifile, `out`: ostream) {.importcpp: "#->output(#)".}

proc ls*(this: Multifile, `out`: ostream) {.importcpp: "#->ls(#)".} ## \
## Shows a list of all subfiles within the Multifile.

proc ls*(this: Multifile) {.importcpp: "#->ls()".} ## \
## Shows a list of all subfiles within the Multifile.

proc get_magic_number*(_: typedesc[Multifile]): string {.importcpp: "nimStringFromStdString(Multifile::get_magic_number())", header: "multifile.h".} ## \
## Returns a string with the first n bytes written to a Multifile, to identify
## it as a Multifile.

proc set_header_prefix*(this: Multifile, header_prefix: string) {.importcpp: "#->set_header_prefix(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the string which is written to the Multifile before the Multifile
## header.  This string must begin with a hash mark and end with a newline
## character; and if it includes embedded newline characters, each one must be
## followed by a hash mark.  If these conditions are not initially true, the
## string will be modified as necessary to make it so.
##
## This is primarily useful as a simple hack to allow p3d applications to be
## run directly from the command line on Unix-like systems.
##
## The return value is true if successful, or false on failure (for instance,
## because the header prefix violates the above rules).

proc get_header_prefix*(this: Multifile): string {.importcpp: "nimStringFromStdString(#->get_header_prefix())", header: stringConversionCode.} ## \
## Returns the string that preceded the Multifile header on the file, if any.
## See set_header_prefix().

proc initNamable*(param0: Namable): Namable {.importcpp: "Namable(#)".}

proc initNamable*(initial_name: string): Namable {.importcpp: "Namable(nimStringToStdString(#))", header: stringConversionCode.}

proc initNamable*(): Namable {.importcpp: "Namable()".}

proc set_name*(this: Namable, name: string) {.importcpp: "#.set_name(nimStringToStdString(#))", header: stringConversionCode.}

proc clear_name*(this: Namable) {.importcpp: "#.clear_name()".} ## \
## Resets the Namable's name to empty.

proc has_name*(this: Namable): bool {.importcpp: "#.has_name()".} ## \
## Returns true if the Namable has a nonempty name set, false if the name is
## empty.

proc get_name*(this: Namable): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.}

proc output*(this: Namable, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Outputs the Namable.  This function simply writes the name to the output
## stream; most Namable derivatives will probably redefine this.

proc get_class_type*(_: typedesc[Namable]): TypeHandle {.importcpp: "Namable::get_class_type()", header: "namable.h".}

proc clear_certificates*(this: OpenSSLWrapper) {.importcpp: "#.clear_certificates()".} ## \
## Removes all the certificates from the global store, including the compiled-
## in certificates loaded from ca_bundle_data.c.  You can add new certificates
## by calling load_certificates().

proc load_certificates*(this: OpenSSLWrapper, filename: Filename): int {.importcpp: "#.load_certificates(#)".} ## \
## Reads the PEM-formatted certificate(s) (delimited by -----BEGIN
## CERTIFICATE----- and -----END CERTIFICATE-----) from the indicated file and
## adds them to the global store object, retrieved via get_x509_store().
##
## Returns the number of certificates read on success, or 0 on failure.
##
## You should call this only with trusted, locally-stored certificates; not
## with certificates received from an untrusted source.

proc load_certificates_from_pem_ram*(this: OpenSSLWrapper, data: string, data_size: clonglong): int {.importcpp: "#.load_certificates_from_pem_ram(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Reads a chain of trusted certificates from the indicated data buffer and
## adds them to the X509_STORE object.  The data buffer should be PEM-
## formatted.  Returns the number of certificates read on success, or 0 on
## failure.
##
## You should call this only with trusted, locally-stored certificates; not
## with certificates received from an untrusted source.

proc load_certificates_from_pem_ram*(this: OpenSSLWrapper, data: string): int {.importcpp: "#.load_certificates_from_pem_ram(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reads a chain of trusted certificates from the indicated data buffer and
## adds them to the X509_STORE object.  The data buffer should be PEM-
## formatted.  Returns the number of certificates read on success, or 0 on
## failure.
##
## You should call this only with trusted, locally-stored certificates; not
## with certificates received from an untrusted source.

proc load_certificates_from_der_ram*(this: OpenSSLWrapper, data: string, data_size: clonglong): int {.importcpp: "#.load_certificates_from_der_ram(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Reads a chain of trusted certificates from the indicated data buffer and
## adds them to the X509_STORE object.  The data buffer should be DER-
## formatted.  Returns the number of certificates read on success, or 0 on
## failure.
##
## You should call this only with trusted, locally-stored certificates; not
## with certificates received from an untrusted source.

proc load_certificates_from_der_ram*(this: OpenSSLWrapper, data: string): int {.importcpp: "#.load_certificates_from_der_ram(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reads a chain of trusted certificates from the indicated data buffer and
## adds them to the X509_STORE object.  The data buffer should be DER-
## formatted.  Returns the number of certificates read on success, or 0 on
## failure.
##
## You should call this only with trusted, locally-stored certificates; not
## with certificates received from an untrusted source.

proc notify_ssl_errors*(this: OpenSSLWrapper) {.importcpp: "#.notify_ssl_errors()".} ## \
## A convenience function that is itself a wrapper around the OpenSSL
## convenience function to output the recent OpenSSL errors.  This function
## sends the error string to express_cat.warning().  If REPORT_OPENSSL_ERRORS
## is not defined, the function does nothing.

proc notify_debug_ssl_errors*(this: OpenSSLWrapper) {.importcpp: "#.notify_debug_ssl_errors()".} ## \
## As notify_ssl_errors(), but sends the output to debug instead of warning.

proc get_global_ptr*(_: typedesc[OpenSSLWrapper]): OpenSSLWrapper {.importcpp: "OpenSSLWrapper::get_global_ptr()", header: "openSSLWrapper.h".}

proc initSubfileInfo*(): SubfileInfo {.importcpp: "SubfileInfo()".}

proc initSubfileInfo*(file: FileReference, start: clonglong, size: clonglong): SubfileInfo {.importcpp: "SubfileInfo(#, #, #)".}

proc initSubfileInfo*(filename: Filename, start: clonglong, size: clonglong): SubfileInfo {.importcpp: "SubfileInfo(#, #, #)".}

proc initSubfileInfo*(copy: SubfileInfo): SubfileInfo {.importcpp: "SubfileInfo(#)".}

proc is_empty*(this: SubfileInfo): bool {.importcpp: "#.is_empty()".} ## \
## Returns true if this SubfileInfo doesn't define any file, false if it has
## real data.

proc get_file*(this: SubfileInfo): FileReference {.importcpp: "#.get_file()".} ## \
## Returns the FileReference that represents this file.

proc get_filename*(this: SubfileInfo): Filename {.importcpp: "#.get_filename()".} ## \
## A shortcut to the filename.

proc get_start*(this: SubfileInfo): clonglong {.importcpp: "#.get_start()".} ## \
## Returns the offset within the file at which this file data begins.

proc get_size*(this: SubfileInfo): clonglong {.importcpp: "#.get_size()".} ## \
## Returns the number of consecutive bytes, beginning at get_start(), that
## correspond to this file data.

proc output*(this: SubfileInfo, `out`: ostream) {.importcpp: "#.output(#)".}

proc get_file_system*(this: VirtualFile): VirtualFileSystem {.importcpp: "#->get_file_system()".}

proc get_filename*(this: VirtualFile): Filename {.importcpp: "#->get_filename()".}

proc get_original_filename*(this: VirtualFile): Filename {.importcpp: "#->get_original_filename()".} ## \
## Returns the original filename as it was used to locate this VirtualFile.
## This is usually, but not always, the same string returned by
## get_filename().

proc has_file*(this: VirtualFile): bool {.importcpp: "#->has_file()".} ## \
## Returns true if this file exists, false otherwise.

proc is_directory*(this: VirtualFile): bool {.importcpp: "#->is_directory()".} ## \
## Returns true if this file represents a directory (and scan_directory() may
## be called), false otherwise.

proc is_regular_file*(this: VirtualFile): bool {.importcpp: "#->is_regular_file()".} ## \
## Returns true if this file represents a regular file (and read_file() may be
## called), false otherwise.

proc is_writable*(this: VirtualFile): bool {.importcpp: "#->is_writable()".} ## \
## Returns true if this file may be written to, which implies write_file() may
## be called (unless it is a directory instead of a regular file).

proc delete_file*(this: VirtualFile): bool {.importcpp: "#->delete_file()".} ## \
## Attempts to delete this file or directory.  This can remove a single file
## or an empty directory.  It will not remove a nonempty directory.  Returns
## true on success, false on failure.

proc rename_file*(this: VirtualFile, new_file: VirtualFile): bool {.importcpp: "#->rename_file(#)".} ## \
## Attempts to move or rename this file or directory.  If the original file is
## an ordinary file, it will quietly replace any already-existing file in the
## new filename (but not a directory).  If the original file is a directory,
## the new filename must not already exist.
##
## If the file is a directory, the new filename must be within the same mount
## point.  If the file is an ordinary file, the new filename may be anywhere;
## but if it is not within the same mount point then the rename operation is
## automatically performed as a two-step copy-and-delete operation.

proc copy_file*(this: VirtualFile, new_file: VirtualFile): bool {.importcpp: "#->copy_file(#)".} ## \
## Attempts to copy the contents of this file to the indicated file.  Returns
## true on success, false on failure.

proc scan_directory*(this: VirtualFile): VirtualFileList {.importcpp: "#->scan_directory()".} ## \
## If the file represents a directory (that is, is_directory() returns true),
## this returns the list of files within the directory at the current time.
## Returns NULL if the file is not a directory or if the directory cannot be
## read.

proc output*(this: VirtualFile, `out`: ostream) {.importcpp: "#->output(#)".}

proc ls*(this: VirtualFile, `out`: ostream) {.importcpp: "#->ls(#)".} ## \
## If the file represents a directory, lists its contents.

proc ls*(this: VirtualFile) {.importcpp: "#->ls()".} ## \
## If the file represents a directory, lists its contents.

proc ls_all*(this: VirtualFile, `out`: ostream) {.importcpp: "#->ls_all(#)".} ## \
## If the file represents a directory, recursively lists its contents and
## those of all subdirectories.

proc ls_all*(this: VirtualFile) {.importcpp: "#->ls_all()".} ## \
## If the file represents a directory, recursively lists its contents and
## those of all subdirectories.

proc open_read_file*(this: VirtualFile, auto_unwrap: bool): istream {.importcpp: "#->open_read_file(#)".} ## \
## Opens the file for reading.  Returns a newly allocated istream on success
## (which you should eventually delete when you are done reading). Returns
## NULL on failure.

proc close_read_file*(this: VirtualFile, stream: istream) {.importcpp: "#->close_read_file(#)".} ## \
## Closes a file opened by a previous call to open_read_file().  This really
## just deletes the istream pointer, but it is recommended to use this
## interface instead of deleting it explicitly, to help work around compiler
## issues.

proc was_read_successful*(this: VirtualFile): bool {.importcpp: "#->was_read_successful()".} ## \
## Call this method after a reading the istream returned by open_read_file()
## to completion.  If it returns true, the file was read completely and
## without error; if it returns false, there may have been some errors or a
## truncated file read.  This is particularly likely if the stream is a
## VirtualFileHTTP.

proc open_write_file*(this: VirtualFile, auto_wrap: bool, truncate: bool): ostream {.importcpp: "#->open_write_file(#, #)".} ## \
## Opens the file for writing.  Returns a newly allocated ostream on success
## (which you should eventually delete when you are done writing). Returns
## NULL on failure.

proc open_append_file*(this: VirtualFile): ostream {.importcpp: "#->open_append_file()".} ## \
## Works like open_write_file(), but the file is opened in append mode.  Like
## open_write_file, the returned pointer should eventually be passed to
## close_write_file().

proc close_write_file*(this: VirtualFile, stream: ostream) {.importcpp: "#->close_write_file(#)".} ## \
## Closes a file opened by a previous call to open_write_file().  This really
## just deletes the ostream pointer, but it is recommended to use this
## interface instead of deleting it explicitly, to help work around compiler
## issues.

proc open_read_write_file*(this: VirtualFile, truncate: bool): iostream {.importcpp: "#->open_read_write_file(#)".} ## \
## Opens the file for writing.  Returns a newly allocated iostream on success
## (which you should eventually delete when you are done writing). Returns
## NULL on failure.

proc open_read_append_file*(this: VirtualFile): iostream {.importcpp: "#->open_read_append_file()".} ## \
## Works like open_read_write_file(), but the file is opened in append mode.
## Like open_read_write_file, the returned pointer should eventually be passed
## to close_read_write_file().

proc close_read_write_file*(this: VirtualFile, stream: iostream) {.importcpp: "#->close_read_write_file(#)".} ## \
## Closes a file opened by a previous call to open_read_write_file().  This
## really just deletes the iostream pointer, but it is recommended to use this
## interface instead of deleting it explicitly, to help work around compiler
## issues.

proc get_file_size*(this: VirtualFile): clonglong {.importcpp: "#->get_file_size()".} ## \
## Returns the current size on disk (or wherever it is) of the file before it
## has been opened.

proc get_file_size*(this: VirtualFile, stream: istream): clonglong {.importcpp: "#->get_file_size(#)".} ## \
## Returns the current size on disk (or wherever it is) of the already-open
## file.  Pass in the stream that was returned by open_read_file(); some
## implementations may require this stream to determine the size.

proc get_timestamp*(this: VirtualFile): int {.importcpp: "#->get_timestamp()".} ## \
## Returns a time_t value that represents the time the file was last modified,
## to within whatever precision the operating system records this information
## (on a Windows95 system, for instance, this may only be accurate to within 2
## seconds).
##
## If the timestamp cannot be determined, either because it is not supported
## by the operating system or because there is some error (such as file not
## found), returns 0.

proc get_system_info*(this: VirtualFile, info: SubfileInfo): bool {.importcpp: "#->get_system_info(#)".} ## \
## Populates the SubfileInfo structure with the data representing where the
## file actually resides on disk, if this is knowable.  Returns true if the
## file might reside on disk, and the info is populated, or false if it does
## not (or it is not known where the file resides), in which case the info is
## meaningless.

proc get_class_type*(_: typedesc[VirtualFile]): TypeHandle {.importcpp: "VirtualFile::get_class_type()", header: "virtualFile.h".}

proc get_class_type*(_: typedesc[VirtualFileComposite]): TypeHandle {.importcpp: "VirtualFileComposite::get_class_type()", header: "virtualFileComposite.h".}

proc get_file_system*(this: VirtualFileMount): VirtualFileSystem {.importcpp: "#->get_file_system()".} ## \
## Returns the file system this mount object is attached to.

proc get_mount_point*(this: VirtualFileMount): Filename {.importcpp: "#->get_mount_point()".} ## \
## Returns the name of the directory within the virtual file system that this
## mount object is attached to.  This directory name will end with a slash.

proc get_mount_flags*(this: VirtualFileMount): int {.importcpp: "#->get_mount_flags()".} ## \
## Returns the set of flags passed by the user to the
## VirtualFileSystem::mount() command.

proc output*(this: VirtualFileMount, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: VirtualFileMount, `out`: ostream) {.importcpp: "#->write(#)".}

proc get_class_type*(_: typedesc[VirtualFileMount]): TypeHandle {.importcpp: "VirtualFileMount::get_class_type()", header: "virtualFileMount.h".}

proc newVirtualFileMountMultifile*(multifile: Multifile): VirtualFileMountMultifile {.importcpp: "new VirtualFileMountMultifile(#)".}

proc get_multifile*(this: VirtualFileMountMultifile): Multifile {.importcpp: "#->get_multifile()".} ## \
## Returns the Multifile pointer that this mount object is based on.

proc get_class_type*(_: typedesc[VirtualFileMountMultifile]): TypeHandle {.importcpp: "VirtualFileMountMultifile::get_class_type()", header: "virtualFileMountMultifile.h".}

proc newVirtualFileMountRamdisk*(): VirtualFileMountRamdisk {.importcpp: "new VirtualFileMountRamdisk()".}

proc get_class_type*(_: typedesc[VirtualFileMountRamdisk]): TypeHandle {.importcpp: "VirtualFileMountRamdisk::get_class_type()", header: "virtualFileMountRamdisk.h".}

proc newVirtualFileMountSystem*(physical_filename: Filename): VirtualFileMountSystem {.importcpp: "new VirtualFileMountSystem(#)".}

proc get_physical_filename*(this: VirtualFileMountSystem): Filename {.importcpp: "#->get_physical_filename()".} ## \
## Returns the name of the source file on the OS filesystem of the directory
## or file that is mounted.

proc get_class_type*(_: typedesc[VirtualFileMountSystem]): TypeHandle {.importcpp: "VirtualFileMountSystem::get_class_type()", header: "virtualFileMountSystem.h".}

proc get_mount*(this: VirtualFileSimple): VirtualFileMount {.importcpp: "#->get_mount()".} ## \
## Returns the VirtualFileMount this file is associated with.

proc is_implicit_pz_file*(this: VirtualFileSimple): bool {.importcpp: "#->is_implicit_pz_file()".} ## \
## Returns true if this file is a .pz file that should be implicitly
## decompressed on load, or false if it is not a .pz file or if it should not
## be decompressed.

proc get_class_type*(_: typedesc[VirtualFileSimple]): TypeHandle {.importcpp: "VirtualFileSimple::get_class_type()", header: "virtualFileSimple.h".}

proc newTemporaryFile*(filename: Filename): TemporaryFile {.importcpp: "new TemporaryFile(#)".}

proc newTemporaryFile*(param0: TemporaryFile): TemporaryFile {.importcpp: "new TemporaryFile(#)".}

proc get_class_type*(_: typedesc[TemporaryFile]): TypeHandle {.importcpp: "TemporaryFile::get_class_type()", header: "temporaryFile.h".}

proc initIDecompressStream*(): IDecompressStream {.importcpp: "IDecompressStream()".}

proc initIDecompressStream*(source: istream, owns_source: bool): IDecompressStream {.importcpp: "IDecompressStream(#, #)".}

proc open*(this: IDecompressStream, source: istream, owns_source: bool): IDecompressStream {.importcpp: "#.open(#, #)".}

proc close*(this: IDecompressStream): IDecompressStream {.importcpp: "#.close()".} ## \
## Resets the ZStream to empty, but does not actually close the source istream
## unless owns_source was true.

proc initOCompressStream*(): OCompressStream {.importcpp: "OCompressStream()".}

proc initOCompressStream*(dest: ostream, owns_dest: bool, compression_level: int): OCompressStream {.importcpp: "OCompressStream(#, #, #)".}

proc initOCompressStream*(dest: ostream, owns_dest: bool): OCompressStream {.importcpp: "OCompressStream(#, #)".}

proc open*(this: OCompressStream, dest: ostream, owns_dest: bool, compression_level: int): OCompressStream {.importcpp: "#.open(#, #, #)".}

proc open*(this: OCompressStream, dest: ostream, owns_dest: bool): OCompressStream {.importcpp: "#.open(#, #)".}

proc close*(this: OCompressStream): OCompressStream {.importcpp: "#.close()".} ## \
## Resets the ZStream to empty, but does not actually close the dest ostream
## unless owns_dest was true.

proc get_num_files*(this: VirtualFileList): clonglong {.importcpp: "#->get_num_files()".} ## \
## Returns the number of files in the list.

proc get_file*(this: VirtualFileList, n: clonglong): VirtualFile {.importcpp: "#->get_file(#)".} ## \
## Returns the nth file in the list.

proc `[]`*(this: VirtualFileList, n: clonglong): VirtualFile {.importcpp: "#->operator [](#)".} ## \
## Returns the nth file in the list.

proc size*(this: VirtualFileList): clonglong {.importcpp: "#->size()".} ## \
## Returns the number of files in the list.

proc `+=`*(this: VirtualFileList, other: VirtualFileList): VirtualFileList {.importcpp: "#->operator +=(#)".}

proc `+`*(this: VirtualFileList, other: VirtualFileList): VirtualFileList {.importcpp: "#->operator +(#)".}

proc newVirtualFileList*(param0: VirtualFileList): VirtualFileList {.importcpp: "new VirtualFileList(#)".}

proc initVirtualFileSystem*(): VirtualFileSystem {.importcpp: "VirtualFileSystem()".}

proc mount*(this: VirtualFileSystem, physical_filename: Filename, mount_point: Filename, flags: int, password: string): bool {.importcpp: "#.mount(#, #, #, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Mounts the indicated system file or directory at the given mount point.  If
## the named file is a directory, mounts the directory.  If the named file is
## a Multifile, mounts it as a Multifile.  Returns true on success, false on
## failure.
##
## A given system directory may be mounted to multiple different mount point,
## and the same mount point may share multiple system directories.  In the
## case of ambiguities (that is, two different files with exactly the same
## full pathname), the most-recently mounted system wins.
##
## The filename specified as the first parameter must refer to a real,
## physical filename on disk; it cannot be a virtual file already appearing
## within the vfs filespace.  However, it is possible to mount such a file;
## see mount_loop() for this.
##
## Note that a mounted VirtualFileSystem directory is fully case-sensitive,
## unlike the native Windows file system, so you must refer to files within
## the virtual file system with exactly the right case.

proc mount*(this: VirtualFileSystem, physical_filename: Filename, mount_point: Filename, flags: int): bool {.importcpp: "#.mount(#, #, #)".} ## \
## Mounts the indicated system file or directory at the given mount point.  If
## the named file is a directory, mounts the directory.  If the named file is
## a Multifile, mounts it as a Multifile.  Returns true on success, false on
## failure.
##
## A given system directory may be mounted to multiple different mount point,
## and the same mount point may share multiple system directories.  In the
## case of ambiguities (that is, two different files with exactly the same
## full pathname), the most-recently mounted system wins.
##
## The filename specified as the first parameter must refer to a real,
## physical filename on disk; it cannot be a virtual file already appearing
## within the vfs filespace.  However, it is possible to mount such a file;
## see mount_loop() for this.
##
## Note that a mounted VirtualFileSystem directory is fully case-sensitive,
## unlike the native Windows file system, so you must refer to files within
## the virtual file system with exactly the right case.

proc mount*(this: VirtualFileSystem, multifile: Multifile, mount_point: Filename, flags: int): bool {.importcpp: "#.mount(#, #, #)".} ## \
## Mounts the indicated Multifile at the given mount point.

proc mount*(this: VirtualFileSystem, mount: VirtualFileMount, mount_point: Filename, flags: int): bool {.importcpp: "#.mount(#, #, #)".} ## \
## Adds the given VirtualFileMount object to the mount list.  This is a lower-
## level function than the other flavors of mount(); it requires you to create
## a VirtualFileMount object specifically.

proc mount_loop*(this: VirtualFileSystem, virtual_filename: Filename, mount_point: Filename, flags: int, password: string): bool {.importcpp: "#.mount_loop(#, #, #, nimStringToStdString(#))", header: stringConversionCode.} ## \
## This is similar to mount(), but it receives the name of a Multifile that
## already appears within the virtual file system.  It can be used to mount a
## Multifile that is itself hosted within a virtually-mounted Multifile.
##
## This interface can also be used to mount physical files (that appear within
## the virtual filespace), but it cannot be used to mount directories.  Use
## mount() if you need to mount a directory.
##
## Note that there is additional overhead, in the form of additional buffer
## copies of the data, for recursively mounting a multifile like this.

proc mount_loop*(this: VirtualFileSystem, virtual_filename: Filename, mount_point: Filename, flags: int): bool {.importcpp: "#.mount_loop(#, #, #)".} ## \
## This is similar to mount(), but it receives the name of a Multifile that
## already appears within the virtual file system.  It can be used to mount a
## Multifile that is itself hosted within a virtually-mounted Multifile.
##
## This interface can also be used to mount physical files (that appear within
## the virtual filespace), but it cannot be used to mount directories.  Use
## mount() if you need to mount a directory.
##
## Note that there is additional overhead, in the form of additional buffer
## copies of the data, for recursively mounting a multifile like this.

proc unmount*(this: VirtualFileSystem, physical_filename: Filename): int {.importcpp: "#.unmount(#)".} ## \
## Unmounts all appearances of the indicated directory name or multifile name
## from the file system.  Returns the number of appearances unmounted.

proc unmount*(this: VirtualFileSystem, multifile: Multifile): int {.importcpp: "#.unmount(#)".} ## \
## Unmounts all appearances of the indicated Multifile from the file system.
## Returns the number of appearances unmounted.

proc unmount*(this: VirtualFileSystem, mount: VirtualFileMount): int {.importcpp: "#.unmount(#)".} ## \
## Unmounts the indicated VirtualFileMount object from the file system.
## Returns the number of appearances unmounted.

proc unmount_point*(this: VirtualFileSystem, mount_point: Filename): int {.importcpp: "#.unmount_point(#)".} ## \
## Unmounts all systems attached to the given mount point from the file
## system.  Returns the number of appearances unmounted.

proc unmount_all*(this: VirtualFileSystem): int {.importcpp: "#.unmount_all()".} ## \
## Unmounts all files from the file system.  Returns the number of systems
## unmounted.

proc get_num_mounts*(this: VirtualFileSystem): int {.importcpp: "#.get_num_mounts()".} ## \
## Returns the number of individual mounts in the system.

proc get_mount*(this: VirtualFileSystem, n: int): VirtualFileMount {.importcpp: "#.get_mount(#)".} ## \
## Returns the nth mount in the system.

proc chdir*(this: VirtualFileSystem, new_directory: Filename): bool {.importcpp: "#.chdir(#)".} ## \
## Changes the current directory.  This is used to resolve relative pathnames
## in get_file() and/or find_file().  Returns true if successful, false
## otherwise.

proc get_cwd*(this: VirtualFileSystem): Filename {.importcpp: "#.get_cwd()".} ## \
## Returns the current directory name.  See chdir().

proc make_directory*(this: VirtualFileSystem, filename: Filename): bool {.importcpp: "#.make_directory(#)".} ## \
## Attempts to create a directory within the file system.  Returns true on
## success, false on failure (for instance, because the parent directory does
## not exist, or is read-only).  If the directory already existed prior to
## this call, returns true.

proc make_directory_full*(this: VirtualFileSystem, filename: Filename): bool {.importcpp: "#.make_directory_full(#)".} ## \
## Attempts to create a directory within the file system.  Will also create
## any intervening directories needed.  Returns true on success, false on
## failure.

proc get_file*(this: VirtualFileSystem, filename: Filename, status_only: bool): VirtualFile {.importcpp: "#.get_file(#, #)".} ## \
## Looks up the file by the indicated name in the file system.  Returns a
## VirtualFile pointer representing the file if it is found, or NULL if it is
## not.
##
## If status_only is true, the file will be checked for existence and length
## and so on, but the returned file's contents cannot be read.  This is an
## optimization which is especially important for certain mount types, for
## instance HTTP, for which opening a file to determine its status is
## substantially less expensive than opening it to read its contents.

proc get_file*(this: VirtualFileSystem, filename: Filename): VirtualFile {.importcpp: "#.get_file(#)".} ## \
## Looks up the file by the indicated name in the file system.  Returns a
## VirtualFile pointer representing the file if it is found, or NULL if it is
## not.
##
## If status_only is true, the file will be checked for existence and length
## and so on, but the returned file's contents cannot be read.  This is an
## optimization which is especially important for certain mount types, for
## instance HTTP, for which opening a file to determine its status is
## substantially less expensive than opening it to read its contents.

proc create_file*(this: VirtualFileSystem, filename: Filename): VirtualFile {.importcpp: "#.create_file(#)".} ## \
## Attempts to create a file by the indicated name in the filesystem, if
## possible, and returns it.  If a file by this name already exists, returns
## the same thing as get_file().  If the filename is located within a read-
## only directory, or the directory doesn't exist, returns NULL.

proc find_file*(this: VirtualFileSystem, filename: Filename, searchpath: DSearchPath, status_only: bool): VirtualFile {.importcpp: "#.find_file(#, #, #)".} ## \
## Uses the indicated search path to find the file within the file system.
## Returns the first occurrence of the file found, or NULL if the file cannot
## be found.

proc find_file*(this: VirtualFileSystem, filename: Filename, searchpath: DSearchPath): VirtualFile {.importcpp: "#.find_file(#, #)".} ## \
## Uses the indicated search path to find the file within the file system.
## Returns the first occurrence of the file found, or NULL if the file cannot
## be found.

proc delete_file*(this: VirtualFileSystem, filename: Filename): bool {.importcpp: "#.delete_file(#)".} ## \
## Attempts to delete the indicated file or directory.  This can remove a
## single file or an empty directory.  It will not remove a nonempty
## directory.  Returns true on success, false on failure.

proc rename_file*(this: VirtualFileSystem, orig_filename: Filename, new_filename: Filename): bool {.importcpp: "#.rename_file(#, #)".} ## \
## Attempts to move or rename the indicated file or directory.  If the
## original file is an ordinary file, it will quietly replace any already-
## existing file in the new filename (but not a directory).  If the original
## file is a directory, the new filename must not already exist.
##
## If the file is a directory, the new filename must be within the same mount
## point.  If the file is an ordinary file, the new filename may be anywhere;
## but if it is not within the same mount point then the rename operation is
## automatically performed as a two-step copy-and-delete operation.

proc copy_file*(this: VirtualFileSystem, orig_filename: Filename, new_filename: Filename): bool {.importcpp: "#.copy_file(#, #)".} ## \
## Attempts to copy the contents of the indicated file to the indicated file.
## Returns true on success, false on failure.

proc resolve_filename*(this: VirtualFileSystem, filename: Filename, searchpath: DSearchPath, default_extension: string): bool {.importcpp: "#.resolve_filename(#, #, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Searches the given search path for the filename.  If it is found, updates
## the filename to the full pathname found and returns true; otherwise,
## returns false.

proc resolve_filename*(this: VirtualFileSystem, filename: Filename, searchpath: DSearchPath): bool {.importcpp: "#.resolve_filename(#, #)".} ## \
## Searches the given search path for the filename.  If it is found, updates
## the filename to the full pathname found and returns true; otherwise,
## returns false.

proc exists*(this: VirtualFileSystem, filename: Filename): bool {.importcpp: "#.exists(#)".} ## \
## Convenience function; returns true if the named file exists.

proc is_directory*(this: VirtualFileSystem, filename: Filename): bool {.importcpp: "#.is_directory(#)".} ## \
## Convenience function; returns true if the named file exists and is a
## directory.

proc is_regular_file*(this: VirtualFileSystem, filename: Filename): bool {.importcpp: "#.is_regular_file(#)".} ## \
## Convenience function; returns true if the named file exists and is a
## regular file.

proc scan_directory*(this: VirtualFileSystem, filename: Filename): VirtualFileList {.importcpp: "#.scan_directory(#)".} ## \
## If the file represents a directory (that is, is_directory() returns true),
## this returns the list of files within the directory at the current time.
## Returns NULL if the file is not a directory or if the directory cannot be
## read.

proc ls*(this: VirtualFileSystem, filename: Filename) {.importcpp: "#.ls(#)".} ## \
## Convenience function; lists the files within the indicated directory.

proc ls_all*(this: VirtualFileSystem, filename: Filename) {.importcpp: "#.ls_all(#)".} ## \
## Convenience function; lists the files within the indicated directory, and
## all files below, recursively.

proc write*(this: VirtualFileSystem, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Print debugging information.  (e.g.  from Python or gdb prompt).

proc get_global_ptr*(_: typedesc[VirtualFileSystem]): VirtualFileSystem {.importcpp: "VirtualFileSystem::get_global_ptr()", header: "virtualFileSystem.h".} ## \
## Returns the default global VirtualFileSystem.  You may create your own
## personal VirtualFileSystem objects and use them for whatever you like, but
## Panda will attempt to load models and stuff from this default object.
##
## Initially, the global VirtualFileSystem is set up to mount the OS
## filesystem to root; i.e.  it is equivalent to the OS filesystem.  This may
## be subsequently adjusted by the user.

proc open_read_file*(this: VirtualFileSystem, filename: Filename, auto_unwrap: bool): istream {.importcpp: "#.open_read_file(#, #)".} ## \
## Convenience function; returns a newly allocated istream if the file exists
## and can be read, or NULL otherwise.  Does not return an invalid istream.
##
## If auto_unwrap is true, an explicitly-named .pz file is automatically
## decompressed and the decompressed contents are returned.  This is different
## than vfs-implicit-pz, which will automatically decompress a file if the
## extension .pz is *not* given.

proc close_read_file*(_: typedesc[VirtualFileSystem], stream: istream) {.importcpp: "VirtualFileSystem::close_read_file(#)", header: "virtualFileSystem.h".} ## \
## Closes a file opened by a previous call to open_read_file().  This really
## just deletes the istream pointer, but it is recommended to use this
## interface instead of deleting it explicitly, to help work around compiler
## issues.

proc open_write_file*(this: VirtualFileSystem, filename: Filename, auto_wrap: bool, truncate: bool): ostream {.importcpp: "#.open_write_file(#, #, #)".} ## \
## Convenience function; returns a newly allocated ostream if the file exists
## and can be written, or NULL otherwise.  Does not return an invalid ostream.
##
## If auto_wrap is true, an explicitly-named .pz file is automatically
## compressed while writing.  If truncate is true, the file is truncated to
## zero length before writing.

proc open_append_file*(this: VirtualFileSystem, filename: Filename): ostream {.importcpp: "#.open_append_file(#)".} ## \
## Works like open_write_file(), but the file is opened in append mode.  Like
## open_write_file, the returned pointer should eventually be passed to
## close_write_file().

proc close_write_file*(_: typedesc[VirtualFileSystem], stream: ostream) {.importcpp: "VirtualFileSystem::close_write_file(#)", header: "virtualFileSystem.h".} ## \
## Closes a file opened by a previous call to open_write_file().  This really
## just deletes the ostream pointer, but it is recommended to use this
## interface instead of deleting it explicitly, to help work around compiler
## issues.

proc open_read_write_file*(this: VirtualFileSystem, filename: Filename, truncate: bool): iostream {.importcpp: "#.open_read_write_file(#, #)".} ## \
## Convenience function; returns a newly allocated iostream if the file exists
## and can be written, or NULL otherwise.  Does not return an invalid
## iostream.

proc open_read_append_file*(this: VirtualFileSystem, filename: Filename): iostream {.importcpp: "#.open_read_append_file(#)".} ## \
## Works like open_read_write_file(), but the file is opened in append mode.
## Like open_read_write_file, the returned pointer should eventually be passed
## to close_read_write_file().

proc close_read_write_file*(_: typedesc[VirtualFileSystem], stream: iostream) {.importcpp: "VirtualFileSystem::close_read_write_file(#)", header: "virtualFileSystem.h".} ## \
## Closes a file opened by a previous call to open_read_write_file().  This
## really just deletes the iostream pointer, but it is recommended to use this
## interface instead of deleting it explicitly, to help work around compiler
## issues.

proc get_long_time*(this: TrueClock): float64 {.importcpp: "#.get_long_time()".} ## \
## get_long_time() returns the most accurate timer we have over a long
## interval.  It may not be very precise for measuring short intervals, but
## it should not drift substantially over the long haul.

proc get_short_time*(this: TrueClock): float64 {.importcpp: "#.get_short_time()".} ## \
## get_short_time() returns the most precise timer we have over a short
## interval.  It may tend to drift over the long haul, but it should have
## lots of digits to measure short intervals very precisely.

proc get_short_raw_time*(this: TrueClock): float64 {.importcpp: "#.get_short_raw_time()".} ## \
## get_short_raw_time() is like get_short_time(), but does not apply any
## corrections (e.g.  paranoid-clock) to the result returned by the OS.

proc get_error_count*(this: TrueClock): int {.importcpp: "#.get_error_count()".} ## \
## Returns the number of clock errors that have been detected.  Each time a
## clock error is detected, in which the value returned by either of the above
## methods is suspect, the value returned by this method will be incremented.
## Applications can monitor this value and react, for instance, by
## resynchronizing their clocks each time this value changes.

proc get_global_ptr*(_: typedesc[TrueClock]): TrueClock {.importcpp: "TrueClock::get_global_ptr()", header: "trueClock.h".} ## \
## Returns a pointer to the one TrueClock object in the world.

proc set_cpu_affinity*(this: TrueClock, mask: int): bool {.importcpp: "#.set_cpu_affinity(#)".}

proc initPatchfile*(): Patchfile {.importcpp: "Patchfile()".} ## \
## Create a patch file and initializes internal data

proc initPatchfile*(buffer: Buffer): Patchfile {.importcpp: "Patchfile(#)".} ## \
## Create patch file with buffer to patch

proc build*(this: Patchfile, file_orig: Filename, file_new: Filename, patch_name: Filename): bool {.importcpp: "#.build(#, #, #)".} ## \
## This implementation uses the "greedy differencing algorithm" described in
## the masters thesis "Differential Compression: A Generalized Solution for
## Binary Files" by Randal C. Burns (p.13). For an original file of size M and
## a new file of size N, this algorithm is O(M) in space and O(M*N) (worst-
## case) in time.  return false on error

proc read_header*(this: Patchfile, patch_file: Filename): int {.importcpp: "#.read_header(#)".} ## \
## Opens the patch file for reading, and gets the header information from the
## file but does not begin to do any real work.  This can be used to query the
## data stored in the patch.

proc initiate*(this: Patchfile, patch_file: Filename, file: Filename): int {.importcpp: "#.initiate(#, #)".} ## \
## Set up to apply the patch to the file (original file and patch are
## destroyed in the process).

proc initiate*(this: Patchfile, patch_file: Filename, orig_file: Filename, target_file: Filename): int {.importcpp: "#.initiate(#, #, #)".} ## \
## Set up to apply the patch to the file.  In this form, neither the original
## file nor the patch file are destroyed.

proc run*(this: Patchfile): int {.importcpp: "#.run()".} ## \
## Perform one buffer's worth of patching.
## Returns one of the following values:
## @li @c EU_ok : while patching
## @li @c EU_success : when done
## @li @c EU_error_abort : Patching has not been initiated
## @li @c EU_error_file_invalid : file is corrupted
## @li @c EU_error_invalid_checksum : incompatible patch file
## @li @c EU_error_write_file_rename : could not rename file

proc apply*(this: Patchfile, patch_file: Filename, file: Filename): bool {.importcpp: "#.apply(#, #)".} ## \
## Patches the entire file in one call returns true on success and false on
## error
##
## This version will delete the patch file and overwrite the original file.

proc apply*(this: Patchfile, patch_file: Filename, orig_file: Filename, target_file: Filename): bool {.importcpp: "#.apply(#, #, #)".} ## \
## Patches the entire file in one call returns true on success and false on
## error
##
## This version will not delete any files.

proc get_progress*(this: Patchfile): float32 {.importcpp: "#.get_progress()".} ## \
## Returns a value in the range 0..1, representing the amount of progress
## through the patchfile, during a session.

proc set_allow_multifile*(this: Patchfile, allow_multifile: bool) {.importcpp: "#.set_allow_multifile(#)".} ## \
## If this flag is set true, the Patchfile will make a special case for
## patching Panda Multifiles, if detected, and attempt to patch them on a
## subfile-by-subfile basis.  If this flag is false, the Patchfile will always
## patch the file on a full-file basis.
##
## This has effect only when building patches; it is not used for applying
## patches.

proc get_allow_multifile*(this: Patchfile): bool {.importcpp: "#.get_allow_multifile()".} ## \
## See set_allow_multifile().

proc set_footprint_length*(this: Patchfile, length: int) {.importcpp: "#.set_footprint_length(#)".}

proc get_footprint_length*(this: Patchfile): int {.importcpp: "#.get_footprint_length()".}

proc reset_footprint_length*(this: Patchfile) {.importcpp: "#.reset_footprint_length()".}

proc has_source_hash*(this: Patchfile): bool {.importcpp: "#.has_source_hash()".} ## \
## Returns true if the MD5 hash for the source file is known.  (Some early
## versions of the patch file did not store this information.)

proc get_source_hash*(this: Patchfile): HashVal {.importcpp: "#.get_source_hash()".} ## \
## Returns the MD5 hash for the source file.

proc get_result_hash*(this: Patchfile): HashVal {.importcpp: "#.get_result_hash()".} ## \
## Returns the MD5 hash for the file after the patch has been applied.

proc password_hash*(password: string, salt: string, iters: int, keylen: int): string {.importcpp: "nimStringFromStdString(password_hash(nimStringToStdString(#), nimStringToStdString(#), #, #))", header: stringConversionCode.}

proc initProfileTimer*(other: ProfileTimer): ProfileTimer {.importcpp: "ProfileTimer(#)".}

proc initProfileTimer*(name: string, maxEntries: int): ProfileTimer {.importcpp: "ProfileTimer(nimStringToStdString(#), #)", header: stringConversionCode.}

proc initProfileTimer*(name: string): ProfileTimer {.importcpp: "ProfileTimer(nimStringToStdString(#))", header: stringConversionCode.}

proc initProfileTimer*(): ProfileTimer {.importcpp: "ProfileTimer()".}

proc init*(this: ProfileTimer, name: string, maxEntries: int) {.importcpp: "#.init(nimStringToStdString(#), #)", header: stringConversionCode.}

proc init*(this: ProfileTimer, name: string) {.importcpp: "#.init(nimStringToStdString(#))", header: stringConversionCode.}

proc on*(this: ProfileTimer) {.importcpp: "#.on()".}

proc mark*(this: ProfileTimer, tag: string) {.importcpp: "#.mark(nimStringToStdString(#))", header: stringConversionCode.}

proc off*(this: ProfileTimer) {.importcpp: "#.off()".}

proc off*(this: ProfileTimer, tag: string) {.importcpp: "#.off(nimStringToStdString(#))", header: stringConversionCode.}

proc getTotalTime*(this: ProfileTimer): float64 {.importcpp: "#.getTotalTime()".} ## \
## Don't call any of the following during timing: (Because they are slow,
## not because anything will break).

proc consolidateAllTo*(_: typedesc[ProfileTimer], `out`: ostream) {.importcpp: "ProfileTimer::consolidateAllTo(#)", header: "profileTimer.h".}

proc consolidateAllTo*(_: typedesc[ProfileTimer]) {.importcpp: "ProfileTimer::consolidateAllTo()", header: "profileTimer.h".}

proc consolidateTo*(this: ProfileTimer, `out`: ostream) {.importcpp: "#.consolidateTo(#)".}

proc consolidateTo*(this: ProfileTimer) {.importcpp: "#.consolidateTo()".}

proc printAllTo*(_: typedesc[ProfileTimer], `out`: ostream) {.importcpp: "ProfileTimer::printAllTo(#)", header: "profileTimer.h".}

proc printAllTo*(_: typedesc[ProfileTimer]) {.importcpp: "ProfileTimer::printAllTo()", header: "profileTimer.h".}

proc printTo*(this: ProfileTimer, `out`: ostream) {.importcpp: "#.printTo(#)".}

proc printTo*(this: ProfileTimer) {.importcpp: "#.printTo()".}

proc was_deleted*(this: WeakPointerToVoid): bool {.importcpp: "#.was_deleted()".} ## \
## Returns true if the object we are pointing to has been deleted, false
## otherwise.  If this returns true, it means that the pointer can not yet be
## reused, but it does not guarantee that it can be safely accessed.  See the
## lock() method for a safe way to access the underlying pointer.
##
## This will always return true for a null pointer, unlike is_valid_pointer().

proc is_valid_pointer*(this: WeakPointerToVoid): bool {.importcpp: "#.is_valid_pointer()".} ## \
## Returns true if the pointer is not null and the object has not been
## deleted.  See was_deleted() for caveats.

proc set_string_value*(_: typedesc[WindowsRegistry], key: string, name: string, value: string): bool {.importcpp: "WindowsRegistry::set_string_value(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the registry key to the indicated value as a string.  The supplied
## string value is automatically converted from whatever encoding is set by
## TextEncoder::set_default_encoding() and written as a Unicode string.  The
## registry key must already exist prior to calling this function.

proc set_int_value*(_: typedesc[WindowsRegistry], key: string, name: string, value: int): bool {.importcpp: "WindowsRegistry::set_int_value(nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Sets the registry key to the indicated value as an integer.  The registry
## key must already exist prior to calling this function.

proc get_string_value*(_: typedesc[WindowsRegistry], key: string, name: string, default_value: string): string {.importcpp: "nimStringFromStdString(WindowsRegistry::get_string_value(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Returns the value associated with the indicated registry key, assuming it
## is a string value.  The string value is automatically encoded using
## TextEncoder::get_default_encoding().  If the key is not defined or is not a
## string type value, default_value is returned instead.

proc get_int_value*(_: typedesc[WindowsRegistry], key: string, name: string, default_value: int): int {.importcpp: "WindowsRegistry::get_int_value(nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Returns the value associated with the indicated registry key, assuming it
## is an integer value.  If the key is not defined or is not an integer type
## value, default_value is returned instead.

proc initWindowsRegistry*(): WindowsRegistry {.importcpp: "WindowsRegistry()".}

proc initWindowsRegistry*(param0: WindowsRegistry): WindowsRegistry {.importcpp: "WindowsRegistry(#)".}

proc is_recording*(this: RecorderBase): bool {.importcpp: "#.is_recording()".} ## \
## Returns true if this recorder is presently recording data for saving to a
## session file, false otherwise.  If this is true, record_data() will be
## called from time to time.

proc is_playing*(this: RecorderBase): bool {.importcpp: "#.is_playing()".} ## \
## Returns true if this recorder is presently playing back data from session
## file, false otherwise.  If this is true, play_data() will be called from
## time to time.

proc get_class_type*(_: typedesc[RecorderBase]): TypeHandle {.importcpp: "RecorderBase::get_class_type()", header: "recorderBase.h".}

converter upcast_to_DataNode*(this: MouseRecorder): DataNode {.importcpp: "(PT(DataNode)(#))".}

converter upcast_to_RecorderBase*(this: MouseRecorder): RecorderBase {.importcpp: "((RecorderBase *)(#.p()))".}

proc newMouseRecorder*(name: string): MouseRecorder {.importcpp: "new MouseRecorder(nimStringToStdString(#))", header: stringConversionCode.}

proc get_class_type*(_: typedesc[MouseRecorder]): TypeHandle {.importcpp: "MouseRecorder::get_class_type()", header: "mouseRecorder.h".}

proc newRecorderController*(): RecorderController {.importcpp: "new RecorderController()".}

proc begin_record*(this: RecorderController, filename: Filename): bool {.importcpp: "#->begin_record(#)".} ## \
## Begins recording data to the indicated filename.  All of the recorders in
## use should already have been added.

proc begin_playback*(this: RecorderController, filename: Filename): bool {.importcpp: "#->begin_playback(#)".} ## \
## Begins playing back data from the indicated filename.  All of the recorders
## in use should already have been added, although this may define additional
## recorders if they are present in the file (these new recorders will not be
## used).  This may also undefine recorders that were previously added but are
## not present in the file.

proc close*(this: RecorderController) {.importcpp: "#->close()".} ## \
## Finishes recording data to the indicated filename.

proc get_start_time*(this: RecorderController): int {.importcpp: "#->get_start_time()".} ## \
## Returns the time (and date) at which the current session was originally
## recorded (or, in recording mode, the time at which the current session
## began).

proc set_random_seed*(this: RecorderController, random_seed: int) {.importcpp: "#->set_random_seed(#)".} ## \
## Indicates an arbitrary number to be recorded in the session file as a
## random seed, should the application wish to take advantage of it.  This
## must be set before begin_record() is called.

proc get_random_seed*(this: RecorderController): int {.importcpp: "#->get_random_seed()".} ## \
## Returns the random seed that was set by a previous call to
## set_random_seed(), or the number read from the session file after
## begin_playback() has been called.

proc is_recording*(this: RecorderController): bool {.importcpp: "#->is_recording()".} ## \
## Returns true if the controller has been opened for output, false otherwise.

proc is_playing*(this: RecorderController): bool {.importcpp: "#->is_playing()".} ## \
## Returns true if the controller has been opened for input, false otherwise.

proc is_open*(this: RecorderController): bool {.importcpp: "#->is_open()".} ## \
## Returns true if the controller has been opened for either input or output,
## false otherwise.

proc get_filename*(this: RecorderController): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the filename that was passed to the most recent call to
## begin_record() or begin_playback().

proc is_error*(this: RecorderController): bool {.importcpp: "#->is_error()".} ## \
## Returns true if the controller has been opened for input or output output
## and there is an error on the stream, or false if the controller is closed
## or if there is no problem.

proc get_clock_offset*(this: RecorderController): float64 {.importcpp: "#->get_clock_offset()".} ## \
## Returns the delta offset between the actual frame time and the frame time
## written to the log.  This is essentially the time at which the recording
## (or playback) started.

proc get_frame_offset*(this: RecorderController): int {.importcpp: "#->get_frame_offset()".} ## \
## Returns the delta offset between the actual frame count and the frame count
## written to the log.  This is essentially the frame number at which the
## recording (or playback) started.

proc add_recorder*(this: RecorderController, name: string, recorder: RecorderBase) {.importcpp: "#->add_recorder(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Adds the named recorder to the set of recorders that are in use.
##
## If the controller is in recording mode, the named recorder will begin
## recording its status to the session file.  If the controller is in playback
## mode and the name and type matches a recorder in the session file, the
## recorder will begin receiving data.

proc has_recorder*(this: RecorderController, name: string): bool {.importcpp: "#->has_recorder(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if the named recorder has been added to the table by a
## previous call to add_recorder(), false otherwise.
##
## If the controller is in playback mode, this will also return false for a
## recorder that was found in the session file but was never explicitly added
## via add_recorder(); see get_recorder().

proc get_recorder*(this: RecorderController, name: string): RecorderBase {.importcpp: "#->get_recorder(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the recorder with the indicated name, or NULL if there is no such
## recorder.
##
## If the controller is in playback mode, this may return the recorder
## matching the indicated name as read from the session file, even if it was
## never added to the table by the user.  In this case, has_recorder() may
## return false, but get_recorder() will return a non-NULL value.

proc remove_recorder*(this: RecorderController, name: string): bool {.importcpp: "#->remove_recorder(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the named recorder from the table.  Returns true if successful,
## false if there was no such recorder.
##
## If the controller is in recording mode, the named recorder will stop
## recording.  If the controller is in playback mode, the named recorder will
## disassociate itself from the session file (but if the session file still
## has data for this name, a default recorder will take its place to decode
## the data from the session file).

proc set_frame_tie*(this: RecorderController, frame_tie: bool) {.importcpp: "#->set_frame_tie(#)".} ## \
## Sets the frame_tie flag.
##
## When this is true, sessions are played back frame-for-frame, based on the
## frame count of the recorded session.  This gives the most accurate
## playback, but the playback rate will vary according to the frame rate of
## the playback machine.
##
## When this is false, sessions are played back at real time, based on the
## clock of the recorded session.  This may introduce playback discrepencies
## if the frames do not fall at exactly the same times as they did in the
## original.

proc get_frame_tie*(this: RecorderController): bool {.importcpp: "#->get_frame_tie()".} ## \
## See set_frame_tie().

proc record_frame*(this: RecorderController) {.importcpp: "#->record_frame()".} ## \
## Gets the next frame of data from all of the active recorders and adds it to
## the output file.

proc play_frame*(this: RecorderController) {.importcpp: "#->play_frame()".} ## \
## Gets the next frame of data from all of the active recorders and adds it to
## the output file.

proc get_class_type*(_: typedesc[RecorderController]): TypeHandle {.importcpp: "RecorderController::get_class_type()", header: "recorderController.h".}

converter upcast_to_RecorderBase*(this: SocketStreamRecorder): RecorderBase {.importcpp: "((RecorderBase *)(#.p()))".}

converter upcast_to_ReferenceCount*(this: SocketStreamRecorder): ReferenceCount {.importcpp: "(PT(ReferenceCount)(#))".}

proc newSocketStreamRecorder*(): SocketStreamRecorder {.importcpp: "new SocketStreamRecorder()".}

proc newSocketStreamRecorder*(stream: SocketStream, owns_stream: bool): SocketStreamRecorder {.importcpp: "new SocketStreamRecorder(#, #)".}

proc receive_datagram*(this: SocketStreamRecorder, dg: Datagram): bool {.importcpp: "#->receive_datagram(#)".} ## \
## Receives a datagram over the socket by expecting a little-endian 16-bit
## byte count as a prefix.  If the socket stream is non-blocking, may return
## false if the data is not available; otherwise, returns false only if the
## socket closes.

proc send_datagram*(this: SocketStreamRecorder, dg: Datagram): bool {.importcpp: "#->send_datagram(#)".} ## \
## See SocketStream::send_datagram().

proc is_closed*(this: SocketStreamRecorder): bool {.importcpp: "#->is_closed()".} ## \
## See SocketStream::is_closed().

proc close*(this: SocketStreamRecorder) {.importcpp: "#->close()".} ## \
## See SocketStream::close().

proc set_collect_tcp*(this: SocketStreamRecorder, collect_tcp: bool) {.importcpp: "#->set_collect_tcp(#)".} ## \
## See SocketStream::set_collect_tcp().

proc get_collect_tcp*(this: SocketStreamRecorder): bool {.importcpp: "#->get_collect_tcp()".} ## \
## See SocketStream::get_collect_tcp().

proc set_collect_tcp_interval*(this: SocketStreamRecorder, interval: float64) {.importcpp: "#->set_collect_tcp_interval(#)".} ## \
## See SocketStream::set_collect_tcp_interval().

proc get_collect_tcp_interval*(this: SocketStreamRecorder): float64 {.importcpp: "#->get_collect_tcp_interval()".} ## \
## See SocketStream::get_collect_tcp_interval().

proc consider_flush*(this: SocketStreamRecorder): bool {.importcpp: "#->consider_flush()".} ## \
## See SocketStream::consider_flush()

proc flush*(this: SocketStreamRecorder): bool {.importcpp: "#->flush()".} ## \
## See SocketStream::flush()

proc get_class_type*(_: typedesc[SocketStreamRecorder]): TypeHandle {.importcpp: "SocketStreamRecorder::get_class_type()", header: "socketStreamRecorder.h".}

converter upcast_to_Light*(this: LightNode): Light {.importcpp: "((Light *)(#.p()))".}

converter upcast_to_PandaNode*(this: LightNode): PandaNode {.importcpp: "(PT(PandaNode)(#))".}

proc output*(this: LightNode, `out`: ostream) {.importcpp: "#->output(#)".} ## \
## We have to explicitly publish these because they resolve the multiple
## inheritance.

proc write*(this: LightNode, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: LightNode, `out`: ostream) {.importcpp: "#->write(#)".}

proc get_class_type*(_: typedesc[LightNode]): TypeHandle {.importcpp: "LightNode::get_class_type()", header: "lightNode.h".}

proc newAmbientLight*(name: string): AmbientLight {.importcpp: "new AmbientLight(nimStringToStdString(#))", header: stringConversionCode.}

proc get_class_type*(_: typedesc[AmbientLight]): TypeHandle {.importcpp: "AmbientLight::get_class_type()", header: "ambientLight.h".}

proc newCallbackNode*(name: string): CallbackNode {.importcpp: "new CallbackNode(nimStringToStdString(#))", header: stringConversionCode.}

proc set_cull_callback*(this: CallbackNode, `object`: CallbackObject) {.importcpp: "#->set_cull_callback(#)".} ## \
## Sets the CallbackObject that will be notified when this node is visited
## during the cull traversal.  This callback will be made during the cull
## thread.
##
## The cull traversal is responsible for determining which nodes are visible
## and within the view frustum, and for accumulating state and transform, and
## generally building up the list of CullableObjects that are to be eventually
## passed to the draw traversal for rendering.
##
## At the time the cull traversal callback is made, the node has been
## determined to be visible and it has passed the bounding-volume test, so it
## lies within the view frustum.
##
## The callback is passed an instance of a NodeCullCallbackData, which
## contains pointers to the CullTraverser and CullTraverserData--enough data
## to examine the current node and its place within the scene graph.  The
## callback *replaces* the normal cull behavior, so if your callback does
## nothing, the cull traversal will not continue below this node.  If you wish
## the cull traversal to continue to visit this node and below, you must call
## cbdata->upcall() from your callback.

proc clear_cull_callback*(this: CallbackNode) {.importcpp: "#->clear_cull_callback()".} ## \
## Removes the callback set by an earlier call to set_cull_callback().

proc get_cull_callback*(this: CallbackNode): CallbackObject {.importcpp: "#->get_cull_callback()".} ## \
## Returns the CallbackObject set by set_cull_callback().

proc set_draw_callback*(this: CallbackNode, `object`: CallbackObject) {.importcpp: "#->set_draw_callback(#)".} ## \
## Sets the CallbackObject that will be notified when this node is visited
## during the draw traversal.  This callback will be made during the draw
## thread.
##
## The draw traversal is responsible for actually issuing the commands to the
## graphics engine to draw primitives.  Its job is to walk through the list of
## CullableObjects build up by the cull traversal, as quickly as possible,
## issuing the appropriate commands to draw each one.
##
## At the time the draw traversal callback is made, the graphics state has
## been loaded with the correct modelview transform and render state, and the
## primitives (if any) in this node are ready to be drawn.
##
## The callback is passed an instance of a GeomDrawCallbackData, which
## contains pointers to the current state and transform, as well as the
## current GSG.  There is a Geom pointer as well, but it will always be NULL
## to this callback, since the CallbackNode does not itself contain any Geoms.

proc clear_draw_callback*(this: CallbackNode) {.importcpp: "#->clear_draw_callback()".} ## \
## Removes the callback set by an earlier call to set_draw_callback().

proc get_draw_callback*(this: CallbackNode): CallbackObject {.importcpp: "#->get_draw_callback()".} ## \
## Returns the CallbackObject set by set_draw_callback().

proc get_class_type*(_: typedesc[CallbackNode]): TypeHandle {.importcpp: "CallbackNode::get_class_type()", header: "callbackNode.h".}

proc newComputeNode*(name: string): ComputeNode {.importcpp: "new ComputeNode(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates a ComputeNode with the given name.  Use add_dispatch and  also
## assign a shader using a ShaderAttrib.

proc add_dispatch*(this: ComputeNode, num_groups: LVecBase3i) {.importcpp: "#->add_dispatch(#)".} ## \
## Adds a dispatch command with the given number of work groups in the X, Y,
## and Z dimensions.  Any of these values may be set to 1 if the respective
## dimension should not be used.

proc add_dispatch*(this: ComputeNode, num_groups_x: int, num_groups_y: int, num_groups_z: int) {.importcpp: "#->add_dispatch(#, #, #)".} ## \
## Adds a dispatch command with the given number of work groups in the X, Y,
## and Z dimensions.  Any of these values may be set to 1 if the respective
## dimension should not be used.

proc get_num_dispatches*(this: ComputeNode): clonglong {.importcpp: "#->get_num_dispatches()".} ## \
## Returns the number of times add_dispatch has been called on this object.

proc get_dispatch*(this: ComputeNode, i: clonglong): LVecBase3i {.importcpp: "#->get_dispatch(#)".} ## \
## Returns the group counts of the nth dispatch associated with this object.

proc set_dispatch*(this: ComputeNode, i: clonglong, num_groups: LVecBase3i) {.importcpp: "#->set_dispatch(#, #)".} ## \
## Sets the group counts of the nth dispatch associated with this object.

proc insert_dispatch*(this: ComputeNode, i: clonglong, num_groups: LVecBase3i) {.importcpp: "#->insert_dispatch(#, #)".} ## \
## Inserts a dispatch command with the given number of work groups in the X,
## Y, and Z dimensions at the given position in the list of dispatch commands.
## Any of these values may be set to 1 if the respective dimension should not
## be used.

proc remove_dispatch*(this: ComputeNode, i: clonglong) {.importcpp: "#->remove_dispatch(#)".} ## \
## Erases the given dispatch index from the list.

proc clear_dispatches*(this: ComputeNode) {.importcpp: "#->clear_dispatches()".} ## \
## Removes all dispatch commands.

proc get_class_type*(_: typedesc[ComputeNode]): TypeHandle {.importcpp: "ComputeNode::get_class_type()", header: "computeNode.h".}

converter upcast_to_Light*(this: LightLensNode): Light {.importcpp: "((Light *)(#.p()))".}

converter upcast_to_Camera*(this: LightLensNode): Camera {.importcpp: "(PT(Camera)(#))".}

proc has_specular_color*(this: LightLensNode): bool {.importcpp: "#->has_specular_color()".} ## \
## Returns true if this light defines a specular color, false if the specular
## color is derived automatically from the light color.

proc is_shadow_caster*(this: LightLensNode): bool {.importcpp: "#->is_shadow_caster()".} ## \
## Returns whether this light is configured to cast shadows or not.

proc set_shadow_caster*(this: LightLensNode, caster: bool) {.importcpp: "#->set_shadow_caster(#)".} ## \
## Sets the flag indicating whether this light should cast shadows or not.
## This is the variant without buffer size, meaning that the current buffer
## size will be kept (512x512 is the default). Note that enabling shadows will
## require the shader generator to be enabled on the scene.

proc set_shadow_caster*(this: LightLensNode, caster: bool, buffer_xsize: int, buffer_ysize: int, sort: int) {.importcpp: "#->set_shadow_caster(#, #, #, #)".} ## \
## Sets the flag indicating whether this light should cast shadows or not.
## The xsize and ysize parameters specify the size of the shadow buffer that
## will be set up, the sort parameter specifies the sort.  Note that enabling
## shadows will require the shader generator to be enabled on the scene.

proc set_shadow_caster*(this: LightLensNode, caster: bool, buffer_xsize: int, buffer_ysize: int) {.importcpp: "#->set_shadow_caster(#, #, #)".} ## \
## Sets the flag indicating whether this light should cast shadows or not.
## The xsize and ysize parameters specify the size of the shadow buffer that
## will be set up, the sort parameter specifies the sort.  Note that enabling
## shadows will require the shader generator to be enabled on the scene.

proc get_shadow_buffer_sort*(this: LightLensNode): int {.importcpp: "#->get_shadow_buffer_sort()".} ## \
## Returns the sort of the shadow buffer to be created for this light source.

proc get_shadow_buffer_size*(this: LightLensNode): LVecBase2i {.importcpp: "#->get_shadow_buffer_size()".} ## \
## Returns the size of the shadow buffer to be created for this light source.

proc set_shadow_buffer_size*(this: LightLensNode, size: LVecBase2i) {.importcpp: "#->set_shadow_buffer_size(#)".} ## \
## Sets the size of the shadow buffer to be created for this light source.

proc get_shadow_buffer*(this: LightLensNode, gsg: GraphicsStateGuardianBase): GraphicsOutputBase {.importcpp: "#->get_shadow_buffer(#)".} ## \
## Returns the buffer that has been constructed for a given GSG, or NULL if no
## such buffer has (yet) been constructed.  This should be used for debugging
## only, you will not need to call this normally.

proc output*(this: LightLensNode, `out`: ostream) {.importcpp: "#->output(#)".} ## \
## We have to explicitly publish these because they resolve the multiple
## inheritance.

proc write*(this: LightLensNode, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: LightLensNode, `out`: ostream) {.importcpp: "#->write(#)".}

proc get_class_type*(_: typedesc[LightLensNode]): TypeHandle {.importcpp: "LightLensNode::get_class_type()", header: "lightLensNode.h".}

proc newDirectionalLight*(name: string): DirectionalLight {.importcpp: "new DirectionalLight(nimStringToStdString(#))", header: stringConversionCode.}

proc set_specular_color*(this: DirectionalLight, color: LColor) {.importcpp: "#->set_specular_color(#)".} ## \
## Sets the color of specular highlights generated by the light.

proc clear_specular_color*(this: DirectionalLight) {.importcpp: "#->clear_specular_color()".} ## \
## Clears a custom specular color setting, meaning that the specular color
## will now come from the color.

proc get_point*(this: DirectionalLight): LPoint3 {.importcpp: "#->get_point()".} ## \
## Returns the point in space at which the light is located.  This is local to
## the coordinate space in which the light is assigned.
##
## This actually has no bearing on the visual effect of the light, since the
## light is rendered as if it were infinitely far away.  This is only used to
## create a visible representation of the light.

proc set_point*(this: DirectionalLight, point: LPoint3) {.importcpp: "#->set_point(#)".} ## \
## Sets the point in space at which the light is located.

proc get_direction*(this: DirectionalLight): LVector3 {.importcpp: "#->get_direction()".} ## \
## Returns the direction in which the light is aimed.  This is local to the
## coordinate space in which the light is assigned.

proc set_direction*(this: DirectionalLight, direction: LVector3) {.importcpp: "#->set_direction(#)".} ## \
## Sets the direction in which the light is aimed.

proc get_class_type*(_: typedesc[DirectionalLight]): TypeHandle {.importcpp: "DirectionalLight::get_class_type()", header: "directionalLight.h".}

proc newLODNode*(name: string): LODNode {.importcpp: "new LODNode(nimStringToStdString(#))", header: stringConversionCode.}

proc make_default_lod*(_: typedesc[LODNode], name: string): LODNode {.importcpp: "LODNode::make_default_lod(nimStringToStdString(#))", header: "lODNode.h".} ## \
## Creates a new LODNode of the type specified by the default-lod-type config
## variable.

proc add_switch*(this: LODNode, `in`: float32, `out`: float32) {.importcpp: "#->add_switch(#, #)".} ## \
## Adds a switch range to the LODNode.  This implies that the corresponding
## child node has been parented to the node.
##
## The sense of in vs.  out distances is as if the object were coming towards
## you from far away: it switches "in" at the far distance, and switches "out"
## at the close distance.  Thus, "in" should be larger than "out".

proc set_switch*(this: LODNode, index: int, `in`: float32, `out`: float32): bool {.importcpp: "#->set_switch(#, #, #)".} ## \
## Changes the switching range of a particular child of the LODNode.  See
## add_switch().

proc clear_switches*(this: LODNode) {.importcpp: "#->clear_switches()".} ## \
## Removes the set of switching ranges for the LODNode, presumably in
## conjunction with removing all of its children.  See add_switch().

proc get_num_switches*(this: LODNode): int {.importcpp: "#->get_num_switches()".} ## \
## Returns the number of switch ranges added to the LODNode.  This should
## correspond to the number of children of the node in order for the LODNode
## to function correctly.

proc get_in*(this: LODNode, index: int): float32 {.importcpp: "#->get_in(#)".} ## \
## Returns the "in" distance of the indicated switch range.  This should be
## larger than the "out" distance of the same range.

proc get_out*(this: LODNode, index: int): float32 {.importcpp: "#->get_out(#)".} ## \
## Returns the "out" distance of the indicated switch range.  This should be
## smaller than the "in" distance of the same range.

proc get_lowest_switch*(this: LODNode): int {.importcpp: "#->get_lowest_switch()".} ## \
## Returns the index number of the child with the lowest level of detail; that
## is, the one that is designed to be seen from the farthest away.  This is
## usually the first child, but it is not necessarily so.

proc get_highest_switch*(this: LODNode): int {.importcpp: "#->get_highest_switch()".} ## \
## Returns the index number of the child with the highest level of detail;
## that is, the one that is designed to be seen from the closest to the
## camera.  This is usually the last child, but it is not necessarily so.

proc force_switch*(this: LODNode, index: int) {.importcpp: "#->force_switch(#)".} ## \
## Forces the LODNode to show the indicated level instead of the level that
## would normally be shown based on the distance from the camera.

proc clear_force_switch*(this: LODNode) {.importcpp: "#->clear_force_switch()".} ## \
## Undoes the effect of a previous call to force_switch() and releases the
## LODNode to once again display the normal level.

proc set_lod_scale*(this: LODNode, value: float32) {.importcpp: "#->set_lod_scale(#)".} ## \
## Sets the multiplier for lod distances.  A higher value means you'll see
## farther switchs than normal

proc get_lod_scale*(this: LODNode): float32 {.importcpp: "#->get_lod_scale()".} ## \
## Returns the multiplier for lod distances

proc set_center*(this: LODNode, center: LPoint3) {.importcpp: "#->set_center(#)".} ## \
## Specifies the center of the LOD.  This is the point that is compared to the
## camera (in camera space) to determine the particular LOD that should be
## chosen.

proc get_center*(this: LODNode): LPoint3 {.importcpp: "#->get_center()".} ## \
## Returns the center of the LOD.  This is the point that is compared to the
## camera (in camera space) to determine the particular LOD that should be
## chosen.

proc show_switch*(this: LODNode, index: int) {.importcpp: "#->show_switch(#)".} ## \
## This is provided as a debugging aid.  show_switch() will put the LODNode
## into a special mode where rather than computing and drawing the appropriate
## level of the LOD, a ring is drawn around the LODNode center indicating the
## switch distances from the camera for the indicated level, and the geometry
## of the indicated level is drawn in wireframe.
##
## Multiple different levels can be visualized this way at once.  Call
## hide_switch() or hide_all_switches() to undo this mode and restore the
## LODNode to its normal behavior.

proc show_switch*(this: LODNode, index: int, color: LColor) {.importcpp: "#->show_switch(#, #)".} ## \
## This is provided as a debugging aid.  show_switch() will put the LODNode
## into a special mode where rather than computing and drawing the appropriate
## level of the LOD, a ring is drawn around the LODNode center indicating the
## switch distances from the camera for the indicated level, and the geometry
## of the indicated level is drawn in wireframe.
##
## Multiple different levels can be visualized this way at once.  Call
## hide_switch() or hide_all_switches() to undo this mode and restore the
## LODNode to its normal behavior.

proc hide_switch*(this: LODNode, index: int) {.importcpp: "#->hide_switch(#)".} ## \
## Disables a previous call to show_switch().

proc show_all_switches*(this: LODNode) {.importcpp: "#->show_all_switches()".} ## \
## Shows all levels in their default colors.

proc hide_all_switches*(this: LODNode) {.importcpp: "#->hide_all_switches()".} ## \
## Hides all levels, restoring the LODNode to normal operation.

proc is_any_shown*(this: LODNode): bool {.importcpp: "#->is_any_shown()".} ## \
## Returns true if any switch has been shown with show_switch(), indicating
## the LODNode is in debug show mode; or false if it is in the normal mode.

proc verify_child_bounds*(this: LODNode): bool {.importcpp: "#->verify_child_bounds()".} ## \
## Returns true if the bounding volumes for the geometry of each fhild node
## entirely fits within the switch_in radius for that child, or false
## otherwise.  It is almost always a mistake for the geometry of an LOD level
## to be larger than its switch_in radius.

proc get_class_type*(_: typedesc[LODNode]): TypeHandle {.importcpp: "LODNode::get_class_type()", header: "lODNode.h".}

proc newFadeLODNode*(name: string): FadeLODNode {.importcpp: "new FadeLODNode(nimStringToStdString(#))", header: stringConversionCode.}

proc set_fade_time*(this: FadeLODNode, t: float32) {.importcpp: "#->set_fade_time(#)".} ## \
## set the time taken to complete an LOD switch

proc get_fade_time*(this: FadeLODNode): float32 {.importcpp: "#->get_fade_time()".} ## \
## get the time taken to complete an LOD switch

proc set_fade_bin*(this: FadeLODNode, name: string, draw_order: int) {.importcpp: "#->set_fade_bin(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Specifies the cull bin and draw order that is assigned to the fading part
## of the geometry during a transition.

proc get_fade_bin_name*(this: FadeLODNode): string {.importcpp: "nimStringFromStdString(#->get_fade_bin_name())", header: stringConversionCode.} ## \
## Returns the cull bin that is assigned to the fading part of the geometry
## during a transition.

proc get_fade_bin_draw_order*(this: FadeLODNode): int {.importcpp: "#->get_fade_bin_draw_order()".} ## \
## Returns the draw order that is assigned (along with the bin name) to the
## fading part of the geometry during a transition.

proc set_fade_state_override*(this: FadeLODNode, override: int) {.importcpp: "#->set_fade_state_override(#)".} ## \
## Specifies the override value that is applied to the state changes necessary
## to apply the fade effect.  This should be larger than any attrib overrides
## on the fading geometry.

proc get_fade_state_override*(this: FadeLODNode): int {.importcpp: "#->get_fade_state_override()".} ## \
## Returns the override value that is applied to the state changes necessary
## to apply the fade effect.  This should be larger than any attrib overrides
## on the fading geometry.

proc get_class_type*(_: typedesc[FadeLODNode]): TypeHandle {.importcpp: "FadeLODNode::get_class_type()", header: "fadeLODNode.h".}

proc get_trav*(this: NodeCullCallbackData): CullTraverser {.importcpp: "#.get_trav()".} ## \
## Returns the CullTraverser in use at the time of the callback.  This object
## contains data that does not change during the traversal, such as the
## DisplayRegion and Camera in use.

proc get_data*(this: NodeCullCallbackData): CullTraverserData {.importcpp: "#.get_data()".} ## \
## Returns the CullTraverserData in use at the time of the callback.  This
## object contains data that changes at each node of the traversal, such as
## the current node and the current net transform to that node.

proc get_class_type*(_: typedesc[NodeCullCallbackData]): TypeHandle {.importcpp: "NodeCullCallbackData::get_class_type()", header: "nodeCullCallbackData.h".}

proc newPointLight*(name: string): PointLight {.importcpp: "new PointLight(nimStringToStdString(#))", header: stringConversionCode.}

proc set_specular_color*(this: PointLight, color: LColor) {.importcpp: "#->set_specular_color(#)".} ## \
## Sets the color of specular highlights generated by the light.

proc clear_specular_color*(this: PointLight) {.importcpp: "#->clear_specular_color()".} ## \
## Clears a custom specular color setting, meaning that the specular color
## will now come from the color.

proc set_attenuation*(this: PointLight, attenuation: LVecBase3) {.importcpp: "#->set_attenuation(#)".} ## \
## Sets the terms of the attenuation equation for the light.  These are, in
## order, the constant, linear, and quadratic terms based on the distance from
## the point to the vertex.

proc get_max_distance*(this: PointLight): float32 {.importcpp: "#->get_max_distance()".} ## \
## Returns the maximum distance at which the light has any effect, as previously
## specified by set_max_distance.

proc set_max_distance*(this: PointLight, max_distance: float32) {.importcpp: "#->set_max_distance(#)".} ## \
## Sets the radius of the light's sphere of influence.  Beyond this distance, the
## light may be attenuated to zero, if this is supported by the shader.

proc get_point*(this: PointLight): LPoint3 {.importcpp: "#->get_point()".} ## \
## Returns the point in space at which the light is located.  This is local to
## the coordinate space in which the light is assigned, and is usually 0.

proc set_point*(this: PointLight, point: LPoint3) {.importcpp: "#->set_point(#)".} ## \
## Sets the point in space at which the light is located.  Usually 0.

proc get_class_type*(_: typedesc[PointLight]): TypeHandle {.importcpp: "PointLight::get_class_type()", header: "pointLight.h".}

proc newRectangleLight*(name: string): RectangleLight {.importcpp: "new RectangleLight(nimStringToStdString(#))", header: stringConversionCode.}

proc get_max_distance*(this: RectangleLight): float32 {.importcpp: "#->get_max_distance()".} ## \
## Returns the maximum distance at which the light has any effect, as previously
## specified by set_max_distance.

proc set_max_distance*(this: RectangleLight, max_distance: float32) {.importcpp: "#->set_max_distance(#)".} ## \
## Sets the radius of the light's sphere of influence.  Beyond this distance, the
## light may be attenuated to zero, if this is supported by the shader.

proc get_class_type*(_: typedesc[RectangleLight]): TypeHandle {.importcpp: "RectangleLight::get_class_type()", header: "rectangleLight.h".}

proc newSelectiveChildNode*(name: string): SelectiveChildNode {.importcpp: "new SelectiveChildNode(nimStringToStdString(#))", header: stringConversionCode.}

proc get_class_type*(_: typedesc[SelectiveChildNode]): TypeHandle {.importcpp: "SelectiveChildNode::get_class_type()", header: "selectiveChildNode.h".}

converter upcast_to_SelectiveChildNode*(this: SequenceNode): SelectiveChildNode {.importcpp: "(PT(SelectiveChildNode)(#))".}

converter upcast_to_AnimInterface*(this: SequenceNode): AnimInterface {.importcpp: "((AnimInterface *)(#.p()))".}

proc newSequenceNode*(name: string): SequenceNode {.importcpp: "new SequenceNode(nimStringToStdString(#))", header: stringConversionCode.}

proc get_num_frames*(this: SequenceNode): int {.importcpp: "#->get_num_frames()".} ## \
## Returns the number of frames in the animation.  This is a property of the
## animation and may not be directly adjusted by the user (although it may
## change without warning with certain kinds of animations, since this is a
## virtual method that may be overridden).

proc set_frame_rate*(this: SequenceNode, frame_rate: float64) {.importcpp: "#->set_frame_rate(#)".} ## \
## Changes the advertised frame rate of the SequenceNode.  This can be used in
## conjunction with get_play_rate() to change the effective frame rate of the
## node.

proc get_class_type*(_: typedesc[SequenceNode]): TypeHandle {.importcpp: "SequenceNode::get_class_type()", header: "sequenceNode.h".}

proc newShaderGenerator*(gsg: GraphicsStateGuardianBase): ShaderGenerator {.importcpp: "new ShaderGenerator(#)".} ## \
## Create a ShaderGenerator.  This has no state, except possibly to cache
## certain results.  The parameter that must be passed is the GSG to which the
## shader generator belongs.

proc newShaderGenerator*(param0: ShaderGenerator): ShaderGenerator {.importcpp: "new ShaderGenerator(#)".}

proc synthesize_shader*(this: ShaderGenerator, rs: RenderState, anim: GeomVertexAnimationSpec): ShaderAttrib {.importcpp: "#->synthesize_shader(#, #)".} ## \
## This is the routine that implements the next-gen fixed function pipeline by
## synthesizing a shader.  It also takes care of setting up any buffers needed
## to produce the requested effects.
##
## Currently supports:
## - flat colors
## - vertex colors
## - lighting
## - normal maps, even multiple
## - gloss maps, but not multiple
## - glow maps, but not multiple
## - materials, but not updates to materials
## - 2D textures
## - all texture stage modes, including combine modes
## - color scale attrib
## - light ramps (for cartoon shading)
## - shadow mapping
## - most texgen modes
## - texmatrix
## - 1D/2D/3D textures, cube textures, 2D tex arrays
## - linear/exp/exp2 fog
## - animation
##
## Potential optimizations
## - omit attenuation calculations if attenuation off

proc rehash_generated_shaders*(this: ShaderGenerator) {.importcpp: "#->rehash_generated_shaders()".} ## \
## Rehashes all the states with generated shaders, removing the ones that are
## no longer fresh.
##
## Call this if certain state has changed in such a way as to require a rerun
## of the shader generator.  This should be rare because in most cases, the
## shader generator will automatically regenerate shaders as necessary.
##
## @since 1.10.0

proc clear_generated_shaders*(this: ShaderGenerator) {.importcpp: "#->clear_generated_shaders()".} ## \
## Removes all previously generated shaders, requiring all shaders to be
## regenerated.  Does not clear cache of compiled shaders.
##
## @since 1.10.0

proc get_class_type*(_: typedesc[ShaderGenerator]): TypeHandle {.importcpp: "ShaderGenerator::get_class_type()", header: "shaderGenerator.h".}

proc newSphereLight*(name: string): SphereLight {.importcpp: "new SphereLight(nimStringToStdString(#))", header: stringConversionCode.}

proc get_radius*(this: SphereLight): float32 {.importcpp: "#->get_radius()".} ## \
## Returns the radius of the sphere.

proc set_radius*(this: SphereLight, radius: float32) {.importcpp: "#->set_radius(#)".} ## \
## Sets the radius of the sphere.

proc get_class_type*(_: typedesc[SphereLight]): TypeHandle {.importcpp: "SphereLight::get_class_type()", header: "sphereLight.h".}

proc newSpotlight*(name: string): Spotlight {.importcpp: "new Spotlight(nimStringToStdString(#))", header: stringConversionCode.}

proc set_exponent*(this: Spotlight, exponent: float32) {.importcpp: "#->set_exponent(#)".} ## \
## Sets the exponent that controls the amount of light falloff from the center
## of the spotlight.  The light is attenuated by the cosine of the angle
## between the direction of the light and the direction of the point being
## lighted, raised to the power of this exponent.  Thus, higher exponents
## result in a more focused light source, regardless of the field-of-view of
## the lens.

proc set_specular_color*(this: Spotlight, color: LColor) {.importcpp: "#->set_specular_color(#)".} ## \
## Sets the color of specular highlights generated by the light.

proc clear_specular_color*(this: Spotlight) {.importcpp: "#->clear_specular_color()".} ## \
## Clears a custom specular color setting, meaning that the specular color
## will now come from the color.

proc set_attenuation*(this: Spotlight, attenuation: LVecBase3) {.importcpp: "#->set_attenuation(#)".} ## \
## Sets the terms of the attenuation equation for the light.  These are, in
## order, the constant, linear, and quadratic terms based on the distance from
## the point to the vertex.

proc get_max_distance*(this: Spotlight): float32 {.importcpp: "#->get_max_distance()".} ## \
## Returns the maximum distance at which the light has any effect, as previously
## specified by set_max_distance.

proc set_max_distance*(this: Spotlight, max_distance: float32) {.importcpp: "#->set_max_distance(#)".} ## \
## Sets the radius of the light's sphere of influence.  Beyond this distance, the
## light may be attenuated to zero, if this is supported by the shader.

proc make_spot*(_: typedesc[Spotlight], pixel_width: int, full_radius: float32, fg: LColor, bg: LColor): Texture {.importcpp: "Spotlight::make_spot(#, #, #, #)", header: "spotlight.h".} ## \
## Returns a newly-generated Texture that renders a circular spot image as
## might be cast from the spotlight.  This may be projected onto target
## geometry (for instance, via NodePath::project_texture()) instead of
## actually enabling the light itself, as a cheesy way to make a high-
## resolution spot appear on the geometry.
##
## pixel_width specifies the height and width of the new texture in pixels,
## full_radius is a value in the range 0..1 that indicates the relative size
## of the fully bright center spot, and fg and bg are the colors of the
## interior and exterior of the spot, respectively.

proc get_class_type*(_: typedesc[Spotlight]): TypeHandle {.importcpp: "Spotlight::get_class_type()", header: "spotlight.h".}

proc newSwitchNode*(name: string): SwitchNode {.importcpp: "new SwitchNode(nimStringToStdString(#))", header: stringConversionCode.}

proc set_visible_child*(this: SwitchNode, index: int) {.importcpp: "#->set_visible_child(#)".} ## \
## Specifies the particular child of this node, by index, that will be
## visible.

proc get_visible_child*(this: SwitchNode): int {.importcpp: "#->get_visible_child()".} ## \
## Returns the index of the child that should be visible.

proc get_class_type*(_: typedesc[SwitchNode]): TypeHandle {.importcpp: "SwitchNode::get_class_type()", header: "switchNode.h".}

proc newUvScrollNode*(name: string): UvScrollNode {.importcpp: "new UvScrollNode(nimStringToStdString(#))", header: stringConversionCode.}

proc newUvScrollNode*(name: string, u_speed: float32, v_speed: float32, w_speed: float32, r_speed: float32): UvScrollNode {.importcpp: "new UvScrollNode(nimStringToStdString(#), #, #, #, #)", header: stringConversionCode.}

proc set_u_speed*(this: UvScrollNode, u_speed: float32) {.importcpp: "#->set_u_speed(#)".}

proc set_v_speed*(this: UvScrollNode, v_speed: float32) {.importcpp: "#->set_v_speed(#)".}

proc set_w_speed*(this: UvScrollNode, w_speed: float32) {.importcpp: "#->set_w_speed(#)".}

proc set_r_speed*(this: UvScrollNode, r_speed: float32) {.importcpp: "#->set_r_speed(#)".}

proc get_u_speed*(this: UvScrollNode): float32 {.importcpp: "#->get_u_speed()".}

proc get_v_speed*(this: UvScrollNode): float32 {.importcpp: "#->get_v_speed()".}

proc get_w_speed*(this: UvScrollNode): float32 {.importcpp: "#->get_w_speed()".}

proc get_r_speed*(this: UvScrollNode): float32 {.importcpp: "#->get_r_speed()".}

proc get_class_type*(_: typedesc[UvScrollNode]): TypeHandle {.importcpp: "UvScrollNode::get_class_type()", header: "uvScrollNode.h".}

proc initSceneGraphAnalyzer*(): SceneGraphAnalyzer {.importcpp: "SceneGraphAnalyzer()".}

proc initSceneGraphAnalyzer*(param0: SceneGraphAnalyzer): SceneGraphAnalyzer {.importcpp: "SceneGraphAnalyzer(#)".}

proc clear*(this: SceneGraphAnalyzer) {.importcpp: "#.clear()".} ## \
## Resets all of the data in the analyzer in preparation for a new run.

proc add_node*(this: SceneGraphAnalyzer, node: PandaNode) {.importcpp: "#.add_node(#)".} ## \
## Adds a new node to the set of data for analysis.  Normally, this would only
## be called once, and passed the top of the scene graph, but it's possible to
## repeatedly pass in subgraphs to get an analysis of all the graphs together.

proc write*(this: SceneGraphAnalyzer, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Describes all the data collected.

proc write*(this: SceneGraphAnalyzer, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Describes all the data collected.

proc get_num_nodes*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_nodes()".}

proc get_num_instances*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_instances()".}

proc get_num_transforms*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_transforms()".}

proc get_num_nodes_with_attribs*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_nodes_with_attribs()".}

proc get_num_lod_nodes*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_lod_nodes()".}

proc get_num_geom_nodes*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_geom_nodes()".}

proc get_num_geoms*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_geoms()".}

proc get_num_geom_vertex_datas*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_geom_vertex_datas()".}

proc get_num_geom_vertex_formats*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_geom_vertex_formats()".}

proc get_vertex_data_size*(this: SceneGraphAnalyzer): clonglong {.importcpp: "#.get_vertex_data_size()".}

proc get_num_vertices*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_vertices()".}

proc get_num_normals*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_normals()".}

proc get_num_colors*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_colors()".}

proc get_num_texcoords*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_texcoords()".}

proc get_num_tris*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_tris()".}

proc get_num_lines*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_lines()".}

proc get_num_points*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_points()".}

proc get_num_patches*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_patches()".}

proc get_num_individual_tris*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_individual_tris()".}

proc get_num_tristrips*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_tristrips()".}

proc get_num_triangles_in_strips*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_triangles_in_strips()".}

proc get_num_trifans*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_trifans()".}

proc get_num_triangles_in_fans*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_triangles_in_fans()".}

proc get_num_vertices_in_patches*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_vertices_in_patches()".}

proc get_texture_bytes*(this: SceneGraphAnalyzer): clonglong {.importcpp: "#.get_texture_bytes()".}

proc get_num_long_normals*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_long_normals()".}

proc get_num_short_normals*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_short_normals()".}

proc get_total_normal_length*(this: SceneGraphAnalyzer): float32 {.importcpp: "#.get_total_normal_length()".}

proc `!=`*(this: TransformState, other: TransformState): bool {.importcpp: "#->operator !=(#)".}

proc compare_to*(this: TransformState, other: TransformState): int {.importcpp: "#->compare_to(#)".} ## \
## Provides an arbitrary ordering among all unique TransformStates, so we can
## store the essentially different ones in a big set and throw away the rest.
##
## Note that if this returns 0, it doesn't necessarily imply that operator ==
## returns true; it uses a very slightly different comparison threshold.

proc compare_to*(this: TransformState, other: TransformState, uniquify_matrix: bool): int {.importcpp: "#->compare_to(#, #)".} ## \
## Provides an arbitrary ordering among all unique TransformStates, so we can
## store the essentially different ones in a big set and throw away the rest.
##
## Note that if this returns 0, it doesn't necessarily imply that operator ==
## returns true; it uses a very slightly different comparison threshold.
##
## If uniquify_matrix is true, then matrix-defined TransformStates are also
## uniqified.  If uniquify_matrix is false, then only component-defined
## TransformStates are uniquified, which is less expensive.

proc `==`*(this: TransformState, other: TransformState): bool {.importcpp: "#->operator ==(#)".}

proc get_hash*(this: TransformState): clonglong {.importcpp: "#->get_hash()".} ## \
## Returns a suitable hash value for phash_map.

proc make_identity*(_: typedesc[TransformState]): TransformState {.importcpp: "TransformState::make_identity()", header: "transformState.h".} ## \
## Constructs an identity transform.

proc make_invalid*(_: typedesc[TransformState]): TransformState {.importcpp: "TransformState::make_invalid()", header: "transformState.h".} ## \
## Constructs an invalid transform; for instance, the result of inverting a
## singular matrix.

proc make_pos*(_: typedesc[TransformState], pos: LVecBase3): TransformState {.importcpp: "TransformState::make_pos(#)", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc make_hpr*(_: typedesc[TransformState], hpr: LVecBase3): TransformState {.importcpp: "TransformState::make_hpr(#)", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc make_quat*(_: typedesc[TransformState], quat: LQuaternion): TransformState {.importcpp: "TransformState::make_quat(#)", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc make_pos_hpr*(_: typedesc[TransformState], pos: LVecBase3, hpr: LVecBase3): TransformState {.importcpp: "TransformState::make_pos_hpr(#, #)", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc make_scale*(_: typedesc[TransformState], scale: LVecBase3): TransformState {.importcpp: "TransformState::make_scale(#)", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc make_scale*(_: typedesc[TransformState], scale: float32): TransformState {.importcpp: "TransformState::make_scale(#)", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc make_shear*(_: typedesc[TransformState], shear: LVecBase3): TransformState {.importcpp: "TransformState::make_shear(#)", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc make_pos_hpr_scale*(_: typedesc[TransformState], pos: LVecBase3, hpr: LVecBase3, scale: LVecBase3): TransformState {.importcpp: "TransformState::make_pos_hpr_scale(#, #, #)", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc make_pos_quat_scale*(_: typedesc[TransformState], pos: LVecBase3, quat: LQuaternion, scale: LVecBase3): TransformState {.importcpp: "TransformState::make_pos_quat_scale(#, #, #)", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc make_pos_hpr_scale_shear*(_: typedesc[TransformState], pos: LVecBase3, hpr: LVecBase3, scale: LVecBase3, shear: LVecBase3): TransformState {.importcpp: "TransformState::make_pos_hpr_scale_shear(#, #, #, #)", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc make_pos_quat_scale_shear*(_: typedesc[TransformState], pos: LVecBase3, quat: LQuaternion, scale: LVecBase3, shear: LVecBase3): TransformState {.importcpp: "TransformState::make_pos_quat_scale_shear(#, #, #, #)", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc make_mat*(_: typedesc[TransformState], mat: LMatrix4): TransformState {.importcpp: "TransformState::make_mat(#)", header: "transformState.h".} ## \
## Makes a new TransformState with the specified transformation matrix.

proc make_pos2d*(_: typedesc[TransformState], pos: LVecBase2): TransformState {.importcpp: "TransformState::make_pos2d(#)", header: "transformState.h".} ## \
## Makes a new 2-d TransformState with the specified components.

proc make_rotate2d*(_: typedesc[TransformState], rotate: float32): TransformState {.importcpp: "TransformState::make_rotate2d(#)", header: "transformState.h".} ## \
## Makes a new 2-d TransformState with the specified components.

proc make_pos_rotate2d*(_: typedesc[TransformState], pos: LVecBase2, rotate: float32): TransformState {.importcpp: "TransformState::make_pos_rotate2d(#, #)", header: "transformState.h".} ## \
## Makes a new 2-d TransformState with the specified components.

proc make_scale2d*(_: typedesc[TransformState], scale: LVecBase2): TransformState {.importcpp: "TransformState::make_scale2d(#)", header: "transformState.h".} ## \
## Makes a new 2-d TransformState with the specified components.

proc make_scale2d*(_: typedesc[TransformState], scale: float32): TransformState {.importcpp: "TransformState::make_scale2d(#)", header: "transformState.h".} ## \
## Makes a new 2-d TransformState with the specified components.

proc make_shear2d*(_: typedesc[TransformState], shear: float32): TransformState {.importcpp: "TransformState::make_shear2d(#)", header: "transformState.h".} ## \
## Makes a new 2-d TransformState with the specified components.

proc make_pos_rotate_scale2d*(_: typedesc[TransformState], pos: LVecBase2, rotate: float32, scale: LVecBase2): TransformState {.importcpp: "TransformState::make_pos_rotate_scale2d(#, #, #)", header: "transformState.h".} ## \
## Makes a new 2-d TransformState with the specified components.

proc make_pos_rotate_scale_shear2d*(_: typedesc[TransformState], pos: LVecBase2, rotate: float32, scale: LVecBase2, shear: float32): TransformState {.importcpp: "TransformState::make_pos_rotate_scale_shear2d(#, #, #, #)", header: "transformState.h".} ## \
## Makes a new two-dimensional TransformState with the specified components.

proc make_mat3*(_: typedesc[TransformState], mat: LMatrix3): TransformState {.importcpp: "TransformState::make_mat3(#)", header: "transformState.h".} ## \
## Makes a new two-dimensional TransformState with the specified 3x3
## transformation matrix.

proc is_identity*(this: TransformState): bool {.importcpp: "#->is_identity()".} ## \
## Returns true if the transform represents the identity matrix, false
## otherwise.

proc is_invalid*(this: TransformState): bool {.importcpp: "#->is_invalid()".} ## \
## Returns true if the transform represents an invalid matrix, for instance
## the result of inverting a singular matrix, or false if the transform is
## valid.

proc is_singular*(this: TransformState): bool {.importcpp: "#->is_singular()".} ## \
## Returns true if the transform represents a singular transform (that is, it
## has a zero scale, and it cannot be inverted), or false otherwise.

proc is_2d*(this: TransformState): bool {.importcpp: "#->is_2d()".} ## \
## Returns true if the transform has been constructed entirely using the 2-d
## transform operations, e.g.  make_pos2d(), and therefore operates strictly
## in two-dimensional space on X and Y only.

proc has_components*(this: TransformState): bool {.importcpp: "#->has_components()".} ## \
## Returns true if the transform can be described by separate pos, hpr, and
## scale components.  Most transforms we use in everyday life can be so
## described, but some kinds of transforms (for instance, those involving a
## skew) cannot.
##
## This is not related to whether the transform was originally described
## componentwise.  Even a transform that was constructed with a 4x4 may return
## true here if the matrix is a simple affine matrix with no skew.
##
## If this returns true, you may safely call get_hpr() and get_scale() to
## retrieve the components.  (You may always safely call get_pos() whether
## this returns true or false.)

proc components_given*(this: TransformState): bool {.importcpp: "#->components_given()".} ## \
## Returns true if the transform was specified componentwise, or false if it
## was specified with a general 4x4 matrix.  If this is true, the components
## returned by get_pos() and get_scale() will be exactly those that were set;
## otherwise, these functions will return computed values.  If this is true,
## the rotation may have been set either with a hpr trio or with a quaternion;
## hpr_given() or quat_given() can resolve the difference.

proc hpr_given*(this: TransformState): bool {.importcpp: "#->hpr_given()".} ## \
## Returns true if the rotation was specified via a trio of Euler angles,
## false otherwise.  If this is true, get_hpr() will be exactly as set;
## otherwise, it will return a computed value.

proc quat_given*(this: TransformState): bool {.importcpp: "#->quat_given()".} ## \
## Returns true if the rotation was specified via a quaternion, false
## otherwise.  If this is true, get_quat() will be exactly as set; otherwise,
## it will return a computed value.

proc has_pos*(this: TransformState): bool {.importcpp: "#->has_pos()".} ## \
## Returns true if the transform's pos component can be extracted out
## separately.  This is generally always true, unless the transform is invalid
## (i.e.  is_invalid() returns true).

proc has_hpr*(this: TransformState): bool {.importcpp: "#->has_hpr()".} ## \
## Returns true if the transform's rotation component can be extracted out
## separately and described as a set of Euler angles.  This is generally true
## only when has_components() is true.

proc has_quat*(this: TransformState): bool {.importcpp: "#->has_quat()".} ## \
## Returns true if the transform's rotation component can be extracted out
## separately and described as a quaternion.  This is generally true only when
## has_components() is true.

proc has_scale*(this: TransformState): bool {.importcpp: "#->has_scale()".} ## \
## Returns true if the transform's scale component can be extracted out
## separately.  This is generally true only when has_components() is true.

proc has_identity_scale*(this: TransformState): bool {.importcpp: "#->has_identity_scale()".} ## \
## Returns true if the scale is uniform 1.0, or false if the scale has some
## real value.

proc has_uniform_scale*(this: TransformState): bool {.importcpp: "#->has_uniform_scale()".} ## \
## Returns true if the scale is uniform across all three axes (and therefore
## can be expressed as a single number), or false if the transform has a
## different scale in different dimensions.

proc has_shear*(this: TransformState): bool {.importcpp: "#->has_shear()".} ## \
## Returns true if the transform's shear component can be extracted out
## separately.  This is generally true only when has_components() is true.

proc has_nonzero_shear*(this: TransformState): bool {.importcpp: "#->has_nonzero_shear()".} ## \
## Returns true if the shear component is non-zero, false if it is zero or if
## the matrix cannot be decomposed.

proc has_mat*(this: TransformState): bool {.importcpp: "#->has_mat()".} ## \
## Returns true if the transform can be described as a matrix.  This is
## generally always true, unless is_invalid() is true.

proc get_pos*(this: TransformState): LPoint3 {.importcpp: "#->get_pos()".} ## \
## Returns the pos component of the transform.  It is an error to call this if
## has_pos() returned false.

proc get_hpr*(this: TransformState): LVecBase3 {.importcpp: "#->get_hpr()".} ## \
## Returns the rotation component of the transform as a trio of Euler angles.
## It is an error to call this if has_components() returned false.

proc get_quat*(this: TransformState): LQuaternion {.importcpp: "#->get_quat()".} ## \
## Returns the rotation component of the transform as a quaternion.  The
## return value will be normalized if a normalized quaternion was given to the
## constructor (or if the quaternion was computed implicitly); it will be non-
## normalized if a non-normalized quaternion was given to the constructor.
## See also get_norm_quat().
##
## It is an error to call this if has_components() returned false.

proc get_norm_quat*(this: TransformState): LQuaternion {.importcpp: "#->get_norm_quat()".} ## \
## Returns the rotation component of the transform as a quaternion.  Unlike
## the result of get_quat(), the return value of this method is guaranteed to
## be normalized.  It is an error to call this if has_components() returned
## false.

proc get_scale*(this: TransformState): LVecBase3 {.importcpp: "#->get_scale()".} ## \
## Returns the scale component of the transform.  It is an error to call this
## if has_components() returned false.

proc get_uniform_scale*(this: TransformState): float32 {.importcpp: "#->get_uniform_scale()".} ## \
## Returns the scale component of the transform, as a single number.  It is an
## error to call this if has_uniform_scale() returned false.

proc get_shear*(this: TransformState): LVecBase3 {.importcpp: "#->get_shear()".} ## \
## Returns the shear component of the transform.  It is an error to call this
## if has_components() returned false.

proc get_mat*(this: TransformState): LMatrix4 {.importcpp: "#->get_mat()".} ## \
## Returns the matrix that describes the transform.

proc get_pos2d*(this: TransformState): LVecBase2 {.importcpp: "#->get_pos2d()".} ## \
## Returns the pos component of the 2-d transform.  It is an error to call
## this if has_pos() or is_2d() returned false.

proc get_rotate2d*(this: TransformState): float32 {.importcpp: "#->get_rotate2d()".} ## \
## Returns the rotation component of the 2-d transform as an angle in degrees
## clockwise about the origin.  It is an error to call this if
## has_components() or is_2d() returned false.

proc get_scale2d*(this: TransformState): LVecBase2 {.importcpp: "#->get_scale2d()".} ## \
## Returns the scale component of the 2-d transform.  It is an error to call
## this if has_components() or is_2d() returned false.

proc get_shear2d*(this: TransformState): float32 {.importcpp: "#->get_shear2d()".} ## \
## Returns the shear component of the 2-d transform.  It is an error to call
## this if has_components() or is_2d() returned false.

proc get_mat3*(this: TransformState): LMatrix3 {.importcpp: "#->get_mat3()".} ## \
## Returns the 3x3 matrix that describes the 2-d transform.  It is an error to
## call this if is_2d() returned false.

proc set_pos*(this: TransformState, pos: LVecBase3): TransformState {.importcpp: "#->set_pos(#)".} ## \
## Returns a new TransformState object that represents the original
## TransformState with its pos component replaced with the indicated value.

proc set_hpr*(this: TransformState, hpr: LVecBase3): TransformState {.importcpp: "#->set_hpr(#)".} ## \
## Returns a new TransformState object that represents the original
## TransformState with its rotation component replaced with the indicated
## value, if possible.

proc set_quat*(this: TransformState, quat: LQuaternion): TransformState {.importcpp: "#->set_quat(#)".} ## \
## Returns a new TransformState object that represents the original
## TransformState with its rotation component replaced with the indicated
## value, if possible.

proc set_scale*(this: TransformState, scale: LVecBase3): TransformState {.importcpp: "#->set_scale(#)".} ## \
## Returns a new TransformState object that represents the original
## TransformState with its scale component replaced with the indicated value,
## if possible.

proc set_shear*(this: TransformState, shear: LVecBase3): TransformState {.importcpp: "#->set_shear(#)".} ## \
## Returns a new TransformState object that represents the original
## TransformState with its shear component replaced with the indicated value,
## if possible.

proc set_pos2d*(this: TransformState, pos: LVecBase2): TransformState {.importcpp: "#->set_pos2d(#)".} ## \
## Returns a new TransformState object that represents the original 2-d
## TransformState with its pos component replaced with the indicated value.

proc set_rotate2d*(this: TransformState, rotate: float32): TransformState {.importcpp: "#->set_rotate2d(#)".} ## \
## Returns a new TransformState object that represents the original 2-d
## TransformState with its rotation component replaced with the indicated
## value, if possible.

proc set_scale2d*(this: TransformState, scale: LVecBase2): TransformState {.importcpp: "#->set_scale2d(#)".} ## \
## Returns a new TransformState object that represents the original 2-d
## TransformState with its scale component replaced with the indicated value,
## if possible.

proc set_shear2d*(this: TransformState, shear: float32): TransformState {.importcpp: "#->set_shear2d(#)".} ## \
## Returns a new TransformState object that represents the original 2-d
## TransformState with its shear component replaced with the indicated value,
## if possible.

proc compose*(this: TransformState, other: TransformState): TransformState {.importcpp: "#->compose(#)".} ## \
## Returns a new TransformState object that represents the composition of this
## state with the other state.
##
## The result of this operation is cached, and will be retained as long as
## both this TransformState object and the other TransformState object
## continue to exist.  Should one of them destruct, the cached entry will be
## removed, and its pointer will be allowed to destruct as well.

proc invert_compose*(this: TransformState, other: TransformState): TransformState {.importcpp: "#->invert_compose(#)".} ## \
## Returns a new TransformState object that represents the composition of this
## state's inverse with the other state.
##
## This is similar to compose(), but is particularly useful for computing the
## relative state of a node as viewed from some other node.

proc get_inverse*(this: TransformState): TransformState {.importcpp: "#->get_inverse()".} ## \
## Returns the inverse of this transform.  If you are going to immediately
## compose this result with another TransformState, it is faster to do it in
## one operation with invert_compose().

proc get_unique*(this: TransformState): TransformState {.importcpp: "#->get_unique()".} ## \
## Returns the pointer to the unique TransformState in the cache that is
## equivalent to this one.  This may be the same pointer as this object, or it
## may be a different pointer; but it will be an equivalent object, and it
## will be a shared pointer.  This may be called from time to time to improve
## cache benefits.

proc get_geom_rendering*(this: TransformState, geom_rendering: int): int {.importcpp: "#->get_geom_rendering(#)".} ## \
## Returns the union of the Geom::GeomRendering bits that will be required
## once this TransformState is applied to a geom which includes the indicated
## geom_rendering bits.  The RenderState's get_geom_rendering() should already
## have been applied.

proc cache_ref*(this: TransformState) {.importcpp: "#->cache_ref()".} ## \
## Overrides this method to update PStats appropriately.

proc cache_unref*(this: TransformState): bool {.importcpp: "#->cache_unref()".} ## \
## Overrides this method to update PStats appropriately.

proc node_ref*(this: TransformState) {.importcpp: "#->node_ref()".} ## \
## Overrides this method to update PStats appropriately.

proc node_unref*(this: TransformState): bool {.importcpp: "#->node_unref()".} ## \
## Overrides this method to update PStats appropriately.

proc get_composition_cache_num_entries*(this: TransformState): clonglong {.importcpp: "#->get_composition_cache_num_entries()".} ## \
## Returns the number of entries in the composition cache for this
## TransformState.  This is the number of other TransformStates whose
## composition with this one has been cached.  This number is not useful for
## any practical reason other than performance analysis.

proc get_invert_composition_cache_num_entries*(this: TransformState): clonglong {.importcpp: "#->get_invert_composition_cache_num_entries()".} ## \
## Returns the number of entries in the invert_composition cache for this
## TransformState.  This is similar to the composition cache, but it records
## cache entries for the invert_compose() operation.  See
## get_composition_cache_num_entries().

proc get_composition_cache_size*(this: TransformState): clonglong {.importcpp: "#->get_composition_cache_size()".} ## \
## Returns the number of slots in the composition cache for this
## TransformState.  You may use this as an upper bound when walking through
## all of the composition cache results via get_composition_cache_source() or
## result().
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc get_composition_cache_source*(this: TransformState, n: clonglong): TransformState {.importcpp: "#->get_composition_cache_source(#)".} ## \
## Returns the source TransformState of the nth element in the composition
## cache.  Returns NULL if there doesn't happen to be an entry in the nth
## element.  See get_composition_cache_result().
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc get_composition_cache_result*(this: TransformState, n: clonglong): TransformState {.importcpp: "#->get_composition_cache_result(#)".} ## \
## Returns the result TransformState of the nth element in the composition
## cache.  Returns NULL if there doesn't happen to be an entry in the nth
## element.
##
## In general, a->compose(a->get_composition_cache_source(n)) ==
## a->get_composition_cache_result(n).
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc get_invert_composition_cache_size*(this: TransformState): clonglong {.importcpp: "#->get_invert_composition_cache_size()".} ## \
## Returns the number of slots in the composition cache for this
## TransformState.  You may use this as an upper bound when walking through
## all of the composition cache results via
## get_invert_composition_cache_source() or result().
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc get_invert_composition_cache_source*(this: TransformState, n: clonglong): TransformState {.importcpp: "#->get_invert_composition_cache_source(#)".} ## \
## Returns the source TransformState of the nth element in the invert
## composition cache.  Returns NULL if there doesn't happen to be an entry in
## the nth element.  See get_invert_composition_cache_result().
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc get_invert_composition_cache_result*(this: TransformState, n: clonglong): TransformState {.importcpp: "#->get_invert_composition_cache_result(#)".} ## \
## Returns the result TransformState of the nth element in the invert
## composition cache.  Returns NULL if there doesn't happen to be an entry in
## the nth element.
##
## In general, a->invert_compose(a->get_invert_composition_cache_source(n)) ==
## a->get_invert_composition_cache_result(n).
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc validate_composition_cache*(this: TransformState): bool {.importcpp: "#->validate_composition_cache()".} ## \
## Returns true if the composition cache and invert composition cache for this
## particular TransformState are self-consistent and valid, false otherwise.

proc output*(this: TransformState, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: TransformState, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write_composition_cache*(this: TransformState, `out`: ostream, indent_level: int) {.importcpp: "#->write_composition_cache(#, #)".} ## \
## Writes a brief description of the composition cache and invert composition
## cache to the indicated ostream.  This is not useful except for performance
## analysis, to examine the cache structure.

proc get_num_states*(_: typedesc[TransformState]): int {.importcpp: "TransformState::get_num_states()", header: "transformState.h".} ## \
## Returns the total number of unique TransformState objects allocated in the
## world.  This will go up and down during normal operations.

proc get_num_unused_states*(_: typedesc[TransformState]): int {.importcpp: "TransformState::get_num_unused_states()", header: "transformState.h".} ## \
## Returns the total number of TransformState objects that have been allocated
## but have no references outside of the internal TransformState cache.
##
## A nonzero return value is not necessarily indicative of leaked references;
## it is normal for two TransformState objects, both of which have references
## held outside the cache, to have the result of their composition stored
## within the cache.  This result will be retained within the cache until one
## of the base TransformStates is released.
##
## Use list_cycles() to get an idea of the number of actual "leaked"
## TransformState objects.

proc clear_cache*(_: typedesc[TransformState]): int {.importcpp: "TransformState::clear_cache()", header: "transformState.h".} ## \
## Empties the cache of composed TransformStates.  This makes every
## TransformState forget what results when it is composed with other
## TransformStates.
##
## This will eliminate any TransformState objects that have been allocated but
## have no references outside of the internal TransformState map.  It will not
## eliminate TransformState objects that are still in use.
##
## Nowadays, this method should not be necessary, as reference-count cycles in
## the composition cache should be automatically detected and broken.
##
## The return value is the number of TransformStates freed by this operation.

proc garbage_collect*(_: typedesc[TransformState]): int {.importcpp: "TransformState::garbage_collect()", header: "transformState.h".} ## \
## Performs a garbage-collection cycle.  This must be called periodically if
## garbage-collect-states is true to ensure that TransformStates get cleaned
## up appropriately.  It does no harm to call it even if this variable is not
## true, but there is probably no advantage in that case.

proc list_cycles*(_: typedesc[TransformState], `out`: ostream) {.importcpp: "TransformState::list_cycles(#)", header: "transformState.h".} ## \
## Detects all of the reference-count cycles in the cache and reports them to
## standard output.
##
## These cycles may be inadvertently created when state compositions cycle
## back to a starting point.  Nowadays, these cycles should be automatically
## detected and broken, so this method should never list any cycles unless
## there is a bug in that detection logic.
##
## The cycles listed here are not leaks in the strictest sense of the word,
## since they can be reclaimed by a call to clear_cache(); but they will not
## be reclaimed automatically.

proc list_states*(_: typedesc[TransformState], `out`: ostream) {.importcpp: "TransformState::list_states(#)", header: "transformState.h".} ## \
## Lists all of the TransformStates in the cache to the output stream, one per
## line.  This can be quite a lot of output if the cache is large, so be
## prepared.

proc validate_states*(_: typedesc[TransformState]): bool {.importcpp: "TransformState::validate_states()", header: "transformState.h".} ## \
## Ensures that the cache is still stored in sorted order, and that none of
## the cache elements have been inadvertently deleted.  Returns true if so,
## false if there is a problem (which implies someone has modified one of the
## supposedly-const TransformState objects).

proc get_class_type*(_: typedesc[TransformState]): TypeHandle {.importcpp: "TransformState::get_class_type()", header: "transformState.h".}

proc get_slot*(this: RenderAttribRegistry, type_handle: TypeHandle): int {.importcpp: "#.get_slot(#)".} ## \
## Returns the slot number assigned to the indicated TypeHandle, or 0 if no
## slot number has been assigned.

proc get_max_slots*(_: typedesc[RenderAttribRegistry]): int {.importcpp: "RenderAttribRegistry::get_max_slots()", header: "renderAttribRegistry.h".}

proc get_num_slots*(this: RenderAttribRegistry): int {.importcpp: "#.get_num_slots()".} ## \
## Returns the number of RenderAttrib slots that have been allocated.  This is
## one more than the highest slot number in use.

proc get_slot_type*(this: RenderAttribRegistry, slot: int): TypeHandle {.importcpp: "#.get_slot_type(#)".} ## \
## Returns the TypeHandle associated with slot n.

proc get_slot_sort*(this: RenderAttribRegistry, slot: int): int {.importcpp: "#.get_slot_sort(#)".} ## \
## Returns the sort number associated with slot n.

proc set_slot_sort*(this: RenderAttribRegistry, slot: int, sort: int) {.importcpp: "#.set_slot_sort(#, #)".} ## \
## Changes the sort number associated with slot n.

proc get_slot_default*(this: RenderAttribRegistry, slot: int): RenderAttrib {.importcpp: "#.get_slot_default(#)".} ## \
## Returns the default RenderAttrib object associated with slot n.  This is
## the attrib that should be applied in the absence of any other attrib of
## this type.

proc get_num_sorted_slots*(this: RenderAttribRegistry): int {.importcpp: "#.get_num_sorted_slots()".} ## \
## Returns the number of entries in the sorted_slots list.

proc get_sorted_slot*(this: RenderAttribRegistry, n: int): int {.importcpp: "#.get_sorted_slot(#)".} ## \
## Returns the nth slot in sorted order.  By traversing this list, you will
## retrieve all the slot numbers in order according to their registered sort
## value.

proc get_global_ptr*(_: typedesc[RenderAttribRegistry]): RenderAttribRegistry {.importcpp: "RenderAttribRegistry::get_global_ptr()", header: "renderAttribRegistry.h".}

proc compose*(this: RenderAttrib, other: RenderAttrib): RenderAttrib {.importcpp: "#->compose(#)".} ## \
## Returns a new RenderAttrib object that represents the composition of this
## attrib with the other attrib.  In most cases, this is the same as the other
## attrib; a compose b produces b.  Some kinds of attributes, like a
## TextureTransform, for instance, might produce a new result: a compose b
## produces c.

proc invert_compose*(this: RenderAttrib, other: RenderAttrib): RenderAttrib {.importcpp: "#->invert_compose(#)".} ## \
## Returns a new RenderAttrib object that represents the composition of the
## inverse of this attrib with the other attrib.  In most cases, this is the
## same as the other attrib; !a compose b produces b.  Some kinds of
## attributes, like a TextureTransform, for instance, might produce a new
## result: !a compose b produces c.
##
## This is similar to compose() except that the source attrib is inverted
## first.  This is used to compute the relative attribute for one node as
## viewed from some other node, which is especially useful for transform-type
## attributes.

proc lower_attrib_can_override*(this: RenderAttrib): bool {.importcpp: "#->lower_attrib_can_override()".} ## \
## Intended to be overridden by derived RenderAttrib types to specify how two
## consecutive RenderAttrib objects of the same type interact.
##
## This should return false if a RenderAttrib on a higher node will compose
## into a RenderAttrib on a lower node that has a higher override value, or
## true if the lower RenderAttrib will completely replace the state.
##
## The default behavior is false: normally, a RenderAttrib in the graph cannot
## completely override a RenderAttrib above it, regardless of its override
## value--instead, the two attribs are composed.  But for some kinds of
## RenderAttribs, it is useful to allow this kind of override.
##
## This method only handles the one special case of a lower RenderAttrib with
## a higher override value.  If the higher RenderAttrib has a higher override
## value, it always completely overrides.  And if both RenderAttribs have the
## same override value, they are always composed.

proc compare_to*(this: RenderAttrib, other: RenderAttrib): int {.importcpp: "#->compare_to(#)".} ## \
## Provides an arbitrary ordering among all unique RenderAttribs, so we can
## store the essentially different ones in a big set and throw away the rest.
##
## This method is not needed outside of the RenderAttrib class because all
## equivalent RenderAttrib objects are guaranteed to share the same pointer;
## thus, a pointer comparison is always sufficient.

proc get_hash*(this: RenderAttrib): clonglong {.importcpp: "#->get_hash()".} ## \
## Returns a suitable hash value for phash_map.

proc get_unique*(this: RenderAttrib): RenderAttrib {.importcpp: "#->get_unique()".} ## \
## Returns the pointer to the unique RenderAttrib in the cache that is
## equivalent to this one.  This may be the same pointer as this object, or it
## may be a different pointer; but it will be an equivalent object, and it
## will be a shared pointer.  This may be called from time to time to improve
## cache benefits.

proc output*(this: RenderAttrib, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: RenderAttrib, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc get_num_attribs*(_: typedesc[RenderAttrib]): int {.importcpp: "RenderAttrib::get_num_attribs()", header: "renderAttrib.h".} ## \
## Returns the total number of unique RenderAttrib objects allocated in the
## world.  This will go up and down during normal operations.

proc list_attribs*(_: typedesc[RenderAttrib], `out`: ostream) {.importcpp: "RenderAttrib::list_attribs(#)", header: "renderAttrib.h".} ## \
## Lists all of the RenderAttribs in the cache to the output stream, one per
## line.  This can be quite a lot of output if the cache is large, so be
## prepared.

proc garbage_collect*(_: typedesc[RenderAttrib]): int {.importcpp: "RenderAttrib::garbage_collect()", header: "renderAttrib.h".} ## \
## Performs a garbage-collection cycle.  This is called automatically from
## RenderState::garbage_collect(); see that method for more information.

proc validate_attribs*(_: typedesc[RenderAttrib]): bool {.importcpp: "RenderAttrib::validate_attribs()", header: "renderAttrib.h".} ## \
## Ensures that the cache is still stored in sorted order.  Returns true if
## so, false if there is a problem (which implies someone has modified one of
## the supposedly-const RenderAttrib objects).

proc get_slot*(this: RenderAttrib): int {.importcpp: "#->get_slot()".}

proc get_class_type*(_: typedesc[RenderAttrib]): TypeHandle {.importcpp: "RenderAttrib::get_class_type()", header: "renderAttrib.h".}

proc make_default*(_: typedesc[RenderModeAttrib]): RenderAttrib {.importcpp: "RenderModeAttrib::make_default()", header: "renderModeAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc get_thickness*(this: RenderModeAttrib): float32 {.importcpp: "#->get_thickness()".} ## \
## Returns the line width or point thickness.  This is only relevant when
## rendering points or lines, such as when the mode is M_wireframe or M_point
## (or when rendering actual points or lines primitives in M_polygon mode).

proc get_perspective*(this: RenderModeAttrib): bool {.importcpp: "#->get_perspective()".} ## \
## Returns the perspective flag.  When this is true, the point thickness
## represented by get_thickness() is actually a width in 3-d units, and the
## points should scale according to perspective.  When it is false, the
## default, the point thickness is actually a width in pixels, and points are
## a uniform size regardless of distance from the camera.

proc get_wireframe_color*(this: RenderModeAttrib): LColor {.importcpp: "#->get_wireframe_color()".} ## \
## Returns the color that is used in M_filled_wireframe mode to distinguish
## the wireframe from the rest of the geometry.

proc get_geom_rendering*(this: RenderModeAttrib, geom_rendering: int): int {.importcpp: "#->get_geom_rendering(#)".} ## \
## Returns the union of the Geom::GeomRendering bits that will be required
## once this RenderModeAttrib is applied to a geom which includes the
## indicated geom_rendering bits.

proc get_class_slot*(_: typedesc[RenderModeAttrib]): int {.importcpp: "RenderModeAttrib::get_class_slot()", header: "renderModeAttrib.h".}

proc get_class_type*(_: typedesc[RenderModeAttrib]): TypeHandle {.importcpp: "RenderModeAttrib::get_class_type()", header: "renderModeAttrib.h".}

proc make*(_: typedesc[TexMatrixAttrib]): RenderAttrib {.importcpp: "TexMatrixAttrib::make()", header: "texMatrixAttrib.h".} ## \
## Constructs a TexMatrixAttrib that applies no stages at all.

proc make*(_: typedesc[TexMatrixAttrib], mat: LMatrix4): RenderAttrib {.importcpp: "TexMatrixAttrib::make(#)", header: "texMatrixAttrib.h".} ## \
## Constructs a TexMatrixAttrib that applies the indicated matrix to the
## default texture stage.  This interface is deprecated.
##
## @deprecated Use the constructor that takes a TextureStage instead.

proc make*(_: typedesc[TexMatrixAttrib], stage: TextureStage, transform: TransformState): RenderAttrib {.importcpp: "TexMatrixAttrib::make(#, #)", header: "texMatrixAttrib.h".} ## \
## Constructs a TexMatrixAttrib that applies the indicated transform to the
## named texture stage.

proc make_default*(_: typedesc[TexMatrixAttrib]): RenderAttrib {.importcpp: "TexMatrixAttrib::make_default()", header: "texMatrixAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc add_stage*(this: TexMatrixAttrib, stage: TextureStage, transform: TransformState, override: int): RenderAttrib {.importcpp: "#->add_stage(#, #, #)".} ## \
## Returns a new TexMatrixAttrib just like this one, with the indicated
## transform for the given stage.  If this stage already exists, its transform
## is replaced.

proc add_stage*(this: TexMatrixAttrib, stage: TextureStage, transform: TransformState): RenderAttrib {.importcpp: "#->add_stage(#, #)".} ## \
## Returns a new TexMatrixAttrib just like this one, with the indicated
## transform for the given stage.  If this stage already exists, its transform
## is replaced.

proc remove_stage*(this: TexMatrixAttrib, stage: TextureStage): RenderAttrib {.importcpp: "#->remove_stage(#)".} ## \
## Returns a new TexMatrixAttrib just like this one, with the indicated stage
## removed.

proc is_empty*(this: TexMatrixAttrib): bool {.importcpp: "#->is_empty()".} ## \
## Returns true if no stages are defined in the TexMatrixAttrib, false if at
## least one is.

proc has_stage*(this: TexMatrixAttrib, stage: TextureStage): bool {.importcpp: "#->has_stage(#)".} ## \
## Returns true if there is a transform associated with the indicated stage,
## or false otherwise (in which case get_transform(stage) will return the
## identity transform).

proc get_num_stages*(this: TexMatrixAttrib): int {.importcpp: "#->get_num_stages()".} ## \
## Returns the number of stages that are represented by this attrib.

proc get_stage*(this: TexMatrixAttrib, n: int): TextureStage {.importcpp: "#->get_stage(#)".} ## \
## Returns the nth stage that is represented by this attrib.  The
## TextureStages are in no particular order.

proc get_mat*(this: TexMatrixAttrib): LMatrix4 {.importcpp: "#->get_mat()".} ## \
## Returns the transformation matrix associated with the default texture
## stage.

proc get_mat*(this: TexMatrixAttrib, stage: TextureStage): LMatrix4 {.importcpp: "#->get_mat(#)".} ## \
## Returns the transformation matrix associated with the indicated texture
## stage, or identity matrix if nothing is associated with the indicated
## stage.

proc get_transform*(this: TexMatrixAttrib, stage: TextureStage): TransformState {.importcpp: "#->get_transform(#)".} ## \
## Returns the transformation associated with the indicated texture stage, or
## identity matrix if nothing is associated with the indicated stage.

proc get_override*(this: TexMatrixAttrib, stage: TextureStage): int {.importcpp: "#->get_override(#)".} ## \
## Returns the override value associated with the indicated stage.

proc get_geom_rendering*(this: TexMatrixAttrib, geom_rendering: int): int {.importcpp: "#->get_geom_rendering(#)".} ## \
## Returns the union of the Geom::GeomRendering bits that will be required
## once this TexMatrixAttrib is applied to a geom which includes the indicated
## geom_rendering bits.

proc get_class_slot*(_: typedesc[TexMatrixAttrib]): int {.importcpp: "TexMatrixAttrib::get_class_slot()", header: "texMatrixAttrib.h".}

proc get_class_type*(_: typedesc[TexMatrixAttrib]): TypeHandle {.importcpp: "TexMatrixAttrib::get_class_type()", header: "texMatrixAttrib.h".}

proc compare_to*(this: RenderState, other: RenderState): int {.importcpp: "#->compare_to(#)".} ## \
## Provides an arbitrary ordering among all unique RenderStates, so we can
## store the essentially different ones in a big set and throw away the rest.
##
## This method is not needed outside of the RenderState class because all
## equivalent RenderState objects are guaranteed to share the same pointer;
## thus, a pointer comparison is always sufficient.

proc compare_sort*(this: RenderState, other: RenderState): int {.importcpp: "#->compare_sort(#)".} ## \
## Returns -1, 0, or 1 according to the relative sorting of these two
## RenderStates, with regards to rendering performance, so that "heavier"
## RenderAttribs (as defined by RenderAttribRegistry::get_slot_sort()) are
## more likely to be grouped together.  This is not related to the sorting
## order defined by compare_to.

proc get_hash*(this: RenderState): clonglong {.importcpp: "#->get_hash()".} ## \
## Returns a suitable hash value for phash_map.

proc is_empty*(this: RenderState): bool {.importcpp: "#->is_empty()".} ## \
## Returns true if the state is empty, false otherwise.

proc has_cull_callback*(this: RenderState): bool {.importcpp: "#->has_cull_callback()".} ## \
## Returns true if any of the RenderAttribs in this state request a
## cull_callback(), false if none of them do.

proc cull_callback*(this: RenderState, trav: CullTraverser, data: CullTraverserData): bool {.importcpp: "#->cull_callback(#, #)".} ## \
## Calls cull_callback() on each attrib.  If any attrib returns false,
## interrupts the list and returns false immediately; otherwise, completes the
## list and returns true.

proc make_empty*(_: typedesc[RenderState]): RenderState {.importcpp: "RenderState::make_empty()", header: "renderState.h".} ## \
## Returns a RenderState with no attributes set.

proc make*(_: typedesc[RenderState], attrib1: RenderAttrib, attrib2: RenderAttrib, attrib3: RenderAttrib, attrib4: RenderAttrib, attrib5: RenderAttrib, override: int): RenderState {.importcpp: "RenderState::make(#, #, #, #, #, #)", header: "renderState.h".} ## \
## Returns a RenderState with five attributes set.

proc make*(_: typedesc[RenderState], attrib1: RenderAttrib, attrib2: RenderAttrib, attrib3: RenderAttrib, attrib4: RenderAttrib, attrib5: RenderAttrib): RenderState {.importcpp: "RenderState::make(#, #, #, #, #)", header: "renderState.h".} ## \
## Returns a RenderState with five attributes set.

proc make*(_: typedesc[RenderState], attrib1: RenderAttrib, attrib2: RenderAttrib, attrib3: RenderAttrib, attrib4: RenderAttrib, override: int): RenderState {.importcpp: "RenderState::make(#, #, #, #, #)", header: "renderState.h".} ## \
## Returns a RenderState with four attributes set.

proc make*(_: typedesc[RenderState], attrib1: RenderAttrib, attrib2: RenderAttrib, attrib3: RenderAttrib, attrib4: RenderAttrib): RenderState {.importcpp: "RenderState::make(#, #, #, #)", header: "renderState.h".} ## \
## Returns a RenderState with four attributes set.

proc make*(_: typedesc[RenderState], attrib1: RenderAttrib, attrib2: RenderAttrib, attrib3: RenderAttrib, override: int): RenderState {.importcpp: "RenderState::make(#, #, #, #)", header: "renderState.h".} ## \
## Returns a RenderState with three attributes set.

proc make*(_: typedesc[RenderState], attrib1: RenderAttrib, attrib2: RenderAttrib, attrib3: RenderAttrib): RenderState {.importcpp: "RenderState::make(#, #, #)", header: "renderState.h".} ## \
## Returns a RenderState with three attributes set.

proc make*(_: typedesc[RenderState], attrib1: RenderAttrib, attrib2: RenderAttrib, override: int): RenderState {.importcpp: "RenderState::make(#, #, #)", header: "renderState.h".} ## \
## Returns a RenderState with two attributes set.

proc make*(_: typedesc[RenderState], attrib1: RenderAttrib, attrib2: RenderAttrib): RenderState {.importcpp: "RenderState::make(#, #)", header: "renderState.h".} ## \
## Returns a RenderState with two attributes set.

proc make*(_: typedesc[RenderState], attrib: RenderAttrib, override: int): RenderState {.importcpp: "RenderState::make(#, #)", header: "renderState.h".} ## \
## Returns a RenderState with one attribute set.

proc make*(_: typedesc[RenderState], attrib: RenderAttrib): RenderState {.importcpp: "RenderState::make(#)", header: "renderState.h".} ## \
## Returns a RenderState with one attribute set.

proc compose*(this: RenderState, other: RenderState): RenderState {.importcpp: "#->compose(#)".} ## \
## Returns a new RenderState object that represents the composition of this
## state with the other state.
##
## The result of this operation is cached, and will be retained as long as
## both this RenderState object and the other RenderState object continue to
## exist.  Should one of them destruct, the cached entry will be removed, and
## its pointer will be allowed to destruct as well.

proc invert_compose*(this: RenderState, other: RenderState): RenderState {.importcpp: "#->invert_compose(#)".} ## \
## Returns a new RenderState object that represents the composition of this
## state's inverse with the other state.
##
## This is similar to compose(), but is particularly useful for computing the
## relative state of a node as viewed from some other node.

proc add_attrib*(this: RenderState, attrib: RenderAttrib, override: int): RenderState {.importcpp: "#->add_attrib(#, #)".} ## \
## Returns a new RenderState object that represents the same as the source
## state, with the new RenderAttrib added.  If there is already a RenderAttrib
## with the same type, it is replaced (unless the override is lower).

proc add_attrib*(this: RenderState, attrib: RenderAttrib): RenderState {.importcpp: "#->add_attrib(#)".} ## \
## Returns a new RenderState object that represents the same as the source
## state, with the new RenderAttrib added.  If there is already a RenderAttrib
## with the same type, it is replaced (unless the override is lower).

proc set_attrib*(this: RenderState, attrib: RenderAttrib): RenderState {.importcpp: "#->set_attrib(#)".} ## \
## Returns a new RenderState object that represents the same as the source
## state, with the new RenderAttrib added.  If there is already a RenderAttrib
## with the same type, it is replaced unconditionally.  The override is not
## changed.

proc set_attrib*(this: RenderState, attrib: RenderAttrib, override: int): RenderState {.importcpp: "#->set_attrib(#, #)".} ## \
## Returns a new RenderState object that represents the same as the source
## state, with the new RenderAttrib added.  If there is already a RenderAttrib
## with the same type, it is replaced unconditionally.  The override is also
## replaced unconditionally.

proc remove_attrib*(this: RenderState, `type`: TypeHandle): RenderState {.importcpp: "#->remove_attrib(#)".} ## \
## Returns a new RenderState object that represents the same as the source
## state, with the indicated RenderAttrib removed.

proc remove_attrib*(this: RenderState, slot: int): RenderState {.importcpp: "#->remove_attrib(#)".} ## \
## Returns a new RenderState object that represents the same as the source
## state, with the indicated RenderAttrib removed.

proc adjust_all_priorities*(this: RenderState, adjustment: int): RenderState {.importcpp: "#->adjust_all_priorities(#)".} ## \
## Returns a new RenderState object that represents the same as the source
## state, with all attributes' override values incremented (or decremented, if
## negative) by the indicated amount.  If the override would drop below zero,
## it is set to zero.

proc has_attrib*(this: RenderState, `type`: TypeHandle): bool {.importcpp: "#->has_attrib(#)".} ## \
## Returns true if an attrib of the indicated type is present, false
## otherwise.

proc has_attrib*(this: RenderState, slot: int): bool {.importcpp: "#->has_attrib(#)".} ## \
## Returns true if an attrib of the indicated type is present, false
## otherwise.

proc get_attrib*(this: RenderState, `type`: TypeHandle): RenderAttrib {.importcpp: "#->get_attrib(#)".} ## \
## Looks for a RenderAttrib of the indicated type in the state, and returns it
## if it is found, or NULL if it is not.

proc get_attrib*(this: RenderState, slot: int): RenderAttrib {.importcpp: "#->get_attrib(#)".} ## \
## Returns the RenderAttrib with the indicated slot index, or NULL if there is
## no such RenderAttrib in the state.

proc get_attrib_def*(this: RenderState, slot: int): RenderAttrib {.importcpp: "#->get_attrib_def(#)".} ## \
## Returns the RenderAttrib with the indicated slot index, or the default
## attrib for that slot if there is no such RenderAttrib in the state.

proc get_override*(this: RenderState, `type`: TypeHandle): int {.importcpp: "#->get_override(#)".} ## \
## Looks for a RenderAttrib of the indicated type in the state, and returns
## its override value if it is found, or 0 if it is not.

proc get_override*(this: RenderState, slot: int): int {.importcpp: "#->get_override(#)".} ## \
## Looks for a RenderAttrib of the indicated type in the state, and returns
## its override value if it is found, or 0 if it is not.

proc get_unique*(this: RenderState): RenderState {.importcpp: "#->get_unique()".} ## \
## Returns the pointer to the unique RenderState in the cache that is
## equivalent to this one.  This may be the same pointer as this object, or it
## may be a different pointer; but it will be an equivalent object, and it
## will be a shared pointer.  This may be called from time to time to improve
## cache benefits.

proc cache_ref*(this: RenderState) {.importcpp: "#->cache_ref()".} ## \
## Overrides this method to update PStats appropriately.

proc cache_unref*(this: RenderState): bool {.importcpp: "#->cache_unref()".} ## \
## Overrides this method to update PStats appropriately.

proc node_ref*(this: RenderState) {.importcpp: "#->node_ref()".} ## \
## Overrides this method to update PStats appropriately.

proc node_unref*(this: RenderState): bool {.importcpp: "#->node_unref()".} ## \
## Overrides this method to update PStats appropriately.

proc get_composition_cache_num_entries*(this: RenderState): clonglong {.importcpp: "#->get_composition_cache_num_entries()".} ## \
## Returns the number of entries in the composition cache for this
## RenderState.  This is the number of other RenderStates whose composition
## with this one has been cached.  This number is not useful for any practical
## reason other than performance analysis.

proc get_invert_composition_cache_num_entries*(this: RenderState): clonglong {.importcpp: "#->get_invert_composition_cache_num_entries()".} ## \
## Returns the number of entries in the invert_composition cache for this
## RenderState.  This is similar to the composition cache, but it records
## cache entries for the invert_compose() operation.  See
## get_composition_cache_num_entries().

proc get_composition_cache_size*(this: RenderState): clonglong {.importcpp: "#->get_composition_cache_size()".} ## \
## Returns the number of slots in the composition cache for this RenderState.
## You may use this as an upper bound when walking through all of the
## composition cache results via get_composition_cache_source() or result().
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc get_composition_cache_source*(this: RenderState, n: clonglong): RenderState {.importcpp: "#->get_composition_cache_source(#)".} ## \
## Returns the source RenderState of the nth element in the composition cache.
## Returns NULL if there doesn't happen to be an entry in the nth element.
## See get_composition_cache_result().
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc get_composition_cache_result*(this: RenderState, n: clonglong): RenderState {.importcpp: "#->get_composition_cache_result(#)".} ## \
## Returns the result RenderState of the nth element in the composition cache.
## Returns NULL if there doesn't happen to be an entry in the nth element.
##
## In general, a->compose(a->get_composition_cache_source(n)) ==
## a->get_composition_cache_result(n).
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc get_invert_composition_cache_size*(this: RenderState): clonglong {.importcpp: "#->get_invert_composition_cache_size()".} ## \
## Returns the number of slots in the composition cache for this RenderState.
## You may use this as an upper bound when walking through all of the
## composition cache results via get_invert_composition_cache_source() or
## result().
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc get_invert_composition_cache_source*(this: RenderState, n: clonglong): RenderState {.importcpp: "#->get_invert_composition_cache_source(#)".} ## \
## Returns the source RenderState of the nth element in the invert composition
## cache.  Returns NULL if there doesn't happen to be an entry in the nth
## element.  See get_invert_composition_cache_result().
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc get_invert_composition_cache_result*(this: RenderState, n: clonglong): RenderState {.importcpp: "#->get_invert_composition_cache_result(#)".} ## \
## Returns the result RenderState of the nth element in the invert composition
## cache.  Returns NULL if there doesn't happen to be an entry in the nth
## element.
##
## In general, a->invert_compose(a->get_invert_composition_cache_source(n)) ==
## a->get_invert_composition_cache_result(n).
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc output*(this: RenderState, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: RenderState, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc get_max_priority*(_: typedesc[RenderState]): int {.importcpp: "RenderState::get_max_priority()", header: "renderState.h".} ## \
## Returns the maximum priority number (sometimes called override) that may be
## set on any node.  This may or may not be enforced, but the scene graph code
## assumes that no priority numbers will be larger than this, and some effects
## may not work properly if you use a larger number.

proc get_num_states*(_: typedesc[RenderState]): int {.importcpp: "RenderState::get_num_states()", header: "renderState.h".} ## \
## Returns the total number of unique RenderState objects allocated in the
## world.  This will go up and down during normal operations.

proc get_num_unused_states*(_: typedesc[RenderState]): int {.importcpp: "RenderState::get_num_unused_states()", header: "renderState.h".} ## \
## Returns the total number of RenderState objects that have been allocated
## but have no references outside of the internal RenderState cache.
##
## A nonzero return value is not necessarily indicative of leaked references;
## it is normal for two RenderState objects, both of which have references
## held outside the cache, to have to result of their composition stored
## within the cache.  This result will be retained within the cache until one
## of the base RenderStates is released.
##
## Use list_cycles() to get an idea of the number of actual "leaked"
## RenderState objects.

proc clear_cache*(_: typedesc[RenderState]): int {.importcpp: "RenderState::clear_cache()", header: "renderState.h".} ## \
## Empties the cache of composed RenderStates.  This makes every RenderState
## forget what results when it is composed with other RenderStates.
##
## This will eliminate any RenderState objects that have been allocated but
## have no references outside of the internal RenderState map.  It will not
## eliminate RenderState objects that are still in use.
##
## Nowadays, this method should not be necessary, as reference-count cycles in
## the composition cache should be automatically detected and broken.
##
## The return value is the number of RenderStates freed by this operation.

proc clear_munger_cache*(_: typedesc[RenderState]) {.importcpp: "RenderState::clear_munger_cache()", header: "renderState.h".} ## \
## Completely empties the cache of state + gsg -> munger, for all states and
## all gsg's.  Normally there is no need to empty this cache.

proc garbage_collect*(_: typedesc[RenderState]): int {.importcpp: "RenderState::garbage_collect()", header: "renderState.h".} ## \
## Performs a garbage-collection cycle.  This must be called periodically if
## garbage-collect-states is true to ensure that RenderStates get cleaned up
## appropriately.  It does no harm to call it even if this variable is not
## true, but there is probably no advantage in that case.
##
## This automatically calls RenderAttrib::garbage_collect() as well.

proc list_cycles*(_: typedesc[RenderState], `out`: ostream) {.importcpp: "RenderState::list_cycles(#)", header: "renderState.h".} ## \
## Detects all of the reference-count cycles in the cache and reports them to
## standard output.
##
## These cycles may be inadvertently created when state compositions cycle
## back to a starting point.  Nowadays, these cycles should be automatically
## detected and broken, so this method should never list any cycles unless
## there is a bug in that detection logic.
##
## The cycles listed here are not leaks in the strictest sense of the word,
## since they can be reclaimed by a call to clear_cache(); but they will not
## be reclaimed automatically.

proc list_states*(_: typedesc[RenderState], `out`: ostream) {.importcpp: "RenderState::list_states(#)", header: "renderState.h".} ## \
## Lists all of the RenderStates in the cache to the output stream, one per
## line.  This can be quite a lot of output if the cache is large, so be
## prepared.

proc validate_states*(_: typedesc[RenderState]): bool {.importcpp: "RenderState::validate_states()", header: "renderState.h".} ## \
## Ensures that the cache is still stored in sorted order, and that none of
## the cache elements have been inadvertently deleted.  Returns true if so,
## false if there is a problem (which implies someone has modified one of the
## supposedly-const RenderState objects).

proc get_draw_order*(this: RenderState): int {.importcpp: "#->get_draw_order()".} ## \
## Returns the draw order indicated by the CullBinAttrib, if any, associated
## by this state (or 0 if there is no CullBinAttrib).  See get_bin_index().

proc get_bin_index*(this: RenderState): int {.importcpp: "#->get_bin_index()".} ## \
## Returns the bin index indicated by the CullBinAttrib, if any, associated by
## this state (or the default bin index if there is no CullBinAttrib).  This
## function is provided as an optimization for determining this at render
## time.

proc get_geom_rendering*(this: RenderState, geom_rendering: int): int {.importcpp: "#->get_geom_rendering(#)".} ## \
## Returns the union of the Geom::GeomRendering bits that will be required
## once this RenderState is applied to a geom which includes the indicated
## geom_rendering bits.

proc get_class_type*(_: typedesc[RenderState]): TypeHandle {.importcpp: "RenderState::get_class_type()", header: "renderState.h".}

proc make_default*(_: typedesc[AlphaTestAttrib]): RenderAttrib {.importcpp: "AlphaTestAttrib::make_default()", header: "alphaTestAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc get_reference_alpha*(this: AlphaTestAttrib): float32 {.importcpp: "#->get_reference_alpha()".} ## \
## Returns the alpha reference value.

proc get_class_slot*(_: typedesc[AlphaTestAttrib]): int {.importcpp: "AlphaTestAttrib::get_class_slot()", header: "alphaTestAttrib.h".}

proc get_class_type*(_: typedesc[AlphaTestAttrib]): TypeHandle {.importcpp: "AlphaTestAttrib::get_class_type()", header: "alphaTestAttrib.h".}

proc make*(_: typedesc[AntialiasAttrib], mode: int): RenderAttrib {.importcpp: "AntialiasAttrib::make(#)", header: "antialiasAttrib.h".} ## \
## Constructs a new AntialiasAttrib object.
##
## The mode should be either M_none, M_auto, or a union of any or all of
## M_point, M_line, M_polygon, and M_multisample.  Also, in addition to the
## above choices, it may include either of M_better of M_faster to specify a
## performance/quality tradeoff hint.
##
## If M_none is specified, no antialiasing is performed.
##
## If M_multisample is specified, it means to use the special framebuffer
## multisample bits for antialiasing, if it is available.  If so, the M_point,
## M_line, and M_polygon modes are ignored.  This advanced antialiasing mode
## is only available on certain graphics hardware.  If it is not available,
## the M_multisample bit is ignored (and the other modes may be used instead,
## if specified).
##
## M_point, M_line, and/or M_polygon specify per-primitive smoothing.  When
## enabled, M_point and M_line may force transparency on.  M_polygon requires
## a frame buffer that includes an alpha channel, and it works best if the
## primitives are sorted front-to-back.
##
## If M_auto is specified, M_multisample is selected if it is available,
## otherwise M_polygon is selected, unless drawing lines or points, in which
## case M_line or M_point is selected (these two generally produce better
## results than M_multisample)

proc make_default*(_: typedesc[AntialiasAttrib]): RenderAttrib {.importcpp: "AntialiasAttrib::make_default()", header: "antialiasAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc get_mode*(this: AntialiasAttrib): int {.importcpp: "#->get_mode()".} ## \
## Returns the specified antialias mode.

proc get_mode_type*(this: AntialiasAttrib): int {.importcpp: "#->get_mode_type()".} ## \
## Returns the specified antialias mode, with the quality bits masked out.
## This therefore indicates only the requested type of antialiasing: M_none,
## M_auto, or some specific combination.

proc get_mode_quality*(this: AntialiasAttrib): int {.importcpp: "#->get_mode_quality()".} ## \
## Returns the specified antialias mode, with the type bits masked out.  This
## therefore indicates only the requested quality settings: one of M_faster,
## M_better, M_dont_care, or zero (unspecified).

proc get_class_slot*(_: typedesc[AntialiasAttrib]): int {.importcpp: "AntialiasAttrib::get_class_slot()", header: "antialiasAttrib.h".}

proc get_class_type*(_: typedesc[AntialiasAttrib]): TypeHandle {.importcpp: "AntialiasAttrib::get_class_type()", header: "antialiasAttrib.h".}

proc compare_to*(this: RenderEffect, other: RenderEffect): int {.importcpp: "#->compare_to(#)".} ## \
## Provides an arbitrary ordering among all unique RenderEffects, so we can
## store the essentially different ones in a big set and throw away the rest.
##
## This method is not needed outside of the RenderEffect class because all
## equivalent RenderEffect objects are guaranteed to share the same pointer;
## thus, a pointer comparison is always sufficient.

proc output*(this: RenderEffect, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: RenderEffect, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc get_num_effects*(_: typedesc[RenderEffect]): int {.importcpp: "RenderEffect::get_num_effects()", header: "renderEffect.h".} ## \
## Returns the total number of unique RenderEffect objects allocated in the
## world.  This will go up and down during normal operations.

proc list_effects*(_: typedesc[RenderEffect], `out`: ostream) {.importcpp: "RenderEffect::list_effects(#)", header: "renderEffect.h".} ## \
## Lists all of the RenderEffects in the cache to the output stream, one per
## line.  This can be quite a lot of output if the cache is large, so be
## prepared.

proc validate_effects*(_: typedesc[RenderEffect]): bool {.importcpp: "RenderEffect::validate_effects()", header: "renderEffect.h".} ## \
## Ensures that the cache is still stored in sorted order.  Returns true if
## so, false if there is a problem (which implies someone has modified one of
## the supposedly-const RenderEffect objects).

proc get_class_type*(_: typedesc[RenderEffect]): TypeHandle {.importcpp: "RenderEffect::get_class_type()", header: "renderEffect.h".}

proc `<`*(this: RenderEffects, other: RenderEffects): bool {.importcpp: "#->operator <(#)".}

proc is_empty*(this: RenderEffects): bool {.importcpp: "#->is_empty()".} ## \
## Returns true if the state is empty, false otherwise.

proc get_num_effects*(this: RenderEffects): clonglong {.importcpp: "#->get_num_effects()".} ## \
## Returns the number of separate effects indicated in the state.
## @deprecated in Python, use len(effects) instead, or effects.size() in C++.

proc get_effect*(this: RenderEffects, `type`: TypeHandle): RenderEffect {.importcpp: "#->get_effect(#)".} ## \
## Looks for a RenderEffect of the indicated type in the state, and returns it
## if it is found, or NULL if it is not.

proc get_effect*(this: RenderEffects, n: clonglong): RenderEffect {.importcpp: "#->get_effect(#)".} ## \
## Returns the nth effect in the state.

proc size*(this: RenderEffects): clonglong {.importcpp: "#->size()".} ## \
## Returns the number of separate effects indicated in the state.

proc `[]`*(this: RenderEffects, `type`: TypeHandle): RenderEffect {.importcpp: "#->operator [](#)".} ## \
## Returns the effect in the state with the given type.

proc `[]`*(this: RenderEffects, n: clonglong): RenderEffect {.importcpp: "#->operator [](#)".} ## \
## Returns the nth effect in the state.

proc find_effect*(this: RenderEffects, `type`: TypeHandle): int {.importcpp: "#->find_effect(#)".} ## \
## Searches for an effect with the indicated type in the state, and returns
## its index if it is found, or -1 if it is not.

proc make_empty*(_: typedesc[RenderEffects]): RenderEffects {.importcpp: "RenderEffects::make_empty()", header: "renderEffects.h".} ## \
## Returns a RenderEffects with no effects set.

proc make*(_: typedesc[RenderEffects], effect: RenderEffect): RenderEffects {.importcpp: "RenderEffects::make(#)", header: "renderEffects.h".} ## \
## Returns a RenderEffects with one effect set.

proc make*(_: typedesc[RenderEffects], effect1: RenderEffect, effect2: RenderEffect): RenderEffects {.importcpp: "RenderEffects::make(#, #)", header: "renderEffects.h".} ## \
## Returns a RenderEffects with two effects set.

proc make*(_: typedesc[RenderEffects], effect1: RenderEffect, effect2: RenderEffect, effect3: RenderEffect): RenderEffects {.importcpp: "RenderEffects::make(#, #, #)", header: "renderEffects.h".} ## \
## Returns a RenderEffects with three effects set.

proc make*(_: typedesc[RenderEffects], effect1: RenderEffect, effect2: RenderEffect, effect3: RenderEffect, effect4: RenderEffect): RenderEffects {.importcpp: "RenderEffects::make(#, #, #, #)", header: "renderEffects.h".} ## \
## Returns a RenderEffects with four effects set.

proc add_effect*(this: RenderEffects, effect: RenderEffect): RenderEffects {.importcpp: "#->add_effect(#)".} ## \
## Returns a new RenderEffects object that represents the same as the source
## state, with the new RenderEffect added.  If there is already a RenderEffect
## with the same type, it is replaced.

proc remove_effect*(this: RenderEffects, `type`: TypeHandle): RenderEffects {.importcpp: "#->remove_effect(#)".} ## \
## Returns a new RenderEffects object that represents the same as the source
## state, with the indicated RenderEffect removed.

proc output*(this: RenderEffects, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: RenderEffects, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc get_num_states*(_: typedesc[RenderEffects]): int {.importcpp: "RenderEffects::get_num_states()", header: "renderEffects.h".} ## \
## Returns the total number of unique RenderEffects objects allocated in the
## world.  This will go up and down during normal operations.

proc list_states*(_: typedesc[RenderEffects], `out`: ostream) {.importcpp: "RenderEffects::list_states(#)", header: "renderEffects.h".} ## \
## Lists all of the RenderEffects in the cache to the output stream, one per
## line.  This can be quite a lot of output if the cache is large, so be
## prepared.

proc validate_states*(_: typedesc[RenderEffects]): bool {.importcpp: "RenderEffects::validate_states()", header: "renderEffects.h".} ## \
## Ensures that the cache is still stored in sorted order.  Returns true if
## so, false if there is a problem (which implies someone has modified one of
## the supposedly-const RenderEffects objects).

proc get_class_type*(_: typedesc[RenderEffects]): TypeHandle {.importcpp: "RenderEffects::get_class_type()", header: "renderEffects.h".}

converter upcast_to_TypedWritableReferenceCount*(this: PandaNode): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcast_to_Namable*(this: PandaNode): Namable {.importcpp: "((Namable *)(#.p()))".}

proc newPandaNode*(name: string): PandaNode {.importcpp: "new PandaNode(nimStringToStdString(#))", header: stringConversionCode.}

proc combine_with*(this: PandaNode, other: PandaNode): PandaNode {.importcpp: "#->combine_with(#)".} ## \
## Collapses this PandaNode with the other PandaNode, if possible, and returns
## a pointer to the combined PandaNode, or NULL if the two PandaNodes cannot
## safely be combined.
##
## The return value may be this, other, or a new PandaNode altogether.
##
## This function is called from GraphReducer::flatten(), and need not deal
## with children; its job is just to decide whether to collapse the two
## PandaNodes and what the collapsed PandaNode should look like.

proc make_copy*(this: PandaNode): PandaNode {.importcpp: "#->make_copy()".} ## \
## Returns a newly-allocated PandaNode that is a shallow copy of this one.  It
## will be a different pointer, but its internal data may or may not be shared
## with that of the original PandaNode.  No children will be copied.

proc copy_subgraph*(this: PandaNode, current_thread: Thread): PandaNode {.importcpp: "#->copy_subgraph(#)".} ## \
## Allocates and returns a complete copy of this PandaNode and the entire
## scene graph rooted at this PandaNode.  Some data may still be shared from
## the original (e.g.  vertex index tables), but nothing that will impede
## normal use of the PandaNode.

proc copy_subgraph*(this: PandaNode): PandaNode {.importcpp: "#->copy_subgraph()".} ## \
## Allocates and returns a complete copy of this PandaNode and the entire
## scene graph rooted at this PandaNode.  Some data may still be shared from
## the original (e.g.  vertex index tables), but nothing that will impede
## normal use of the PandaNode.

proc get_num_parents*(this: PandaNode, current_thread: Thread): int {.importcpp: "#->get_num_parents(#)".} ## \
## Returns the number of parent nodes this node has.  If this number is
## greater than 1, the node has been multiply instanced.  The order of the
## parent nodes is not meaningful and is not related to the order in which the
## node was instanced to them.

proc get_num_parents*(this: PandaNode): int {.importcpp: "#->get_num_parents()".} ## \
## Returns the number of parent nodes this node has.  If this number is
## greater than 1, the node has been multiply instanced.  The order of the
## parent nodes is not meaningful and is not related to the order in which the
## node was instanced to them.

proc get_parent*(this: PandaNode, n: int, current_thread: Thread): PandaNode {.importcpp: "#->get_parent(#, #)".} ## \
## Returns the nth parent node of this node.  See get_num_parents().  Also see
## get_parents(), if your intention is to iterate through the complete list of
## parents; get_parents() is preferable in this case.

proc get_parent*(this: PandaNode, n: int): PandaNode {.importcpp: "#->get_parent(#)".} ## \
## Returns the nth parent node of this node.  See get_num_parents().  Also see
## get_parents(), if your intention is to iterate through the complete list of
## parents; get_parents() is preferable in this case.

proc find_parent*(this: PandaNode, node: PandaNode, current_thread: Thread): int {.importcpp: "#->find_parent(#, #)".} ## \
## Returns the index of the indicated parent node, if it is a parent, or -1 if
## it is not.

proc find_parent*(this: PandaNode, node: PandaNode): int {.importcpp: "#->find_parent(#)".} ## \
## Returns the index of the indicated parent node, if it is a parent, or -1 if
## it is not.

proc get_num_children*(this: PandaNode, current_thread: Thread): int {.importcpp: "#->get_num_children(#)".} ## \
## Returns the number of child nodes this node has.  The order of the child
## nodes *is* meaningful and is based on the sort number that was passed to
## add_child(), and also on the order in which the nodes were added.

proc get_num_children*(this: PandaNode): int {.importcpp: "#->get_num_children()".} ## \
## Returns the number of child nodes this node has.  The order of the child
## nodes *is* meaningful and is based on the sort number that was passed to
## add_child(), and also on the order in which the nodes were added.

proc get_child*(this: PandaNode, n: int, current_thread: Thread): PandaNode {.importcpp: "#->get_child(#, #)".} ## \
## Returns the nth child node of this node.  See get_num_children().  Also see
## get_children(), if your intention is to iterate through the complete list
## of children; get_children() is preferable in this case.

proc get_child*(this: PandaNode, n: int): PandaNode {.importcpp: "#->get_child(#)".} ## \
## Returns the nth child node of this node.  See get_num_children().  Also see
## get_children(), if your intention is to iterate through the complete list
## of children; get_children() is preferable in this case.

proc get_child_sort*(this: PandaNode, n: int, current_thread: Thread): int {.importcpp: "#->get_child_sort(#, #)".} ## \
## Returns the sort index of the nth child node of this node (that is, the
## number that was passed to add_child()).  See get_num_children().

proc get_child_sort*(this: PandaNode, n: int): int {.importcpp: "#->get_child_sort(#)".} ## \
## Returns the sort index of the nth child node of this node (that is, the
## number that was passed to add_child()).  See get_num_children().

proc find_child*(this: PandaNode, node: PandaNode, current_thread: Thread): int {.importcpp: "#->find_child(#, #)".} ## \
## Returns the index of the indicated child node, if it is a child, or -1 if
## it is not.

proc find_child*(this: PandaNode, node: PandaNode): int {.importcpp: "#->find_child(#)".} ## \
## Returns the index of the indicated child node, if it is a child, or -1 if
## it is not.

proc count_num_descendants*(this: PandaNode): int {.importcpp: "#->count_num_descendants()".} ## \
## Returns the number of nodes at and below this level.

proc add_child*(this: PandaNode, child_node: PandaNode, sort: int, current_thread: Thread) {.importcpp: "#->add_child(#, #, #)".} ## \
## Adds a new child to the node.  The child is added in the relative position
## indicated by sort; if all children have the same sort index, the child is
## added at the end.
##
## If the same child is added to a node more than once, the previous instance
## is first removed.

proc add_child*(this: PandaNode, child_node: PandaNode, sort: int) {.importcpp: "#->add_child(#, #)".} ## \
## Adds a new child to the node.  The child is added in the relative position
## indicated by sort; if all children have the same sort index, the child is
## added at the end.
##
## If the same child is added to a node more than once, the previous instance
## is first removed.

proc add_child*(this: PandaNode, child_node: PandaNode) {.importcpp: "#->add_child(#)".} ## \
## Adds a new child to the node.  The child is added in the relative position
## indicated by sort; if all children have the same sort index, the child is
## added at the end.
##
## If the same child is added to a node more than once, the previous instance
## is first removed.

proc remove_child*(this: PandaNode, child_node: PandaNode, current_thread: Thread): bool {.importcpp: "#->remove_child(#, #)".} ## \
## Removes the indicated child from the node.  Returns true if the child was
## removed, false if it was not already a child of the node.  This will also
## successfully remove the child if it had been stashed.

proc remove_child*(this: PandaNode, child_node: PandaNode): bool {.importcpp: "#->remove_child(#)".} ## \
## Removes the indicated child from the node.  Returns true if the child was
## removed, false if it was not already a child of the node.  This will also
## successfully remove the child if it had been stashed.

proc remove_child*(this: PandaNode, child_index: int, current_thread: Thread) {.importcpp: "#->remove_child(#, #)".} ## \
## Removes the nth child from the node.

proc remove_child*(this: PandaNode, child_index: int) {.importcpp: "#->remove_child(#)".} ## \
## Removes the nth child from the node.

proc replace_child*(this: PandaNode, orig_child: PandaNode, new_child: PandaNode, current_thread: Thread): bool {.importcpp: "#->replace_child(#, #, #)".} ## \
## Searches for the orig_child node in the node's list of children, and
## replaces it with the new_child instead.  Returns true if the replacement is
## made, or false if the node is not a child or if there is some other
## problem.

proc replace_child*(this: PandaNode, orig_child: PandaNode, new_child: PandaNode): bool {.importcpp: "#->replace_child(#, #)".} ## \
## Searches for the orig_child node in the node's list of children, and
## replaces it with the new_child instead.  Returns true if the replacement is
## made, or false if the node is not a child or if there is some other
## problem.

proc stash_child*(this: PandaNode, child_node: PandaNode, current_thread: Thread): bool {.importcpp: "#->stash_child(#, #)".} ## \
## Stashes the indicated child node.  This removes the child from the list of
## active children and puts it on a special list of stashed children.  This
## child node no longer contributes to the bounding volume of the PandaNode,
## and is not visited in normal traversals.  It is invisible and uncollidable.
## The child may later be restored by calling unstash_child().
##
## This function returns true if the child node was successfully stashed, or
## false if it was not a child of the node in the first place (e.g.  it was
## previously stashed).

proc stash_child*(this: PandaNode, child_node: PandaNode): bool {.importcpp: "#->stash_child(#)".} ## \
## Stashes the indicated child node.  This removes the child from the list of
## active children and puts it on a special list of stashed children.  This
## child node no longer contributes to the bounding volume of the PandaNode,
## and is not visited in normal traversals.  It is invisible and uncollidable.
## The child may later be restored by calling unstash_child().
##
## This function returns true if the child node was successfully stashed, or
## false if it was not a child of the node in the first place (e.g.  it was
## previously stashed).

proc stash_child*(this: PandaNode, child_index: int, current_thread: Thread) {.importcpp: "#->stash_child(#, #)".} ## \
## Stashes the indicated child node.  This removes the child from the list of
## active children and puts it on a special list of stashed children.  This
## child node no longer contributes to the bounding volume of the PandaNode,
## and is not visited in normal traversals.  It is invisible and uncollidable.
## The child may later be restored by calling unstash_child().
##
## This can only be called from the top pipeline stage (i.e.  from App).

proc stash_child*(this: PandaNode, child_index: int) {.importcpp: "#->stash_child(#)".} ## \
## Stashes the indicated child node.  This removes the child from the list of
## active children and puts it on a special list of stashed children.  This
## child node no longer contributes to the bounding volume of the PandaNode,
## and is not visited in normal traversals.  It is invisible and uncollidable.
## The child may later be restored by calling unstash_child().
##
## This can only be called from the top pipeline stage (i.e.  from App).

proc unstash_child*(this: PandaNode, child_node: PandaNode, current_thread: Thread): bool {.importcpp: "#->unstash_child(#, #)".} ## \
## Returns the indicated stashed node to normal child status.  This removes
## the child from the list of stashed children and puts it on the normal list
## of active children.  This child node once again contributes to the bounding
## volume of the PandaNode, and will be visited in normal traversals.  It is
## visible and collidable.
##
## This function returns true if the child node was successfully stashed, or
## false if it was not a child of the node in the first place (e.g.  it was
## previously stashed).

proc unstash_child*(this: PandaNode, child_node: PandaNode): bool {.importcpp: "#->unstash_child(#)".} ## \
## Returns the indicated stashed node to normal child status.  This removes
## the child from the list of stashed children and puts it on the normal list
## of active children.  This child node once again contributes to the bounding
## volume of the PandaNode, and will be visited in normal traversals.  It is
## visible and collidable.
##
## This function returns true if the child node was successfully stashed, or
## false if it was not a child of the node in the first place (e.g.  it was
## previously stashed).

proc unstash_child*(this: PandaNode, stashed_index: int, current_thread: Thread) {.importcpp: "#->unstash_child(#, #)".} ## \
## Returns the indicated stashed node to normal child status.  This removes
## the child from the list of stashed children and puts it on the normal list
## of active children.  This child node once again contributes to the bounding
## volume of the PandaNode, and will be visited in normal traversals.  It is
## visible and collidable.
##
## This can only be called from the top pipeline stage (i.e.  from App).

proc unstash_child*(this: PandaNode, stashed_index: int) {.importcpp: "#->unstash_child(#)".} ## \
## Returns the indicated stashed node to normal child status.  This removes
## the child from the list of stashed children and puts it on the normal list
## of active children.  This child node once again contributes to the bounding
## volume of the PandaNode, and will be visited in normal traversals.  It is
## visible and collidable.
##
## This can only be called from the top pipeline stage (i.e.  from App).

proc get_num_stashed*(this: PandaNode, current_thread: Thread): int {.importcpp: "#->get_num_stashed(#)".} ## \
## Returns the number of stashed nodes this node has.  These are former
## children of the node that have been moved to the special stashed list via
## stash_child().

proc get_num_stashed*(this: PandaNode): int {.importcpp: "#->get_num_stashed()".} ## \
## Returns the number of stashed nodes this node has.  These are former
## children of the node that have been moved to the special stashed list via
## stash_child().

proc get_stashed*(this: PandaNode, n: int, current_thread: Thread): PandaNode {.importcpp: "#->get_stashed(#, #)".} ## \
## Returns the nth stashed child of this node.  See get_num_stashed().  Also
## see get_stashed(), if your intention is to iterate through the complete
## list of stashed children; get_stashed() is preferable in this case.

proc get_stashed*(this: PandaNode, n: int): PandaNode {.importcpp: "#->get_stashed(#)".} ## \
## Returns the nth stashed child of this node.  See get_num_stashed().  Also
## see get_stashed(), if your intention is to iterate through the complete
## list of stashed children; get_stashed() is preferable in this case.

proc get_stashed_sort*(this: PandaNode, n: int, current_thread: Thread): int {.importcpp: "#->get_stashed_sort(#, #)".} ## \
## Returns the sort index of the nth stashed node of this node (that is, the
## number that was passed to add_child()).  See get_num_stashed().

proc get_stashed_sort*(this: PandaNode, n: int): int {.importcpp: "#->get_stashed_sort(#)".} ## \
## Returns the sort index of the nth stashed node of this node (that is, the
## number that was passed to add_child()).  See get_num_stashed().

proc find_stashed*(this: PandaNode, node: PandaNode, current_thread: Thread): int {.importcpp: "#->find_stashed(#, #)".} ## \
## Returns the index of the indicated stashed node, if it is a stashed child,
## or -1 if it is not.

proc find_stashed*(this: PandaNode, node: PandaNode): int {.importcpp: "#->find_stashed(#)".} ## \
## Returns the index of the indicated stashed node, if it is a stashed child,
## or -1 if it is not.

proc add_stashed*(this: PandaNode, child_node: PandaNode, sort: int, current_thread: Thread) {.importcpp: "#->add_stashed(#, #, #)".} ## \
## Adds a new child to the node, directly as a stashed child.  The child is
## not added in the normal sense, but will be revealed if unstash_child() is
## called on it later.
##
## If the same child is added to a node more than once, the previous instance
## is first removed.
##
## This can only be called from the top pipeline stage (i.e.  from App).

proc add_stashed*(this: PandaNode, child_node: PandaNode, sort: int) {.importcpp: "#->add_stashed(#, #)".} ## \
## Adds a new child to the node, directly as a stashed child.  The child is
## not added in the normal sense, but will be revealed if unstash_child() is
## called on it later.
##
## If the same child is added to a node more than once, the previous instance
## is first removed.
##
## This can only be called from the top pipeline stage (i.e.  from App).

proc add_stashed*(this: PandaNode, child_node: PandaNode) {.importcpp: "#->add_stashed(#)".} ## \
## Adds a new child to the node, directly as a stashed child.  The child is
## not added in the normal sense, but will be revealed if unstash_child() is
## called on it later.
##
## If the same child is added to a node more than once, the previous instance
## is first removed.
##
## This can only be called from the top pipeline stage (i.e.  from App).

proc remove_stashed*(this: PandaNode, child_index: int, current_thread: Thread) {.importcpp: "#->remove_stashed(#, #)".} ## \
## Removes the nth stashed child from the node.

proc remove_stashed*(this: PandaNode, child_index: int) {.importcpp: "#->remove_stashed(#)".} ## \
## Removes the nth stashed child from the node.

proc remove_all_children*(this: PandaNode, current_thread: Thread) {.importcpp: "#->remove_all_children(#)".} ## \
## Removes all the children from the node at once, including stashed children.
##
## This can only be called from the top pipeline stage (i.e.  from App).

proc remove_all_children*(this: PandaNode) {.importcpp: "#->remove_all_children()".} ## \
## Removes all the children from the node at once, including stashed children.
##
## This can only be called from the top pipeline stage (i.e.  from App).

proc steal_children*(this: PandaNode, other: PandaNode, current_thread: Thread) {.importcpp: "#->steal_children(#, #)".} ## \
## Moves all the children from the other node onto this node.
##
## Any NodePaths to child nodes of the other node are truncated, rather than
## moved to the new parent.

proc steal_children*(this: PandaNode, other: PandaNode) {.importcpp: "#->steal_children(#)".} ## \
## Moves all the children from the other node onto this node.
##
## Any NodePaths to child nodes of the other node are truncated, rather than
## moved to the new parent.

proc copy_children*(this: PandaNode, other: PandaNode, current_thread: Thread) {.importcpp: "#->copy_children(#, #)".} ## \
## Makes another instance of all the children of the other node, copying them
## to this node.

proc copy_children*(this: PandaNode, other: PandaNode) {.importcpp: "#->copy_children(#)".} ## \
## Makes another instance of all the children of the other node, copying them
## to this node.

proc set_attrib*(this: PandaNode, attrib: RenderAttrib, override: int) {.importcpp: "#->set_attrib(#, #)".} ## \
## Adds the indicated render attribute to the scene graph on this node.  This
## attribute will now apply to this node and everything below.  If there was
## already an attribute of the same type, it is replaced.

proc set_attrib*(this: PandaNode, attrib: RenderAttrib) {.importcpp: "#->set_attrib(#)".} ## \
## Adds the indicated render attribute to the scene graph on this node.  This
## attribute will now apply to this node and everything below.  If there was
## already an attribute of the same type, it is replaced.

proc get_attrib*(this: PandaNode, `type`: TypeHandle): RenderAttrib {.importcpp: "#->get_attrib(#)".} ## \
## Returns the render attribute of the indicated type, if it is defined on the
## node, or NULL if it is not.  This checks only what is set on this
## particular node level, and has nothing to do with what render attributes
## may be inherited from parent nodes.

proc get_attrib*(this: PandaNode, slot: int): RenderAttrib {.importcpp: "#->get_attrib(#)".} ## \
## Returns the render attribute of the indicated type, if it is defined on the
## node, or NULL if it is not.  This checks only what is set on this
## particular node level, and has nothing to do with what render attributes
## may be inherited from parent nodes.

proc has_attrib*(this: PandaNode, `type`: TypeHandle): bool {.importcpp: "#->has_attrib(#)".} ## \
## Returns true if there is a render attribute of the indicated type defined
## on this node, or false if there is not.

proc has_attrib*(this: PandaNode, slot: int): bool {.importcpp: "#->has_attrib(#)".} ## \
## Returns true if there is a render attribute of the indicated type defined
## on this node, or false if there is not.

proc clear_attrib*(this: PandaNode, `type`: TypeHandle) {.importcpp: "#->clear_attrib(#)".} ## \
## Removes the render attribute of the given type from this node.  This node,
## and the subgraph below, will now inherit the indicated render attribute
## from the nodes above this one.

proc clear_attrib*(this: PandaNode, slot: int) {.importcpp: "#->clear_attrib(#)".} ## \
## Removes the render attribute of the given type from this node.  This node,
## and the subgraph below, will now inherit the indicated render attribute
## from the nodes above this one.

proc set_effect*(this: PandaNode, effect: RenderEffect) {.importcpp: "#->set_effect(#)".} ## \
## Adds the indicated render effect to the scene graph on this node.  If there
## was already an effect of the same type, it is replaced.

proc get_effect*(this: PandaNode, `type`: TypeHandle): RenderEffect {.importcpp: "#->get_effect(#)".} ## \
## Returns the render effect of the indicated type, if it is defined on the
## node, or NULL if it is not.

proc has_effect*(this: PandaNode, `type`: TypeHandle): bool {.importcpp: "#->has_effect(#)".} ## \
## Returns true if there is a render effect of the indicated type defined on
## this node, or false if there is not.

proc clear_effect*(this: PandaNode, `type`: TypeHandle) {.importcpp: "#->clear_effect(#)".} ## \
## Removes the render effect of the given type from this node.

proc set_state*(this: PandaNode, state: RenderState, current_thread: Thread) {.importcpp: "#->set_state(#, #)".} ## \
## Sets the complete RenderState that will be applied to all nodes at this
## level and below.  (The actual state that will be applied to lower nodes is
## based on the composition of RenderStates from above this node as well).
## This completely replaces whatever has been set on this node via repeated
## calls to set_attrib().

proc set_state*(this: PandaNode, state: RenderState) {.importcpp: "#->set_state(#)".} ## \
## Sets the complete RenderState that will be applied to all nodes at this
## level and below.  (The actual state that will be applied to lower nodes is
## based on the composition of RenderStates from above this node as well).
## This completely replaces whatever has been set on this node via repeated
## calls to set_attrib().

proc get_state*(this: PandaNode, current_thread: Thread): RenderState {.importcpp: "#->get_state(#)".} ## \
## Returns the complete RenderState that will be applied to all nodes at this
## level and below, as set on this node.  This returns only the RenderState
## set on this particular node, and has nothing to do with state that might be
## inherited from above.

proc get_state*(this: PandaNode): RenderState {.importcpp: "#->get_state()".} ## \
## Returns the complete RenderState that will be applied to all nodes at this
## level and below, as set on this node.  This returns only the RenderState
## set on this particular node, and has nothing to do with state that might be
## inherited from above.

proc clear_state*(this: PandaNode, current_thread: Thread) {.importcpp: "#->clear_state(#)".} ## \
## Resets this node to leave the render state alone.  Nodes at this level and
## below will once again inherit their render state unchanged from the nodes
## above this level.

proc clear_state*(this: PandaNode) {.importcpp: "#->clear_state()".} ## \
## Resets this node to leave the render state alone.  Nodes at this level and
## below will once again inherit their render state unchanged from the nodes
## above this level.

proc set_effects*(this: PandaNode, effects: RenderEffects, current_thread: Thread) {.importcpp: "#->set_effects(#, #)".} ## \
## Sets the complete RenderEffects that will be applied this node.  This
## completely replaces whatever has been set on this node via repeated calls
## to set_attrib().

proc set_effects*(this: PandaNode, effects: RenderEffects) {.importcpp: "#->set_effects(#)".} ## \
## Sets the complete RenderEffects that will be applied this node.  This
## completely replaces whatever has been set on this node via repeated calls
## to set_attrib().

proc get_effects*(this: PandaNode, current_thread: Thread): RenderEffects {.importcpp: "#->get_effects(#)".} ## \
## Returns the complete RenderEffects that will be applied to this node.

proc get_effects*(this: PandaNode): RenderEffects {.importcpp: "#->get_effects()".} ## \
## Returns the complete RenderEffects that will be applied to this node.

proc clear_effects*(this: PandaNode, current_thread: Thread) {.importcpp: "#->clear_effects(#)".} ## \
## Resets this node to have no render effects.

proc clear_effects*(this: PandaNode) {.importcpp: "#->clear_effects()".} ## \
## Resets this node to have no render effects.

proc set_transform*(this: PandaNode, transform: TransformState, current_thread: Thread) {.importcpp: "#->set_transform(#, #)".} ## \
## Sets the transform that will be applied to this node and below.  This
## defines a new coordinate space at this point in the scene graph and below.

proc set_transform*(this: PandaNode, transform: TransformState) {.importcpp: "#->set_transform(#)".} ## \
## Sets the transform that will be applied to this node and below.  This
## defines a new coordinate space at this point in the scene graph and below.

proc get_transform*(this: PandaNode, current_thread: Thread): TransformState {.importcpp: "#->get_transform(#)".} ## \
## Returns the transform that has been set on this particular node.  This is
## not the net transform from the root, but simply the transform on this
## particular node.

proc get_transform*(this: PandaNode): TransformState {.importcpp: "#->get_transform()".} ## \
## Returns the transform that has been set on this particular node.  This is
## not the net transform from the root, but simply the transform on this
## particular node.

proc clear_transform*(this: PandaNode, current_thread: Thread) {.importcpp: "#->clear_transform(#)".} ## \
## Resets the transform on this node to the identity transform.

proc clear_transform*(this: PandaNode) {.importcpp: "#->clear_transform()".} ## \
## Resets the transform on this node to the identity transform.

proc set_prev_transform*(this: PandaNode, transform: TransformState, current_thread: Thread) {.importcpp: "#->set_prev_transform(#, #)".} ## \
## Sets the transform that represents this node's "previous" position, one
## frame ago, for the purposes of detecting motion for accurate collision
## calculations.

proc set_prev_transform*(this: PandaNode, transform: TransformState) {.importcpp: "#->set_prev_transform(#)".} ## \
## Sets the transform that represents this node's "previous" position, one
## frame ago, for the purposes of detecting motion for accurate collision
## calculations.

proc get_prev_transform*(this: PandaNode, current_thread: Thread): TransformState {.importcpp: "#->get_prev_transform(#)".} ## \
## Returns the transform that has been set as this node's "previous" position.
## See set_prev_transform().

proc get_prev_transform*(this: PandaNode): TransformState {.importcpp: "#->get_prev_transform()".} ## \
## Returns the transform that has been set as this node's "previous" position.
## See set_prev_transform().

proc reset_prev_transform*(this: PandaNode, current_thread: Thread) {.importcpp: "#->reset_prev_transform(#)".} ## \
## Resets the transform that represents this node's "previous" position to the
## same as the current transform.  This is not the same thing as clearing it
## to identity.

proc reset_prev_transform*(this: PandaNode) {.importcpp: "#->reset_prev_transform()".} ## \
## Resets the transform that represents this node's "previous" position to the
## same as the current transform.  This is not the same thing as clearing it
## to identity.

proc has_dirty_prev_transform*(this: PandaNode): bool {.importcpp: "#->has_dirty_prev_transform()".} ## \
## Returns true if this node has the _dirty_prev_transform flag set, which
## indicates its _prev_transform is different from its _transform value (in
## pipeline stage 0).  In this case, the node will be visited by
## reset_prev_transform().

proc reset_all_prev_transform*(_: typedesc[PandaNode], current_thread: Thread) {.importcpp: "PandaNode::reset_all_prev_transform(#)", header: "pandaNode.h".} ## \
## Visits all nodes in the world with the _dirty_prev_transform flag--that is,
## all nodes whose _prev_transform is different from the _transform in
## pipeline stage 0--and resets the _prev_transform to be the same as
## _transform.

proc reset_all_prev_transform*(_: typedesc[PandaNode]) {.importcpp: "PandaNode::reset_all_prev_transform()", header: "pandaNode.h".} ## \
## Visits all nodes in the world with the _dirty_prev_transform flag--that is,
## all nodes whose _prev_transform is different from the _transform in
## pipeline stage 0--and resets the _prev_transform to be the same as
## _transform.

proc set_tag*(this: PandaNode, key: string, value: string, current_thread: Thread) {.importcpp: "#->set_tag(nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Associates a user-defined value with a user-defined key which is stored on
## the node.  This value has no meaning to Panda; but it is stored
## indefinitely on the node until it is requested again.
##
## Each unique key stores a different string value.  There is no effective
## limit on the number of different keys that may be stored or on the length
## of any one key's value.

proc set_tag*(this: PandaNode, key: string, value: string) {.importcpp: "#->set_tag(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Associates a user-defined value with a user-defined key which is stored on
## the node.  This value has no meaning to Panda; but it is stored
## indefinitely on the node until it is requested again.
##
## Each unique key stores a different string value.  There is no effective
## limit on the number of different keys that may be stored or on the length
## of any one key's value.

proc get_tag*(this: PandaNode, key: string, current_thread: Thread): string {.importcpp: "nimStringFromStdString(#->get_tag(nimStringToStdString(#), #))", header: stringConversionCode.} ## \
## Retrieves the user-defined value that was previously set on this node for
## the particular key, if any.  If no value has been previously set, returns
## the empty string.

proc get_tag*(this: PandaNode, key: string): string {.importcpp: "nimStringFromStdString(#->get_tag(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Retrieves the user-defined value that was previously set on this node for
## the particular key, if any.  If no value has been previously set, returns
## the empty string.

proc has_tag*(this: PandaNode, key: string, current_thread: Thread): bool {.importcpp: "#->has_tag(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Returns true if a value has been defined on this node for the particular
## key (even if that value is the empty string), or false if no value has been
## set.

proc has_tag*(this: PandaNode, key: string): bool {.importcpp: "#->has_tag(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if a value has been defined on this node for the particular
## key (even if that value is the empty string), or false if no value has been
## set.

proc clear_tag*(this: PandaNode, key: string, current_thread: Thread) {.importcpp: "#->clear_tag(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Removes the value defined for this key on this particular node.  After a
## call to clear_tag(), has_tag() will return false for the indicated key.

proc clear_tag*(this: PandaNode, key: string) {.importcpp: "#->clear_tag(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the value defined for this key on this particular node.  After a
## call to clear_tag(), has_tag() will return false for the indicated key.

proc get_num_tags*(this: PandaNode): clonglong {.importcpp: "#->get_num_tags()".} ## \
## Returns the number of tags applied to this node.

proc get_tag_key*(this: PandaNode, i: clonglong): string {.importcpp: "nimStringFromStdString(#->get_tag_key(#))", header: stringConversionCode.} ## \
## Returns the key of the nth tag applied to this node.

proc has_tags*(this: PandaNode): bool {.importcpp: "#->has_tags()".} ## \
## Returns true if the node has any tags (or any Python tags) at all, false if
## it has none.

proc copy_tags*(this: PandaNode, other: PandaNode) {.importcpp: "#->copy_tags(#)".} ## \
## Copies all of the tags stored on the other node onto this node.  If a
## particular tag exists on both nodes, the contents of this node's value is
## replaced by that of the other.

proc list_tags*(this: PandaNode, `out`: ostream, separator: string) {.importcpp: "#->list_tags(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Writes a list of all the tag keys assigned to the node to the indicated
## stream.  Writes one instance of the separator following each key (but does
## not write a terminal separator).  The value associated with each key is not
## written.
##
## This is mainly for the benefit of the realtime user, to see the list of all
## of the associated tag keys.

proc list_tags*(this: PandaNode, `out`: ostream) {.importcpp: "#->list_tags(#)".} ## \
## Writes a list of all the tag keys assigned to the node to the indicated
## stream.  Writes one instance of the separator following each key (but does
## not write a terminal separator).  The value associated with each key is not
## written.
##
## This is mainly for the benefit of the realtime user, to see the list of all
## of the associated tag keys.

proc compare_tags*(this: PandaNode, other: PandaNode): int {.importcpp: "#->compare_tags(#)".} ## \
## Returns a number less than 0, 0, or greater than 0, to indicate the
## similarity of tags between this node and the other one.  If this returns 0,
## the tags are identical.  If it returns other than 0, then the tags are
## different; and the nodes may be sorted into a consistent (but arbitrary)
## ordering based on this number.

proc copy_all_properties*(this: PandaNode, other: PandaNode) {.importcpp: "#->copy_all_properties(#)".} ## \
## Copies the TransformState, RenderState, RenderEffects, tags, Python tags,
## and the show/hide state from the other node onto this one.  Typically this
## is used to prepare a node to replace another node in the scene graph (also
## see replace_node()).

proc replace_node*(this: PandaNode, other: PandaNode) {.importcpp: "#->replace_node(#)".} ## \
## Inserts this node into the scene graph in place of the other one, and
## removes the other node.  All scene graph attributes (TransformState,
## RenderState, etc.) are copied to this node.
##
## All children are moved to this node, and removed from the old node.  The
## new node is left in the same place in the old node's parent's list of
## children.
##
## Even NodePaths that reference the old node are updated in-place to
## reference the new node instead.
##
## This method is intended to be used to replace a node of a given type in the
## scene graph with a node of a different type.

proc set_unexpected_change*(this: PandaNode, flags: int) {.importcpp: "#->set_unexpected_change(#)".} ## \
## Sets one or more of the PandaNode::UnexpectedChange bits on, indicating
## that the corresponding property should not change again on this node.  Once
## one of these bits has been set, if the property changes, an assertion
## failure will be raised, which is designed to assist the developer in
## identifying the troublesome code that modified the property unexpectedly.
##
## The input parameter is the union of bits that are to be set.  To clear
## these bits later, use clear_unexpected_change().
##
## Since this is a developer debugging tool only, this function does nothing
## in a production (NDEBUG) build.

proc get_unexpected_change*(this: PandaNode, flags: int): int {.importcpp: "#->get_unexpected_change(#)".} ## \
## Returns nonzero if any of the bits in the input parameter are set on this
## node, or zero if none of them are set.  More specifically, this returns the
## particular set of bits (masked by the input parameter) that have been set
## on this node.  See set_unexpected_change().
##
## Since this is a developer debugging tool only, this function always returns
## zero in a production (NDEBUG) build.

proc clear_unexpected_change*(this: PandaNode, flags: int) {.importcpp: "#->clear_unexpected_change(#)".} ## \
## Sets one or more of the PandaNode::UnexpectedChange bits off, indicating
## that the corresponding property may once again change on this node.  See
## set_unexpected_change().
##
## The input parameter is the union of bits that are to be cleared.
##
## Since this is a developer debugging tool only, this function does nothing
## in a production (NDEBUG) build.

proc is_overall_hidden*(this: PandaNode): bool {.importcpp: "#->is_overall_hidden()".} ## \
## Returns true if the node has been hidden to all cameras by clearing its
## overall bit.

proc set_overall_hidden*(this: PandaNode, overall_hidden: bool) {.importcpp: "#->set_overall_hidden(#)".} ## \
## Sets or clears the hidden flag.  When the hidden flag is true, the node and
## all of its children are invisible to all cameras, regardless of the setting
## of any draw masks.  Setting the hidden flag to false restores the previous
## visibility as established by the draw masks.
##
## This actually works by twiddling the reserved _overall_bit in the node's
## draw mask, which has special meaning.

proc get_off_clip_planes*(this: PandaNode, current_thread: Thread): RenderAttrib {.importcpp: "#->get_off_clip_planes(#)".} ## \
## Returns a ClipPlaneAttrib which represents the union of all of the clip
## planes that have been turned *off* at this level and below.

proc get_off_clip_planes*(this: PandaNode): RenderAttrib {.importcpp: "#->get_off_clip_planes()".} ## \
## Returns a ClipPlaneAttrib which represents the union of all of the clip
## planes that have been turned *off* at this level and below.

proc prepare_scene*(this: PandaNode, gsg: GraphicsStateGuardianBase, node_state: RenderState) {.importcpp: "#->prepare_scene(#, #)".} ## \
## Walks through the scene graph beginning at this node, and does whatever
## initialization is required to render the scene properly with the indicated
## GSG.  It is not strictly necessary to call this, since the GSG will
## initialize itself when the scene is rendered, but this may take some of the
## overhead away from that process.
##
## In particular, this will ensure that textures and vertex buffers within the
## scene are loaded into graphics memory.

proc is_scene_root*(this: PandaNode): bool {.importcpp: "#->is_scene_root()".} ## \
## Returns true if this particular node is known to be the render root of some
## active DisplayRegion associated with the global GraphicsEngine, false
## otherwise.

proc is_under_scene_root*(this: PandaNode): bool {.importcpp: "#->is_under_scene_root()".} ## \
## Returns true if this particular node is in a live scene graph: that is, it
## is a child or descendent of a node that is itself a scene root.  If this is
## true, this node may potentially be traversed by the render traverser.
## Stashed nodes don't count for this purpose, but hidden nodes do.

proc output*(this: PandaNode, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: PandaNode, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc ls*(this: PandaNode, `out`: ostream, indent_level: int) {.importcpp: "#->ls(#, #)".} ## \
## Lists all the nodes at and below the current path hierarchically.

proc set_bounds*(this: PandaNode, volume: BoundingVolume) {.importcpp: "#->set_bounds(#)".} ## \
## Resets the bounding volume so that it is the indicated volume.  When it is
## explicitly set, the bounding volume will no longer be automatically
## computed according to the contents of the node itself, for nodes like
## GeomNodes and TextNodes that contain substance (but the bounding volume
## will still be automatically expanded to include its children).
##
## Call clear_bounds() if you would like to return the bounding volume to its
## default behavior later.

proc set_bound*(this: PandaNode, volume: BoundingVolume) {.importcpp: "#->set_bound(#)".} ## \
## Deprecated.  Use set_bounds() instead.

proc clear_bounds*(this: PandaNode) {.importcpp: "#->clear_bounds()".} ## \
## Reverses the effect of a previous call to set_bounds(), and allows the
## node's bounding volume to be automatically computed once more based on the
## contents of the node.

proc get_bounds*(this: PandaNode, current_thread: Thread): BoundingVolume {.importcpp: "#->get_bounds(#)".} ## \
## Returns the external bounding volume of this node: a bounding volume that
## contains the user bounding volume, the internal bounding volume, and all of
## the children's bounding volumes.

proc get_bounds*(this: PandaNode): BoundingVolume {.importcpp: "#->get_bounds()".} ## \
## Returns the external bounding volume of this node: a bounding volume that
## contains the user bounding volume, the internal bounding volume, and all of
## the children's bounding volumes.

proc get_bounds*(this: PandaNode, seq: UpdateSeq, current_thread: Thread): BoundingVolume {.importcpp: "#->get_bounds(#, #)".} ## \
## This flavor of get_bounds() return the external bounding volume, and also
## fills in seq with the bounding volume's current sequence number.  When this
## sequence number changes, it indicates that the bounding volume might have
## changed, e.g.  because some nested child's bounding volume has changed.
##
## Although this might occasionally increment without changing the bounding
## volume, the bounding volume will never change without incrementing this
## counter, so as long as this counter remains unchanged you can be confident
## the bounding volume is also unchanged.

proc get_bounds*(this: PandaNode, seq: UpdateSeq): BoundingVolume {.importcpp: "#->get_bounds(#)".} ## \
## This flavor of get_bounds() return the external bounding volume, and also
## fills in seq with the bounding volume's current sequence number.  When this
## sequence number changes, it indicates that the bounding volume might have
## changed, e.g.  because some nested child's bounding volume has changed.
##
## Although this might occasionally increment without changing the bounding
## volume, the bounding volume will never change without incrementing this
## counter, so as long as this counter remains unchanged you can be confident
## the bounding volume is also unchanged.

proc get_nested_vertices*(this: PandaNode, current_thread: Thread): int {.importcpp: "#->get_nested_vertices(#)".} ## \
## Returns the total number of vertices that will be rendered by this node and
## all of its descendents.
##
## This is not necessarily an accurate count of vertices that will actually be
## rendered, since this will include all vertices of all LOD's, and it will
## also include hidden nodes.  It may also omit or only approximate certain
## kinds of dynamic geometry.  However, it will not include stashed nodes.

proc get_nested_vertices*(this: PandaNode): int {.importcpp: "#->get_nested_vertices()".} ## \
## Returns the total number of vertices that will be rendered by this node and
## all of its descendents.
##
## This is not necessarily an accurate count of vertices that will actually be
## rendered, since this will include all vertices of all LOD's, and it will
## also include hidden nodes.  It may also omit or only approximate certain
## kinds of dynamic geometry.  However, it will not include stashed nodes.

proc get_internal_bounds*(this: PandaNode, current_thread: Thread): BoundingVolume {.importcpp: "#->get_internal_bounds(#)".} ## \
## Returns the node's internal bounding volume.  This is the bounding volume
## around the node alone, without including children.  If the user has called
## set_bounds(), it will be the specified bounding volume.

proc get_internal_bounds*(this: PandaNode): BoundingVolume {.importcpp: "#->get_internal_bounds()".} ## \
## Returns the node's internal bounding volume.  This is the bounding volume
## around the node alone, without including children.  If the user has called
## set_bounds(), it will be the specified bounding volume.

proc get_internal_vertices*(this: PandaNode, current_thread: Thread): int {.importcpp: "#->get_internal_vertices(#)".} ## \
## Returns the total number of vertices that will be rendered by this
## particular node alone, not accounting for its children.
##
## This may not include all vertices for certain dynamic effects.

proc get_internal_vertices*(this: PandaNode): int {.importcpp: "#->get_internal_vertices()".} ## \
## Returns the total number of vertices that will be rendered by this
## particular node alone, not accounting for its children.
##
## This may not include all vertices for certain dynamic effects.

proc mark_bounds_stale*(this: PandaNode, current_thread: Thread) {.importcpp: "#->mark_bounds_stale(#)".} ## \
## Indicates that the bounding volume, or something that influences the
## bounding volume (or any of the other things stored in CData, like
## net_collide_mask), may have changed for this node, and that it must be
## recomputed.
##
## With no parameters, this means to iterate through all stages including and
## upstream of the current pipeline stage.
##
## This method is intended for internal use; usually it is not necessary for a
## user to call this directly.  It will be called automatically by derived
## classes when appropriate.

proc mark_bounds_stale*(this: PandaNode) {.importcpp: "#->mark_bounds_stale()".} ## \
## Indicates that the bounding volume, or something that influences the
## bounding volume (or any of the other things stored in CData, like
## net_collide_mask), may have changed for this node, and that it must be
## recomputed.
##
## With no parameters, this means to iterate through all stages including and
## upstream of the current pipeline stage.
##
## This method is intended for internal use; usually it is not necessary for a
## user to call this directly.  It will be called automatically by derived
## classes when appropriate.

proc mark_internal_bounds_stale*(this: PandaNode, current_thread: Thread) {.importcpp: "#->mark_internal_bounds_stale(#)".} ## \
## Should be called by a derived class to mark the internal bounding volume
## stale, so that compute_internal_bounds() will be called when the bounding
## volume is next requested.
##
## With no parameters, this means to iterate through all stages including and
## upstream of the current pipeline stage.
##
## It is normally not necessary to call this method directly; each node should
## be responsible for calling it when its internals have changed.

proc mark_internal_bounds_stale*(this: PandaNode) {.importcpp: "#->mark_internal_bounds_stale()".} ## \
## Should be called by a derived class to mark the internal bounding volume
## stale, so that compute_internal_bounds() will be called when the bounding
## volume is next requested.
##
## With no parameters, this means to iterate through all stages including and
## upstream of the current pipeline stage.
##
## It is normally not necessary to call this method directly; each node should
## be responsible for calling it when its internals have changed.

proc is_bounds_stale*(this: PandaNode): bool {.importcpp: "#->is_bounds_stale()".} ## \
## Returns true if the bounding volume of this node is stale and will be
## implicitly recomputed at the next call to get_bounds(), or false if it is
## fresh and need not be recomputed.

proc set_final*(this: PandaNode, flag: bool) {.importcpp: "#->set_final(#)".} ## \
## Sets the "final" flag on this PandaNode.  If this is true, than no bounding
## volume need be tested below it; a positive intersection with this node's
## bounding volume is deemed to be a positive intersection with all geometry
## inside.
##
## This is useful to quickly force a larger bounding volume around a node when
## the GeomNodes themselves are inaccurate for some reason, without forcing a
## recompute of every nested bounding volume.  It's also helpful when the
## bounding volume is tricked by some special properties, like billboards,
## that may move geometry out of its bounding volume otherwise.

proc is_final*(this: PandaNode, current_thread: Thread): bool {.importcpp: "#->is_final(#)".} ## \
## Returns the current state of the "final" flag.  Initially, this flag is off
## (false), but it may be changed by an explicit call to set_final().  See
## set_final().

proc is_final*(this: PandaNode): bool {.importcpp: "#->is_final()".} ## \
## Returns the current state of the "final" flag.  Initially, this flag is off
## (false), but it may be changed by an explicit call to set_final().  See
## set_final().

proc is_geom_node*(this: PandaNode): bool {.importcpp: "#->is_geom_node()".} ## \
## A simple downcast check.  Returns true if this kind of node happens to
## inherit from GeomNode, false otherwise.
##
## This is provided as a a faster alternative to calling
## is_of_type(GeomNode::get_class_type()), since this test is so important to
## rendering.

proc is_lod_node*(this: PandaNode): bool {.importcpp: "#->is_lod_node()".} ## \
## A simple downcast check.  Returns true if this kind of node happens to
## inherit from LODNode, false otherwise.
##
## This is provided as a a faster alternative to calling
## is_of_type(LODNode::get_class_type()).

proc is_collision_node*(this: PandaNode): bool {.importcpp: "#->is_collision_node()".} ## \
## A simple downcast check.  Returns true if this kind of node happens to
## inherit from CollisionNode, false otherwise.
##
## This is provided as a a faster alternative to calling
## is_of_type(CollisionNode::get_class_type()).

proc as_light*(this: PandaNode): Light {.importcpp: "#->as_light()".} ## \
## Cross-casts the node to a Light pointer, if it is one of the four kinds of
## Light nodes, or returns NULL if it is not.

proc is_ambient_light*(this: PandaNode): bool {.importcpp: "#->is_ambient_light()".} ## \
## Returns true if this is an AmbientLight, false if it is not a light, or it
## is some other kind of light.

proc get_fancy_bits*(this: PandaNode, current_thread: Thread): int {.importcpp: "#->get_fancy_bits(#)".} ## \
## Returns the union of all of the enum FancyBits values corresponding to the
## various "fancy" attributes that are set on the node.  If this returns 0,
## the node has nothing interesting about it.  This is intended to speed
## traversal by quickly skipping past nodes that don't particularly affect the
## render state.

proc get_fancy_bits*(this: PandaNode): int {.importcpp: "#->get_fancy_bits()".} ## \
## Returns the union of all of the enum FancyBits values corresponding to the
## various "fancy" attributes that are set on the node.  If this returns 0,
## the node has nothing interesting about it.  This is intended to speed
## traversal by quickly skipping past nodes that don't particularly affect the
## render state.

proc get_class_type*(_: typedesc[PandaNode]): TypeHandle {.importcpp: "PandaNode::get_class_type()", header: "pandaNode.h".}

proc make_default*(_: typedesc[TransparencyAttrib]): RenderAttrib {.importcpp: "TransparencyAttrib::make_default()", header: "transparencyAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc get_class_slot*(_: typedesc[TransparencyAttrib]): int {.importcpp: "TransparencyAttrib::get_class_slot()", header: "transparencyAttrib.h".}

proc get_class_type*(_: typedesc[TransparencyAttrib]): TypeHandle {.importcpp: "TransparencyAttrib::get_class_type()", header: "transparencyAttrib.h".}

proc make_off*(_: typedesc[LogicOpAttrib]): RenderAttrib {.importcpp: "LogicOpAttrib::make_off()", header: "logicOpAttrib.h".} ## \
## Constructs a new LogicOpAttrib object that disables special-effect
## blending, allowing normal transparency to be used instead.

proc make_default*(_: typedesc[LogicOpAttrib]): RenderAttrib {.importcpp: "LogicOpAttrib::make_default()", header: "logicOpAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc get_class_slot*(_: typedesc[LogicOpAttrib]): int {.importcpp: "LogicOpAttrib::get_class_slot()", header: "logicOpAttrib.h".}

proc get_class_type*(_: typedesc[LogicOpAttrib]): TypeHandle {.importcpp: "LogicOpAttrib::get_class_type()", header: "logicOpAttrib.h".}

proc get_blank*(_: typedesc[ShaderInput]): ShaderInput {.importcpp: "ShaderInput::get_blank()", header: "shaderInput.h".} ## \
## Returns a static ShaderInput object with name NULL, priority zero, type
## INVALID, and all value-fields cleared.

proc initShaderInput*(name: InternalName, tex: Texture, sampler: SamplerState, priority: int): ShaderInput {.importcpp: "ShaderInput(#, #, #, #)".}

proc initShaderInput*(name: InternalName, tex: Texture, sampler: SamplerState): ShaderInput {.importcpp: "ShaderInput(#, #, #)".}

proc initShaderInput*(name: InternalName, tex: Texture, read: bool, write: bool, z: int, n: int, priority: int): ShaderInput {.importcpp: "ShaderInput(#, #, #, #, #, #, #)".}

proc initShaderInput*(name: InternalName, tex: Texture, read: bool, write: bool, z: int, n: int): ShaderInput {.importcpp: "ShaderInput(#, #, #, #, #, #)".}

proc initShaderInput*(name: InternalName, tex: Texture, read: bool, write: bool, z: int): ShaderInput {.importcpp: "ShaderInput(#, #, #, #, #)".}

proc initShaderInput*(name: InternalName, tex: Texture, read: bool, write: bool): ShaderInput {.importcpp: "ShaderInput(#, #, #, #)".}

proc initShaderInput*(name: InternalName, priority: int): ShaderInput {.importcpp: "ShaderInput(#, #)".}

proc initShaderInput*(name: InternalName): ShaderInput {.importcpp: "ShaderInput(#)".}

proc initShaderInput*(param0: ShaderInput): ShaderInput {.importcpp: "ShaderInput(#)".}

proc `typecast bool`*(this: ShaderInput): bool {.importcpp: "#.operator typecast bool()".}

proc `==`*(this: ShaderInput, other: ShaderInput): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: ShaderInput, other: ShaderInput): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: ShaderInput, other: ShaderInput): bool {.importcpp: "#.operator <(#)".}

proc add_hash*(this: ShaderInput, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".}

proc get_name*(this: ShaderInput): InternalName {.importcpp: "#.get_name()".}

proc get_value_type*(this: ShaderInput): int {.importcpp: "#.get_value_type()".}

proc get_priority*(this: ShaderInput): int {.importcpp: "#.get_priority()".}

proc get_vector*(this: ShaderInput): LVecBase4 {.importcpp: "#.get_vector()".}

proc get_nodepath*(this: ShaderInput): NodePath {.importcpp: "#.get_nodepath()".} ## \
## Warning: no error checking is done.  This *will* crash if get_value_type()
## is not M_nodepath.

proc get_texture*(this: ShaderInput): Texture {.importcpp: "#.get_texture()".}

proc get_sampler*(this: ShaderInput): SamplerState {.importcpp: "#.get_sampler()".} ## \
## Warning: no error checking is done.

proc initInternalNameCollection*(): InternalNameCollection {.importcpp: "InternalNameCollection()".}

proc initInternalNameCollection*(copy: InternalNameCollection): InternalNameCollection {.importcpp: "InternalNameCollection(#)".}

proc add_name*(this: InternalNameCollection, name: InternalName) {.importcpp: "#.add_name(#)".} ## \
## Adds a new InternalName to the collection.

proc remove_name*(this: InternalNameCollection, name: InternalName): bool {.importcpp: "#.remove_name(#)".} ## \
## Removes the indicated InternalName from the collection.  Returns true if
## the name was removed, false if it was not a member of the collection.

proc add_names_from*(this: InternalNameCollection, other: InternalNameCollection) {.importcpp: "#.add_names_from(#)".} ## \
## Adds all the InternalNames indicated in the other collection to this name.
## The other names are simply appended to the end of the names in this list;
## duplicates are not automatically removed.

proc remove_names_from*(this: InternalNameCollection, other: InternalNameCollection) {.importcpp: "#.remove_names_from(#)".} ## \
## Removes from this collection all of the InternalNames listed in the other
## collection.

proc remove_duplicate_names*(this: InternalNameCollection) {.importcpp: "#.remove_duplicate_names()".} ## \
## Removes any duplicate entries of the same InternalNames on this collection.
## If a InternalName appears multiple times, the first appearance is retained;
## subsequent appearances are removed.

proc has_name*(this: InternalNameCollection, name: InternalName): bool {.importcpp: "#.has_name(#)".} ## \
## Returns true if the indicated InternalName appears in this collection,
## false otherwise.

proc clear*(this: InternalNameCollection) {.importcpp: "#.clear()".} ## \
## Removes all InternalNames from the collection.

proc get_num_names*(this: InternalNameCollection): int {.importcpp: "#.get_num_names()".} ## \
## Returns the number of InternalNames in the collection.

proc get_name*(this: InternalNameCollection, index: int): InternalName {.importcpp: "#.get_name(#)".} ## \
## Returns the nth InternalName in the collection.

proc `[]`*(this: InternalNameCollection, index: int): InternalName {.importcpp: "#.operator [](#)".} ## \
## Returns the nth InternalName in the collection.  This is the same as
## get_name(), but it may be a more convenient way to access it.

proc size*(this: InternalNameCollection): int {.importcpp: "#.size()".} ## \
## Returns the number of names in the collection.  This is the same thing as
## get_num_names().

proc `+=`*(this: InternalNameCollection, other: InternalNameCollection): InternalNameCollection {.importcpp: "#.operator +=(#)".}

proc `+`*(this: InternalNameCollection, other: InternalNameCollection): InternalNameCollection {.importcpp: "#.operator +(#)".}

proc output*(this: InternalNameCollection, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes a brief one-line description of the InternalNameCollection to the
## indicated output stream.

proc write*(this: InternalNameCollection, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes a complete multi-line description of the InternalNameCollection to
## the indicated output stream.

proc write*(this: InternalNameCollection, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a complete multi-line description of the InternalNameCollection to
## the indicated output stream.

proc initMaterialCollection*(): MaterialCollection {.importcpp: "MaterialCollection()".}

proc initMaterialCollection*(copy: MaterialCollection): MaterialCollection {.importcpp: "MaterialCollection(#)".}

proc add_material*(this: MaterialCollection, node_material: Material) {.importcpp: "#.add_material(#)".} ## \
## Adds a new Material to the collection.

proc remove_material*(this: MaterialCollection, node_material: Material): bool {.importcpp: "#.remove_material(#)".} ## \
## Removes the indicated Material from the collection.  Returns true if the
## material was removed, false if it was not a member of the collection.

proc add_materials_from*(this: MaterialCollection, other: MaterialCollection) {.importcpp: "#.add_materials_from(#)".} ## \
## Adds all the Materials indicated in the other collection to this material.
## The other materials are simply appended to the end of the materials in this
## list; duplicates are not automatically removed.

proc remove_materials_from*(this: MaterialCollection, other: MaterialCollection) {.importcpp: "#.remove_materials_from(#)".} ## \
## Removes from this collection all of the Materials listed in the other
## collection.

proc remove_duplicate_materials*(this: MaterialCollection) {.importcpp: "#.remove_duplicate_materials()".} ## \
## Removes any duplicate entries of the same Materials on this collection.  If
## a Material appears multiple times, the first appearance is retained;
## subsequent appearances are removed.

proc has_material*(this: MaterialCollection, material: Material): bool {.importcpp: "#.has_material(#)".} ## \
## Returns true if the indicated Material appears in this collection, false
## otherwise.

proc clear*(this: MaterialCollection) {.importcpp: "#.clear()".} ## \
## Removes all Materials from the collection.

proc find_material*(this: MaterialCollection, name: string): Material {.importcpp: "#.find_material(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the material in the collection with the indicated name, if any, or
## NULL if no material has that name.

proc get_num_materials*(this: MaterialCollection): int {.importcpp: "#.get_num_materials()".} ## \
## Returns the number of Materials in the collection.

proc get_material*(this: MaterialCollection, index: int): Material {.importcpp: "#.get_material(#)".} ## \
## Returns the nth Material in the collection.

proc `[]`*(this: MaterialCollection, index: int): Material {.importcpp: "#.operator [](#)".} ## \
## Returns the nth Material in the collection.  This is the same as
## get_material(), but it may be a more convenient way to access it.

proc size*(this: MaterialCollection): int {.importcpp: "#.size()".} ## \
## Returns the number of materials in the collection.  This is the same thing
## as get_num_materials().

proc `+=`*(this: MaterialCollection, other: MaterialCollection): MaterialCollection {.importcpp: "#.operator +=(#)".}

proc `+`*(this: MaterialCollection, other: MaterialCollection): MaterialCollection {.importcpp: "#.operator +(#)".}

proc output*(this: MaterialCollection, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes a brief one-line description of the MaterialCollection to the
## indicated output stream.

proc write*(this: MaterialCollection, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes a complete multi-line description of the MaterialCollection to the
## indicated output stream.

proc write*(this: MaterialCollection, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a complete multi-line description of the MaterialCollection to the
## indicated output stream.

proc initTextureStageCollection*(): TextureStageCollection {.importcpp: "TextureStageCollection()".}

proc initTextureStageCollection*(copy: TextureStageCollection): TextureStageCollection {.importcpp: "TextureStageCollection(#)".}

proc add_texture_stage*(this: TextureStageCollection, node_texture_stage: TextureStage) {.importcpp: "#.add_texture_stage(#)".} ## \
## Adds a new TextureStage to the collection.

proc remove_texture_stage*(this: TextureStageCollection, node_texture_stage: TextureStage): bool {.importcpp: "#.remove_texture_stage(#)".} ## \
## Removes the indicated TextureStage from the collection.  Returns true if
## the texture_stage was removed, false if it was not a member of the
## collection.

proc add_texture_stages_from*(this: TextureStageCollection, other: TextureStageCollection) {.importcpp: "#.add_texture_stages_from(#)".} ## \
## Adds all the TextureStages indicated in the other collection to this
## texture_stage.  The other texture_stages are simply appended to the end of
## the texture_stages in this list; duplicates are not automatically removed.

proc remove_texture_stages_from*(this: TextureStageCollection, other: TextureStageCollection) {.importcpp: "#.remove_texture_stages_from(#)".} ## \
## Removes from this collection all of the TextureStages listed in the other
## collection.

proc remove_duplicate_texture_stages*(this: TextureStageCollection) {.importcpp: "#.remove_duplicate_texture_stages()".} ## \
## Removes any duplicate entries of the same TextureStages on this collection.
## If a TextureStage appears multiple times, the first appearance is retained;
## subsequent appearances are removed.

proc has_texture_stage*(this: TextureStageCollection, texture_stage: TextureStage): bool {.importcpp: "#.has_texture_stage(#)".} ## \
## Returns true if the indicated TextureStage appears in this collection,
## false otherwise.

proc clear*(this: TextureStageCollection) {.importcpp: "#.clear()".} ## \
## Removes all TextureStages from the collection.

proc find_texture_stage*(this: TextureStageCollection, name: string): TextureStage {.importcpp: "#.find_texture_stage(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the texture_stage in the collection with the indicated name, if
## any, or NULL if no texture_stage has that name.

proc get_num_texture_stages*(this: TextureStageCollection): int {.importcpp: "#.get_num_texture_stages()".} ## \
## Returns the number of TextureStages in the collection.

proc get_texture_stage*(this: TextureStageCollection, index: int): TextureStage {.importcpp: "#.get_texture_stage(#)".} ## \
## Returns the nth TextureStage in the collection.

proc `[]`*(this: TextureStageCollection, index: int): TextureStage {.importcpp: "#.operator [](#)".} ## \
## Returns the nth TextureStage in the collection.  This is the same as
## get_texture_stage(), but it may be a more convenient way to access it.

proc size*(this: TextureStageCollection): int {.importcpp: "#.size()".} ## \
## Returns the number of texture stages in the collection.  This is the same
## thing as get_num_texture_stages().

proc `+=`*(this: TextureStageCollection, other: TextureStageCollection): TextureStageCollection {.importcpp: "#.operator +=(#)".}

proc `+`*(this: TextureStageCollection, other: TextureStageCollection): TextureStageCollection {.importcpp: "#.operator +(#)".}

proc sort*(this: TextureStageCollection) {.importcpp: "#.sort()".} ## \
## Sorts the TextureStages in this collection into order by
## TextureStage::sort(), from lowest to highest.

proc output*(this: TextureStageCollection, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes a brief one-line description of the TextureStageCollection to the
## indicated output stream.

proc write*(this: TextureStageCollection, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes a complete multi-line description of the TextureStageCollection to
## the indicated output stream.

proc write*(this: TextureStageCollection, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a complete multi-line description of the TextureStageCollection to
## the indicated output stream.

proc initNodePath*(): NodePath {.importcpp: "NodePath()".} ## \
## This constructs an empty NodePath with no nodes.

proc initNodePath*(copy: NodePath): NodePath {.importcpp: "NodePath(#)".}

proc initNodePath*(parent: NodePath, child_node: PandaNode, current_thread: Thread): NodePath {.importcpp: "NodePath(#, #, #)".} ## \
## Constructs a NodePath with the indicated parent NodePath and child node;
## the child node must be a stashed or unstashed child of the parent.

proc initNodePath*(parent: NodePath, child_node: PandaNode): NodePath {.importcpp: "NodePath(#, #)".} ## \
## Constructs a NodePath with the indicated parent NodePath and child node;
## the child node must be a stashed or unstashed child of the parent.

proc initNodePath*(node: PandaNode, current_thread: Thread): NodePath {.importcpp: "NodePath(#, #)".} ## \
## This constructs a NodePath for the indicated node.  If the node does not
## have any parents, this creates a singleton NodePath; otherwise, it
## automatically finds the path from the node to the root.  If the node has
## multiple paths to the root, one path is chosen arbitrarily and a warning
## message is printed (but see also NodePath::any_path(), below).

proc initNodePath*(node: PandaNode): NodePath {.importcpp: "NodePath(#)".} ## \
## This constructs a NodePath for the indicated node.  If the node does not
## have any parents, this creates a singleton NodePath; otherwise, it
## automatically finds the path from the node to the root.  If the node has
## multiple paths to the root, one path is chosen arbitrarily and a warning
## message is printed (but see also NodePath::any_path(), below).

proc initNodePath*(top_node_name: string, current_thread: Thread): NodePath {.importcpp: "NodePath(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## This constructs a new NodePath with a single node.  An ordinary, unattached
## PandaNode is created with the indicated name.

proc initNodePath*(top_node_name: string): NodePath {.importcpp: "NodePath(nimStringToStdString(#))", header: stringConversionCode.} ## \
## This constructs a new NodePath with a single node.  An ordinary, unattached
## PandaNode is created with the indicated name.

proc any_path*(_: typedesc[NodePath], node: PandaNode, current_thread: Thread): NodePath {.importcpp: "NodePath::any_path(#, #)", header: "nodePath.h".} ## \
## Returns a new NodePath that represents any arbitrary path from the root to
## the indicated node.  This is the same thing that would be returned by
## NodePath(node), except that no warning is issued if the path is ambiguous.

proc any_path*(_: typedesc[NodePath], node: PandaNode): NodePath {.importcpp: "NodePath::any_path(#)", header: "nodePath.h".} ## \
## Returns a new NodePath that represents any arbitrary path from the root to
## the indicated node.  This is the same thing that would be returned by
## NodePath(node), except that no warning is issued if the path is ambiguous.

proc clear*(this: NodePath) {.importcpp: "#.clear()".} ## \
## Sets this NodePath to the empty NodePath.  It will no longer point to any
## node.

proc not_found*(_: typedesc[NodePath]): NodePath {.importcpp: "NodePath::not_found()", header: "nodePath.h".} ## \
## Creates a NodePath with the ET_not_found error type set.

proc removed*(_: typedesc[NodePath]): NodePath {.importcpp: "NodePath::removed()", header: "nodePath.h".} ## \
## Creates a NodePath with the ET_removed error type set.

proc fail*(_: typedesc[NodePath]): NodePath {.importcpp: "NodePath::fail()", header: "nodePath.h".} ## \
## Creates a NodePath with the ET_fail error type set.

proc set_max_search_depth*(_: typedesc[NodePath], max_search_depth: int) {.importcpp: "NodePath::set_max_search_depth(#)", header: "nodePath.h".} ## \
## Certain operations, such as find() or find_all_matches(), require a
## traversal of the scene graph to search for the target node or nodes.  This
## traversal does not attempt to detect cycles, so an arbitrary cap is set on
## the depth of the traversal as a poor man's cycle detection, in the event
## that a cycle has inadvertently been introduced into the scene graph.
##
## There may be other reasons you'd want to truncate a search before the
## bottom of the scene graph has been reached.  In any event, this function
## sets the limit on the number of levels that a traversal will continue, and
## hence the maximum length of a path that may be returned by a traversal.
##
## This is a static method, and so changing this parameter affects all of the
## NodePaths in the universe.

proc get_max_search_depth*(_: typedesc[NodePath]): int {.importcpp: "NodePath::get_max_search_depth()", header: "nodePath.h".} ## \
## Returns the current setting of the search depth limit.  See
## set_max_search_depth.

proc is_empty*(this: NodePath): bool {.importcpp: "#.is_empty()".} ## \
## Returns true if the NodePath contains no nodes.

proc `typecast bool`*(this: NodePath): bool {.importcpp: "#.operator typecast bool()".}

proc is_singleton*(this: NodePath, current_thread: Thread): bool {.importcpp: "#.is_singleton(#)".} ## \
## Returns true if the NodePath contains exactly one node.

proc is_singleton*(this: NodePath): bool {.importcpp: "#.is_singleton()".} ## \
## Returns true if the NodePath contains exactly one node.

proc get_num_nodes*(this: NodePath, current_thread: Thread): int {.importcpp: "#.get_num_nodes(#)".} ## \
## Returns the number of nodes in the path.

proc get_num_nodes*(this: NodePath): int {.importcpp: "#.get_num_nodes()".} ## \
## Returns the number of nodes in the path.

proc get_node*(this: NodePath, index: int, current_thread: Thread): PandaNode {.importcpp: "#.get_node(#, #)".} ## \
## Returns the nth node of the path, where 0 is the referenced (bottom) node
## and get_num_nodes() - 1 is the top node.  This requires iterating through
## the path.
##
## Also see node(), which is a convenience function to return the same thing
## as get_node(0) (since the bottom node is the most important node in the
## NodePath, and is the one most frequently referenced).
##
## Note that this function returns the same thing as
## get_ancestor(index).node().

proc get_node*(this: NodePath, index: int): PandaNode {.importcpp: "#.get_node(#)".} ## \
## Returns the nth node of the path, where 0 is the referenced (bottom) node
## and get_num_nodes() - 1 is the top node.  This requires iterating through
## the path.
##
## Also see node(), which is a convenience function to return the same thing
## as get_node(0) (since the bottom node is the most important node in the
## NodePath, and is the one most frequently referenced).
##
## Note that this function returns the same thing as
## get_ancestor(index).node().

proc get_ancestor*(this: NodePath, index: int, current_thread: Thread): NodePath {.importcpp: "#.get_ancestor(#, #)".} ## \
## Returns the nth ancestor of the path, where 0 is the NodePath itself and
## get_num_nodes() - 1 is get_top(). This requires iterating through the path.
##
## Also see get_node(), which returns the same thing as a PandaNode pointer,
## not a NodePath.

proc get_ancestor*(this: NodePath, index: int): NodePath {.importcpp: "#.get_ancestor(#)".} ## \
## Returns the nth ancestor of the path, where 0 is the NodePath itself and
## get_num_nodes() - 1 is get_top(). This requires iterating through the path.
##
## Also see get_node(), which returns the same thing as a PandaNode pointer,
## not a NodePath.

proc get_top_node*(this: NodePath, current_thread: Thread): PandaNode {.importcpp: "#.get_top_node(#)".} ## \
## Returns the top node of the path, or NULL if the path is empty.  This
## requires iterating through the path.

proc get_top_node*(this: NodePath): PandaNode {.importcpp: "#.get_top_node()".} ## \
## Returns the top node of the path, or NULL if the path is empty.  This
## requires iterating through the path.

proc get_top*(this: NodePath, current_thread: Thread): NodePath {.importcpp: "#.get_top(#)".} ## \
## Returns a singleton NodePath that represents the top of the path, or empty
## NodePath if this path is empty.

proc get_top*(this: NodePath): NodePath {.importcpp: "#.get_top()".} ## \
## Returns a singleton NodePath that represents the top of the path, or empty
## NodePath if this path is empty.

proc node*(this: NodePath): PandaNode {.importcpp: "#.node()".} ## \
## Returns the referenced node of the path.

proc get_key*(this: NodePath): int {.importcpp: "#.get_key()".} ## \
## Returns an integer that is guaranteed to be the same for all NodePaths that
## represent the same node instance, and different for all NodePaths that
## represent a different node instance.
##
## The same key will be returned for a particular instance as long as at least
## one NodePath exists that represents that instance; if all NodePaths for a
## particular instance destruct and a new one is later created, it may have a
## different index.  However, a given key will never be reused for a different
## instance (unless the app has been running long enough that we overflow the
## integer key value).

proc add_hash*(this: NodePath, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the NodePath into the running hash.  This is intended to be used by
## lower-level code that computes a hash for each NodePath.  It modifies the
## hash value passed in by a unique adjustment for each NodePath, and returns
## the modified hash.
##
## This is similar to the unique integer returned by get_key(), but it is not
## guaranteed to remain unique beyond the lifetime of this particular
## NodePath.  Once this NodePath destructs, a different NodePath may be
## created which shares the same hash value.

proc is_same_graph*(this: NodePath, other: NodePath, current_thread: Thread): bool {.importcpp: "#.is_same_graph(#, #)".} ## \
## Returns true if the node represented by this NodePath is parented within
## the same graph as that of the other NodePath.  This is essentially the same
## thing as asking whether get_top() of both NodePaths is the same (e.g., both
## "render").

proc is_same_graph*(this: NodePath, other: NodePath): bool {.importcpp: "#.is_same_graph(#)".} ## \
## Returns true if the node represented by this NodePath is parented within
## the same graph as that of the other NodePath.  This is essentially the same
## thing as asking whether get_top() of both NodePaths is the same (e.g., both
## "render").

proc is_ancestor_of*(this: NodePath, other: NodePath, current_thread: Thread): bool {.importcpp: "#.is_ancestor_of(#, #)".} ## \
## Returns true if the node represented by this NodePath is a parent or other
## ancestor of the other NodePath, or false if it is not.

proc is_ancestor_of*(this: NodePath, other: NodePath): bool {.importcpp: "#.is_ancestor_of(#)".} ## \
## Returns true if the node represented by this NodePath is a parent or other
## ancestor of the other NodePath, or false if it is not.

proc get_common_ancestor*(this: NodePath, other: NodePath, current_thread: Thread): NodePath {.importcpp: "#.get_common_ancestor(#, #)".} ## \
## Returns the lowest NodePath that both of these two NodePaths have in
## common: the first ancestor that both of them share.  If the two NodePaths
## are unrelated, returns NodePath::not_found().

proc get_common_ancestor*(this: NodePath, other: NodePath): NodePath {.importcpp: "#.get_common_ancestor(#)".} ## \
## Returns the lowest NodePath that both of these two NodePaths have in
## common: the first ancestor that both of them share.  If the two NodePaths
## are unrelated, returns NodePath::not_found().

proc get_children*(this: NodePath, current_thread: Thread): NodePathCollection {.importcpp: "#.get_children(#)".} ## \
## Returns the set of all child nodes of the referenced node.

proc get_children*(this: NodePath): NodePathCollection {.importcpp: "#.get_children()".} ## \
## Returns the set of all child nodes of the referenced node.

proc get_num_children*(this: NodePath, current_thread: Thread): int {.importcpp: "#.get_num_children(#)".} ## \
## Returns the number of children of the referenced node.

proc get_num_children*(this: NodePath): int {.importcpp: "#.get_num_children()".} ## \
## Returns the number of children of the referenced node.

proc get_child*(this: NodePath, n: int, current_thread: Thread): NodePath {.importcpp: "#.get_child(#, #)".} ## \
## Returns a NodePath representing the nth child of the referenced node.

proc get_child*(this: NodePath, n: int): NodePath {.importcpp: "#.get_child(#)".} ## \
## Returns a NodePath representing the nth child of the referenced node.

proc get_stashed_children*(this: NodePath, current_thread: Thread): NodePathCollection {.importcpp: "#.get_stashed_children(#)".} ## \
## Returns the set of all child nodes of the referenced node that have been
## stashed.  These children are not normally visible on the node, and do not
## appear in the list returned by get_children().

proc get_stashed_children*(this: NodePath): NodePathCollection {.importcpp: "#.get_stashed_children()".} ## \
## Returns the set of all child nodes of the referenced node that have been
## stashed.  These children are not normally visible on the node, and do not
## appear in the list returned by get_children().

proc initNodePathCollection*(): NodePathCollection {.importcpp: "NodePathCollection()".}

proc initNodePathCollection*(param0: NodePathCollection): NodePathCollection {.importcpp: "NodePathCollection(#)".}

proc add_path*(this: NodePathCollection, node_path: NodePath) {.importcpp: "#.add_path(#)".} ## \
## Adds a new NodePath to the collection.

proc remove_path*(this: NodePathCollection, node_path: NodePath): bool {.importcpp: "#.remove_path(#)".} ## \
## Removes the indicated NodePath from the collection.  Returns true if the
## path was removed, false if it was not a member of the collection.

proc add_paths_from*(this: NodePathCollection, other: NodePathCollection) {.importcpp: "#.add_paths_from(#)".} ## \
## Adds all the NodePaths indicated in the other collection to this path.  The
## other paths are simply appended to the end of the paths in this list;
## duplicates are not automatically removed.

proc remove_paths_from*(this: NodePathCollection, other: NodePathCollection) {.importcpp: "#.remove_paths_from(#)".} ## \
## Removes from this collection all of the NodePaths listed in the other
## collection.

proc remove_duplicate_paths*(this: NodePathCollection) {.importcpp: "#.remove_duplicate_paths()".} ## \
## Removes any duplicate entries of the same NodePaths on this collection.  If
## a NodePath appears multiple times, the first appearance is retained;
## subsequent appearances are removed.

proc has_path*(this: NodePathCollection, path: NodePath): bool {.importcpp: "#.has_path(#)".} ## \
## Returns true if the indicated NodePath appears in this collection, false
## otherwise.

proc clear*(this: NodePathCollection) {.importcpp: "#.clear()".} ## \
## Removes all NodePaths from the collection.

proc reserve*(this: NodePathCollection, num: clonglong) {.importcpp: "#.reserve(#)".} ## \
## This is a hint to Panda to allocate enough memory to hold the given number
## of NodePaths, if you know ahead of time how many you will be adding.

proc is_empty*(this: NodePathCollection): bool {.importcpp: "#.is_empty()".} ## \
## Returns true if there are no NodePaths in the collection, false otherwise.

proc get_num_paths*(this: NodePathCollection): int {.importcpp: "#.get_num_paths()".} ## \
## Returns the number of NodePaths in the collection.

proc get_path*(this: NodePathCollection, index: int): NodePath {.importcpp: "#.get_path(#)".} ## \
## Returns the nth NodePath in the collection.

proc `[]`*(this: NodePathCollection, index: clonglong): NodePath {.importcpp: "#.operator [](#)".}

proc size*(this: NodePathCollection): clonglong {.importcpp: "#.size()".} ## \
## Returns the number of paths in the collection.  This is the same thing as
## get_num_paths().

proc `+=`*(this: NodePathCollection, other: NodePathCollection): NodePathCollection {.importcpp: "#.operator +=(#)".}

proc `+`*(this: NodePathCollection, other: NodePathCollection): NodePathCollection {.importcpp: "#.operator +(#)".}

proc append*(this: NodePathCollection, node_path: NodePath) {.importcpp: "#.append(#)".} ## \
## Adds a new NodePath to the collection.  This method duplicates the
## add_path() method; it is provided to satisfy Python's naming convention.

proc extend*(this: NodePathCollection, other: NodePathCollection) {.importcpp: "#.extend(#)".} ## \
## Appends the other list onto the end of this one.  This method duplicates
## the += operator; it is provided to satisfy Python's naming convention.

proc ls*(this: NodePathCollection) {.importcpp: "#.ls()".} ## \
## Lists all the nodes at and below each node in the collection
## hierarchically.

proc ls*(this: NodePathCollection, `out`: ostream, indent_level: int) {.importcpp: "#.ls(#, #)".} ## \
## Lists all the nodes at and below each node in the collection
## hierarchically.

proc ls*(this: NodePathCollection, `out`: ostream) {.importcpp: "#.ls(#)".} ## \
## Lists all the nodes at and below each node in the collection
## hierarchically.

proc find_all_matches*(this: NodePathCollection, path: string): NodePathCollection {.importcpp: "#.find_all_matches(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the complete set of all NodePaths that begin with any NodePath in
## this collection and can be extended by path.  The shortest paths will be
## listed first.

proc reparent_to*(this: NodePathCollection, other: NodePath) {.importcpp: "#.reparent_to(#)".} ## \
## Reparents all the NodePaths in the collection to the indicated node.

proc wrt_reparent_to*(this: NodePathCollection, other: NodePath) {.importcpp: "#.wrt_reparent_to(#)".} ## \
## Reparents all the NodePaths in the collection to the indicated node,
## adjusting each transform so as not to move in world coordinates.

proc show*(this: NodePathCollection) {.importcpp: "#.show()".} ## \
## Shows all NodePaths in the collection.

proc hide*(this: NodePathCollection) {.importcpp: "#.hide()".} ## \
## Hides all NodePaths in the collection.

proc stash*(this: NodePathCollection) {.importcpp: "#.stash()".} ## \
## Stashes all NodePaths in the collection.

proc unstash*(this: NodePathCollection) {.importcpp: "#.unstash()".} ## \
## Unstashes all NodePaths in the collection.

proc detach*(this: NodePathCollection) {.importcpp: "#.detach()".} ## \
## Detaches all NodePaths in the collection.

proc calc_tight_bounds*(this: NodePathCollection, min_point: LPoint3, max_point: LPoint3): bool {.importcpp: "#.calc_tight_bounds(#, #)".} ## \
## Calculates the minimum and maximum vertices of all Geoms at these
## NodePath's bottom nodes and below This is a tight bounding box; it will
## generally be tighter than the bounding volume returned by get_bounds() (but
## it is more expensive to compute).
##
## The return value is true if any points are within the bounding volume, or
## false if none are.

proc set_texture*(this: NodePathCollection, tex: Texture, priority: int) {.importcpp: "#.set_texture(#, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the default texture stage.
##
## This is the deprecated single-texture variant of this method; it is now
## superceded by set_texture() that accepts a stage and texture.  However,
## this method may be used in the presence of multitexture if you just want to
## adjust the default stage.

proc set_texture*(this: NodePathCollection, tex: Texture) {.importcpp: "#.set_texture(#)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the default texture stage.
##
## This is the deprecated single-texture variant of this method; it is now
## superceded by set_texture() that accepts a stage and texture.  However,
## this method may be used in the presence of multitexture if you just want to
## adjust the default stage.

proc set_texture*(this: NodePathCollection, stage: TextureStage, tex: Texture, priority: int) {.importcpp: "#.set_texture(#, #, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the indicated multitexture stage.  If there are multiple texture stages
## specified (possibly on multiple different nodes at different levels), they
## will all be applied to geometry together, according to the stage
## specification set up in the TextureStage object.

proc set_texture*(this: NodePathCollection, stage: TextureStage, tex: Texture) {.importcpp: "#.set_texture(#, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the indicated multitexture stage.  If there are multiple texture stages
## specified (possibly on multiple different nodes at different levels), they
## will all be applied to geometry together, according to the stage
## specification set up in the TextureStage object.

proc set_texture_off*(this: NodePathCollection, stage: TextureStage, priority: int) {.importcpp: "#.set_texture_off(#, #)".} ## \
## Sets the geometry at this level and below to render using no texture, on
## the indicated stage.  This is different from not specifying a texture;
## rather, this specifically contradicts set_texture() at a higher node level
## (or, with a priority, overrides a set_texture() at a lower level).

proc set_texture_off*(this: NodePathCollection, stage: TextureStage) {.importcpp: "#.set_texture_off(#)".} ## \
## Sets the geometry at this level and below to render using no texture, on
## the indicated stage.  This is different from not specifying a texture;
## rather, this specifically contradicts set_texture() at a higher node level
## (or, with a priority, overrides a set_texture() at a lower level).

proc set_texture_off*(this: NodePathCollection, priority: int) {.importcpp: "#.set_texture_off(#)".} ## \
## Sets the geometry at this level and below to render using no texture, on
## any stage.  This is different from not specifying a texture; rather, this
## specifically contradicts set_texture() at a higher node level (or, with a
## priority, overrides a set_texture() at a lower level).

proc set_texture_off*(this: NodePathCollection) {.importcpp: "#.set_texture_off()".} ## \
## Sets the geometry at this level and below to render using no texture, on
## any stage.  This is different from not specifying a texture; rather, this
## specifically contradicts set_texture() at a higher node level (or, with a
## priority, overrides a set_texture() at a lower level).

proc set_color*(this: NodePathCollection, color: LColor, priority: int) {.importcpp: "#.set_color(#, #)".} ## \
## Colors all NodePaths in the collection

proc set_color*(this: NodePathCollection, color: LColor) {.importcpp: "#.set_color(#)".} ## \
## Colors all NodePaths in the collection

proc set_color*(this: NodePathCollection, r: float32, g: float32, b: float32, a: float32, priority: int) {.importcpp: "#.set_color(#, #, #, #, #)".} ## \
## Colors all NodePaths in the collection

proc set_color*(this: NodePathCollection, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_color(#, #, #, #)".} ## \
## Colors all NodePaths in the collection

proc set_color*(this: NodePathCollection, r: float32, g: float32, b: float32) {.importcpp: "#.set_color(#, #, #)".} ## \
## Colors all NodePaths in the collection

proc set_color_scale*(this: NodePathCollection, scale: LVecBase4, priority: int) {.importcpp: "#.set_color_scale(#, #)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale is replaced.

proc set_color_scale*(this: NodePathCollection, scale: LVecBase4) {.importcpp: "#.set_color_scale(#)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale is replaced.

proc set_color_scale*(this: NodePathCollection, r: float32, g: float32, b: float32, a: float32, priority: int) {.importcpp: "#.set_color_scale(#, #, #, #, #)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale is replaced.

proc set_color_scale*(this: NodePathCollection, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_color_scale(#, #, #, #)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale is replaced.

proc set_color_scale*(this: NodePathCollection, r: float32, g: float32, b: float32) {.importcpp: "#.set_color_scale(#, #, #)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale is replaced.

proc compose_color_scale*(this: NodePathCollection, scale: LVecBase4, priority: int) {.importcpp: "#.compose_color_scale(#, #)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale, if any, is multiplied by the specified color scale.

proc compose_color_scale*(this: NodePathCollection, scale: LVecBase4) {.importcpp: "#.compose_color_scale(#)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale, if any, is multiplied by the specified color scale.

proc compose_color_scale*(this: NodePathCollection, r: float32, g: float32, b: float32, a: float32, priority: int) {.importcpp: "#.compose_color_scale(#, #, #, #, #)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale, if any, is multiplied by the specified color scale.

proc compose_color_scale*(this: NodePathCollection, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.compose_color_scale(#, #, #, #)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale, if any, is multiplied by the specified color scale.

proc compose_color_scale*(this: NodePathCollection, r: float32, g: float32, b: float32) {.importcpp: "#.compose_color_scale(#, #, #)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale, if any, is multiplied by the specified color scale.

proc set_attrib*(this: NodePathCollection, attrib: RenderAttrib, priority: int) {.importcpp: "#.set_attrib(#, #)".} ## \
## Applies the indicated RenderAttrib to all NodePaths in the collection.  An
## effort is made to apply the attrib to many NodePaths as quickly as
## possible; redundant RenderState compositions are not duplicated.

proc set_attrib*(this: NodePathCollection, attrib: RenderAttrib) {.importcpp: "#.set_attrib(#)".} ## \
## Applies the indicated RenderAttrib to all NodePaths in the collection.  An
## effort is made to apply the attrib to many NodePaths as quickly as
## possible; redundant RenderState compositions are not duplicated.

proc output*(this: NodePathCollection, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes a brief one-line description of the NodePathCollection to the
## indicated output stream.

proc write*(this: NodePathCollection, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes a complete multi-line description of the NodePathCollection to the
## indicated output stream.

proc write*(this: NodePathCollection, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a complete multi-line description of the NodePathCollection to the
## indicated output stream.

proc count_num_descendants*(this: NodePath): int {.importcpp: "#.count_num_descendants()".} ## \
## Returns the number of nodes at and below this level.

proc has_parent*(this: NodePath, current_thread: Thread): bool {.importcpp: "#.has_parent(#)".} ## \
## Returns true if the referenced node has a parent; i.e.  the NodePath chain
## contains at least two nodes.

proc has_parent*(this: NodePath): bool {.importcpp: "#.has_parent()".} ## \
## Returns true if the referenced node has a parent; i.e.  the NodePath chain
## contains at least two nodes.

proc get_parent*(this: NodePath, current_thread: Thread): NodePath {.importcpp: "#.get_parent(#)".} ## \
## Returns the NodePath to the parent of the referenced node: that is, this
## NodePath, shortened by one node.  The parent of a singleton NodePath is
## defined to be the empty NodePath.

proc get_parent*(this: NodePath): NodePath {.importcpp: "#.get_parent()".} ## \
## Returns the NodePath to the parent of the referenced node: that is, this
## NodePath, shortened by one node.  The parent of a singleton NodePath is
## defined to be the empty NodePath.

proc get_sort*(this: NodePath, current_thread: Thread): int {.importcpp: "#.get_sort(#)".} ## \
## Returns the sort value of the referenced node within its parent; that is,
## the sort number passed on the last reparenting operation for this node.
## This will control the position of the node within its parent's list of
## children.

proc get_sort*(this: NodePath): int {.importcpp: "#.get_sort()".} ## \
## Returns the sort value of the referenced node within its parent; that is,
## the sort number passed on the last reparenting operation for this node.
## This will control the position of the node within its parent's list of
## children.

proc find*(this: NodePath, path: string): NodePath {.importcpp: "#.find(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Searches for a node below the referenced node that matches the indicated
## string.  Returns the shortest match found, if any, or an empty NodePath if
## no match can be found.
##
## The referenced node itself is not considered in the search.

proc find_path_to*(this: NodePath, node: PandaNode): NodePath {.importcpp: "#.find_path_to(#)".} ## \
## Searches for the indicated node below this node and returns the shortest
## NodePath that connects them.

proc find_all_matches*(this: NodePath, path: string): NodePathCollection {.importcpp: "#.find_all_matches(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the complete set of all NodePaths that begin with this NodePath and
## can be extended by path.  The shortest paths will be listed first.
##
## The referenced node itself is not considered in the search.

proc find_all_paths_to*(this: NodePath, node: PandaNode): NodePathCollection {.importcpp: "#.find_all_paths_to(#)".} ## \
## Returns the set of all NodePaths that extend from this NodePath down to the
## indicated node.  The shortest paths will be listed first.

proc reparent_to*(this: NodePath, other: NodePath, sort: int, current_thread: Thread) {.importcpp: "#.reparent_to(#, #, #)".} ## \
## Removes the referenced node of the NodePath from its current parent and
## attaches it to the referenced node of the indicated NodePath.
##
## If the destination NodePath is empty, this is the same thing as
## detach_node().
##
## If the referenced node is already a child of the indicated NodePath (via
## some other instance), this operation fails and leaves the NodePath
## detached.

proc reparent_to*(this: NodePath, other: NodePath, sort: int) {.importcpp: "#.reparent_to(#, #)".} ## \
## Removes the referenced node of the NodePath from its current parent and
## attaches it to the referenced node of the indicated NodePath.
##
## If the destination NodePath is empty, this is the same thing as
## detach_node().
##
## If the referenced node is already a child of the indicated NodePath (via
## some other instance), this operation fails and leaves the NodePath
## detached.

proc reparent_to*(this: NodePath, other: NodePath) {.importcpp: "#.reparent_to(#)".} ## \
## Removes the referenced node of the NodePath from its current parent and
## attaches it to the referenced node of the indicated NodePath.
##
## If the destination NodePath is empty, this is the same thing as
## detach_node().
##
## If the referenced node is already a child of the indicated NodePath (via
## some other instance), this operation fails and leaves the NodePath
## detached.

proc stash_to*(this: NodePath, other: NodePath, sort: int, current_thread: Thread) {.importcpp: "#.stash_to(#, #, #)".} ## \
## Similar to reparent_to(), but the node is added to its new parent's stashed
## list, so that the result is equivalent to calling reparent_to() immediately
## followed by stash().

proc stash_to*(this: NodePath, other: NodePath, sort: int) {.importcpp: "#.stash_to(#, #)".} ## \
## Similar to reparent_to(), but the node is added to its new parent's stashed
## list, so that the result is equivalent to calling reparent_to() immediately
## followed by stash().

proc stash_to*(this: NodePath, other: NodePath) {.importcpp: "#.stash_to(#)".} ## \
## Similar to reparent_to(), but the node is added to its new parent's stashed
## list, so that the result is equivalent to calling reparent_to() immediately
## followed by stash().

proc wrt_reparent_to*(this: NodePath, other: NodePath, sort: int, current_thread: Thread) {.importcpp: "#.wrt_reparent_to(#, #, #)".} ## \
## This functions identically to reparent_to(), except the transform on this
## node is also adjusted so that the node remains in the same place in world
## coordinates, even if it is reparented into a different coordinate system.

proc wrt_reparent_to*(this: NodePath, other: NodePath, sort: int) {.importcpp: "#.wrt_reparent_to(#, #)".} ## \
## This functions identically to reparent_to(), except the transform on this
## node is also adjusted so that the node remains in the same place in world
## coordinates, even if it is reparented into a different coordinate system.

proc wrt_reparent_to*(this: NodePath, other: NodePath) {.importcpp: "#.wrt_reparent_to(#)".} ## \
## This functions identically to reparent_to(), except the transform on this
## node is also adjusted so that the node remains in the same place in world
## coordinates, even if it is reparented into a different coordinate system.

proc instance_to*(this: NodePath, other: NodePath, sort: int, current_thread: Thread): NodePath {.importcpp: "#.instance_to(#, #, #)".} ## \
## Adds the referenced node of the NodePath as a child of the referenced node
## of the indicated other NodePath.  Any other parent-child relations of the
## node are unchanged; in particular, the node is not removed from its
## existing parent, if any.
##
## If the node already had an existing parent, this method will create a new
## instance of the node within the scene graph.
##
## This does not change the NodePath itself, but does return a new NodePath
## that reflects the new instance node.
##
## If the destination NodePath is empty, this creates a new instance which is
## not yet parented to any node.  A new instance of this sort cannot easily be
## differentiated from other similar instances, but it is nevertheless a
## different instance and it will return a different get_id() value.
##
## If the referenced node is already a child of the indicated NodePath,
## returns that already-existing instance, unstashing it first if necessary.

proc instance_to*(this: NodePath, other: NodePath, sort: int): NodePath {.importcpp: "#.instance_to(#, #)".} ## \
## Adds the referenced node of the NodePath as a child of the referenced node
## of the indicated other NodePath.  Any other parent-child relations of the
## node are unchanged; in particular, the node is not removed from its
## existing parent, if any.
##
## If the node already had an existing parent, this method will create a new
## instance of the node within the scene graph.
##
## This does not change the NodePath itself, but does return a new NodePath
## that reflects the new instance node.
##
## If the destination NodePath is empty, this creates a new instance which is
## not yet parented to any node.  A new instance of this sort cannot easily be
## differentiated from other similar instances, but it is nevertheless a
## different instance and it will return a different get_id() value.
##
## If the referenced node is already a child of the indicated NodePath,
## returns that already-existing instance, unstashing it first if necessary.

proc instance_to*(this: NodePath, other: NodePath): NodePath {.importcpp: "#.instance_to(#)".} ## \
## Adds the referenced node of the NodePath as a child of the referenced node
## of the indicated other NodePath.  Any other parent-child relations of the
## node are unchanged; in particular, the node is not removed from its
## existing parent, if any.
##
## If the node already had an existing parent, this method will create a new
## instance of the node within the scene graph.
##
## This does not change the NodePath itself, but does return a new NodePath
## that reflects the new instance node.
##
## If the destination NodePath is empty, this creates a new instance which is
## not yet parented to any node.  A new instance of this sort cannot easily be
## differentiated from other similar instances, but it is nevertheless a
## different instance and it will return a different get_id() value.
##
## If the referenced node is already a child of the indicated NodePath,
## returns that already-existing instance, unstashing it first if necessary.

proc instance_under_node*(this: NodePath, other: NodePath, name: string, sort: int, current_thread: Thread): NodePath {.importcpp: "#.instance_under_node(#, nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Behaves like instance_to(), but implicitly creates a new node to instance
## the geometry under, and returns a NodePath to that new node.  This allows
## the programmer to set a unique state and/or transform on this instance.

proc instance_under_node*(this: NodePath, other: NodePath, name: string, sort: int): NodePath {.importcpp: "#.instance_under_node(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Behaves like instance_to(), but implicitly creates a new node to instance
## the geometry under, and returns a NodePath to that new node.  This allows
## the programmer to set a unique state and/or transform on this instance.

proc instance_under_node*(this: NodePath, other: NodePath, name: string): NodePath {.importcpp: "#.instance_under_node(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Behaves like instance_to(), but implicitly creates a new node to instance
## the geometry under, and returns a NodePath to that new node.  This allows
## the programmer to set a unique state and/or transform on this instance.

proc copy_to*(this: NodePath, other: NodePath, sort: int, current_thread: Thread): NodePath {.importcpp: "#.copy_to(#, #, #)".} ## \
## Functions like instance_to(), except a deep copy is made of the referenced
## node and all of its descendents, which is then parented to the indicated
## node.  A NodePath to the newly created copy is returned.

proc copy_to*(this: NodePath, other: NodePath, sort: int): NodePath {.importcpp: "#.copy_to(#, #)".} ## \
## Functions like instance_to(), except a deep copy is made of the referenced
## node and all of its descendents, which is then parented to the indicated
## node.  A NodePath to the newly created copy is returned.

proc copy_to*(this: NodePath, other: NodePath): NodePath {.importcpp: "#.copy_to(#)".} ## \
## Functions like instance_to(), except a deep copy is made of the referenced
## node and all of its descendents, which is then parented to the indicated
## node.  A NodePath to the newly created copy is returned.

proc attach_new_node*(this: NodePath, node: PandaNode, sort: int, current_thread: Thread): NodePath {.importcpp: "#.attach_new_node(#, #, #)".} ## \
## Attaches a new node, with or without existing parents, to the scene graph
## below the referenced node of this NodePath.  This is the preferred way to
## add nodes to the graph.
##
## If the node was already a child of the parent, this returns a NodePath to
## the existing child.
##
## This does *not* automatically extend the current NodePath to reflect the
## attachment; however, a NodePath that does reflect this extension is
## returned.

proc attach_new_node*(this: NodePath, node: PandaNode, sort: int): NodePath {.importcpp: "#.attach_new_node(#, #)".} ## \
## Attaches a new node, with or without existing parents, to the scene graph
## below the referenced node of this NodePath.  This is the preferred way to
## add nodes to the graph.
##
## If the node was already a child of the parent, this returns a NodePath to
## the existing child.
##
## This does *not* automatically extend the current NodePath to reflect the
## attachment; however, a NodePath that does reflect this extension is
## returned.

proc attach_new_node*(this: NodePath, node: PandaNode): NodePath {.importcpp: "#.attach_new_node(#)".} ## \
## Attaches a new node, with or without existing parents, to the scene graph
## below the referenced node of this NodePath.  This is the preferred way to
## add nodes to the graph.
##
## If the node was already a child of the parent, this returns a NodePath to
## the existing child.
##
## This does *not* automatically extend the current NodePath to reflect the
## attachment; however, a NodePath that does reflect this extension is
## returned.

proc attach_new_node*(this: NodePath, name: string, sort: int, current_thread: Thread): NodePath {.importcpp: "#.attach_new_node(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Creates an ordinary PandaNode and attaches it below the current NodePath,
## returning a new NodePath that references it.

proc attach_new_node*(this: NodePath, name: string, sort: int): NodePath {.importcpp: "#.attach_new_node(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Creates an ordinary PandaNode and attaches it below the current NodePath,
## returning a new NodePath that references it.

proc attach_new_node*(this: NodePath, name: string): NodePath {.importcpp: "#.attach_new_node(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates an ordinary PandaNode and attaches it below the current NodePath,
## returning a new NodePath that references it.

proc remove_node*(this: NodePath, current_thread: Thread) {.importcpp: "#.remove_node(#)".} ## \
## Disconnects the referenced node from the scene graph.  This will also
## delete the node if there are no other pointers to it.
##
## Normally, this should be called only when you are really done with the
## node.  If you want to remove a node from the scene graph but keep it around
## for later, you should probably use detach_node() instead.
##
## In practice, the only difference between remove_node() and detach_node() is
## that remove_node() also resets the NodePath to empty, which will cause the
## node to be deleted immediately if there are no other references.  On the
## other hand, detach_node() leaves the NodePath referencing the node, which
## will keep at least one reference to the node for as long as the NodePath
## exists.

proc remove_node*(this: NodePath) {.importcpp: "#.remove_node()".} ## \
## Disconnects the referenced node from the scene graph.  This will also
## delete the node if there are no other pointers to it.
##
## Normally, this should be called only when you are really done with the
## node.  If you want to remove a node from the scene graph but keep it around
## for later, you should probably use detach_node() instead.
##
## In practice, the only difference between remove_node() and detach_node() is
## that remove_node() also resets the NodePath to empty, which will cause the
## node to be deleted immediately if there are no other references.  On the
## other hand, detach_node() leaves the NodePath referencing the node, which
## will keep at least one reference to the node for as long as the NodePath
## exists.

proc detach_node*(this: NodePath, current_thread: Thread) {.importcpp: "#.detach_node(#)".} ## \
## Disconnects the referenced node from its parent, but does not immediately
## delete it.  The NodePath retains a pointer to the node, and becomes a
## singleton NodePath.
##
## This should be called to detach a node from the scene graph, with the
## option of reattaching it later to the same parent or to a different parent.
##
## In practice, the only difference between remove_node() and detach_node() is
## that remove_node() also resets the NodePath to empty, which will cause the
## node to be deleted immediately if there are no other references.  On the
## other hand, detach_node() leaves the NodePath referencing the node, which
## will keep at least one reference to the node for as long as the NodePath
## exists.

proc detach_node*(this: NodePath) {.importcpp: "#.detach_node()".} ## \
## Disconnects the referenced node from its parent, but does not immediately
## delete it.  The NodePath retains a pointer to the node, and becomes a
## singleton NodePath.
##
## This should be called to detach a node from the scene graph, with the
## option of reattaching it later to the same parent or to a different parent.
##
## In practice, the only difference between remove_node() and detach_node() is
## that remove_node() also resets the NodePath to empty, which will cause the
## node to be deleted immediately if there are no other references.  On the
## other hand, detach_node() leaves the NodePath referencing the node, which
## will keep at least one reference to the node for as long as the NodePath
## exists.

proc output*(this: NodePath, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes a sensible description of the NodePath to the indicated output
## stream.

proc ls*(this: NodePath) {.importcpp: "#.ls()".} ## \
## Lists the hierarchy at and below the referenced node.

proc ls*(this: NodePath, `out`: ostream, indent_level: int) {.importcpp: "#.ls(#, #)".} ## \
## Lists the hierarchy at and below the referenced node.

proc ls*(this: NodePath, `out`: ostream) {.importcpp: "#.ls(#)".} ## \
## Lists the hierarchy at and below the referenced node.

proc reverse_ls*(this: NodePath) {.importcpp: "#.reverse_ls()".} ## \
## Lists the hierarchy at and above the referenced node.

proc reverse_ls*(this: NodePath, `out`: ostream, indent_level: int): int {.importcpp: "#.reverse_ls(#, #)".} ## \
## Lists the hierarchy at and above the referenced node.

proc reverse_ls*(this: NodePath, `out`: ostream): int {.importcpp: "#.reverse_ls(#)".} ## \
## Lists the hierarchy at and above the referenced node.

proc get_state*(this: NodePath, other: NodePath, current_thread: Thread): RenderState {.importcpp: "#.get_state(#, #)".} ## \
## Returns the state changes that must be made to transition to the render
## state of this node from the render state of the other node.

proc get_state*(this: NodePath, other: NodePath): RenderState {.importcpp: "#.get_state(#)".} ## \
## Returns the state changes that must be made to transition to the render
## state of this node from the render state of the other node.

proc get_state*(this: NodePath, current_thread: Thread): RenderState {.importcpp: "#.get_state(#)".} ## \
## Returns the complete state object set on this node.

proc get_state*(this: NodePath): RenderState {.importcpp: "#.get_state()".} ## \
## Returns the complete state object set on this node.

proc set_state*(this: NodePath, other: NodePath, state: RenderState, current_thread: Thread) {.importcpp: "#.set_state(#, #, #)".} ## \
## Sets the state object on this node, relative to the other node.  This
## computes a new state object that will have the indicated value when seen
## from the other node.

proc set_state*(this: NodePath, other: NodePath, state: RenderState) {.importcpp: "#.set_state(#, #)".} ## \
## Sets the state object on this node, relative to the other node.  This
## computes a new state object that will have the indicated value when seen
## from the other node.

proc set_state*(this: NodePath, state: RenderState, current_thread: Thread) {.importcpp: "#.set_state(#, #)".} ## \
## Changes the complete state object on this node.

proc set_state*(this: NodePath, state: RenderState) {.importcpp: "#.set_state(#)".} ## \
## Changes the complete state object on this node.

proc get_net_state*(this: NodePath, current_thread: Thread): RenderState {.importcpp: "#.get_net_state(#)".} ## \
## Returns the net state on this node from the root.

proc get_net_state*(this: NodePath): RenderState {.importcpp: "#.get_net_state()".} ## \
## Returns the net state on this node from the root.

proc set_attrib*(this: NodePath, attrib: RenderAttrib, priority: int) {.importcpp: "#.set_attrib(#, #)".} ## \
## Adds the indicated render attribute to the scene graph on this node.  This
## attribute will now apply to this node and everything below.  If there was
## already an attribute of the same type, it is replaced.

proc set_attrib*(this: NodePath, attrib: RenderAttrib) {.importcpp: "#.set_attrib(#)".} ## \
## Adds the indicated render attribute to the scene graph on this node.  This
## attribute will now apply to this node and everything below.  If there was
## already an attribute of the same type, it is replaced.

proc get_attrib*(this: NodePath, `type`: TypeHandle): RenderAttrib {.importcpp: "#.get_attrib(#)".} ## \
## Returns the render attribute of the indicated type, if it is defined on the
## node, or NULL if it is not.  This checks only what is set on this
## particular node level, and has nothing to do with what render attributes
## may be inherited from parent nodes.

proc has_attrib*(this: NodePath, `type`: TypeHandle): bool {.importcpp: "#.has_attrib(#)".} ## \
## Returns true if there is a render attribute of the indicated type defined
## on this node, or false if there is not.

proc clear_attrib*(this: NodePath, `type`: TypeHandle) {.importcpp: "#.clear_attrib(#)".} ## \
## Removes the render attribute of the given type from this node.  This node,
## and the subgraph below, will now inherit the indicated render attribute
## from the nodes above this one.

proc set_effect*(this: NodePath, effect: RenderEffect) {.importcpp: "#.set_effect(#)".} ## \
## Adds the indicated render effect to the scene graph on this node.  If there
## was already an effect of the same type, it is replaced.

proc get_effect*(this: NodePath, `type`: TypeHandle): RenderEffect {.importcpp: "#.get_effect(#)".} ## \
## Returns the render effect of the indicated type, if it is defined on the
## node, or NULL if it is not.

proc has_effect*(this: NodePath, `type`: TypeHandle): bool {.importcpp: "#.has_effect(#)".} ## \
## Returns true if there is a render effect of the indicated type defined on
## this node, or false if there is not.

proc clear_effect*(this: NodePath, `type`: TypeHandle) {.importcpp: "#.clear_effect(#)".} ## \
## Removes the render effect of the given type from this node.

proc set_effects*(this: NodePath, effects: RenderEffects) {.importcpp: "#.set_effects(#)".} ## \
## Sets the complete RenderEffects that will be applied this node.  This
## completely replaces whatever has been set on this node via repeated calls
## to set_attrib().

proc get_effects*(this: NodePath): RenderEffects {.importcpp: "#.get_effects()".} ## \
## Returns the complete RenderEffects that will be applied to this node.

proc clear_effects*(this: NodePath) {.importcpp: "#.clear_effects()".} ## \
## Resets this node to have no render effects.

proc get_transform*(this: NodePath, other: NodePath, current_thread: Thread): TransformState {.importcpp: "#.get_transform(#, #)".} ## \
## Returns the relative transform to this node from the other node; i.e.  the
## transformation of this node as seen from the other node.

proc get_transform*(this: NodePath, other: NodePath): TransformState {.importcpp: "#.get_transform(#)".} ## \
## Returns the relative transform to this node from the other node; i.e.  the
## transformation of this node as seen from the other node.

proc get_transform*(this: NodePath, current_thread: Thread): TransformState {.importcpp: "#.get_transform(#)".} ## \
## Returns the complete transform object set on this node.

proc get_transform*(this: NodePath): TransformState {.importcpp: "#.get_transform()".} ## \
## Returns the complete transform object set on this node.

proc clear_transform*(this: NodePath, other: NodePath, current_thread: Thread) {.importcpp: "#.clear_transform(#, #)".} ## \
## Sets the transform object on this node to identity, relative to the other
## node.  This effectively places this node at the same position as the other
## node.

proc clear_transform*(this: NodePath, other: NodePath) {.importcpp: "#.clear_transform(#)".} ## \
## Sets the transform object on this node to identity, relative to the other
## node.  This effectively places this node at the same position as the other
## node.

proc clear_transform*(this: NodePath, current_thread: Thread) {.importcpp: "#.clear_transform(#)".} ## \
## Sets the transform object on this node to identity.

proc clear_transform*(this: NodePath) {.importcpp: "#.clear_transform()".} ## \
## Sets the transform object on this node to identity.

proc set_transform*(this: NodePath, other: NodePath, transform: TransformState, current_thread: Thread) {.importcpp: "#.set_transform(#, #, #)".} ## \
## Sets the transform object on this node, relative to the other node.  This
## computes a new transform object that will have the indicated value when
## seen from the other node.

proc set_transform*(this: NodePath, other: NodePath, transform: TransformState) {.importcpp: "#.set_transform(#, #)".} ## \
## Sets the transform object on this node, relative to the other node.  This
## computes a new transform object that will have the indicated value when
## seen from the other node.

proc set_transform*(this: NodePath, transform: TransformState, current_thread: Thread) {.importcpp: "#.set_transform(#, #)".} ## \
## Changes the complete transform object on this node.

proc set_transform*(this: NodePath, transform: TransformState) {.importcpp: "#.set_transform(#)".} ## \
## Changes the complete transform object on this node.

proc get_net_transform*(this: NodePath, current_thread: Thread): TransformState {.importcpp: "#.get_net_transform(#)".} ## \
## Returns the net transform on this node from the root.

proc get_net_transform*(this: NodePath): TransformState {.importcpp: "#.get_net_transform()".} ## \
## Returns the net transform on this node from the root.

proc get_prev_transform*(this: NodePath, other: NodePath, current_thread: Thread): TransformState {.importcpp: "#.get_prev_transform(#, #)".} ## \
## Returns the relative "previous" transform to this node from the other node;
## i.e.  the position of this node in the previous frame, as seen by the other
## node in the previous frame.

proc get_prev_transform*(this: NodePath, other: NodePath): TransformState {.importcpp: "#.get_prev_transform(#)".} ## \
## Returns the relative "previous" transform to this node from the other node;
## i.e.  the position of this node in the previous frame, as seen by the other
## node in the previous frame.

proc get_prev_transform*(this: NodePath, current_thread: Thread): TransformState {.importcpp: "#.get_prev_transform(#)".} ## \
## Returns the transform that has been set as this node's "previous" position.
## See set_prev_transform().

proc get_prev_transform*(this: NodePath): TransformState {.importcpp: "#.get_prev_transform()".} ## \
## Returns the transform that has been set as this node's "previous" position.
## See set_prev_transform().

proc set_prev_transform*(this: NodePath, other: NodePath, transform: TransformState, current_thread: Thread) {.importcpp: "#.set_prev_transform(#, #, #)".} ## \
## Sets the "previous" transform object on this node, relative to the other
## node.  This computes a new transform object that will have the indicated
## value when seen from the other node.

proc set_prev_transform*(this: NodePath, other: NodePath, transform: TransformState) {.importcpp: "#.set_prev_transform(#, #)".} ## \
## Sets the "previous" transform object on this node, relative to the other
## node.  This computes a new transform object that will have the indicated
## value when seen from the other node.

proc set_prev_transform*(this: NodePath, transform: TransformState, current_thread: Thread) {.importcpp: "#.set_prev_transform(#, #)".} ## \
## Sets the transform that represents this node's "previous" position, one
## frame ago, for the purposes of detecting motion for accurate collision
## calculations.

proc set_prev_transform*(this: NodePath, transform: TransformState) {.importcpp: "#.set_prev_transform(#)".} ## \
## Sets the transform that represents this node's "previous" position, one
## frame ago, for the purposes of detecting motion for accurate collision
## calculations.

proc get_net_prev_transform*(this: NodePath, current_thread: Thread): TransformState {.importcpp: "#.get_net_prev_transform(#)".} ## \
## Returns the net "previous" transform on this node from the root.  See
## set_prev_transform().

proc get_net_prev_transform*(this: NodePath): TransformState {.importcpp: "#.get_net_prev_transform()".} ## \
## Returns the net "previous" transform on this node from the root.  See
## set_prev_transform().

proc set_pos*(this: NodePath, pos: LVecBase3) {.importcpp: "#.set_pos(#)".} ## \
## Sets the translation component of the transform, leaving rotation and scale
## untouched.  This also resets the node's "previous" position, so that the
## collision system will see the node as having suddenly appeared in the new
## position, without passing any points in between.  See Also:
## NodePath::set_fluid_pos

proc set_pos*(this: NodePath, other: NodePath, pos: LVecBase3) {.importcpp: "#.set_pos(#, #)".} ## \
## Sets the translation component of the transform, relative to the other
## node.

proc set_pos*(this: NodePath, other: NodePath, x: float32, y: float32, z: float32) {.importcpp: "#.set_pos(#, #, #, #)".} ## \
## Sets the translation component of the transform, relative to the other
## node.

proc set_pos*(this: NodePath, x: float32, y: float32, z: float32) {.importcpp: "#.set_pos(#, #, #)".} ## \
## Sets the translation component of the transform, leaving rotation and scale
## untouched.  This also resets the node's "previous" position, so that the
## collision system will see the node as having suddenly appeared in the new
## position, without passing any points in between.

proc set_x*(this: NodePath, other: NodePath, x: float32) {.importcpp: "#.set_x(#, #)".}

proc set_x*(this: NodePath, x: float32) {.importcpp: "#.set_x(#)".} ## \
## Sets the X component of the position transform, leaving other components
## untouched.
## @see set_pos()

proc set_y*(this: NodePath, other: NodePath, y: float32) {.importcpp: "#.set_y(#, #)".}

proc set_y*(this: NodePath, y: float32) {.importcpp: "#.set_y(#)".} ## \
## Sets the Y component of the position transform, leaving other components
## untouched.
## @see set_pos()

proc set_z*(this: NodePath, other: NodePath, z: float32) {.importcpp: "#.set_z(#, #)".}

proc set_z*(this: NodePath, z: float32) {.importcpp: "#.set_z(#)".} ## \
## Sets the Z component of the position transform, leaving other components
## untouched.
## @see set_pos()

proc set_fluid_pos*(this: NodePath, pos: LVecBase3) {.importcpp: "#.set_fluid_pos(#)".} ## \
## Sets the translation component, without changing the "previous" position,
## so that the collision system will see the node as moving fluidly from its
## previous position to its new position.  See Also: NodePath::set_pos

proc set_fluid_pos*(this: NodePath, other: NodePath, pos: LVecBase3) {.importcpp: "#.set_fluid_pos(#, #)".} ## \
## Sets the translation component of the transform, relative to the other
## node.

proc set_fluid_pos*(this: NodePath, other: NodePath, x: float32, y: float32, z: float32) {.importcpp: "#.set_fluid_pos(#, #, #, #)".} ## \
## Sets the translation component, without changing the "previous" position,
## so that the collision system will see the node as moving fluidly from its
## previous position to its new position.

proc set_fluid_pos*(this: NodePath, x: float32, y: float32, z: float32) {.importcpp: "#.set_fluid_pos(#, #, #)".} ## \
## Sets the translation component, without changing the "previous" position,
## so that the collision system will see the node as moving fluidly from its
## previous position to its new position.

proc set_fluid_x*(this: NodePath, other: NodePath, x: float32) {.importcpp: "#.set_fluid_x(#, #)".}

proc set_fluid_x*(this: NodePath, x: float32) {.importcpp: "#.set_fluid_x(#)".}

proc set_fluid_y*(this: NodePath, other: NodePath, y: float32) {.importcpp: "#.set_fluid_y(#, #)".}

proc set_fluid_y*(this: NodePath, y: float32) {.importcpp: "#.set_fluid_y(#)".}

proc set_fluid_z*(this: NodePath, other: NodePath, z: float32) {.importcpp: "#.set_fluid_z(#, #)".}

proc set_fluid_z*(this: NodePath, z: float32) {.importcpp: "#.set_fluid_z(#)".}

proc get_pos*(this: NodePath): LPoint3 {.importcpp: "#.get_pos()".} ## \
## Retrieves the translation component of the transform.

proc get_pos*(this: NodePath, other: NodePath): LPoint3 {.importcpp: "#.get_pos(#)".} ## \
## Returns the relative position of the referenced node as seen from the other
## node.

proc get_x*(this: NodePath): float32 {.importcpp: "#.get_x()".}

proc get_x*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_x(#)".}

proc get_y*(this: NodePath): float32 {.importcpp: "#.get_y()".}

proc get_y*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_y(#)".}

proc get_z*(this: NodePath): float32 {.importcpp: "#.get_z()".}

proc get_z*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_z(#)".}

proc get_pos_delta*(this: NodePath): LVector3 {.importcpp: "#.get_pos_delta()".} ## \
## Returns the delta vector from this node's position in the previous frame
## (according to set_prev_transform(), typically set via the use of
## set_fluid_pos()) and its position in the current frame.  This is the vector
## used to determine collisions.  Generally, if the node was last repositioned
## via set_pos(), the delta will be zero; if it was adjusted via
## set_fluid_pos(), the delta will represent the change from the previous
## frame's position.

proc get_pos_delta*(this: NodePath, other: NodePath): LVector3 {.importcpp: "#.get_pos_delta(#)".} ## \
## Returns the delta vector from this node's position in the previous frame
## (according to set_prev_transform(), typically set via the use of
## set_fluid_pos()) and its position in the current frame, as seen in the
## indicated node's coordinate space.  This is the vector used to determine
## collisions.  Generally, if the node was last repositioned via set_pos(),
## the delta will be zero; if it was adjusted via set_fluid_pos(), the delta
## will represent the change from the previous frame's position.

proc set_hpr*(this: NodePath, hpr: LVecBase3) {.importcpp: "#.set_hpr(#)".} ## \
## Sets the rotation component of the transform, leaving translation and scale
## untouched.

proc set_hpr*(this: NodePath, other: NodePath, hpr: LVecBase3) {.importcpp: "#.set_hpr(#, #)".} ## \
## Sets the rotation component of the transform, relative to the other node.

proc set_hpr*(this: NodePath, other: NodePath, h: float32, p: float32, r: float32) {.importcpp: "#.set_hpr(#, #, #, #)".} ## \
## Sets the rotation component of the transform, relative to the other node.

proc set_hpr*(this: NodePath, h: float32, p: float32, r: float32) {.importcpp: "#.set_hpr(#, #, #)".} ## \
## Sets the rotation component of the transform, leaving translation and scale
## untouched.

proc set_h*(this: NodePath, other: NodePath, h: float32) {.importcpp: "#.set_h(#, #)".}

proc set_h*(this: NodePath, h: float32) {.importcpp: "#.set_h(#)".}

proc set_p*(this: NodePath, other: NodePath, p: float32) {.importcpp: "#.set_p(#, #)".}

proc set_p*(this: NodePath, p: float32) {.importcpp: "#.set_p(#)".}

proc set_r*(this: NodePath, other: NodePath, r: float32) {.importcpp: "#.set_r(#, #)".}

proc set_r*(this: NodePath, r: float32) {.importcpp: "#.set_r(#)".}

proc get_hpr*(this: NodePath): LVecBase3 {.importcpp: "#.get_hpr()".} ## \
## Retrieves the rotation component of the transform.

proc get_hpr*(this: NodePath, other: NodePath): LVecBase3 {.importcpp: "#.get_hpr(#)".} ## \
## Returns the relative orientation of the bottom node as seen from the other
## node.

proc get_h*(this: NodePath): float32 {.importcpp: "#.get_h()".}

proc get_h*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_h(#)".}

proc get_p*(this: NodePath): float32 {.importcpp: "#.get_p()".}

proc get_p*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_p(#)".}

proc get_r*(this: NodePath): float32 {.importcpp: "#.get_r()".}

proc get_r*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_r(#)".}

proc set_quat*(this: NodePath, quat: LQuaternion) {.importcpp: "#.set_quat(#)".} ## \
## Sets the rotation component of the transform, leaving translation and scale
## untouched.

proc set_quat*(this: NodePath, other: NodePath, quat: LQuaternion) {.importcpp: "#.set_quat(#, #)".} ## \
## Sets the rotation component of the transform, relative to the other node.

proc get_quat*(this: NodePath): LQuaternion {.importcpp: "#.get_quat()".} ## \
## Retrieves the rotation component of the transform.

proc get_quat*(this: NodePath, other: NodePath): LQuaternion {.importcpp: "#.get_quat(#)".} ## \
## Returns the relative orientation of the bottom node as seen from the other
## node.

proc set_scale*(this: NodePath, scale: LVecBase3) {.importcpp: "#.set_scale(#)".} ## \
## Sets the scale component of the transform, leaving translation and rotation
## untouched.

proc set_scale*(this: NodePath, other: NodePath, scale: LVecBase3) {.importcpp: "#.set_scale(#, #)".} ## \
## Sets the scale component of the transform, relative to the other node.

proc set_scale*(this: NodePath, other: NodePath, scale: float32) {.importcpp: "#.set_scale(#, #)".} ## \
## Sets the scale component of the transform, relative to the other node.

proc set_scale*(this: NodePath, other: NodePath, sx: float32, sy: float32, sz: float32) {.importcpp: "#.set_scale(#, #, #, #)".} ## \
## Sets the scale component of the transform, relative to the other node.

proc set_scale*(this: NodePath, scale: float32) {.importcpp: "#.set_scale(#)".} ## \
## Sets the scale component of the transform, leaving translation and rotation
## untouched.

proc set_scale*(this: NodePath, sx: float32, sy: float32, sz: float32) {.importcpp: "#.set_scale(#, #, #)".}

proc set_sx*(this: NodePath, other: NodePath, sx: float32) {.importcpp: "#.set_sx(#, #)".}

proc set_sx*(this: NodePath, sx: float32) {.importcpp: "#.set_sx(#)".} ## \
## Sets the x-scale component of the transform, leaving other components
## untouched.
## @see set_scale()

proc set_sy*(this: NodePath, other: NodePath, sy: float32) {.importcpp: "#.set_sy(#, #)".}

proc set_sy*(this: NodePath, sy: float32) {.importcpp: "#.set_sy(#)".} ## \
## Sets the y-scale component of the transform, leaving other components
## untouched.
## @see set_scale()

proc set_sz*(this: NodePath, other: NodePath, sz: float32) {.importcpp: "#.set_sz(#, #)".}

proc set_sz*(this: NodePath, sz: float32) {.importcpp: "#.set_sz(#)".} ## \
## Sets the z-scale component of the transform, leaving other components
## untouched.
## @see set_scale()

proc get_scale*(this: NodePath): LVecBase3 {.importcpp: "#.get_scale()".} ## \
## Retrieves the scale component of the transform.

proc get_scale*(this: NodePath, other: NodePath): LVecBase3 {.importcpp: "#.get_scale(#)".} ## \
## Returns the relative scale of the bottom node as seen from the other node.

proc get_sx*(this: NodePath): float32 {.importcpp: "#.get_sx()".}

proc get_sx*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_sx(#)".} ## \
## Returns the relative scale of the referenced node as seen from the other
## node.

proc get_sy*(this: NodePath): float32 {.importcpp: "#.get_sy()".}

proc get_sy*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_sy(#)".}

proc get_sz*(this: NodePath): float32 {.importcpp: "#.get_sz()".}

proc get_sz*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_sz(#)".}

proc set_shear*(this: NodePath, shear: LVecBase3) {.importcpp: "#.set_shear(#)".} ## \
## Sets the shear component of the transform, leaving translation and rotation
## untouched.

proc set_shear*(this: NodePath, other: NodePath, shear: LVecBase3) {.importcpp: "#.set_shear(#, #)".} ## \
## Sets the shear component of the transform, relative to the other node.

proc set_shear*(this: NodePath, other: NodePath, shxy: float32, shxz: float32, shyz: float32) {.importcpp: "#.set_shear(#, #, #, #)".} ## \
## Sets the shear component of the transform, relative to the other node.

proc set_shear*(this: NodePath, shxy: float32, shxz: float32, shyz: float32) {.importcpp: "#.set_shear(#, #, #)".} ## \
## Sets the shear component of the transform, leaving translation, rotation,
## and scale untouched.

proc set_shxy*(this: NodePath, other: NodePath, shxy: float32) {.importcpp: "#.set_shxy(#, #)".}

proc set_shxy*(this: NodePath, shxy: float32) {.importcpp: "#.set_shxy(#)".}

proc set_shxz*(this: NodePath, other: NodePath, shxz: float32) {.importcpp: "#.set_shxz(#, #)".}

proc set_shxz*(this: NodePath, shxz: float32) {.importcpp: "#.set_shxz(#)".}

proc set_shyz*(this: NodePath, other: NodePath, shyz: float32) {.importcpp: "#.set_shyz(#, #)".}

proc set_shyz*(this: NodePath, shyz: float32) {.importcpp: "#.set_shyz(#)".}

proc get_shear*(this: NodePath): LVecBase3 {.importcpp: "#.get_shear()".} ## \
## Retrieves the shear component of the transform.

proc get_shear*(this: NodePath, other: NodePath): LVecBase3 {.importcpp: "#.get_shear(#)".} ## \
## Returns the relative shear of the bottom node as seen from the other node.

proc get_shxy*(this: NodePath): float32 {.importcpp: "#.get_shxy()".}

proc get_shxy*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_shxy(#)".} ## \
## Returns the relative shear of the referenced node as seen from the other
## node.

proc get_shxz*(this: NodePath): float32 {.importcpp: "#.get_shxz()".}

proc get_shxz*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_shxz(#)".}

proc get_shyz*(this: NodePath): float32 {.importcpp: "#.get_shyz()".}

proc get_shyz*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_shyz(#)".}

proc set_pos_hpr*(this: NodePath, pos: LVecBase3, hpr: LVecBase3) {.importcpp: "#.set_pos_hpr(#, #)".} ## \
## Sets the translation and rotation component of the transform, leaving scale
## untouched.

proc set_pos_hpr*(this: NodePath, other: NodePath, pos: LVecBase3, hpr: LVecBase3) {.importcpp: "#.set_pos_hpr(#, #, #)".} ## \
## Sets the translation and rotation component of the transform, relative to
## the other node.

proc set_pos_hpr*(this: NodePath, other: NodePath, x: float32, y: float32, z: float32, h: float32, p: float32, r: float32) {.importcpp: "#.set_pos_hpr(#, #, #, #, #, #, #)".} ## \
## Sets the translation and rotation component of the transform, relative to
## the other node.

proc set_pos_hpr*(this: NodePath, x: float32, y: float32, z: float32, h: float32, p: float32, r: float32) {.importcpp: "#.set_pos_hpr(#, #, #, #, #, #)".} ## \
## Sets the translation and rotation component of the transform, leaving scale
## untouched.

proc set_pos_quat*(this: NodePath, pos: LVecBase3, quat: LQuaternion) {.importcpp: "#.set_pos_quat(#, #)".} ## \
## Sets the translation and rotation component of the transform, leaving scale
## untouched.

proc set_pos_quat*(this: NodePath, other: NodePath, pos: LVecBase3, quat: LQuaternion) {.importcpp: "#.set_pos_quat(#, #, #)".} ## \
## Sets the translation and rotation component of the transform, relative to
## the other node.

proc set_hpr_scale*(this: NodePath, hpr: LVecBase3, scale: LVecBase3) {.importcpp: "#.set_hpr_scale(#, #)".} ## \
## Sets the rotation and scale components of the transform, leaving
## translation untouched.

proc set_hpr_scale*(this: NodePath, other: NodePath, hpr: LVecBase3, scale: LVecBase3) {.importcpp: "#.set_hpr_scale(#, #, #)".} ## \
## Sets the rotation and scale components of the transform, leaving
## translation untouched.  This, or set_pos_hpr_scale, is the preferred way to
## update a transform when both hpr and scale are to be changed.

proc set_hpr_scale*(this: NodePath, other: NodePath, h: float32, p: float32, r: float32, sx: float32, sy: float32, sz: float32) {.importcpp: "#.set_hpr_scale(#, #, #, #, #, #, #)".} ## \
## Sets the rotation and scale components of the transform, leaving
## translation untouched.  This, or set_pos_hpr_scale, is the preferred way to
## update a transform when both hpr and scale are to be changed.

proc set_hpr_scale*(this: NodePath, h: float32, p: float32, r: float32, sx: float32, sy: float32, sz: float32) {.importcpp: "#.set_hpr_scale(#, #, #, #, #, #)".} ## \
## Sets the rotation and scale components of the transform, leaving
## translation untouched.

proc set_quat_scale*(this: NodePath, quat: LQuaternion, scale: LVecBase3) {.importcpp: "#.set_quat_scale(#, #)".} ## \
## Sets the rotation and scale components of the transform, leaving
## translation untouched.

proc set_quat_scale*(this: NodePath, other: NodePath, quat: LQuaternion, scale: LVecBase3) {.importcpp: "#.set_quat_scale(#, #, #)".} ## \
## Sets the rotation and scale components of the transform, leaving
## translation untouched.  This, or set_pos_quat_scale, is the preferred way
## to update a transform when both quat and scale are to be changed.

proc set_pos_hpr_scale*(this: NodePath, pos: LVecBase3, hpr: LVecBase3, scale: LVecBase3) {.importcpp: "#.set_pos_hpr_scale(#, #, #)".} ## \
## Replaces the translation, rotation, and scale components, implicitly
## setting shear to 0.

proc set_pos_hpr_scale*(this: NodePath, other: NodePath, pos: LVecBase3, hpr: LVecBase3, scale: LVecBase3) {.importcpp: "#.set_pos_hpr_scale(#, #, #, #)".} ## \
## Completely replaces the transform with new translation, rotation, and scale
## components, relative to the other node, implicitly setting shear to 0.

proc set_pos_hpr_scale*(this: NodePath, other: NodePath, x: float32, y: float32, z: float32, h: float32, p: float32, r: float32, sx: float32, sy: float32, sz: float32) {.importcpp: "#.set_pos_hpr_scale(#, #, #, #, #, #, #, #, #, #)".} ## \
## Completely replaces the transform with new translation, rotation, and scale
## components, relative to the other node.

proc set_pos_hpr_scale*(this: NodePath, x: float32, y: float32, z: float32, h: float32, p: float32, r: float32, sx: float32, sy: float32, sz: float32) {.importcpp: "#.set_pos_hpr_scale(#, #, #, #, #, #, #, #, #)".} ## \
## Completely replaces the transform with new translation, rotation, and scale
## components.

proc set_pos_quat_scale*(this: NodePath, pos: LVecBase3, quat: LQuaternion, scale: LVecBase3) {.importcpp: "#.set_pos_quat_scale(#, #, #)".} ## \
## Replaces the translation, rotation, and scale components, implicitly
## setting shear to 0.

proc set_pos_quat_scale*(this: NodePath, other: NodePath, pos: LVecBase3, quat: LQuaternion, scale: LVecBase3) {.importcpp: "#.set_pos_quat_scale(#, #, #, #)".} ## \
## Completely replaces the transform with new translation, rotation, and scale
## components, relative to the other node, implicitly setting shear to 0.

proc set_pos_hpr_scale_shear*(this: NodePath, pos: LVecBase3, hpr: LVecBase3, scale: LVecBase3, shear: LVecBase3) {.importcpp: "#.set_pos_hpr_scale_shear(#, #, #, #)".} ## \
## Completely replaces the transform with new translation, rotation, scale,
## and shear components.

proc set_pos_hpr_scale_shear*(this: NodePath, other: NodePath, pos: LVecBase3, hpr: LVecBase3, scale: LVecBase3, shear: LVecBase3) {.importcpp: "#.set_pos_hpr_scale_shear(#, #, #, #, #)".} ## \
## Completely replaces the transform with new translation, rotation, scale,
## and shear components, relative to the other node.

proc set_pos_quat_scale_shear*(this: NodePath, pos: LVecBase3, quat: LQuaternion, scale: LVecBase3, shear: LVecBase3) {.importcpp: "#.set_pos_quat_scale_shear(#, #, #, #)".} ## \
## Completely replaces the transform with new translation, rotation, scale,
## and shear components.

proc set_pos_quat_scale_shear*(this: NodePath, other: NodePath, pos: LVecBase3, quat: LQuaternion, scale: LVecBase3, shear: LVecBase3) {.importcpp: "#.set_pos_quat_scale_shear(#, #, #, #, #)".} ## \
## Completely replaces the transform with new translation, rotation, scale,
## and shear components, relative to the other node.

proc set_mat*(this: NodePath, mat: LMatrix4) {.importcpp: "#.set_mat(#)".} ## \
## Directly sets an arbitrary 4x4 transform matrix.

proc set_mat*(this: NodePath, other: NodePath, mat: LMatrix4) {.importcpp: "#.set_mat(#, #)".} ## \
## Converts the indicated matrix from the other's coordinate space to the
## local coordinate space, and applies it to the node.

proc clear_mat*(this: NodePath) {.importcpp: "#.clear_mat()".} ## \
## Completely removes any transform from the referenced node.

proc has_mat*(this: NodePath): bool {.importcpp: "#.has_mat()".} ## \
## Returns true if a non-identity transform matrix has been applied to the
## referenced node, false otherwise.

proc get_mat*(this: NodePath): LMatrix4 {.importcpp: "#.get_mat()".} ## \
## Returns the transform matrix that has been applied to the referenced node,
## or the identity matrix if no matrix has been applied.

proc get_mat*(this: NodePath, other: NodePath): LMatrix4 {.importcpp: "#.get_mat(#)".} ## \
## Returns the matrix that describes the coordinate space of the bottom node,
## relative to the other path's bottom node's coordinate space.

proc look_at*(this: NodePath, point: LPoint3, up: LVector3) {.importcpp: "#.look_at(#, #)".} ## \
## Sets the hpr on this NodePath so that it rotates to face the indicated
## point in space.

proc look_at*(this: NodePath, point: LPoint3) {.importcpp: "#.look_at(#)".} ## \
## Sets the hpr on this NodePath so that it rotates to face the indicated
## point in space.

proc look_at*(this: NodePath, other: NodePath, point: LPoint3, up: LVector3) {.importcpp: "#.look_at(#, #, #)".} ## \
## Sets the transform on this NodePath so that it rotates to face the
## indicated point in space, which is relative to the other NodePath.

proc look_at*(this: NodePath, other: NodePath, point: LPoint3) {.importcpp: "#.look_at(#, #)".} ## \
## Sets the transform on this NodePath so that it rotates to face the
## indicated point in space, which is relative to the other NodePath.

proc look_at*(this: NodePath, other: NodePath) {.importcpp: "#.look_at(#)".} ## \
## Sets the transform on this NodePath so that it rotates to face the
## indicated point in space, which is relative to the other NodePath.

proc look_at*(this: NodePath, other: NodePath, x: float32, y: float32, z: float32) {.importcpp: "#.look_at(#, #, #, #)".} ## \
## Sets the hpr on this NodePath so that it rotates to face the indicated
## point in space, which is relative to the other NodePath.

proc look_at*(this: NodePath, x: float32, y: float32, z: float32) {.importcpp: "#.look_at(#, #, #)".} ## \
## Sets the transform on this NodePath so that it rotates to face the
## indicated point in space.  This will overwrite any previously existing
## scale on the node, although it will preserve any translation.

proc heads_up*(this: NodePath, point: LPoint3, up: LVector3) {.importcpp: "#.heads_up(#, #)".} ## \
## Behaves like look_at(), but with a strong preference to keeping the up
## vector oriented in the indicated "up" direction.

proc heads_up*(this: NodePath, point: LPoint3) {.importcpp: "#.heads_up(#)".} ## \
## Behaves like look_at(), but with a strong preference to keeping the up
## vector oriented in the indicated "up" direction.

proc heads_up*(this: NodePath, other: NodePath, point: LPoint3, up: LVector3) {.importcpp: "#.heads_up(#, #, #)".} ## \
## Behaves like look_at(), but with a strong preference to keeping the up
## vector oriented in the indicated "up" direction.

proc heads_up*(this: NodePath, other: NodePath, point: LPoint3) {.importcpp: "#.heads_up(#, #)".} ## \
## Behaves like look_at(), but with a strong preference to keeping the up
## vector oriented in the indicated "up" direction.

proc heads_up*(this: NodePath, other: NodePath) {.importcpp: "#.heads_up(#)".} ## \
## Behaves like look_at(), but with a strong preference to keeping the up
## vector oriented in the indicated "up" direction.

proc heads_up*(this: NodePath, other: NodePath, x: float32, y: float32, z: float32) {.importcpp: "#.heads_up(#, #, #, #)".} ## \
## Behaves like look_at(), but with a strong preference to keeping the up
## vector oriented in the indicated "up" direction.

proc heads_up*(this: NodePath, x: float32, y: float32, z: float32) {.importcpp: "#.heads_up(#, #, #)".} ## \
## Behaves like look_at(), but with a strong preference to keeping the up
## vector oriented in the indicated "up" direction.

proc get_relative_point*(this: NodePath, other: NodePath, point: LVecBase3): LPoint3 {.importcpp: "#.get_relative_point(#, #)".} ## \
## Given that the indicated point is in the coordinate system of the other
## node, returns the same point in this node's coordinate system.

proc get_relative_vector*(this: NodePath, other: NodePath, vec: LVecBase3): LVector3 {.importcpp: "#.get_relative_vector(#, #)".} ## \
## Given that the indicated vector is in the coordinate system of the other
## node, returns the same vector in this node's coordinate system.

proc get_distance*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_distance(#)".} ## \
## Returns the straight-line distance between this referenced node's
## coordinate frame's origin, and that of the other node's origin.

proc set_color*(this: NodePath, color: LColor, priority: int) {.importcpp: "#.set_color(#, #)".} ## \
## Applies a scene-graph color to the referenced node.  This color will apply
## to all geometry at this level and below (that does not specify a new color
## or a set_color_off()).

proc set_color*(this: NodePath, color: LColor) {.importcpp: "#.set_color(#)".} ## \
## Applies a scene-graph color to the referenced node.  This color will apply
## to all geometry at this level and below (that does not specify a new color
## or a set_color_off()).

proc set_color*(this: NodePath, r: float32, g: float32, b: float32, a: float32, priority: int) {.importcpp: "#.set_color(#, #, #, #, #)".} ## \
## Applies a scene-graph color to the referenced node.  This color will apply
## to all geometry at this level and below (that does not specify a new color
## or a set_color_off()).

proc set_color*(this: NodePath, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_color(#, #, #, #)".} ## \
## Applies a scene-graph color to the referenced node.  This color will apply
## to all geometry at this level and below (that does not specify a new color
## or a set_color_off()).

proc set_color*(this: NodePath, r: float32, g: float32, b: float32) {.importcpp: "#.set_color(#, #, #)".} ## \
## Applies a scene-graph color to the referenced node.  This color will apply
## to all geometry at this level and below (that does not specify a new color
## or a set_color_off()).

proc set_color_off*(this: NodePath, priority: int) {.importcpp: "#.set_color_off(#)".} ## \
## Sets the geometry at this level and below to render using the geometry
## color.  This is normally the default, but it may be useful to use this to
## contradict set_color() at a higher node level (or, with a priority, to
## override a set_color() at a lower level).

proc set_color_off*(this: NodePath) {.importcpp: "#.set_color_off()".} ## \
## Sets the geometry at this level and below to render using the geometry
## color.  This is normally the default, but it may be useful to use this to
## contradict set_color() at a higher node level (or, with a priority, to
## override a set_color() at a lower level).

proc clear_color*(this: NodePath) {.importcpp: "#.clear_color()".} ## \
## Completely removes any color adjustment from the node.  This allows the
## natural color of the geometry, or whatever color transitions might be
## otherwise affecting the geometry, to show instead.

proc has_color*(this: NodePath): bool {.importcpp: "#.has_color()".} ## \
## Returns true if a color has been applied to the given node, false
## otherwise.

proc get_color*(this: NodePath): LColor {.importcpp: "#.get_color()".} ## \
## Returns the color that has been assigned to the node, or black if no color
## has been assigned.

proc has_color_scale*(this: NodePath): bool {.importcpp: "#.has_color_scale()".} ## \
## Returns true if a color scale has been applied to the referenced node,
## false otherwise.  It is still possible that color at this node might have
## been scaled by an ancestor node.

proc clear_color_scale*(this: NodePath) {.importcpp: "#.clear_color_scale()".} ## \
## Completely removes any color scale from the referenced node.  This is
## preferable to simply setting the color scale to identity, as it also
## removes the overhead associated with having a color scale at all.

proc set_color_scale*(this: NodePath, scale: LVecBase4, priority: int) {.importcpp: "#.set_color_scale(#, #)".} ## \
## Sets the color scale component of the transform, leaving translation and
## rotation untouched.

proc set_color_scale*(this: NodePath, scale: LVecBase4) {.importcpp: "#.set_color_scale(#)".} ## \
## Sets the color scale component of the transform, leaving translation and
## rotation untouched.

proc set_color_scale*(this: NodePath, sx: float32, sy: float32, sz: float32, sa: float32, priority: int) {.importcpp: "#.set_color_scale(#, #, #, #, #)".} ## \
## Sets the color scale component of the transform

proc set_color_scale*(this: NodePath, sx: float32, sy: float32, sz: float32, sa: float32) {.importcpp: "#.set_color_scale(#, #, #, #)".} ## \
## Sets the color scale component of the transform

proc compose_color_scale*(this: NodePath, scale: LVecBase4, priority: int) {.importcpp: "#.compose_color_scale(#, #)".} ## \
## multiplies the color scale component of the transform, with previous color
## scale leaving translation and rotation untouched.

proc compose_color_scale*(this: NodePath, scale: LVecBase4) {.importcpp: "#.compose_color_scale(#)".} ## \
## multiplies the color scale component of the transform, with previous color
## scale leaving translation and rotation untouched.

proc compose_color_scale*(this: NodePath, sx: float32, sy: float32, sz: float32, sa: float32, priority: int) {.importcpp: "#.compose_color_scale(#, #, #, #, #)".} ## \
## Sets the color scale component of the transform

proc compose_color_scale*(this: NodePath, sx: float32, sy: float32, sz: float32, sa: float32) {.importcpp: "#.compose_color_scale(#, #, #, #)".} ## \
## Sets the color scale component of the transform

proc set_color_scale_off*(this: NodePath, priority: int) {.importcpp: "#.set_color_scale_off(#)".} ## \
## Disables any color scale attribute inherited from above.  This is not the
## same thing as clear_color_scale(), which undoes any previous
## set_color_scale() operation on this node; rather, this actively disables
## any set_color_scale() that might be inherited from a parent node.  This
## also disables set_alpha_scale() at the same time.
##
## It is legal to specify a new color scale on the same node with a subsequent
## call to set_color_scale() or set_alpha_scale(); this new scale will apply
## to lower geometry.

proc set_color_scale_off*(this: NodePath) {.importcpp: "#.set_color_scale_off()".} ## \
## Disables any color scale attribute inherited from above.  This is not the
## same thing as clear_color_scale(), which undoes any previous
## set_color_scale() operation on this node; rather, this actively disables
## any set_color_scale() that might be inherited from a parent node.  This
## also disables set_alpha_scale() at the same time.
##
## It is legal to specify a new color scale on the same node with a subsequent
## call to set_color_scale() or set_alpha_scale(); this new scale will apply
## to lower geometry.

proc set_alpha_scale*(this: NodePath, scale: float32, priority: int) {.importcpp: "#.set_alpha_scale(#, #)".} ## \
## Sets the alpha scale component of the transform without (much) affecting
## the color scale.  Note that any priority specified will also apply to the
## color scale.

proc set_alpha_scale*(this: NodePath, scale: float32) {.importcpp: "#.set_alpha_scale(#)".} ## \
## Sets the alpha scale component of the transform without (much) affecting
## the color scale.  Note that any priority specified will also apply to the
## color scale.

proc set_all_color_scale*(this: NodePath, scale: float32, priority: int) {.importcpp: "#.set_all_color_scale(#, #)".} ## \
## Scales all the color components of the object by the same amount, darkening
## the object, without (much) affecting alpha.  Note that any priority
## specified will also apply to the alpha scale.

proc set_all_color_scale*(this: NodePath, scale: float32) {.importcpp: "#.set_all_color_scale(#)".} ## \
## Scales all the color components of the object by the same amount, darkening
## the object, without (much) affecting alpha.  Note that any priority
## specified will also apply to the alpha scale.

proc set_sr*(this: NodePath, sr: float32) {.importcpp: "#.set_sr(#)".} ## \
## Sets the red component of the color scale.
## @see set_color_scale()

proc set_sg*(this: NodePath, sg: float32) {.importcpp: "#.set_sg(#)".} ## \
## Sets the green component of the color scale.
## @see set_color_scale()

proc set_sb*(this: NodePath, sb: float32) {.importcpp: "#.set_sb(#)".} ## \
## Sets the blue component of the color scale.
## @see set_color_scale()

proc set_sa*(this: NodePath, sa: float32) {.importcpp: "#.set_sa(#)".} ## \
## Sets the alpha component of the color scale.
## @see set_color_scale()

proc get_color_scale*(this: NodePath): LVecBase4 {.importcpp: "#.get_color_scale()".} ## \
## Returns the complete color scale vector that has been applied to this node
## via a previous call to set_color_scale() and/or set_alpha_scale(), or all
## 1's (identity) if no scale has been applied to this particular node.

proc get_sr*(this: NodePath): float32 {.importcpp: "#.get_sr()".} ## \
## Gets the red component of the color scale.
## @see get_color_scale()

proc get_sg*(this: NodePath): float32 {.importcpp: "#.get_sg()".} ## \
## Gets the green component of the color scale.
## @see get_color_scale()

proc get_sb*(this: NodePath): float32 {.importcpp: "#.get_sb()".} ## \
## Gets the blue component of the color scale.
## @see get_color_scale()

proc get_sa*(this: NodePath): float32 {.importcpp: "#.get_sa()".} ## \
## Gets the alpha component of the color scale.
## @see get_color_scale()

proc set_light*(this: NodePath, light: NodePath, priority: int) {.importcpp: "#.set_light(#, #)".} ## \
## Adds the indicated Light or PolylightNode to the list of lights that
## illuminate geometry at this node and below.  The light itself should be
## parented into the scene graph elsewhere, to represent the light's position
## in space; but until set_light() is called it will illuminate no geometry.

proc set_light*(this: NodePath, light: NodePath) {.importcpp: "#.set_light(#)".} ## \
## Adds the indicated Light or PolylightNode to the list of lights that
## illuminate geometry at this node and below.  The light itself should be
## parented into the scene graph elsewhere, to represent the light's position
## in space; but until set_light() is called it will illuminate no geometry.

proc set_light_off*(this: NodePath, light: NodePath, priority: int) {.importcpp: "#.set_light_off(#, #)".} ## \
## Sets the geometry at this level and below to render without using the
## indicated Light.  This is different from not specifying the Light; rather,
## this specifically contradicts set_light() at a higher node level (or, with
## a priority, overrides a set_light() at a lower level).
##
## This interface does not support PolylightNodes, which cannot be turned off
## at a lower level.

proc set_light_off*(this: NodePath, light: NodePath) {.importcpp: "#.set_light_off(#)".} ## \
## Sets the geometry at this level and below to render without using the
## indicated Light.  This is different from not specifying the Light; rather,
## this specifically contradicts set_light() at a higher node level (or, with
## a priority, overrides a set_light() at a lower level).
##
## This interface does not support PolylightNodes, which cannot be turned off
## at a lower level.

proc set_light_off*(this: NodePath, priority: int) {.importcpp: "#.set_light_off(#)".} ## \
## Sets the geometry at this level and below to render using no lights at all.
## This is different from not specifying a light; rather, this specifically
## contradicts set_light() at a higher node level (or, with a priority,
## overrides a set_light() at a lower level).
##
## If no lights are in effect on a particular piece of geometry, that geometry
## is rendered with lighting disabled.

proc set_light_off*(this: NodePath) {.importcpp: "#.set_light_off()".} ## \
## Sets the geometry at this level and below to render using no lights at all.
## This is different from not specifying a light; rather, this specifically
## contradicts set_light() at a higher node level (or, with a priority,
## overrides a set_light() at a lower level).
##
## If no lights are in effect on a particular piece of geometry, that geometry
## is rendered with lighting disabled.

proc clear_light*(this: NodePath) {.importcpp: "#.clear_light()".} ## \
## Completely removes any lighting operations that may have been set via
## set_light() or set_light_off() from this particular node.

proc clear_light*(this: NodePath, light: NodePath) {.importcpp: "#.clear_light(#)".} ## \
## Removes any reference to the indicated Light or PolylightNode from the
## NodePath.

proc has_light*(this: NodePath, light: NodePath): bool {.importcpp: "#.has_light(#)".} ## \
## Returns true if the indicated Light or PolylightNode has been specifically
## enabled on this particular node.  This means that someone called
## set_light() on this node with the indicated light.

proc has_light_off*(this: NodePath): bool {.importcpp: "#.has_light_off()".} ## \
## Returns true if all Lights have been specifically disabled on this
## particular node.  This means that someone called set_light_off() on this
## node with no parameters.

proc has_light_off*(this: NodePath, light: NodePath): bool {.importcpp: "#.has_light_off(#)".} ## \
## Returns true if the indicated Light has been specifically disabled on this
## particular node.  This means that someone called set_light_off() on this
## node with the indicated light.
##
## This interface does not support PolylightNodes, which cannot be turned off
## at a lower level.

proc set_clip_plane*(this: NodePath, clip_plane: NodePath, priority: int) {.importcpp: "#.set_clip_plane(#, #)".} ## \
## Adds the indicated clipping plane to the list of planes that apply to
## geometry at this node and below.  The clipping plane itself, a PlaneNode,
## should be parented into the scene graph elsewhere, to represent the plane's
## position in space; but until set_clip_plane() is called it will clip no
## geometry.

proc set_clip_plane*(this: NodePath, clip_plane: NodePath) {.importcpp: "#.set_clip_plane(#)".} ## \
## Adds the indicated clipping plane to the list of planes that apply to
## geometry at this node and below.  The clipping plane itself, a PlaneNode,
## should be parented into the scene graph elsewhere, to represent the plane's
## position in space; but until set_clip_plane() is called it will clip no
## geometry.

proc set_clip_plane_off*(this: NodePath, clip_plane: NodePath, priority: int) {.importcpp: "#.set_clip_plane_off(#, #)".} ## \
## Sets the geometry at this level and below to render without being clipped
## by the indicated PlaneNode.  This is different from not specifying the
## PlaneNode; rather, this specifically contradicts set_clip_plane() at a
## higher node level (or, with a priority, overrides a set_clip_plane() at a
## lower level).

proc set_clip_plane_off*(this: NodePath, clip_plane: NodePath) {.importcpp: "#.set_clip_plane_off(#)".} ## \
## Sets the geometry at this level and below to render without being clipped
## by the indicated PlaneNode.  This is different from not specifying the
## PlaneNode; rather, this specifically contradicts set_clip_plane() at a
## higher node level (or, with a priority, overrides a set_clip_plane() at a
## lower level).

proc set_clip_plane_off*(this: NodePath, priority: int) {.importcpp: "#.set_clip_plane_off(#)".} ## \
## Sets the geometry at this level and below to render using no clip_planes at
## all.  This is different from not specifying a clip_plane; rather, this
## specifically contradicts set_clip_plane() at a higher node level (or, with
## a priority, overrides a set_clip_plane() at a lower level).
##
## If no clip_planes are in effect on a particular piece of geometry, that
## geometry is rendered without being clipped (other than by the viewing
## frustum).

proc set_clip_plane_off*(this: NodePath) {.importcpp: "#.set_clip_plane_off()".} ## \
## Sets the geometry at this level and below to render using no clip_planes at
## all.  This is different from not specifying a clip_plane; rather, this
## specifically contradicts set_clip_plane() at a higher node level (or, with
## a priority, overrides a set_clip_plane() at a lower level).
##
## If no clip_planes are in effect on a particular piece of geometry, that
## geometry is rendered without being clipped (other than by the viewing
## frustum).

proc clear_clip_plane*(this: NodePath) {.importcpp: "#.clear_clip_plane()".} ## \
## Completely removes any clip planes that may have been set via
## set_clip_plane() or set_clip_plane_off() from this particular node.

proc clear_clip_plane*(this: NodePath, clip_plane: NodePath) {.importcpp: "#.clear_clip_plane(#)".} ## \
## Removes any reference to the indicated clipping plane from the NodePath.

proc has_clip_plane*(this: NodePath, clip_plane: NodePath): bool {.importcpp: "#.has_clip_plane(#)".} ## \
## Returns true if the indicated clipping plane has been specifically applied
## to this particular node.  This means that someone called set_clip_plane()
## on this node with the indicated clip_plane.

proc has_clip_plane_off*(this: NodePath): bool {.importcpp: "#.has_clip_plane_off()".} ## \
## Returns true if all clipping planes have been specifically disabled on this
## particular node.  This means that someone called set_clip_plane_off() on
## this node with no parameters.

proc has_clip_plane_off*(this: NodePath, clip_plane: NodePath): bool {.importcpp: "#.has_clip_plane_off(#)".} ## \
## Returns true if the indicated clipping plane has been specifically disabled
## on this particular node.  This means that someone called
## set_clip_plane_off() on this node with the indicated clip_plane.

proc set_scissor*(this: NodePath, a: LPoint3, b: LPoint3) {.importcpp: "#.set_scissor(#, #)".} ## \
## Sets up a scissor region on the nodes rendered at this level and below.
## The two points are understood to be relative to this node.  When these
## points are projected into screen space, they define the diagonally-opposite
## points that determine the scissor region.

proc set_scissor*(this: NodePath, a: LPoint3, b: LPoint3, c: LPoint3, d: LPoint3) {.importcpp: "#.set_scissor(#, #, #, #)".} ## \
## Sets up a scissor region on the nodes rendered at this level and below.
## The four points are understood to be relative to this node.  When these
## points are projected into screen space, they define the bounding volume of
## the scissor region (the scissor region is the smallest onscreen rectangle
## that encloses all four points).

proc set_scissor*(this: NodePath, other: NodePath, a: LPoint3, b: LPoint3) {.importcpp: "#.set_scissor(#, #, #)".} ## \
## Sets up a scissor region on the nodes rendered at this level and below.
## The two points are understood to be relative to the indicated other node.
## When these points are projected into screen space, they define the
## diagonally-opposite points that determine the scissor region.

proc set_scissor*(this: NodePath, other: NodePath, a: LPoint3, b: LPoint3, c: LPoint3, d: LPoint3) {.importcpp: "#.set_scissor(#, #, #, #, #)".} ## \
## Sets up a scissor region on the nodes rendered at this level and below.
## The four points are understood to be relative to the indicated other node.
## When these points are projected into screen space, they define the bounding
## volume of the scissor region (the scissor region is the smallest onscreen
## rectangle that encloses all four points).

proc set_scissor*(this: NodePath, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#.set_scissor(#, #, #, #)".} ## \
## Sets up a scissor region on the nodes rendered at this level and below.
## The four coordinates are understood to define a rectangle in screen space.
## These numbers are relative to the current DisplayRegion, where (0,0) is the
## lower-left corner of the DisplayRegion, and (1,1) is the upper-right
## corner.

proc clear_scissor*(this: NodePath) {.importcpp: "#.clear_scissor()".} ## \
## Removes the scissor region that was defined at this node level by a
## previous call to set_scissor().

proc has_scissor*(this: NodePath): bool {.importcpp: "#.has_scissor()".} ## \
## Returns true if a scissor region was defined at this node by a previous
## call to set_scissor().  This does not check for scissor regions inherited
## from a parent class.  It also does not check for the presence of a low-
## level ScissorAttrib, which is different from the ScissorEffect added by
## set_scissor.

proc set_occluder*(this: NodePath, occluder: NodePath) {.importcpp: "#.set_occluder(#)".} ## \
## Adds the indicated occluder to the list of occluders that apply to geometry
## at this node and below.  The occluder itself, an OccluderNode, should be
## parented into the scene graph elsewhere, to represent the occluder's
## position in space; but until set_occluder() is called it will clip no
## geometry.

proc clear_occluder*(this: NodePath) {.importcpp: "#.clear_occluder()".} ## \
## Completely removes any occluders that may have been set via set_occluder()
## from this particular node.

proc clear_occluder*(this: NodePath, occluder: NodePath) {.importcpp: "#.clear_occluder(#)".} ## \
## Removes any reference to the indicated occluder from the NodePath.

proc has_occluder*(this: NodePath, occluder: NodePath): bool {.importcpp: "#.has_occluder(#)".} ## \
## Returns true if the indicated occluder has been specifically applied to
## this particular node.  This means that someone called set_occluder() on
## this node with the indicated occluder.

proc set_bin*(this: NodePath, bin_name: string, draw_order: int, priority: int) {.importcpp: "#.set_bin(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Assigns the geometry at this level and below to the named rendering bin.
## It is the user's responsibility to ensure that such a bin already exists,
## either via the cull-bin Configrc variable, or by explicitly creating a
## GeomBin of the appropriate type at runtime.
##
## There are two default bins created when Panda is started: "default" and
## "fixed".  Normally, all geometry is assigned to "default" unless specified
## otherwise.  This bin renders opaque geometry in state-sorted order,
## followed by transparent geometry sorted back-to-front.  If any geometry is
## assigned to "fixed", this will be rendered following all the geometry in
## "default", in the order specified by draw_order for each piece of geometry
## so assigned.
##
## The draw_order parameter is meaningful only for GeomBinFixed type bins,
## e.g.  "fixed".  Other kinds of bins ignore it.

proc set_bin*(this: NodePath, bin_name: string, draw_order: int) {.importcpp: "#.set_bin(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Assigns the geometry at this level and below to the named rendering bin.
## It is the user's responsibility to ensure that such a bin already exists,
## either via the cull-bin Configrc variable, or by explicitly creating a
## GeomBin of the appropriate type at runtime.
##
## There are two default bins created when Panda is started: "default" and
## "fixed".  Normally, all geometry is assigned to "default" unless specified
## otherwise.  This bin renders opaque geometry in state-sorted order,
## followed by transparent geometry sorted back-to-front.  If any geometry is
## assigned to "fixed", this will be rendered following all the geometry in
## "default", in the order specified by draw_order for each piece of geometry
## so assigned.
##
## The draw_order parameter is meaningful only for GeomBinFixed type bins,
## e.g.  "fixed".  Other kinds of bins ignore it.

proc clear_bin*(this: NodePath) {.importcpp: "#.clear_bin()".} ## \
## Completely removes any bin adjustment that may have been set via set_bin()
## from this particular node.

proc has_bin*(this: NodePath): bool {.importcpp: "#.has_bin()".} ## \
## Returns true if the node has been assigned to the a particular rendering
## bin via set_bin(), false otherwise.

proc get_bin_name*(this: NodePath): string {.importcpp: "nimStringFromStdString(#.get_bin_name())", header: stringConversionCode.} ## \
## Returns the name of the bin that this particular node was assigned to via
## set_bin(), or the empty string if no bin was assigned.  See set_bin() and
## has_bin().

proc get_bin_draw_order*(this: NodePath): int {.importcpp: "#.get_bin_draw_order()".} ## \
## Returns the drawing order associated with the bin that this particular node
## was assigned to via set_bin(), or 0 if no bin was assigned.  See set_bin()
## and has_bin().

proc set_texture*(this: NodePath, tex: Texture, sampler: SamplerState, priority: int) {.importcpp: "#.set_texture(#, #, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the default texture stage.
##
## The given sampler state will override the sampling settings on the texture
## itself.  Note that this method makes a copy of the sampler settings that
## you give; further changes to this object will not be reflected.
##
## This is the convenience single-texture variant of this method; it is now
## superceded by set_texture() that accepts a stage and texture.  You may use
## this method if you just want to adjust the default stage.

proc set_texture*(this: NodePath, tex: Texture, sampler: SamplerState) {.importcpp: "#.set_texture(#, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the default texture stage.
##
## The given sampler state will override the sampling settings on the texture
## itself.  Note that this method makes a copy of the sampler settings that
## you give; further changes to this object will not be reflected.
##
## This is the convenience single-texture variant of this method; it is now
## superceded by set_texture() that accepts a stage and texture.  You may use
## this method if you just want to adjust the default stage.

proc set_texture*(this: NodePath, tex: Texture, priority: int) {.importcpp: "#.set_texture(#, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the default texture stage.
##
## This is the convenience single-texture variant of this method; it is now
## superceded by set_texture() that accepts a stage and texture.  You may use
## this method if you just want to adjust the default stage.

proc set_texture*(this: NodePath, tex: Texture) {.importcpp: "#.set_texture(#)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the default texture stage.
##
## This is the convenience single-texture variant of this method; it is now
## superceded by set_texture() that accepts a stage and texture.  You may use
## this method if you just want to adjust the default stage.

proc set_texture*(this: NodePath, stage: TextureStage, tex: Texture, sampler: SamplerState, priority: int) {.importcpp: "#.set_texture(#, #, #, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the indicated multitexture stage.  If there are multiple texture stages
## specified (possibly on multiple different nodes at different levels), they
## will all be applied to geometry together, according to the stage
## specification set up in the TextureStage object.
##
## The given sampler state will override the sampling settings on the texture
## itself.  Note that this method makes a copy of the sampler settings that
## you give; further changes to this object will not be reflected.

proc set_texture*(this: NodePath, stage: TextureStage, tex: Texture, sampler: SamplerState) {.importcpp: "#.set_texture(#, #, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the indicated multitexture stage.  If there are multiple texture stages
## specified (possibly on multiple different nodes at different levels), they
## will all be applied to geometry together, according to the stage
## specification set up in the TextureStage object.
##
## The given sampler state will override the sampling settings on the texture
## itself.  Note that this method makes a copy of the sampler settings that
## you give; further changes to this object will not be reflected.

proc set_texture*(this: NodePath, stage: TextureStage, tex: Texture, priority: int) {.importcpp: "#.set_texture(#, #, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the indicated multitexture stage.  If there are multiple texture stages
## specified (possibly on multiple different nodes at different levels), they
## will all be applied to geometry together, according to the stage
## specification set up in the TextureStage object.

proc set_texture*(this: NodePath, stage: TextureStage, tex: Texture) {.importcpp: "#.set_texture(#, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the indicated multitexture stage.  If there are multiple texture stages
## specified (possibly on multiple different nodes at different levels), they
## will all be applied to geometry together, according to the stage
## specification set up in the TextureStage object.

proc set_texture_off*(this: NodePath, stage: TextureStage, priority: int) {.importcpp: "#.set_texture_off(#, #)".} ## \
## Sets the geometry at this level and below to render using no texture, on
## the indicated stage.  This is different from not specifying a texture;
## rather, this specifically contradicts set_texture() at a higher node level
## (or, with a priority, overrides a set_texture() at a lower level).

proc set_texture_off*(this: NodePath, stage: TextureStage) {.importcpp: "#.set_texture_off(#)".} ## \
## Sets the geometry at this level and below to render using no texture, on
## the indicated stage.  This is different from not specifying a texture;
## rather, this specifically contradicts set_texture() at a higher node level
## (or, with a priority, overrides a set_texture() at a lower level).

proc set_texture_off*(this: NodePath, priority: int) {.importcpp: "#.set_texture_off(#)".} ## \
## Sets the geometry at this level and below to render using no texture, on
## any stage.  This is different from not specifying a texture; rather, this
## specifically contradicts set_texture() at a higher node level (or, with a
## priority, overrides a set_texture() at a lower level).

proc set_texture_off*(this: NodePath) {.importcpp: "#.set_texture_off()".} ## \
## Sets the geometry at this level and below to render using no texture, on
## any stage.  This is different from not specifying a texture; rather, this
## specifically contradicts set_texture() at a higher node level (or, with a
## priority, overrides a set_texture() at a lower level).

proc clear_texture*(this: NodePath) {.importcpp: "#.clear_texture()".} ## \
## Completely removes any texture adjustment that may have been set via
## set_texture() or set_texture_off() from this particular node.  This allows
## whatever textures might be otherwise affecting the geometry to show
## instead.

proc clear_texture*(this: NodePath, stage: TextureStage) {.importcpp: "#.clear_texture(#)".} ## \
## Removes any reference to the indicated texture stage from the NodePath.

proc has_texture*(this: NodePath): bool {.importcpp: "#.has_texture()".} ## \
## Returns true if a texture has been applied to this particular node via
## set_texture(), false otherwise.  This is not the same thing as asking
## whether the geometry at this node will be rendered with texturing, as there
## may be a texture in effect from a higher or lower level.

proc has_texture*(this: NodePath, stage: TextureStage): bool {.importcpp: "#.has_texture(#)".} ## \
## Returns true if texturing has been specifically enabled on this particular
## node for the indicated stage.  This means that someone called set_texture()
## on this node with the indicated stage name, or the stage_name is the
## default stage_name, and someone called set_texture() on this node.

proc has_texture_off*(this: NodePath): bool {.importcpp: "#.has_texture_off()".} ## \
## Returns true if texturing has been specifically disabled on this particular
## node via set_texture_off(), false otherwise.  This is not the same thing as
## asking whether the geometry at this node will be rendered untextured, as
## there may be a texture in effect from a higher or lower level.

proc has_texture_off*(this: NodePath, stage: TextureStage): bool {.importcpp: "#.has_texture_off(#)".} ## \
## Returns true if texturing has been specifically disabled on this particular
## node for the indicated stage.  This means that someone called
## set_texture_off() on this node with the indicated stage name, or that
## someone called set_texture_off() on this node to remove all stages.

proc get_texture*(this: NodePath): Texture {.importcpp: "#.get_texture()".} ## \
## Returns the base-level texture that has been set on this particular node,
## or NULL if no texture has been set.  This is not necessarily the texture
## that will be applied to the geometry at or below this level, as another
## texture at a higher or lower level may override.
##
## See also find_texture().

proc get_texture*(this: NodePath, stage: TextureStage): Texture {.importcpp: "#.get_texture(#)".} ## \
## Returns the texture that has been set on the indicated stage for this
## particular node, or NULL if no texture has been set for this stage.

proc replace_texture*(this: NodePath, tex: Texture, new_tex: Texture) {.importcpp: "#.replace_texture(#, #)".} ## \
## Recursively searches the scene graph for references to the given texture,
## and replaces them with the new texture.
##
## @since 1.10.4

proc get_texture_sampler*(this: NodePath): SamplerState {.importcpp: "#.get_texture_sampler()".} ## \
## Returns the sampler state that has been given for the base-level texture
## that has been set on this particular node.  If no sampler state was given,
## this returns the texture's default sampler settings.
##
## It is an error to call this if there is no base-level texture applied to
## this particular node.

proc get_texture_sampler*(this: NodePath, stage: TextureStage): SamplerState {.importcpp: "#.get_texture_sampler(#)".} ## \
## Returns the sampler state that has been given for the indicated texture
## stage that has been set on this particular node.  If no sampler state was
## given, this returns the texture's default sampler settings.
##
## It is an error to call this if there is no texture set for this stage on
## this particular node.

proc set_shader*(this: NodePath, sha: Shader, priority: int) {.importcpp: "#.set_shader(#, #)".}

proc set_shader*(this: NodePath, sha: Shader) {.importcpp: "#.set_shader(#)".}

proc set_shader_off*(this: NodePath, priority: int) {.importcpp: "#.set_shader_off(#)".}

proc set_shader_off*(this: NodePath) {.importcpp: "#.set_shader_off()".}

proc set_shader_auto*(this: NodePath, priority: int) {.importcpp: "#.set_shader_auto(#)".}

proc set_shader_auto*(this: NodePath) {.importcpp: "#.set_shader_auto()".}

proc clear_shader*(this: NodePath) {.importcpp: "#.clear_shader()".}

proc set_shader_input*(this: NodePath, id: InternalName, n1: float32, n2: float32, n3: float32, n4: float32, priority: int) {.importcpp: "#.set_shader_input(#, #, #, #, #, #)".}

proc set_shader_input*(this: NodePath, id: InternalName, n1: float32, n2: float32, n3: float32, n4: float32) {.importcpp: "#.set_shader_input(#, #, #, #, #)".}

proc set_shader_input*(this: NodePath, id: InternalName, n1: float32, n2: float32, n3: float32) {.importcpp: "#.set_shader_input(#, #, #, #)".}

proc set_shader_input*(this: NodePath, id: InternalName, n1: float32, n2: float32) {.importcpp: "#.set_shader_input(#, #, #)".}

proc set_shader_input*(this: NodePath, id: InternalName, tex: Texture, sampler: SamplerState, priority: int) {.importcpp: "#.set_shader_input(#, #, #, #)".}

proc set_shader_input*(this: NodePath, id: InternalName, tex: Texture, sampler: SamplerState) {.importcpp: "#.set_shader_input(#, #, #)".}

proc set_shader_input*(this: NodePath, id: InternalName, tex: Texture, read: bool, write: bool, z: int, n: int, priority: int) {.importcpp: "#.set_shader_input(#, #, #, #, #, #, #)".}

proc set_shader_input*(this: NodePath, id: InternalName, tex: Texture, read: bool, write: bool, z: int, n: int) {.importcpp: "#.set_shader_input(#, #, #, #, #, #)".}

proc set_shader_input*(this: NodePath, id: InternalName, tex: Texture, read: bool, write: bool, z: int) {.importcpp: "#.set_shader_input(#, #, #, #, #)".}

proc set_shader_input*(this: NodePath, id: InternalName, tex: Texture, read: bool, write: bool) {.importcpp: "#.set_shader_input(#, #, #, #)".}

proc set_shader_input*(this: NodePath, id: InternalName, n1: int, n2: int, n3: int, n4: int, priority: int) {.importcpp: "#.set_shader_input(#, #, #, #, #, #)".}

proc set_shader_input*(this: NodePath, id: InternalName, n1: int, n2: int, n3: int, n4: int) {.importcpp: "#.set_shader_input(#, #, #, #, #)".}

proc set_shader_input*(this: NodePath, id: InternalName, n1: int, n2: int, n3: int) {.importcpp: "#.set_shader_input(#, #, #, #)".}

proc set_shader_input*(this: NodePath, id: InternalName, n1: int, n2: int) {.importcpp: "#.set_shader_input(#, #, #)".}

proc set_shader_input*(this: NodePath, input: ShaderInput) {.importcpp: "#.set_shader_input(#)".}

proc clear_shader_input*(this: NodePath, id: InternalName) {.importcpp: "#.clear_shader_input(#)".}

proc set_instance_count*(this: NodePath, instance_count: int) {.importcpp: "#.set_instance_count(#)".} ## \
## Sets the geometry instance count, or 0 if geometry instancing should be
## disabled.  Do not confuse with instanceTo which only applies to animation
## instancing.

proc get_shader*(this: NodePath): Shader {.importcpp: "#.get_shader()".}

proc get_shader_input*(this: NodePath, id: InternalName): ShaderInput {.importcpp: "#.get_shader_input(#)".}

proc get_instance_count*(this: NodePath): int {.importcpp: "#.get_instance_count()".} ## \
## Returns the geometry instance count, or 0 if disabled.  See
## set_instance_count.

proc set_tex_transform*(this: NodePath, other: NodePath, stage: TextureStage, transform: TransformState) {.importcpp: "#.set_tex_transform(#, #, #)".} ## \
## Sets the texture matrix on the current node to the indicated transform for
## the given stage.

proc set_tex_transform*(this: NodePath, stage: TextureStage, transform: TransformState) {.importcpp: "#.set_tex_transform(#, #)".} ## \
## Sets the texture matrix on the current node to the indicated transform for
## the given stage.

proc clear_tex_transform*(this: NodePath) {.importcpp: "#.clear_tex_transform()".} ## \
## Removes all texture matrices from the current node.

proc clear_tex_transform*(this: NodePath, stage: TextureStage) {.importcpp: "#.clear_tex_transform(#)".} ## \
## Removes the texture matrix on the current node for the given stage.

proc has_tex_transform*(this: NodePath, stage: TextureStage): bool {.importcpp: "#.has_tex_transform(#)".} ## \
## Returns true if there is an explicit texture matrix on the current node for
## the given stage.

proc get_tex_transform*(this: NodePath, other: NodePath, stage: TextureStage): TransformState {.importcpp: "#.get_tex_transform(#, #)".} ## \
## Returns the texture matrix on the current node for the given stage,
## relative to the other node.

proc get_tex_transform*(this: NodePath, stage: TextureStage): TransformState {.importcpp: "#.get_tex_transform(#)".} ## \
## Returns the texture matrix on the current node for the given stage, or
## identity transform if there is no explicit transform set for the given
## stage.

proc set_tex_offset*(this: NodePath, other: NodePath, stage: TextureStage, uv: LVecBase2) {.importcpp: "#.set_tex_offset(#, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated offset to
## UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc set_tex_offset*(this: NodePath, other: NodePath, stage: TextureStage, u: float32, v: float32) {.importcpp: "#.set_tex_offset(#, #, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated offset to
## UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc set_tex_offset*(this: NodePath, stage: TextureStage, uv: LVecBase2) {.importcpp: "#.set_tex_offset(#, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated offset to
## UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc set_tex_offset*(this: NodePath, stage: TextureStage, u: float32, v: float32) {.importcpp: "#.set_tex_offset(#, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated offset to
## UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc set_tex_rotate*(this: NodePath, other: NodePath, stage: TextureStage, r: float32) {.importcpp: "#.set_tex_rotate(#, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated rotation,
## clockwise in degrees, to UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc set_tex_rotate*(this: NodePath, stage: TextureStage, r: float32) {.importcpp: "#.set_tex_rotate(#, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated rotation,
## clockwise in degrees, to UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc set_tex_scale*(this: NodePath, other: NodePath, stage: TextureStage, scale: LVecBase2) {.importcpp: "#.set_tex_scale(#, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc set_tex_scale*(this: NodePath, other: NodePath, stage: TextureStage, scale: LVecBase3) {.importcpp: "#.set_tex_scale(#, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc set_tex_scale*(this: NodePath, other: NodePath, stage: TextureStage, scale: float32) {.importcpp: "#.set_tex_scale(#, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UV's for the given stage.
##
## This call is appropriate for 2-d or 3-d texture coordinates.

proc set_tex_scale*(this: NodePath, other: NodePath, stage: TextureStage, su: float32, sv: float32) {.importcpp: "#.set_tex_scale(#, #, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc set_tex_scale*(this: NodePath, other: NodePath, stage: TextureStage, su: float32, sv: float32, sw: float32) {.importcpp: "#.set_tex_scale(#, #, #, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc set_tex_scale*(this: NodePath, stage: TextureStage, scale: LVecBase2) {.importcpp: "#.set_tex_scale(#, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc set_tex_scale*(this: NodePath, stage: TextureStage, scale: LVecBase3) {.importcpp: "#.set_tex_scale(#, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc set_tex_scale*(this: NodePath, stage: TextureStage, scale: float32) {.importcpp: "#.set_tex_scale(#, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UVW's for the given stage.
##
## This call is appropriate for 2-d or 3-d texture coordinates.

proc set_tex_scale*(this: NodePath, stage: TextureStage, su: float32, sv: float32) {.importcpp: "#.set_tex_scale(#, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc set_tex_scale*(this: NodePath, stage: TextureStage, su: float32, sv: float32, sw: float32) {.importcpp: "#.set_tex_scale(#, #, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc get_tex_offset*(this: NodePath, other: NodePath, stage: TextureStage): LVecBase2 {.importcpp: "#.get_tex_offset(#, #)".} ## \
## Returns the offset set for the UV's for the given stage on the current
## node.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc get_tex_offset*(this: NodePath, stage: TextureStage): LVecBase2 {.importcpp: "#.get_tex_offset(#)".} ## \
## Returns the offset set for the UV's for the given stage on the current
## node.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc get_tex_rotate*(this: NodePath, other: NodePath, stage: TextureStage): float32 {.importcpp: "#.get_tex_rotate(#, #)".} ## \
## Returns the rotation set for the UV's for the given stage on the current
## node.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc get_tex_rotate*(this: NodePath, stage: TextureStage): float32 {.importcpp: "#.get_tex_rotate(#)".} ## \
## Returns the rotation set for the UV's for the given stage on the current
## node.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc get_tex_scale*(this: NodePath, other: NodePath, stage: TextureStage): LVecBase2 {.importcpp: "#.get_tex_scale(#, #)".} ## \
## Returns the scale set for the UV's for the given stage on the current node.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc get_tex_scale*(this: NodePath, stage: TextureStage): LVecBase2 {.importcpp: "#.get_tex_scale(#)".} ## \
## Returns the scale set for the UV's for the given stage on the current node.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc set_tex_pos*(this: NodePath, other: NodePath, stage: TextureStage, uvw: LVecBase3) {.importcpp: "#.set_tex_pos(#, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated offset to
## UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc set_tex_pos*(this: NodePath, other: NodePath, stage: TextureStage, u: float32, v: float32, w: float32) {.importcpp: "#.set_tex_pos(#, #, #, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated offset to
## UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc set_tex_pos*(this: NodePath, stage: TextureStage, uvw: LVecBase3) {.importcpp: "#.set_tex_pos(#, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated offset to
## UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc set_tex_pos*(this: NodePath, stage: TextureStage, u: float32, v: float32, w: float32) {.importcpp: "#.set_tex_pos(#, #, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated offset to
## UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc set_tex_hpr*(this: NodePath, other: NodePath, stage: TextureStage, hpr: LVecBase3) {.importcpp: "#.set_tex_hpr(#, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated rotation,
## as a 3-D HPR, to UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc set_tex_hpr*(this: NodePath, other: NodePath, stage: TextureStage, h: float32, p: float32, r: float32) {.importcpp: "#.set_tex_hpr(#, #, #, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated rotation,
## as a 3-D HPR, to UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc set_tex_hpr*(this: NodePath, stage: TextureStage, hpr: LVecBase3) {.importcpp: "#.set_tex_hpr(#, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated rotation,
## as a 3-D HPR, to UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc set_tex_hpr*(this: NodePath, stage: TextureStage, h: float32, p: float32, r: float32) {.importcpp: "#.set_tex_hpr(#, #, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated rotation,
## as a 3-D HPR, to UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc get_tex_pos*(this: NodePath, other: NodePath, stage: TextureStage): LVecBase3 {.importcpp: "#.get_tex_pos(#, #)".} ## \
## Returns the offset set for the UVW's for the given stage on the current
## node.
##
## This call is appropriate for 3-d texture coordinates.

proc get_tex_pos*(this: NodePath, stage: TextureStage): LVecBase3 {.importcpp: "#.get_tex_pos(#)".} ## \
## Returns the offset set for the UVW's for the given stage on the current
## node.
##
## This call is appropriate for 3-d texture coordinates.

proc get_tex_hpr*(this: NodePath, other: NodePath, stage: TextureStage): LVecBase3 {.importcpp: "#.get_tex_hpr(#, #)".} ## \
## Returns the 3-D HPR set for the UVW's for the given stage on the current
## node.
##
## This call is appropriate for 3-d texture coordinates.

proc get_tex_hpr*(this: NodePath, stage: TextureStage): LVecBase3 {.importcpp: "#.get_tex_hpr(#)".} ## \
## Returns the 3-D HPR set for the UVW's for the given stage on the current
## node.
##
## This call is appropriate for 3-d texture coordinates.

proc get_tex_scale_3d*(this: NodePath, other: NodePath, stage: TextureStage): LVecBase3 {.importcpp: "#.get_tex_scale_3d(#, #)".} ## \
## Returns the scale set for the UVW's for the given stage on the current
## node.
##
## This call is appropriate for 3-d texture coordinates.

proc get_tex_scale_3d*(this: NodePath, stage: TextureStage): LVecBase3 {.importcpp: "#.get_tex_scale_3d(#)".} ## \
## Returns the scale set for the UVW's for the given stage on the current
## node.
##
## This call is appropriate for 3-d texture coordinates.

proc clear_tex_gen*(this: NodePath) {.importcpp: "#.clear_tex_gen()".} ## \
## Removes the texture coordinate generation mode from all texture stages on
## this node.

proc clear_tex_gen*(this: NodePath, stage: TextureStage) {.importcpp: "#.clear_tex_gen(#)".} ## \
## Disables automatic texture coordinate generation for the indicated texture
## stage.

proc has_tex_gen*(this: NodePath, stage: TextureStage): bool {.importcpp: "#.has_tex_gen(#)".} ## \
## Returns true if there is a mode for automatic texture coordinate generation
## on the current node for the given stage.

proc set_tex_projector*(this: NodePath, stage: TextureStage, `from`: NodePath, to: NodePath, lens_index: int) {.importcpp: "#.set_tex_projector(#, #, #, #)".} ## \
## Establishes a TexProjectorEffect on this node, which can be used to
## establish projective texturing (but see also the
## NodePath::project_texture() convenience function), or it can be used to
## bind this node's texture transform to particular node's position in space,
## allowing a LerpInterval (for instance) to adjust this node's texture
## coordinates.
##
## If to is a LensNode, then the fourth parameter, lens_index, can be provided
## to select a particular lens to apply.  Otherwise lens_index is not used.

proc set_tex_projector*(this: NodePath, stage: TextureStage, `from`: NodePath, to: NodePath) {.importcpp: "#.set_tex_projector(#, #, #)".} ## \
## Establishes a TexProjectorEffect on this node, which can be used to
## establish projective texturing (but see also the
## NodePath::project_texture() convenience function), or it can be used to
## bind this node's texture transform to particular node's position in space,
## allowing a LerpInterval (for instance) to adjust this node's texture
## coordinates.
##
## If to is a LensNode, then the fourth parameter, lens_index, can be provided
## to select a particular lens to apply.  Otherwise lens_index is not used.

proc clear_tex_projector*(this: NodePath) {.importcpp: "#.clear_tex_projector()".} ## \
## Removes the TexProjectorEffect for all stages from this node.

proc clear_tex_projector*(this: NodePath, stage: TextureStage) {.importcpp: "#.clear_tex_projector(#)".} ## \
## Removes the TexProjectorEffect for the indicated stage from this node.

proc has_tex_projector*(this: NodePath, stage: TextureStage): bool {.importcpp: "#.has_tex_projector(#)".} ## \
## Returns true if this node has a TexProjectorEffect for the indicated stage,
## false otherwise.

proc get_tex_projector_from*(this: NodePath, stage: TextureStage): NodePath {.importcpp: "#.get_tex_projector_from(#)".} ## \
## Returns the "from" node associated with the TexProjectorEffect on the
## indicated stage.  The relative transform between the "from" and the "to"
## nodes is automatically applied to the texture transform each frame.

proc get_tex_projector_to*(this: NodePath, stage: TextureStage): NodePath {.importcpp: "#.get_tex_projector_to(#)".} ## \
## Returns the "to" node associated with the TexProjectorEffect on the
## indicated stage.  The relative transform between the "from" and the "to"
## nodes is automatically applied to the texture transform each frame.

proc project_texture*(this: NodePath, stage: TextureStage, tex: Texture, projector: NodePath) {.importcpp: "#.project_texture(#, #, #)".} ## \
## A convenience function to enable projective texturing at this node level
## and below, using the indicated NodePath (which should contain a LensNode)
## as the projector.

proc clear_project_texture*(this: NodePath, stage: TextureStage) {.importcpp: "#.clear_project_texture(#)".} ## \
## Undoes the effect of project_texture().

proc has_texcoord*(this: NodePath, texcoord_name: string): bool {.importcpp: "#.has_texcoord(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if there are at least some vertices at this node and below
## that use the named texture coordinate set, false otherwise.  Pass the empty
## string for the default texture coordinate set.

proc has_vertex_column*(this: NodePath, name: InternalName): bool {.importcpp: "#.has_vertex_column(#)".} ## \
## Returns true if there are at least some vertices at this node and below
## that contain a reference to the indicated vertex data column name, false
## otherwise.
##
## This is particularly useful for testing whether a particular model has a
## given texture coordinate set (but see has_texcoord()).

proc find_all_vertex_columns*(this: NodePath): InternalNameCollection {.importcpp: "#.find_all_vertex_columns()".} ## \
## Returns a list of all vertex array columns stored on some geometry found at
## this node level and below.

proc find_all_vertex_columns*(this: NodePath, name: string): InternalNameCollection {.importcpp: "#.find_all_vertex_columns(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a list of all vertex array columns stored on some geometry found at
## this node level and below that match the indicated name (which may contain
## wildcard characters).

proc find_all_texcoords*(this: NodePath): InternalNameCollection {.importcpp: "#.find_all_texcoords()".} ## \
## Returns a list of all texture coordinate sets used by any geometry at this
## node level and below.

proc find_all_texcoords*(this: NodePath, name: string): InternalNameCollection {.importcpp: "#.find_all_texcoords(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a list of all texture coordinate sets used by any geometry at this
## node level and below that match the indicated name (which may contain
## wildcard characters).

proc find_texture*(this: NodePath, stage: TextureStage): Texture {.importcpp: "#.find_texture(#)".} ## \
## Returns the first texture found applied to geometry at this node or below
## that is assigned to the indicated texture stage.  Returns the texture if it
## is found, or NULL if it is not.

proc find_texture*(this: NodePath, name: string): Texture {.importcpp: "#.find_texture(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the first texture found applied to geometry at this node or below
## that matches the indicated name (which may contain wildcards).  Returns the
## texture if it is found, or NULL if it is not.

proc find_all_textures*(this: NodePath): TextureCollection {.importcpp: "#.find_all_textures()".} ## \
## Returns a list of a textures applied to geometry at this node and below.

proc find_all_textures*(this: NodePath, stage: TextureStage): TextureCollection {.importcpp: "#.find_all_textures(#)".} ## \
## Returns a list of a textures on geometry at this node and below that are
## assigned to the indicated texture stage.

proc find_all_textures*(this: NodePath, name: string): TextureCollection {.importcpp: "#.find_all_textures(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a list of a textures applied to geometry at this node and below
## that match the indicated name (which may contain wildcard characters).

proc find_texture_stage*(this: NodePath, name: string): TextureStage {.importcpp: "#.find_texture_stage(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the first TextureStage found applied to geometry at this node or
## below that matches the indicated name (which may contain wildcards).
## Returns the TextureStage if it is found, or NULL if it is not.

proc find_all_texture_stages*(this: NodePath): TextureStageCollection {.importcpp: "#.find_all_texture_stages()".} ## \
## Returns a list of a TextureStages applied to geometry at this node and
## below.

proc find_all_texture_stages*(this: NodePath, name: string): TextureStageCollection {.importcpp: "#.find_all_texture_stages(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a list of a TextureStages applied to geometry at this node and
## below that match the indicated name (which may contain wildcard
## characters).

proc unify_texture_stages*(this: NodePath, stage: TextureStage) {.importcpp: "#.unify_texture_stages(#)".} ## \
## Searches through all TextureStages at this node and below.  Any
## TextureStages that share the same name as the indicated TextureStage object
## are replaced with this object, thus ensuring that all geometry at this node
## and below with a particular TextureStage name is using the same
## TextureStage object.

proc find_material*(this: NodePath, name: string): Material {.importcpp: "#.find_material(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the first material found applied to geometry at this node or below
## that matches the indicated name (which may contain wildcards).  Returns the
## material if it is found, or NULL if it is not.

proc find_all_materials*(this: NodePath): MaterialCollection {.importcpp: "#.find_all_materials()".} ## \
## Returns a list of a materials applied to geometry at this node and below.

proc find_all_materials*(this: NodePath, name: string): MaterialCollection {.importcpp: "#.find_all_materials(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a list of a materials applied to geometry at this node and below
## that match the indicated name (which may contain wildcard characters).

proc set_material*(this: NodePath, tex: Material, priority: int) {.importcpp: "#.set_material(#, #)".} ## \
## Sets the geometry at this level and below to render using the indicated
## material.
##
## Previously, this operation made a copy of the material structure, but
## nowadays it assigns the pointer directly.

proc set_material*(this: NodePath, tex: Material) {.importcpp: "#.set_material(#)".} ## \
## Sets the geometry at this level and below to render using the indicated
## material.
##
## Previously, this operation made a copy of the material structure, but
## nowadays it assigns the pointer directly.

proc set_material_off*(this: NodePath, priority: int) {.importcpp: "#.set_material_off(#)".} ## \
## Sets the geometry at this level and below to render using no material.
## This is normally the default, but it may be useful to use this to
## contradict set_material() at a higher node level (or, with a priority, to
## override a set_material() at a lower level).

proc set_material_off*(this: NodePath) {.importcpp: "#.set_material_off()".} ## \
## Sets the geometry at this level and below to render using no material.
## This is normally the default, but it may be useful to use this to
## contradict set_material() at a higher node level (or, with a priority, to
## override a set_material() at a lower level).

proc clear_material*(this: NodePath) {.importcpp: "#.clear_material()".} ## \
## Completely removes any material adjustment that may have been set via
## set_material() from this particular node.

proc has_material*(this: NodePath): bool {.importcpp: "#.has_material()".} ## \
## Returns true if a material has been applied to this particular node via
## set_material(), false otherwise.

proc get_material*(this: NodePath): Material {.importcpp: "#.get_material()".} ## \
## Returns the material that has been set on this particular node, or NULL if
## no material has been set.  This is not necessarily the material that will
## be applied to the geometry at or below this level, as another material at a
## higher or lower level may override.
##
## See also find_material().

proc replace_material*(this: NodePath, mat: Material, new_mat: Material) {.importcpp: "#.replace_material(#, #)".} ## \
## Recursively searches the scene graph for references to the given material,
## and replaces them with the new material.
##
## @since 1.10.0

proc set_fog*(this: NodePath, fog: Fog, priority: int) {.importcpp: "#.set_fog(#, #)".} ## \
## Sets the geometry at this level and below to render using the indicated
## fog.

proc set_fog*(this: NodePath, fog: Fog) {.importcpp: "#.set_fog(#)".} ## \
## Sets the geometry at this level and below to render using the indicated
## fog.

proc set_fog_off*(this: NodePath, priority: int) {.importcpp: "#.set_fog_off(#)".} ## \
## Sets the geometry at this level and below to render using no fog.  This is
## normally the default, but it may be useful to use this to contradict
## set_fog() at a higher node level (or, with a priority, to override a
## set_fog() at a lower level).

proc set_fog_off*(this: NodePath) {.importcpp: "#.set_fog_off()".} ## \
## Sets the geometry at this level and below to render using no fog.  This is
## normally the default, but it may be useful to use this to contradict
## set_fog() at a higher node level (or, with a priority, to override a
## set_fog() at a lower level).

proc clear_fog*(this: NodePath) {.importcpp: "#.clear_fog()".} ## \
## Completely removes any fog adjustment that may have been set via set_fog()
## or set_fog_off() from this particular node.  This allows whatever fogs
## might be otherwise affecting the geometry to show instead.

proc has_fog*(this: NodePath): bool {.importcpp: "#.has_fog()".} ## \
## Returns true if a fog has been applied to this particular node via
## set_fog(), false otherwise.  This is not the same thing as asking whether
## the geometry at this node will be rendered with fog, as there may be a fog
## in effect from a higher or lower level.

proc has_fog_off*(this: NodePath): bool {.importcpp: "#.has_fog_off()".} ## \
## Returns true if a fog has been specifically disabled on this particular
## node via set_fog_off(), false otherwise.  This is not the same thing as
## asking whether the geometry at this node will be rendered unfogged, as
## there may be a fog in effect from a higher or lower level.

proc get_fog*(this: NodePath): Fog {.importcpp: "#.get_fog()".} ## \
## Returns the fog that has been set on this particular node, or NULL if no
## fog has been set.  This is not necessarily the fog that will be applied to
## the geometry at or below this level, as another fog at a higher or lower
## level may override.

proc set_render_mode_wireframe*(this: NodePath, priority: int) {.importcpp: "#.set_render_mode_wireframe(#)".} ## \
## Sets up the geometry at this level and below (unless overridden) to render
## in wireframe mode.

proc set_render_mode_wireframe*(this: NodePath) {.importcpp: "#.set_render_mode_wireframe()".} ## \
## Sets up the geometry at this level and below (unless overridden) to render
## in wireframe mode.

proc set_render_mode_filled*(this: NodePath, priority: int) {.importcpp: "#.set_render_mode_filled(#)".} ## \
## Sets up the geometry at this level and below (unless overridden) to render
## in filled (i.e.  not wireframe) mode.

proc set_render_mode_filled*(this: NodePath) {.importcpp: "#.set_render_mode_filled()".} ## \
## Sets up the geometry at this level and below (unless overridden) to render
## in filled (i.e.  not wireframe) mode.

proc set_render_mode_filled_wireframe*(this: NodePath, wireframe_color: LColor, priority: int) {.importcpp: "#.set_render_mode_filled_wireframe(#, #)".} ## \
## Sets up the geometry at this level and below (unless overridden) to render
## in filled, but overlay the wireframe on top with a fixed color.  This is
## useful for debug visualizations.

proc set_render_mode_filled_wireframe*(this: NodePath, wireframe_color: LColor) {.importcpp: "#.set_render_mode_filled_wireframe(#)".} ## \
## Sets up the geometry at this level and below (unless overridden) to render
## in filled, but overlay the wireframe on top with a fixed color.  This is
## useful for debug visualizations.

proc set_render_mode_thickness*(this: NodePath, thickness: float32, priority: int) {.importcpp: "#.set_render_mode_thickness(#, #)".} ## \
## Sets up the point geometry at this level and below to render as thick
## points (that is, billboarded quads).  The thickness is in pixels, unless
## set_render_mode_perspective is also true, in which case it is in 3-D units.
##
## If you want the quads to be individually textured, you should also set a
## TexGenAttrib::M_point_sprite on the node.

proc set_render_mode_thickness*(this: NodePath, thickness: float32) {.importcpp: "#.set_render_mode_thickness(#)".} ## \
## Sets up the point geometry at this level and below to render as thick
## points (that is, billboarded quads).  The thickness is in pixels, unless
## set_render_mode_perspective is also true, in which case it is in 3-D units.
##
## If you want the quads to be individually textured, you should also set a
## TexGenAttrib::M_point_sprite on the node.

proc set_render_mode_perspective*(this: NodePath, perspective: bool, priority: int) {.importcpp: "#.set_render_mode_perspective(#, #)".} ## \
## Sets up the point geometry at this level and below to render as perspective
## sprites (that is, billboarded quads).  The thickness, as specified with
## set_render_mode_thickness(), is the width of each point in 3-D units,
## unless it is overridden on a per-vertex basis.  This does not affect
## geometry other than points.
##
## If you want the quads to be individually textured, you should also set a
## TexGenAttrib::M_point_sprite on the node.

proc set_render_mode_perspective*(this: NodePath, perspective: bool) {.importcpp: "#.set_render_mode_perspective(#)".} ## \
## Sets up the point geometry at this level and below to render as perspective
## sprites (that is, billboarded quads).  The thickness, as specified with
## set_render_mode_thickness(), is the width of each point in 3-D units,
## unless it is overridden on a per-vertex basis.  This does not affect
## geometry other than points.
##
## If you want the quads to be individually textured, you should also set a
## TexGenAttrib::M_point_sprite on the node.

proc clear_render_mode*(this: NodePath) {.importcpp: "#.clear_render_mode()".} ## \
## Completely removes any render mode adjustment that may have been set on
## this node via set_render_mode_wireframe() or set_render_mode_filled().

proc has_render_mode*(this: NodePath): bool {.importcpp: "#.has_render_mode()".} ## \
## Returns true if a render mode has been explicitly set on this particular
## node via set_render_mode() (or set_render_mode_wireframe() or
## set_render_mode_filled()), false otherwise.

proc get_render_mode_thickness*(this: NodePath): float32 {.importcpp: "#.get_render_mode_thickness()".} ## \
## Returns the render mode thickness that has been specifically set on this
## node via set_render_mode(), or 1.0 if nothing has been set.

proc get_render_mode_perspective*(this: NodePath): bool {.importcpp: "#.get_render_mode_perspective()".} ## \
## Returns the flag that has been set on this node via
## set_render_mode_perspective(), or false if no flag has been set.

proc set_two_sided*(this: NodePath, two_sided: bool, priority: int) {.importcpp: "#.set_two_sided(#, #)".} ## \
## Specifically sets or disables two-sided rendering mode on this particular
## node.  If no other nodes override, this will cause backfacing polygons to
## be drawn (in two-sided mode, true) or culled (in one-sided mode, false).

proc set_two_sided*(this: NodePath, two_sided: bool) {.importcpp: "#.set_two_sided(#)".} ## \
## Specifically sets or disables two-sided rendering mode on this particular
## node.  If no other nodes override, this will cause backfacing polygons to
## be drawn (in two-sided mode, true) or culled (in one-sided mode, false).

proc clear_two_sided*(this: NodePath) {.importcpp: "#.clear_two_sided()".} ## \
## Completely removes any two-sided adjustment that may have been set on this
## node via set_two_sided(). The geometry at this level and below will
## subsequently be rendered either two-sided or one-sided, according to
## whatever other nodes may have had set_two_sided() on it, or according to
## the initial state otherwise.

proc has_two_sided*(this: NodePath): bool {.importcpp: "#.has_two_sided()".} ## \
## Returns true if a two-sided adjustment has been explicitly set on this
## particular node via set_two_sided().  If this returns true, then
## get_two_sided() may be called to determine which has been set.

proc get_two_sided*(this: NodePath): bool {.importcpp: "#.get_two_sided()".} ## \
## Returns true if two-sided rendering has been specifically set on this node
## via set_two_sided(), or false if one-sided rendering has been specifically
## set, or if nothing has been specifically set.  See also has_two_sided().
## This does not necessarily imply that the geometry will or will not be
## rendered two-sided, as there may be other nodes that override.

proc set_depth_test*(this: NodePath, depth_test: bool, priority: int) {.importcpp: "#.set_depth_test(#, #)".} ## \
## Specifically sets or disables the testing of the depth buffer on this
## particular node.  This is normally on in the 3-d scene graph and off in the
## 2-d scene graph; it should be on for rendering most 3-d objects properly.

proc set_depth_test*(this: NodePath, depth_test: bool) {.importcpp: "#.set_depth_test(#)".} ## \
## Specifically sets or disables the testing of the depth buffer on this
## particular node.  This is normally on in the 3-d scene graph and off in the
## 2-d scene graph; it should be on for rendering most 3-d objects properly.

proc clear_depth_test*(this: NodePath) {.importcpp: "#.clear_depth_test()".} ## \
## Completely removes any depth-test adjustment that may have been set on this
## node via set_depth_test().

proc has_depth_test*(this: NodePath): bool {.importcpp: "#.has_depth_test()".} ## \
## Returns true if a depth-test adjustment has been explicitly set on this
## particular node via set_depth_test().  If this returns true, then
## get_depth_test() may be called to determine which has been set.

proc get_depth_test*(this: NodePath): bool {.importcpp: "#.get_depth_test()".} ## \
## Returns true if depth-test rendering has been specifically set on this node
## via set_depth_test(), or false if depth-test rendering has been
## specifically disabled.  If nothing has been specifically set, returns true.
## See also has_depth_test().

proc set_depth_write*(this: NodePath, depth_write: bool, priority: int) {.importcpp: "#.set_depth_write(#, #)".} ## \
## Specifically sets or disables the writing to the depth buffer on this
## particular node.  This is normally on in the 3-d scene graph and off in the
## 2-d scene graph; it should be on for rendering most 3-d objects properly.

proc set_depth_write*(this: NodePath, depth_write: bool) {.importcpp: "#.set_depth_write(#)".} ## \
## Specifically sets or disables the writing to the depth buffer on this
## particular node.  This is normally on in the 3-d scene graph and off in the
## 2-d scene graph; it should be on for rendering most 3-d objects properly.

proc clear_depth_write*(this: NodePath) {.importcpp: "#.clear_depth_write()".} ## \
## Completely removes any depth-write adjustment that may have been set on
## this node via set_depth_write().

proc has_depth_write*(this: NodePath): bool {.importcpp: "#.has_depth_write()".} ## \
## Returns true if a depth-write adjustment has been explicitly set on this
## particular node via set_depth_write().  If this returns true, then
## get_depth_write() may be called to determine which has been set.

proc get_depth_write*(this: NodePath): bool {.importcpp: "#.get_depth_write()".} ## \
## Returns true if depth-write rendering has been specifically set on this
## node via set_depth_write(), or false if depth-write rendering has been
## specifically disabled.  If nothing has been specifically set, returns true.
## See also has_depth_write().

proc set_depth_offset*(this: NodePath, bias: int, priority: int) {.importcpp: "#.set_depth_offset(#, #)".} ## \
## This instructs the graphics driver to apply an offset or bias to the
## generated depth values for rendered polygons, before they are written to
## the depth buffer.  This can be used to shift polygons forward slightly, to
## resolve depth conflicts, or self-shadowing artifacts on thin objects.  The
## bias is always an integer number, and each integer increment represents the
## smallest possible increment in Z that is sufficient to completely resolve
## two coplanar polygons.  Positive numbers are closer towards the camera.

proc set_depth_offset*(this: NodePath, bias: int) {.importcpp: "#.set_depth_offset(#)".} ## \
## This instructs the graphics driver to apply an offset or bias to the
## generated depth values for rendered polygons, before they are written to
## the depth buffer.  This can be used to shift polygons forward slightly, to
## resolve depth conflicts, or self-shadowing artifacts on thin objects.  The
## bias is always an integer number, and each integer increment represents the
## smallest possible increment in Z that is sufficient to completely resolve
## two coplanar polygons.  Positive numbers are closer towards the camera.

proc clear_depth_offset*(this: NodePath) {.importcpp: "#.clear_depth_offset()".} ## \
## Completely removes any depth-offset adjustment that may have been set on
## this node via set_depth_offset().

proc has_depth_offset*(this: NodePath): bool {.importcpp: "#.has_depth_offset()".} ## \
## Returns true if a depth-offset adjustment has been explicitly set on this
## particular node via set_depth_offset().  If this returns true, then
## get_depth_offset() may be called to determine which has been set.

proc get_depth_offset*(this: NodePath): int {.importcpp: "#.get_depth_offset()".} ## \
## Returns the depth offset value if it has been specified using
## set_depth_offset, or 0 if not.

proc do_billboard_axis*(this: NodePath, camera: NodePath, offset: float32) {.importcpp: "#.do_billboard_axis(#, #)".} ## \
## Performs a billboard-type rotate to the indicated camera node, one time
## only, and leaves the object rotated.  This is similar in principle to
## heads_up().

proc do_billboard_point_eye*(this: NodePath, camera: NodePath, offset: float32) {.importcpp: "#.do_billboard_point_eye(#, #)".} ## \
## Performs a billboard-type rotate to the indicated camera node, one time
## only, and leaves the object rotated.  This is similar in principle to
## look_at(), although the point_eye billboard effect cannot be achieved using
## the ordinary look_at() call.

proc do_billboard_point_world*(this: NodePath, camera: NodePath, offset: float32) {.importcpp: "#.do_billboard_point_world(#, #)".} ## \
## Performs a billboard-type rotate to the indicated camera node, one time
## only, and leaves the object rotated.  This is similar in principle to
## look_at().

proc set_billboard_axis*(this: NodePath, camera: NodePath, offset: float32) {.importcpp: "#.set_billboard_axis(#, #)".} ## \
## Puts a billboard transition on the node such that it will rotate in two
## dimensions around the up axis, towards a specified "camera" instead of to
## the viewing camera.

proc set_billboard_axis*(this: NodePath, offset: float32) {.importcpp: "#.set_billboard_axis(#)".} ## \
## Puts a billboard transition on the node such that it will rotate in two
## dimensions around the up axis.

proc set_billboard_axis*(this: NodePath) {.importcpp: "#.set_billboard_axis()".} ## \
## Puts a billboard transition on the node such that it will rotate in two
## dimensions around the up axis.

proc set_billboard_point_eye*(this: NodePath, camera: NodePath, offset: float32, fixed_depth: bool) {.importcpp: "#.set_billboard_point_eye(#, #, #)".} ## \
## Puts a billboard transition on the node such that it will rotate in three
## dimensions about the origin, keeping its up vector oriented to the top of
## the camera, towards a specified "camera" instead of to the viewing camera.

proc set_billboard_point_eye*(this: NodePath, camera: NodePath, offset: float32) {.importcpp: "#.set_billboard_point_eye(#, #)".} ## \
## Puts a billboard transition on the node such that it will rotate in three
## dimensions about the origin, keeping its up vector oriented to the top of
## the camera, towards a specified "camera" instead of to the viewing camera.

proc set_billboard_point_eye*(this: NodePath, offset: float32, fixed_depth: bool) {.importcpp: "#.set_billboard_point_eye(#, #)".} ## \
## Puts a billboard transition on the node such that it will rotate in three
## dimensions about the origin, keeping its up vector oriented to the top of
## the camera.

proc set_billboard_point_eye*(this: NodePath, offset: float32) {.importcpp: "#.set_billboard_point_eye(#)".} ## \
## Puts a billboard transition on the node such that it will rotate in three
## dimensions about the origin, keeping its up vector oriented to the top of
## the camera.

proc set_billboard_point_eye*(this: NodePath) {.importcpp: "#.set_billboard_point_eye()".} ## \
## Puts a billboard transition on the node such that it will rotate in three
## dimensions about the origin, keeping its up vector oriented to the top of
## the camera.

proc set_billboard_point_world*(this: NodePath, camera: NodePath, offset: float32) {.importcpp: "#.set_billboard_point_world(#, #)".} ## \
## Puts a billboard transition on the node such that it will rotate in three
## dimensions about the origin, keeping its up vector oriented to the sky,
## towards a specified "camera" instead of to the viewing camera.

proc set_billboard_point_world*(this: NodePath, offset: float32) {.importcpp: "#.set_billboard_point_world(#)".} ## \
## Puts a billboard transition on the node such that it will rotate in three
## dimensions about the origin, keeping its up vector oriented to the sky.

proc set_billboard_point_world*(this: NodePath) {.importcpp: "#.set_billboard_point_world()".} ## \
## Puts a billboard transition on the node such that it will rotate in three
## dimensions about the origin, keeping its up vector oriented to the sky.

proc clear_billboard*(this: NodePath) {.importcpp: "#.clear_billboard()".} ## \
## Removes any billboard effect from the node.

proc has_billboard*(this: NodePath): bool {.importcpp: "#.has_billboard()".} ## \
## Returns true if there is any billboard effect on the node.

proc set_compass*(this: NodePath, reference: NodePath) {.importcpp: "#.set_compass(#)".} ## \
## Puts a compass effect on the node, so that it will retain a fixed rotation
## relative to the reference node (or render if the reference node is empty)
## regardless of the transforms above it.

proc set_compass*(this: NodePath) {.importcpp: "#.set_compass()".} ## \
## Puts a compass effect on the node, so that it will retain a fixed rotation
## relative to the reference node (or render if the reference node is empty)
## regardless of the transforms above it.

proc clear_compass*(this: NodePath) {.importcpp: "#.clear_compass()".} ## \
## Removes any compass effect from the node.

proc has_compass*(this: NodePath): bool {.importcpp: "#.has_compass()".} ## \
## Returns true if there is any compass effect on the node.

proc clear_transparency*(this: NodePath) {.importcpp: "#.clear_transparency()".} ## \
## Completely removes any transparency adjustment that may have been set on
## this node via set_transparency(). The geometry at this level and below will
## subsequently be rendered either transparent or not, to whatever other nodes
## may have had set_transparency() on them.

proc has_transparency*(this: NodePath): bool {.importcpp: "#.has_transparency()".} ## \
## Returns true if a transparent-rendering adjustment has been explicitly set
## on this particular node via set_transparency().  If this returns true, then
## get_transparency() may be called to determine whether transparency has been
## explicitly enabled or explicitly disabled for this node.

proc clear_logic_op*(this: NodePath) {.importcpp: "#.clear_logic_op()".} ## \
## Completely removes any logical operation that may have been set on this
## node via set_logic_op(). The geometry at this level and below will
## subsequently be rendered using standard color blending.
##
## @since 1.10.0

proc has_logic_op*(this: NodePath): bool {.importcpp: "#.has_logic_op()".} ## \
## Returns true if a logical operation has been explicitly set on this
## particular node via set_logic_op().  If this returns true, then
## get_logic_op() may be called to determine whether a logical operation has
## been explicitly disabled for this node or set to particular operation.
##
## @since 1.10.0

proc set_antialias*(this: NodePath, mode: int, priority: int) {.importcpp: "#.set_antialias(#, #)".} ## \
## Specifies the antialiasing type that should be applied at this node and
## below.  See AntialiasAttrib.

proc set_antialias*(this: NodePath, mode: int) {.importcpp: "#.set_antialias(#)".} ## \
## Specifies the antialiasing type that should be applied at this node and
## below.  See AntialiasAttrib.

proc clear_antialias*(this: NodePath) {.importcpp: "#.clear_antialias()".} ## \
## Completely removes any antialias setting that may have been set on this
## node via set_antialias().

proc has_antialias*(this: NodePath): bool {.importcpp: "#.has_antialias()".} ## \
## Returns true if an antialias setting has been explicitly mode on this
## particular node via set_antialias().  If this returns true, then
## get_antialias() may be called to determine what the setting was.

proc get_antialias*(this: NodePath): int {.importcpp: "#.get_antialias()".} ## \
## Returns the antialias setting that has been specifically set on this node
## via set_antialias(), or M_none if no setting has been made.

proc has_audio_volume*(this: NodePath): bool {.importcpp: "#.has_audio_volume()".} ## \
## Returns true if an audio volume has been applied to the referenced node,
## false otherwise.  It is still possible that volume at this node might have
## been scaled by an ancestor node.

proc clear_audio_volume*(this: NodePath) {.importcpp: "#.clear_audio_volume()".} ## \
## Completely removes any audio volume from the referenced node.  This is
## preferable to simply setting the audio volume to identity, as it also
## removes the overhead associated with having an audio volume at all.

proc set_audio_volume*(this: NodePath, volume: float32, priority: int) {.importcpp: "#.set_audio_volume(#, #)".} ## \
## Sets the audio volume component of the transform

proc set_audio_volume*(this: NodePath, volume: float32) {.importcpp: "#.set_audio_volume(#)".} ## \
## Sets the audio volume component of the transform

proc set_audio_volume_off*(this: NodePath, priority: int) {.importcpp: "#.set_audio_volume_off(#)".} ## \
## Disables any audio volume attribute inherited from above.  This is not the
## same thing as clear_audio_volume(), which undoes any previous
## set_audio_volume() operation on this node; rather, this actively disables
## any set_audio_volume() that might be inherited from a parent node.
##
## It is legal to specify a new volume on the same node with a subsequent call
## to set_audio_volume(); this new scale will apply to lower nodes.

proc set_audio_volume_off*(this: NodePath) {.importcpp: "#.set_audio_volume_off()".} ## \
## Disables any audio volume attribute inherited from above.  This is not the
## same thing as clear_audio_volume(), which undoes any previous
## set_audio_volume() operation on this node; rather, this actively disables
## any set_audio_volume() that might be inherited from a parent node.
##
## It is legal to specify a new volume on the same node with a subsequent call
## to set_audio_volume(); this new scale will apply to lower nodes.

proc get_audio_volume*(this: NodePath): float32 {.importcpp: "#.get_audio_volume()".} ## \
## Returns the complete audio volume that has been applied to this node via a
## previous call to set_audio_volume(), or 1. (identity) if no volume has been
## applied to this particular node.

proc get_net_audio_volume*(this: NodePath): float32 {.importcpp: "#.get_net_audio_volume()".} ## \
## Returns the complete audio volume for this node taking highers nodes in the
## graph into account.

proc adjust_all_priorities*(this: NodePath, adjustment: int) {.importcpp: "#.adjust_all_priorities(#)".} ## \
## Adds the indicated adjustment amount (which may be negative) to the
## priority for all transitions on the referenced node, and for all nodes in
## the subgraph below.  This can be used to force these nodes not to be
## overridden by a high-level state change above.  If the priority would drop
## below zero, it is set to zero.

proc show*(this: NodePath) {.importcpp: "#.show()".} ## \
## Undoes the effect of a previous hide() on this node: makes the referenced
## node (and the entire subgraph below this node) visible to all cameras.
##
## This will not reveal the node if a parent node has been hidden.

proc show_through*(this: NodePath) {.importcpp: "#.show_through()".} ## \
## Makes the referenced node visible just to the cameras whose camera_mask
## shares the indicated bits.
##
## Unlike show(), this will reveal the node even if a parent node has been
## hidden, thus "showing through" a parent's hide().

proc hide*(this: NodePath) {.importcpp: "#.hide()".} ## \
## Makes the referenced node (and the entire subgraph below this node)
## invisible to all cameras.  It remains part of the scene graph, its bounding
## volume still contributes to its parent's bounding volume, and it will still
## be involved in collision tests.
##
## To undo this, call show().

proc is_hidden*(this: NodePath): bool {.importcpp: "#.is_hidden()".} ## \
## Returns true if the referenced node is hidden from the indicated camera(s)
## either directly, or because some ancestor is hidden.

proc get_hidden_ancestor*(this: NodePath): NodePath {.importcpp: "#.get_hidden_ancestor()".} ## \
## Returns the NodePath at or above the referenced node that is hidden to the
## indicated camera(s), or an empty NodePath if no ancestor of the referenced
## node is hidden (and the node should be visible).

proc stash*(this: NodePath, sort: int, current_thread: Thread) {.importcpp: "#.stash(#, #)".} ## \
## Removes the referenced node (and the entire subgraph below this node) from
## the scene graph in any normal sense.  The node will no longer be visible
## and is not tested for collisions; furthermore, no normal scene graph
## traversal will visit the node.  The node's bounding volume no longer
## contributes to its parent's bounding volume.
##
## A stashed node cannot be located by a normal find() operation (although a
## special find string can still retrieve it).

proc stash*(this: NodePath, sort: int) {.importcpp: "#.stash(#)".} ## \
## Removes the referenced node (and the entire subgraph below this node) from
## the scene graph in any normal sense.  The node will no longer be visible
## and is not tested for collisions; furthermore, no normal scene graph
## traversal will visit the node.  The node's bounding volume no longer
## contributes to its parent's bounding volume.
##
## A stashed node cannot be located by a normal find() operation (although a
## special find string can still retrieve it).

proc stash*(this: NodePath) {.importcpp: "#.stash()".} ## \
## Removes the referenced node (and the entire subgraph below this node) from
## the scene graph in any normal sense.  The node will no longer be visible
## and is not tested for collisions; furthermore, no normal scene graph
## traversal will visit the node.  The node's bounding volume no longer
## contributes to its parent's bounding volume.
##
## A stashed node cannot be located by a normal find() operation (although a
## special find string can still retrieve it).

proc unstash*(this: NodePath, sort: int, current_thread: Thread) {.importcpp: "#.unstash(#, #)".} ## \
## Undoes the effect of a previous stash() on this node: makes the referenced
## node (and the entire subgraph below this node) once again part of the scene
## graph.

proc unstash*(this: NodePath, sort: int) {.importcpp: "#.unstash(#)".} ## \
## Undoes the effect of a previous stash() on this node: makes the referenced
## node (and the entire subgraph below this node) once again part of the scene
## graph.

proc unstash*(this: NodePath) {.importcpp: "#.unstash()".} ## \
## Undoes the effect of a previous stash() on this node: makes the referenced
## node (and the entire subgraph below this node) once again part of the scene
## graph.

proc unstash_all*(this: NodePath, current_thread: Thread) {.importcpp: "#.unstash_all(#)".} ## \
## Unstashes this node and all stashed child nodes.

proc unstash_all*(this: NodePath) {.importcpp: "#.unstash_all()".} ## \
## Unstashes this node and all stashed child nodes.

proc is_stashed*(this: NodePath): bool {.importcpp: "#.is_stashed()".} ## \
## Returns true if the referenced node is stashed either directly, or because
## some ancestor is stashed.

proc get_stashed_ancestor*(this: NodePath, current_thread: Thread): NodePath {.importcpp: "#.get_stashed_ancestor(#)".} ## \
## Returns the NodePath at or above the referenced node that is stashed, or an
## empty NodePath if no ancestor of the referenced node is stashed (and the
## node should be visible).

proc get_stashed_ancestor*(this: NodePath): NodePath {.importcpp: "#.get_stashed_ancestor()".} ## \
## Returns the NodePath at or above the referenced node that is stashed, or an
## empty NodePath if no ancestor of the referenced node is stashed (and the
## node should be visible).

proc `==`*(this: NodePath, other: NodePath): bool {.importcpp: "#.operator ==(#)".} ## \
## Comparison methods

proc `==`*(this: NodePath, other: WeakNodePath): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: NodePath, other: NodePath): bool {.importcpp: "#.operator !=(#)".}

proc `!=`*(this: NodePath, other: WeakNodePath): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: NodePath, other: NodePath): bool {.importcpp: "#.operator <(#)".}

proc `<`*(this: NodePath, other: WeakNodePath): bool {.importcpp: "#.operator <(#)".}

proc compare_to*(this: NodePath, other: NodePath): int {.importcpp: "#.compare_to(#)".} ## \
## Returns a number less than zero if this NodePath sorts before the other
## one, greater than zero if it sorts after, or zero if they are equivalent.
##
## Two NodePaths are considered equivalent if they consist of exactly the same
## list of nodes in the same order.  Otherwise, they are different; different
## NodePaths will be ranked in a consistent but undefined ordering; the
## ordering is useful only for placing the NodePaths in a sorted container
## like an STL set.

proc compare_to*(this: NodePath, other: WeakNodePath): int {.importcpp: "#.compare_to(#)".} ## \
## Returns a number less than zero if this NodePath sorts before the other
## one, greater than zero if it sorts after, or zero if they are equivalent.
##
## Two NodePaths are considered equivalent if they consist of exactly the same
## list of nodes in the same order.  Otherwise, they are different; different
## NodePaths will be ranked in a consistent but undefined ordering; the
## ordering is useful only for placing the NodePaths in a sorted container
## like an STL set.

proc verify_complete*(this: NodePath, current_thread: Thread): bool {.importcpp: "#.verify_complete(#)".} ## \
## Returns true if all of the nodes described in the NodePath are connected,
## or false otherwise.

proc verify_complete*(this: NodePath): bool {.importcpp: "#.verify_complete()".} ## \
## Returns true if all of the nodes described in the NodePath are connected,
## or false otherwise.

proc premunge_scene*(this: NodePath, gsg: GraphicsStateGuardianBase) {.importcpp: "#.premunge_scene(#)".} ## \
## Walks through the scene graph beginning at the bottom node, and internally
## adjusts any GeomVertexFormats for optimal rendering on the indicated GSG.
## If this step is not done prior to rendering, the formats will be optimized
## at render time instead, for a small cost.
##
## It is not normally necessary to do this on a model loaded directly from
## disk, since the loader will do this by default.

proc premunge_scene*(this: NodePath) {.importcpp: "#.premunge_scene()".} ## \
## Walks through the scene graph beginning at the bottom node, and internally
## adjusts any GeomVertexFormats for optimal rendering on the indicated GSG.
## If this step is not done prior to rendering, the formats will be optimized
## at render time instead, for a small cost.
##
## It is not normally necessary to do this on a model loaded directly from
## disk, since the loader will do this by default.

proc prepare_scene*(this: NodePath, gsg: GraphicsStateGuardianBase) {.importcpp: "#.prepare_scene(#)".} ## \
## Walks through the scene graph beginning at the bottom node, and does
## whatever initialization is required to render the scene properly with the
## indicated GSG.  It is not strictly necessary to call this, since the GSG
## will initialize itself when the scene is rendered, but this may take some
## of the overhead away from that process.
##
## In particular, this will ensure that textures and vertex buffers within the
## scene are loaded into graphics memory.

proc show_bounds*(this: NodePath) {.importcpp: "#.show_bounds()".} ## \
## Causes the bounding volume of the bottom node and all of its descendants
## (that is, the bounding volume associated with the the bottom arc) to be
## rendered, if possible.  The rendering method is less than optimal; this is
## intended primarily for debugging.

proc show_tight_bounds*(this: NodePath) {.importcpp: "#.show_tight_bounds()".} ## \
## Similar to show_bounds(), this draws a bounding box representing the
## "tight" bounds of this node and all of its descendants.  The bounding box
## is recomputed every frame by reexamining all of the vertices; this is far
## from efficient, but this is intended for debugging.

proc hide_bounds*(this: NodePath) {.importcpp: "#.hide_bounds()".} ## \
## Stops the rendering of the bounding volume begun with show_bounds().

proc get_bounds*(this: NodePath, current_thread: Thread): BoundingVolume {.importcpp: "#.get_bounds(#)".} ## \
## Returns a newly-allocated bounding volume containing the bottom node and
## all of its descendants.  This is the bounding volume on the bottom arc,
## converted to the local coordinate space of the node.

proc get_bounds*(this: NodePath): BoundingVolume {.importcpp: "#.get_bounds()".} ## \
## Returns a newly-allocated bounding volume containing the bottom node and
## all of its descendants.  This is the bounding volume on the bottom arc,
## converted to the local coordinate space of the node.

proc force_recompute_bounds*(this: NodePath) {.importcpp: "#.force_recompute_bounds()".} ## \
## Forces the recomputing of all the bounding volumes at every node in the
## subgraph beginning at this node and below.
##
## This should not normally need to be called, since the bounding volumes are
## supposed to be recomputed automatically when necessary.  It may be useful
## when debugging, to verify that the bounding volumes have not become
## inadvertently stale; it may also be useful to force animated characters to
## update their bounding volumes (which does not presently happen
## automatically).

proc write_bounds*(this: NodePath, `out`: ostream) {.importcpp: "#.write_bounds(#)".} ## \
## Writes a description of the bounding volume containing the bottom node and
## all of its descendants to the indicated output stream.

proc calc_tight_bounds*(this: NodePath, min_point: LPoint3, max_point: LPoint3, other: NodePath, current_thread: Thread): bool {.importcpp: "#.calc_tight_bounds(#, #, #, #)".} ## \
## Calculates the minimum and maximum vertices of all Geoms at this NodePath's
## bottom node and below.  This is a tight bounding box; it will generally be
## tighter than the bounding volume returned by get_bounds() (but it is more
## expensive to compute).
##
## The bounding box is computed relative to the parent node's coordinate
## system by default.  You can optionally specify a different NodePath to
## compute the bounds relative to.  Note that the box is always axis-aligned
## against the given NodePath's coordinate system, so you might get a
## differently sized box depending on which node you pass.
##
## The return value is true if any points are within the bounding volume, or
## false if none are.

proc calc_tight_bounds*(this: NodePath, min_point: LPoint3, max_point: LPoint3, other: NodePath): bool {.importcpp: "#.calc_tight_bounds(#, #, #)".} ## \
## Calculates the minimum and maximum vertices of all Geoms at this NodePath's
## bottom node and below.  This is a tight bounding box; it will generally be
## tighter than the bounding volume returned by get_bounds() (but it is more
## expensive to compute).
##
## The bounding box is computed relative to the parent node's coordinate
## system by default.  You can optionally specify a different NodePath to
## compute the bounds relative to.  Note that the box is always axis-aligned
## against the given NodePath's coordinate system, so you might get a
## differently sized box depending on which node you pass.
##
## The return value is true if any points are within the bounding volume, or
## false if none are.

proc calc_tight_bounds*(this: NodePath, min_point: LPoint3, max_point: LPoint3): bool {.importcpp: "#.calc_tight_bounds(#, #)".} ## \
## Calculates the minimum and maximum vertices of all Geoms at this NodePath's
## bottom node and below.  This is a tight bounding box; it will generally be
## tighter than the bounding volume returned by get_bounds() (but it is more
## expensive to compute).
##
## The bounding box is computed relative to the parent node's coordinate
## system by default.  You can optionally specify a different NodePath to
## compute the bounds relative to.  Note that the box is always axis-aligned
## against the given NodePath's coordinate system, so you might get a
## differently sized box depending on which node you pass.
##
## The return value is true if any points are within the bounding volume, or
## false if none are.

proc flatten_light*(this: NodePath): int {.importcpp: "#.flatten_light()".} ## \
## Lightly flattens out the hierarchy below this node by applying transforms,
## colors, and texture matrices from the nodes onto the vertices, but does not
## remove any nodes.
##
## This can result in improved rendering performance because there will be
## fewer transforms in the resulting scene graph, but the number of nodes will
## remain the same.
##
## In particular, any NodePaths that reference nodes within this hierarchy
## will not be damaged.  However, since this operation will remove transforms
## from the scene graph, it may be dangerous to apply to nodes where you
## expect to dynamically modify the transform, or where you expect the
## geometry to remain in a particular local coordinate system.
##
## The return value is always 0, since flatten_light does not remove any
## nodes.

proc flatten_medium*(this: NodePath): int {.importcpp: "#.flatten_medium()".} ## \
## A more thorough flattening than flatten_light(), this first applies all the
## transforms, colors, and texture matrices from the nodes onto the vertices,
## and then removes unneeded grouping nodes--nodes that have exactly one
## child, for instance, but have no special properties in themselves.
##
## This results in improved performance over flatten_light() because the
## number of nodes in the scene graph is reduced.
##
## The return value is the number of nodes removed.

proc flatten_strong*(this: NodePath): int {.importcpp: "#.flatten_strong()".} ## \
## The strongest possible flattening.  This first applies all of the
## transforms to the vertices, as in flatten_medium(), but then it will
## combine sibling nodes together when possible, in addition to removing
## unnecessary parent-child nodes.  This can result in substantially fewer
## nodes, but any nicely-grouped hierachical bounding volumes may be lost.
##
## It is generally a good idea to apply this kind of flattening only to nodes
## that will be culled largely as a single unit, like a car.  Applying this to
## an entire scene may result in overall poorer performance because of less-
## effective culling.

proc apply_texture_colors*(this: NodePath) {.importcpp: "#.apply_texture_colors()".} ## \
## Removes textures from Geoms at this node and below by applying the texture
## colors to the vertices.  This is primarily useful to simplify a low-LOD
## model.  The texture colors are replaced by flat colors that approximate the
## original textures.
##
## Only the bottommost texture on each Geom is used (if there is more than
## one), and it is applied as if it were M_modulate, and WM_repeat, regardless
## of its actual settings.  If the texture has a simple_ram_image, this may be
## used if the main image isn't resident.
##
## After this call, there will be no texturing specified at this level and
## below.  Of course, there might still be texturing inherited from above.

proc clear_model_nodes*(this: NodePath): int {.importcpp: "#.clear_model_nodes()".} ## \
## Recursively walks through the scene graph at this level and below, looking
## for ModelNodes, and calls model_node->set_preserve_transform(PT_drop_node)
## on each one.  This allows a subsequent call to flatten_strong() to
## eliminate all of the ModelNodes.
##
## Returns the number of ModelNodes found.

proc set_tag*(this: NodePath, key: string, value: string) {.importcpp: "#.set_tag(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Associates a user-defined value with a user-defined key which is stored on
## the node.  This value has no meaning to Panda; but it is stored
## indefinitely on the node until it is requested again.
##
## Each unique key stores a different string value.  There is no effective
## limit on the number of different keys that may be stored or on the length
## of any one key's value.

proc get_tag*(this: NodePath, key: string): string {.importcpp: "nimStringFromStdString(#.get_tag(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Retrieves the user-defined value that was previously set on this node for
## the particular key, if any.  If no value has been previously set, returns
## the empty string.  See also get_net_tag().

proc has_tag*(this: NodePath, key: string): bool {.importcpp: "#.has_tag(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if a value has been defined on this node for the particular
## key (even if that value is the empty string), or false if no value has been
## set.  See also has_net_tag().

proc clear_tag*(this: NodePath, key: string) {.importcpp: "#.clear_tag(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the value defined for this key on this particular node.  After a
## call to clear_tag(), has_tag() will return false for the indicated key.

proc get_net_tag*(this: NodePath, key: string): string {.importcpp: "nimStringFromStdString(#.get_net_tag(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Returns the tag value that has been defined on this node, or the nearest
## ancestor node, for the indicated key.  If no value has been defined for the
## indicated key on any ancestor node, returns the empty string.  See also
## get_tag().

proc has_net_tag*(this: NodePath, key: string): bool {.importcpp: "#.has_net_tag(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if the indicated tag value has been defined on this node or on
## any ancestor node, or false otherwise.  See also has_tag().

proc find_net_tag*(this: NodePath, key: string): NodePath {.importcpp: "#.find_net_tag(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the lowest ancestor of this node that contains a tag definition
## with the indicated key, if any, or an empty NodePath if no ancestor of this
## node contains this tag definition.  See set_tag().

proc list_tags*(this: NodePath) {.importcpp: "#.list_tags()".} ## \
## Lists the tags to the nout stream, one per line.  See
## PandaNode::list_tags() for a variant that allows you to specify the output
## stream.

proc set_name*(this: NodePath, name: string) {.importcpp: "#.set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of the referenced node.

proc get_name*(this: NodePath): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the referenced node.

proc write_bam_file*(this: NodePath, filename: Filename): bool {.importcpp: "#.write_bam_file(#)".} ## \
## Writes the contents of this node and below out to a bam file with the
## indicated filename.  This file may then be read in again, as is, at some
## later point.  Returns true if successful, false on some kind of error.

proc write_bam_stream*(this: NodePath, `out`: ostream): bool {.importcpp: "#.write_bam_stream(#)".} ## \
## Writes the contents of this node and below out to the indicated stream.

proc get_class_type*(_: typedesc[NodePath]): TypeHandle {.importcpp: "NodePath::get_class_type()", header: "nodePath.h".}

proc add_node*(this: AttribNodeRegistry, attrib_node: NodePath) {.importcpp: "#.add_node(#)".} ## \
## Adds the indicated NodePath to the registry.  The name and type of the node
## are noted at the time of this call; if the name changes later, it will not
## update the registry index.
##
## The NodePath must reference some kind of an attribute node, such as a
## LightNode or a PlaneNode.  When bam files that reference an attribute node
## of the same type and the same name are loaded, they will quietly be
## redirected to reference this NodePath.
##
## If there is already a node matching the indicated name and type, it will be
## replaced.

proc remove_node*(this: AttribNodeRegistry, attrib_node: NodePath): bool {.importcpp: "#.remove_node(#)".} ## \
## Removes the indicated NodePath from the registry.  The name of the node
## must not have changed since the matching call to add_node(), or it will not
## be successfully removed.
##
## Returns true if the NodePath is found and removed, false if it is not found
## (for instance, because the name has changed).

proc remove_node*(this: AttribNodeRegistry, n: int) {.importcpp: "#.remove_node(#)".} ## \
## Removes the nth node from the registry.

proc lookup_node*(this: AttribNodeRegistry, orig_node: NodePath): NodePath {.importcpp: "#.lookup_node(#)".} ## \
## Looks up the indicated NodePath in the registry.  If there is a node
## already in the registry with the matching name and type, returns that
## NodePath instead; otherwise, returns the original NodePath.

proc get_num_nodes*(this: AttribNodeRegistry): int {.importcpp: "#.get_num_nodes()".} ## \
## Returns the total number of nodes in the registry.

proc get_node*(this: AttribNodeRegistry, n: int): NodePath {.importcpp: "#.get_node(#)".} ## \
## Returns the nth NodePath recorded in the registry.

proc get_node_type*(this: AttribNodeRegistry, n: int): TypeHandle {.importcpp: "#.get_node_type(#)".} ## \
## Returns the type of the nth node, as recorded in the registry.

proc get_node_name*(this: AttribNodeRegistry, n: int): string {.importcpp: "nimStringFromStdString(#.get_node_name(#))", header: stringConversionCode.} ## \
## Returns the name of the nth node, as recorded in the registry.  This will
## be the node name as it was at the time the node was recorded; if the node
## has changed names since then, this will still return the original name.

proc find_node*(this: AttribNodeRegistry, attrib_node: NodePath): int {.importcpp: "#.find_node(#)".} ## \
## Returns the index number of the indicated NodePath in the registry
## (assuming its name hasn't changed since it was recorded in the registry),
## or -1 if the NodePath cannot be found (for instance, because its name has
## changed).

proc find_node*(this: AttribNodeRegistry, `type`: TypeHandle, name: string): int {.importcpp: "#.find_node(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the index number of the node with the indicated type and name in
## the registry, or -1 if there is no such node in the registry.

proc clear*(this: AttribNodeRegistry) {.importcpp: "#.clear()".} ## \
## Removes all nodes from the registry.

proc output*(this: AttribNodeRegistry, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: AttribNodeRegistry, `out`: ostream) {.importcpp: "#.write(#)".}

proc get_global_ptr*(_: typedesc[AttribNodeRegistry]): AttribNodeRegistry {.importcpp: "AttribNodeRegistry::get_global_ptr()", header: "attribNodeRegistry.h".}

proc make_identity*(_: typedesc[AudioVolumeAttrib]): RenderAttrib {.importcpp: "AudioVolumeAttrib::make_identity()", header: "audioVolumeAttrib.h".} ## \
## Constructs an identity audio volume attrib.

proc make*(_: typedesc[AudioVolumeAttrib], volume: float32): RenderAttrib {.importcpp: "AudioVolumeAttrib::make(#)", header: "audioVolumeAttrib.h".} ## \
## Constructs a new AudioVolumeAttrib object that indicates audio volume
## should be scaled by the indicated factor.

proc make_off*(_: typedesc[AudioVolumeAttrib]): RenderAttrib {.importcpp: "AudioVolumeAttrib::make_off()", header: "audioVolumeAttrib.h".} ## \
## Constructs a new AudioVolumeAttrib object that ignores any
## AudioVolumeAttrib inherited from above.  You may also specify an additional
## volume scale to apply to geometry below (using set_volume()).

proc make_default*(_: typedesc[AudioVolumeAttrib]): RenderAttrib {.importcpp: "AudioVolumeAttrib::make_default()", header: "audioVolumeAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc is_off*(this: AudioVolumeAttrib): bool {.importcpp: "#->is_off()".} ## \
## Returns true if the AudioVolumeAttrib will ignore any color scales
## inherited from above, false otherwise.  This is not the same thing as
## !has_scale(); a AudioVolumeAttrib may have the "off" flag set and also have
## another scale specified.

proc has_volume*(this: AudioVolumeAttrib): bool {.importcpp: "#->has_volume()".} ## \
## Returns true if the AudioVolumeAttrib has a non-identity volume, false
## otherwise (in which case it might be an off attrib or an identity attrib).

proc get_volume*(this: AudioVolumeAttrib): float32 {.importcpp: "#->get_volume()".} ## \
## Returns the volume to be applied to sounds.

proc set_volume*(this: AudioVolumeAttrib, volume: float32): RenderAttrib {.importcpp: "#->set_volume(#)".} ## \
## Returns a new AudioVolumeAttrib, just like this one, but with the volume
## changed to the indicated value.

proc get_class_slot*(_: typedesc[AudioVolumeAttrib]): int {.importcpp: "AudioVolumeAttrib::get_class_slot()", header: "audioVolumeAttrib.h".}

proc get_class_type*(_: typedesc[AudioVolumeAttrib]): TypeHandle {.importcpp: "AudioVolumeAttrib::get_class_type()", header: "audioVolumeAttrib.h".}

proc make*(_: typedesc[AuxBitplaneAttrib]): RenderAttrib {.importcpp: "AuxBitplaneAttrib::make()", header: "auxBitplaneAttrib.h".} ## \
## Constructs a default AuxBitplaneAttrib object.

proc make*(_: typedesc[AuxBitplaneAttrib], outputs: int): RenderAttrib {.importcpp: "AuxBitplaneAttrib::make(#)", header: "auxBitplaneAttrib.h".} ## \
## Constructs a specified AuxBitplaneAttrib object.

proc make_default*(_: typedesc[AuxBitplaneAttrib]): RenderAttrib {.importcpp: "AuxBitplaneAttrib::make_default()", header: "auxBitplaneAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc get_outputs*(this: AuxBitplaneAttrib): int {.importcpp: "#->get_outputs()".} ## \
## Returns the AuxBitplaneAttrib output bits.

proc get_class_slot*(_: typedesc[AuxBitplaneAttrib]): int {.importcpp: "AuxBitplaneAttrib::get_class_slot()", header: "auxBitplaneAttrib.h".}

proc get_class_type*(_: typedesc[AuxBitplaneAttrib]): TypeHandle {.importcpp: "AuxBitplaneAttrib::get_class_type()", header: "auxBitplaneAttrib.h".}

proc set_duration*(this: AuxSceneData, duration: float64) {.importcpp: "#->set_duration(#)".} ## \
## Specifies the minimum length in time, in seconds, to keep this AuxSceneData
## object around in the scene graph after the last time it was rendered.

proc get_duration*(this: AuxSceneData): float64 {.importcpp: "#->get_duration()".} ## \
## Returns the minimum length in time, in seconds, to keep this AuxSceneData
## object around in the scene graph after the last time it was rendered.

proc set_last_render_time*(this: AuxSceneData, render_time: float64) {.importcpp: "#->set_last_render_time(#)".} ## \
## Should be called with the current frame_time each time the AuxSceneData is
## used during traversal.

proc get_last_render_time*(this: AuxSceneData): float64 {.importcpp: "#->get_last_render_time()".} ## \
## Returns the last time this object was used during traversal (according to
## set_last_render_time()).

proc get_expiration_time*(this: AuxSceneData): float64 {.importcpp: "#->get_expiration_time()".} ## \
## Returns the frame_time at which this AuxSceneData object is currently
## scheduled to be removed from the scene graph.

proc output*(this: AuxSceneData, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: AuxSceneData, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: AuxSceneData, `out`: ostream) {.importcpp: "#->write(#)".}

proc get_class_type*(_: typedesc[AuxSceneData]): TypeHandle {.importcpp: "AuxSceneData::get_class_type()", header: "auxSceneData.h".}

proc newAuxSceneData*(param0: AuxSceneData): AuxSceneData {.importcpp: "new AuxSceneData(#)".}

proc initBamFile*(): BamFile {.importcpp: "BamFile()".}

proc open_read*(this: BamFile, bam_filename: Filename, report_errors: bool): bool {.importcpp: "#.open_read(#, #)".} ## \
## Attempts to open the indicated filename for reading.  Returns true if
## successful, false on error.

proc open_read*(this: BamFile, bam_filename: Filename): bool {.importcpp: "#.open_read(#)".} ## \
## Attempts to open the indicated filename for reading.  Returns true if
## successful, false on error.

proc open_read*(this: BamFile, `in`: istream, bam_filename: string, report_errors: bool): bool {.importcpp: "#.open_read(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Attempts to open the indicated stream for reading.  The filename is just
## for information purposes only.  Returns true if successful, false on error.

proc open_read*(this: BamFile, `in`: istream, bam_filename: string): bool {.importcpp: "#.open_read(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Attempts to open the indicated stream for reading.  The filename is just
## for information purposes only.  Returns true if successful, false on error.

proc open_read*(this: BamFile, `in`: istream): bool {.importcpp: "#.open_read(#)".} ## \
## Attempts to open the indicated stream for reading.  The filename is just
## for information purposes only.  Returns true if successful, false on error.

proc read_object*(this: BamFile): TypedWritable {.importcpp: "#.read_object()".} ## \
## Reads and returns the next object from the Bam file, or NULL if the end of
## the file has been reached, or if there is an error condition.  Use is_eof()
## to differentiate these two cases.
##
## The pointers returned by this method will not be valid for use until
## resolve() is subsequently called.

proc is_eof*(this: BamFile): bool {.importcpp: "#.is_eof()".} ## \
## Returns true if the reader has reached end-of-file, false otherwise.  This
## call is only valid after a call to read_object().

proc resolve*(this: BamFile): bool {.importcpp: "#.resolve()".} ## \
## This must be called after one or more objects have been read via calls to
## read_object() in order to resolve all internal pointer references in the
## objects read and make all the pointers valid.  It returns true if all
## objects are successfully resolved, or false if some have not been (in which
## case you must call resolve() again later).

proc read_node*(this: BamFile, report_errors: bool): PandaNode {.importcpp: "#.read_node(#)".} ## \
## Although the bam file format is general enough to store a list of objects
## of arbitrary type, bam files on disk usually contain just one object, a
## PandaNode that is the root of a scene graph.  (Bam files that store other
## kinds of things are usually given the extension "boo", for "binary other
## objects", to differentiate them from the normal scene graph type file.)
##
## This is a convenience method for when you believe you are reading a scene
## graph bam file.  It reads the one PandaNode and returns it.  It also calls
## resolve() to fully resolve the object, since we expect this will be the
## only object in the file.
##
## If the bam file contains something other than a PandaNode, an error is
## printed and NULL is returned.

proc read_node*(this: BamFile): PandaNode {.importcpp: "#.read_node()".} ## \
## Although the bam file format is general enough to store a list of objects
## of arbitrary type, bam files on disk usually contain just one object, a
## PandaNode that is the root of a scene graph.  (Bam files that store other
## kinds of things are usually given the extension "boo", for "binary other
## objects", to differentiate them from the normal scene graph type file.)
##
## This is a convenience method for when you believe you are reading a scene
## graph bam file.  It reads the one PandaNode and returns it.  It also calls
## resolve() to fully resolve the object, since we expect this will be the
## only object in the file.
##
## If the bam file contains something other than a PandaNode, an error is
## printed and NULL is returned.

proc open_write*(this: BamFile, bam_filename: Filename, report_errors: bool): bool {.importcpp: "#.open_write(#, #)".} ## \
## Attempts to open the indicated file for writing.  If another file by the
## same name already exists, it will be silently removed.  Returns true if
## successful, false otherwise.

proc open_write*(this: BamFile, bam_filename: Filename): bool {.importcpp: "#.open_write(#)".} ## \
## Attempts to open the indicated file for writing.  If another file by the
## same name already exists, it will be silently removed.  Returns true if
## successful, false otherwise.

proc open_write*(this: BamFile, `out`: ostream, bam_filename: string, report_errors: bool): bool {.importcpp: "#.open_write(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Attempts to open the indicated stream for writing.  The filename is just
## for information purposes only.  Returns true if successful, false on error.

proc open_write*(this: BamFile, `out`: ostream, bam_filename: string): bool {.importcpp: "#.open_write(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Attempts to open the indicated stream for writing.  The filename is just
## for information purposes only.  Returns true if successful, false on error.

proc open_write*(this: BamFile, `out`: ostream): bool {.importcpp: "#.open_write(#)".} ## \
## Attempts to open the indicated stream for writing.  The filename is just
## for information purposes only.  Returns true if successful, false on error.

proc write_object*(this: BamFile, `object`: TypedWritable): bool {.importcpp: "#.write_object(#)".} ## \
## Writes the indicated object to the Bam file.  Returns true if successful,
## false on error.

proc close*(this: BamFile) {.importcpp: "#.close()".} ## \
## Closes the input or output stream.

proc is_valid_read*(this: BamFile): bool {.importcpp: "#.is_valid_read()".} ## \
## Returns true if the Bam file is open and ready for reading with no errors
## so far detected, or false otherwise.

proc is_valid_write*(this: BamFile): bool {.importcpp: "#.is_valid_write()".} ## \
## Returns true if the Bam file is open and ready for writing with no errors
## so far detected, or false otherwise.

proc get_file_major_ver*(this: BamFile): int {.importcpp: "#.get_file_major_ver()".} ## \
## Returns the major version number of the file currently being read, or the
## system current major version number if no file is currently open for
## reading.

proc get_file_minor_ver*(this: BamFile): int {.importcpp: "#.get_file_minor_ver()".} ## \
## Returns the minor version number of the file currently being read, or the
## system current minor version number if no file is currently open for
## reading.

proc get_file_stdfloat_double*(this: BamFile): bool {.importcpp: "#.get_file_stdfloat_double()".} ## \
## Returns true if the file stores all "standard" floats as 64-bit doubles, or
## false if they are 32-bit floats.

proc get_current_major_ver*(this: BamFile): int {.importcpp: "#.get_current_major_ver()".} ## \
## Returns the system current major version number.  This is the version
## number that will be assigned to any generated Bam files.

proc get_current_minor_ver*(this: BamFile): int {.importcpp: "#.get_current_minor_ver()".} ## \
## Returns the system current minor version number.  This is the version
## number that will be assigned to any generated Bam files.

proc get_reader*(this: BamFile): BamReader {.importcpp: "#.get_reader()".} ## \
## Returns the BamReader in charge of performing the read operations.  This
## will return NULL unless open_read() was called.

proc get_writer*(this: BamFile): BamWriter {.importcpp: "#.get_writer()".} ## \
## Returns the BamWriter in charge of performing the write operations.  This
## will return NULL unless open_write() was called.

proc make*(_: typedesc[BillboardEffect], up_vector: LVector3, eye_relative: bool, axial_rotate: bool, offset: float32, look_at: NodePath, look_at_point: LPoint3, fixed_depth: bool): RenderEffect {.importcpp: "BillboardEffect::make(#, #, #, #, #, #, #)", header: "billboardEffect.h".} ## \
## Constructs a new BillboardEffect object with the indicated properties.

proc make*(_: typedesc[BillboardEffect], up_vector: LVector3, eye_relative: bool, axial_rotate: bool, offset: float32, look_at: NodePath, look_at_point: LPoint3): RenderEffect {.importcpp: "BillboardEffect::make(#, #, #, #, #, #)", header: "billboardEffect.h".} ## \
## Constructs a new BillboardEffect object with the indicated properties.

proc make_axis*(_: typedesc[BillboardEffect]): RenderEffect {.importcpp: "BillboardEffect::make_axis()", header: "billboardEffect.h".} ## \
## A convenience function to make a typical axis-rotating billboard.

proc make_point_eye*(_: typedesc[BillboardEffect]): RenderEffect {.importcpp: "BillboardEffect::make_point_eye()", header: "billboardEffect.h".} ## \
## A convenience function to make a typical eye-relative point-rotating
## billboard.

proc make_point_world*(_: typedesc[BillboardEffect]): RenderEffect {.importcpp: "BillboardEffect::make_point_world()", header: "billboardEffect.h".} ## \
## A convenience function to make a typical world-relative point-rotating
## billboard.

proc is_off*(this: BillboardEffect): bool {.importcpp: "#->is_off()".} ## \
## Returns true if the BillboardEffect is an 'off' BillboardEffect, indicating
## that it does not enable billboarding.  This kind of BillboardEffect isn't
## particularly useful and isn't normally created or stored in the graph; it
## might be implicitly discovered as the result of a
## NodePath::get_rel_state().

proc get_up_vector*(this: BillboardEffect): LVector3 {.importcpp: "#->get_up_vector()".} ## \
## Returns the up vector in effect for this billboard.

proc get_eye_relative*(this: BillboardEffect): bool {.importcpp: "#->get_eye_relative()".} ## \
## Returns true if this billboard interprets the up vector relative to the
## camera, or false if it is relative to the world.

proc get_axial_rotate*(this: BillboardEffect): bool {.importcpp: "#->get_axial_rotate()".} ## \
## Returns true if this billboard rotates only around the axis of the up
## vector, or false if it rotates freely in three dimensions.

proc get_fixed_depth*(this: BillboardEffect): bool {.importcpp: "#->get_fixed_depth()".} ## \
## Returns true if this billboard always appears at a fixed distance from the
## camera.

proc get_offset*(this: BillboardEffect): float32 {.importcpp: "#->get_offset()".} ## \
## Returns the distance toward the camera (or the look_at_point) the billboard
## is moved towards, after rotating.  This can be used to ensure the billboard
## is not obscured by nearby geometry.

proc get_look_at*(this: BillboardEffect): NodePath {.importcpp: "#->get_look_at()".} ## \
## Returns the node this billboard will rotate to look towards.  If this is
## empty, it means the billboard will rotate towards the current camera node,
## wherever that might be.

proc get_look_at_point*(this: BillboardEffect): LPoint3 {.importcpp: "#->get_look_at_point()".} ## \
## Returns the point, relative to the look_at node, towards which the
## billboard will rotate.  Normally this is (0, 0, 0).

proc get_class_type*(_: typedesc[BillboardEffect]): TypeHandle {.importcpp: "BillboardEffect::get_class_type()", header: "billboardEffect.h".}

proc newLensNode*(name: string, lens: Lens): LensNode {.importcpp: "new LensNode(nimStringToStdString(#), #)", header: stringConversionCode.}

proc newLensNode*(name: string): LensNode {.importcpp: "new LensNode(nimStringToStdString(#))", header: stringConversionCode.}

proc copy_lens*(this: LensNode, lens: Lens) {.importcpp: "#->copy_lens(#)".} ## \
## Sets up the LensNode using a copy of the indicated Lens.  If the original
## Lens is changed or destroyed, this LensNode is not affected.

proc copy_lens*(this: LensNode, index: int, lens: Lens) {.importcpp: "#->copy_lens(#, #)".} ## \
## Copies the indicated lens into the specified slot.

proc set_lens*(this: LensNode, lens: Lens) {.importcpp: "#->set_lens(#)".} ## \
## Sets up the LensNode using this particular Lens pointer.  If the lens is
## subsequently modified, the LensNode properties immediately reflect the
## change.

proc set_lens*(this: LensNode, index: int, lens: Lens) {.importcpp: "#->set_lens(#, #)".} ## \
## Sets the indicated lens.  Although a LensNode normally holds only one lens,
## it may optionally include multiple lenses, each with a different index
## number.  The different lenses may be referenced by index number on the
## DisplayRegion.  Adding a new lens automatically makes it active.

proc get_lens*(this: LensNode, index: int): Lens {.importcpp: "#->get_lens(#)".} ## \
## Returns a pointer to the particular Lens associated with this LensNode, or
## NULL if there is not yet a Lens associated.  If an index number is
## specified, returns the nth lens.

proc get_lens*(this: LensNode): Lens {.importcpp: "#->get_lens()".} ## \
## Returns a pointer to the particular Lens associated with this LensNode, or
## NULL if there is not yet a Lens associated.  If an index number is
## specified, returns the nth lens.

proc set_lens_active*(this: LensNode, index: int, active: bool): bool {.importcpp: "#->set_lens_active(#, #)".} ## \
## Sets the active flag for the nth lens.  When a lens is inactive, it is not
## used for rendering, and any DisplayRegions associated with it are
## implicitly inactive as well.  Returns true if the flag is changed, false if
## it already had this value.

proc get_lens_active*(this: LensNode, index: int): bool {.importcpp: "#->get_lens_active(#)".} ## \
## Returns the active flag for the nth lens.

proc activate_lens*(this: LensNode, index: int): bool {.importcpp: "#->activate_lens(#)".} ## \
## An alternate way to call set_lens_active(index, true).

proc deactivate_lens*(this: LensNode, index: int): bool {.importcpp: "#->deactivate_lens(#)".} ## \
## An alternate way to call set_lens_active(index, false).

proc is_in_view*(this: LensNode, pos: LPoint3): bool {.importcpp: "#->is_in_view(#)".} ## \
## Returns true if the given point is within the bounds of the lens of the
## LensNode (i.e.  if the camera can see the point).

proc is_in_view*(this: LensNode, index: int, pos: LPoint3): bool {.importcpp: "#->is_in_view(#, #)".} ## \
## Returns true if the given point is within the bounds of the lens of the
## LensNode (i.e.  if the camera can see the point).

proc show_frustum*(this: LensNode) {.importcpp: "#->show_frustum()".} ## \
## Enables the drawing of the lens's frustum to aid in visualization.  This
## actually creates a GeomNode which is parented to the LensNode.

proc hide_frustum*(this: LensNode) {.importcpp: "#->hide_frustum()".} ## \
## Disables the drawing of the lens's frustum to aid in visualization.

proc get_class_type*(_: typedesc[LensNode]): TypeHandle {.importcpp: "LensNode::get_class_type()", header: "lensNode.h".}

proc initWeakNodePath*(node_path: NodePath): WeakNodePath {.importcpp: "WeakNodePath(#)".}

proc initWeakNodePath*(copy: WeakNodePath): WeakNodePath {.importcpp: "WeakNodePath(#)".}

proc clear*(this: WeakNodePath) {.importcpp: "#.clear()".} ## \
## Sets this NodePath to the empty NodePath.  It will no longer point to any
## node.

proc `typecast bool`*(this: WeakNodePath): bool {.importcpp: "#.operator typecast bool()".}

proc is_empty*(this: WeakNodePath): bool {.importcpp: "#.is_empty()".} ## \
## Returns true if the NodePath contains no nodes, or if it has been deleted.

proc was_deleted*(this: WeakNodePath): bool {.importcpp: "#.was_deleted()".} ## \
## Returns true if the NodePath we were referencing has been quietly deleted
## outside of the WeakNodePath.

proc get_node_path*(this: WeakNodePath): NodePath {.importcpp: "#.get_node_path()".} ## \
## Returns the NodePath held within this object, or an empty NodePath with the
## error flag set if the object was deleted.

proc node*(this: WeakNodePath): PandaNode {.importcpp: "#.node()".} ## \
## Returns the PandaNode held within this object, or nullptr if the object was
## deleted.

proc `==`*(this: WeakNodePath, other: NodePath): bool {.importcpp: "#.operator ==(#)".}

proc `==`*(this: WeakNodePath, other: WeakNodePath): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: WeakNodePath, other: NodePath): bool {.importcpp: "#.operator !=(#)".}

proc `!=`*(this: WeakNodePath, other: WeakNodePath): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: WeakNodePath, other: NodePath): bool {.importcpp: "#.operator <(#)".}

proc `<`*(this: WeakNodePath, other: WeakNodePath): bool {.importcpp: "#.operator <(#)".}

proc compare_to*(this: WeakNodePath, other: NodePath): int {.importcpp: "#.compare_to(#)".} ## \
## Returns a number less than zero if this NodePath sorts before the other
## one, greater than zero if it sorts after, or zero if they are equivalent.
##
## Two NodePaths are considered equivalent if they consist of exactly the same
## list of nodes in the same order.  Otherwise, they are different; different
## NodePaths will be ranked in a consistent but undefined ordering; the
## ordering is useful only for placing the NodePaths in a sorted container
## like an STL set.

proc compare_to*(this: WeakNodePath, other: WeakNodePath): int {.importcpp: "#.compare_to(#)".} ## \
## Returns a number less than zero if this WeakNodePath sorts before the other
## one, greater than zero if it sorts after, or zero if they are equivalent.
##
## Two WeakNodePaths are considered equivalent if they consist of exactly the
## same list of nodes in the same order.  Otherwise, they are different;
## different WeakNodePaths will be ranked in a consistent but undefined
## ordering; the ordering is useful only for placing the WeakNodePaths in a
## sorted container like an STL set.

proc get_key*(this: WeakNodePath): int {.importcpp: "#.get_key()".} ## \
## Returns the same values as NodePath::get_key().

proc output*(this: WeakNodePath, `out`: ostream) {.importcpp: "#.output(#)".}

proc newCamera*(copy: Camera): Camera {.importcpp: "new Camera(#)".}

proc newCamera*(name: string, lens: Lens): Camera {.importcpp: "new Camera(nimStringToStdString(#), #)", header: stringConversionCode.}

proc newCamera*(name: string): Camera {.importcpp: "new Camera(nimStringToStdString(#))", header: stringConversionCode.}

proc set_active*(this: Camera, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets the active flag on the camera.  When the camera is not active, nothing
## will be rendered.

proc is_active*(this: Camera): bool {.importcpp: "#->is_active()".} ## \
## Returns the current setting of the active flag on the camera.

proc set_scene*(this: Camera, scene: NodePath) {.importcpp: "#->set_scene(#)".} ## \
## Sets the scene that will be rendered by the camera.  This is normally the
## root node of a scene graph, typically a node called 'render', although it
## could represent the root of any subgraph.
##
## Note that the use of this method is now deprecated.  In the absence of an
## explicit scene set on the camera, the camera will render whatever scene it
## is parented into.  This is the preferred way to specify the scene, since it
## is the more intuitive mechanism.

proc get_scene*(this: Camera): NodePath {.importcpp: "#->get_scene()".} ## \
## Returns the scene that will be rendered by the camera.  See set_scene().

proc get_num_display_regions*(this: Camera): clonglong {.importcpp: "#->get_num_display_regions()".} ## \
## Returns the number of display regions associated with the camera.

proc get_display_region*(this: Camera, n: clonglong): DisplayRegion {.importcpp: "#->get_display_region(#)".} ## \
## Returns the nth display region associated with the camera.

proc set_cull_center*(this: Camera, cull_center: NodePath) {.importcpp: "#->set_cull_center(#)".} ## \
## Specifies the point from which the culling operations are performed.
## Normally, this is the same as the camera, and that is the default if this
## is not specified; but it may sometimes be useful to perform the culling
## from some other viewpoint, particularly when you are debugging the culling
## itself.

proc get_cull_center*(this: Camera): NodePath {.importcpp: "#->get_cull_center()".} ## \
## Returns the point from which the culling operations will be performed, if
## it was set by set_cull_center(), or the empty NodePath otherwise.

proc set_cull_bounds*(this: Camera, cull_bounds: BoundingVolume) {.importcpp: "#->set_cull_bounds(#)".} ## \
## Specifies the bounding volume that should be used to perform culling from
## this camera.  Normally, this is the bounding volume returned from the
## active lens' make_bounds() call, but you may override this to specify a
## custom volume if you require.  The specified bounding volume will be
## understood to be in the coordinate space of the get_cull_center() node.

proc get_cull_bounds*(this: Camera): BoundingVolume {.importcpp: "#->get_cull_bounds()".} ## \
## Returns the custom cull volume that was set by set_cull_bounds(), if any,
## or NULL if no custom cull volume was set.

proc set_lod_center*(this: Camera, lod_center: NodePath) {.importcpp: "#->set_lod_center(#)".} ## \
## Specifies the point from which the LOD distances are measured.  Normally,
## this is the same as the camera, and that is the default if this is not
## specified; but it may sometimes be useful to perform the distance test from
## some other viewpoint.  This may be used, for instance, to reduce LOD
## popping when the camera rotates in a small circle about an avatar.

proc get_lod_center*(this: Camera): NodePath {.importcpp: "#->get_lod_center()".} ## \
## Returns the point from which the LOD distances will be measured, if it was
## set by set_lod_center(), or the empty NodePath otherwise.

proc set_initial_state*(this: Camera, state: RenderState) {.importcpp: "#->set_initial_state(#)".} ## \
## Sets the initial state which is applied to all nodes in the scene, as if it
## were set at the top of the scene graph.

proc get_initial_state*(this: Camera): RenderState {.importcpp: "#->get_initial_state()".} ## \
## Returns the initial state as set by a previous call to set_initial_state().

proc set_tag_state_key*(this: Camera, tag_state_key: string) {.importcpp: "#->set_tag_state_key(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the tag key which, when encountered as a tag on nodes in the scene
## graph, causes this Camera to apply an arbitrary state transition based on
## the value of the tag (as specified to set_tag_state()).

proc get_tag_state_key*(this: Camera): string {.importcpp: "nimStringFromStdString(#->get_tag_state_key())", header: stringConversionCode.} ## \
## Returns the tag key as set by a previous call to set_tag_state_key().

proc set_lod_scale*(this: Camera, value: float32) {.importcpp: "#->set_lod_scale(#)".} ## \
## Sets the multiplier for LOD distances.  This value is multiplied with the
## LOD scale set on LodNodes.

proc get_lod_scale*(this: Camera): float32 {.importcpp: "#->get_lod_scale()".} ## \
## Returns the multiplier for LOD distances.

proc set_tag_state*(this: Camera, tag_state: string, state: RenderState) {.importcpp: "#->set_tag_state(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Associates a particular state transition with the indicated tag value.
## When a node is encountered during traversal with the tag key specified by
## set_tag_state_key(), if the value of that tag matches tag_state, then the
## indicated state is applied to this node--but only when it is rendered by
## this camera.
##
## This can be used to apply special effects to nodes when they are rendered
## by certain cameras.  It is particularly useful for multipass rendering, in
## which specialty cameras might be needed to render the scene with a
## particular set of effects.

proc clear_tag_state*(this: Camera, tag_state: string) {.importcpp: "#->clear_tag_state(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the association established by a previous call to set_tag_state().

proc clear_tag_states*(this: Camera) {.importcpp: "#->clear_tag_states()".} ## \
## Removes all associations established by previous calls to set_tag_state().

proc has_tag_state*(this: Camera, tag_state: string): bool {.importcpp: "#->has_tag_state(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if set_tag_state() has previously been called with the
## indicated tag state, false otherwise.

proc get_tag_state*(this: Camera, tag_state: string): RenderState {.importcpp: "#->get_tag_state(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the state associated with the indicated tag state by a previous
## call to set_tag_state(), or the empty state if nothing has been associated.

proc set_aux_scene_data*(this: Camera, node_path: NodePath, data: AuxSceneData) {.importcpp: "#->set_aux_scene_data(#, #)".} ## \
## Associates the indicated AuxSceneData object with the given NodePath,
## possibly replacing a previous data defined for the same NodePath, if any.

proc clear_aux_scene_data*(this: Camera, node_path: NodePath): bool {.importcpp: "#->clear_aux_scene_data(#)".} ## \
## Removes the AuxSceneData associated with the indicated NodePath.  Returns
## true if it is removed successfully, false if it was already gone.

proc get_aux_scene_data*(this: Camera, node_path: NodePath): AuxSceneData {.importcpp: "#->get_aux_scene_data(#)".} ## \
## Returns the AuxSceneData associated with the indicated NodePath, or NULL if
## nothing is associated.

proc list_aux_scene_data*(this: Camera, `out`: ostream) {.importcpp: "#->list_aux_scene_data(#)".} ## \
## Outputs all of the NodePaths and AuxSceneDatas in use.

proc cleanup_aux_scene_data*(this: Camera, current_thread: Thread): int {.importcpp: "#->cleanup_aux_scene_data(#)".} ## \
## Walks through the list of currently-assigned AuxSceneData objects and
## releases any that are past their expiration times.  Returns the number of
## elements released.

proc cleanup_aux_scene_data*(this: Camera): int {.importcpp: "#->cleanup_aux_scene_data()".} ## \
## Walks through the list of currently-assigned AuxSceneData objects and
## releases any that are past their expiration times.  Returns the number of
## elements released.

proc get_class_type*(_: typedesc[Camera]): TypeHandle {.importcpp: "Camera::get_class_type()", header: "camera.h".}

proc newPlaneNode*(name: string, plane: LPlane): PlaneNode {.importcpp: "new PlaneNode(nimStringToStdString(#), #)", header: stringConversionCode.}

proc newPlaneNode*(name: string): PlaneNode {.importcpp: "new PlaneNode(nimStringToStdString(#))", header: stringConversionCode.}

proc set_plane*(this: PlaneNode, plane: LPlane) {.importcpp: "#->set_plane(#)".} ## \
## Sets the particular plane represented by the PlaneNode.

proc get_plane*(this: PlaneNode): LPlane {.importcpp: "#->get_plane()".} ## \
## Returns the plane represented by the PlaneNode.

proc set_viz_scale*(this: PlaneNode, viz_scale: float32) {.importcpp: "#->set_viz_scale(#)".} ## \
## Specifies the size of the visual representation of the plane that is drawn
## if the PlaneNode is shown.

proc get_viz_scale*(this: PlaneNode): float32 {.importcpp: "#->get_viz_scale()".} ## \
## Returns the size of the visual representation of the plane that is drawn if
## the PlaneNode is shown.

proc set_priority*(this: PlaneNode, priority: int) {.importcpp: "#->set_priority(#)".} ## \
## Changes the relative importance of this PlaneNode (when it is used as a
## clip plane) relative to the other clip planes that are applied
## simultaneously.
##
## The priority number is used to decide which of the requested clip planes
## are to be activated when more clip planes are requested than the hardware
## will support.  The highest-priority n planes are selected for rendering.
##
## This is similar to TextureStage::set_priority().

proc get_priority*(this: PlaneNode): int {.importcpp: "#->get_priority()".} ## \
## Returns the priority associated with this clip plane.  See set_priority().

proc set_clip_effect*(this: PlaneNode, clip_effect: int) {.importcpp: "#->set_clip_effect(#)".} ## \
## Specifies the sort of things this plane will actually clip (when it is used
## as a clip plane).  This is a bitmask union of ClipEffect values.  If it
## includes CE_visible, then it will clip visible geometry; if it includes
## CE_collision, then it will clip collision polygons.  If it includes neither
## bit, it will still affect culling, but objects will either be wholly behind
## the clipping plane, or wholly present.

proc get_clip_effect*(this: PlaneNode): int {.importcpp: "#->get_clip_effect()".} ## \
## Returns the clip_effect bits for this clip plane.  See set_clip_effect().

proc get_class_type*(_: typedesc[PlaneNode]): TypeHandle {.importcpp: "PlaneNode::get_class_type()", header: "planeNode.h".}

proc make*(_: typedesc[ClipPlaneAttrib]): RenderAttrib {.importcpp: "ClipPlaneAttrib::make()", header: "clipPlaneAttrib.h".} ## \
## The following is the new, more general interface to the ClipPlaneAttrib.

proc make_default*(_: typedesc[ClipPlaneAttrib]): RenderAttrib {.importcpp: "ClipPlaneAttrib::make_default()", header: "clipPlaneAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc get_num_planes*(this: ClipPlaneAttrib): int {.importcpp: "#->get_num_planes()".} ## \
## Returns the number of planes listed in the attribute.
##
## @deprecated ClipPlaneAttribs nowadays have a separate list of on_planes and
## off_planes, so this method no longer makes sense.  Query the lists
## independently.

proc get_plane*(this: ClipPlaneAttrib, n: int): PlaneNode {.importcpp: "#->get_plane(#)".} ## \
## Returns the nth plane listed in the attribute.
##
## @deprecated ClipPlaneAttribs nowadays have a separate list of on_planes and
## off_planes, so this method no longer makes sense.  Query the lists
## independently.

proc has_plane*(this: ClipPlaneAttrib, plane: PlaneNode): bool {.importcpp: "#->has_plane(#)".} ## \
## Returns true if the indicated plane is listed in the attrib, false
## otherwise.
##
## @deprecated ClipPlaneAttribs nowadays have a separate list of on_planes and
## off_planes, so this method no longer makes sense.  Query the lists
## independently.

proc add_plane*(this: ClipPlaneAttrib, plane: PlaneNode): RenderAttrib {.importcpp: "#->add_plane(#)".} ## \
## Returns a new ClipPlaneAttrib, just like this one, but with the indicated
## plane added to the list of planes.
##
## @deprecated Use add_on_plane() or add_off_plane() instead.

proc remove_plane*(this: ClipPlaneAttrib, plane: PlaneNode): RenderAttrib {.importcpp: "#->remove_plane(#)".} ## \
## Returns a new ClipPlaneAttrib, just like this one, but with the indicated
## plane removed from the list of planes.
##
## @deprecated Use remove_on_plane() or remove_off_plane() instead.

proc make_all_off*(_: typedesc[ClipPlaneAttrib]): RenderAttrib {.importcpp: "ClipPlaneAttrib::make_all_off()", header: "clipPlaneAttrib.h".} ## \
## Constructs a new ClipPlaneAttrib object that disables all planes (and hence
## disables clipping).

proc get_num_on_planes*(this: ClipPlaneAttrib): int {.importcpp: "#->get_num_on_planes()".} ## \
## Returns the number of planes that are enabled by the attribute.

proc get_on_plane*(this: ClipPlaneAttrib, n: int): NodePath {.importcpp: "#->get_on_plane(#)".} ## \
## Returns the nth plane enabled by the attribute, sorted in render order.

proc has_on_plane*(this: ClipPlaneAttrib, plane: NodePath): bool {.importcpp: "#->has_on_plane(#)".} ## \
## Returns true if the indicated plane is enabled by the attrib, false
## otherwise.

proc get_num_off_planes*(this: ClipPlaneAttrib): int {.importcpp: "#->get_num_off_planes()".} ## \
## Returns the number of planes that are disabled by the attribute.

proc get_off_plane*(this: ClipPlaneAttrib, n: int): NodePath {.importcpp: "#->get_off_plane(#)".} ## \
## Returns the nth plane disabled by the attribute, sorted in arbitrary
## (pointer) order.

proc has_off_plane*(this: ClipPlaneAttrib, plane: NodePath): bool {.importcpp: "#->has_off_plane(#)".} ## \
## Returns true if the indicated plane is disabled by the attrib, false
## otherwise.

proc has_all_off*(this: ClipPlaneAttrib): bool {.importcpp: "#->has_all_off()".} ## \
## Returns true if this attrib disables all planes (although it may also
## enable some).

proc is_identity*(this: ClipPlaneAttrib): bool {.importcpp: "#->is_identity()".} ## \
## Returns true if this is an identity attrib: it does not change the set of
## planes in use.

proc add_on_plane*(this: ClipPlaneAttrib, plane: NodePath): RenderAttrib {.importcpp: "#->add_on_plane(#)".} ## \
## Returns a new ClipPlaneAttrib, just like this one, but with the indicated
## plane added to the list of planes enabled by this attrib.

proc remove_on_plane*(this: ClipPlaneAttrib, plane: NodePath): RenderAttrib {.importcpp: "#->remove_on_plane(#)".} ## \
## Returns a new ClipPlaneAttrib, just like this one, but with the indicated
## plane removed from the list of planes enabled by this attrib.

proc add_off_plane*(this: ClipPlaneAttrib, plane: NodePath): RenderAttrib {.importcpp: "#->add_off_plane(#)".} ## \
## Returns a new ClipPlaneAttrib, just like this one, but with the indicated
## plane added to the list of planes disabled by this attrib.

proc remove_off_plane*(this: ClipPlaneAttrib, plane: NodePath): RenderAttrib {.importcpp: "#->remove_off_plane(#)".} ## \
## Returns a new ClipPlaneAttrib, just like this one, but with the indicated
## plane removed from the list of planes disabled by this attrib.

proc filter_to_max*(this: ClipPlaneAttrib, max_clip_planes: int): ClipPlaneAttrib {.importcpp: "#->filter_to_max(#)".} ## \
## Returns a new ClipPlaneAttrib, very much like this one, but with the number
## of on_planes reduced to be no more than max_clip_planes.  The number of
## off_planes in the new ClipPlaneAttrib is undefined.

proc get_class_slot*(_: typedesc[ClipPlaneAttrib]): int {.importcpp: "ClipPlaneAttrib::get_class_slot()", header: "clipPlaneAttrib.h".}

proc get_class_type*(_: typedesc[ClipPlaneAttrib]): TypeHandle {.importcpp: "ClipPlaneAttrib::get_class_type()", header: "clipPlaneAttrib.h".}

proc make_vertex*(_: typedesc[ColorAttrib]): RenderAttrib {.importcpp: "ColorAttrib::make_vertex()", header: "colorAttrib.h".} ## \
## Constructs a new ColorAttrib object that indicates geometry should be
## rendered according to its own vertex color.

proc make_flat*(_: typedesc[ColorAttrib], color: LColor): RenderAttrib {.importcpp: "ColorAttrib::make_flat(#)", header: "colorAttrib.h".} ## \
## Constructs a new ColorAttrib object that indicates geometry should be
## rendered in the indicated color.

proc make_off*(_: typedesc[ColorAttrib]): RenderAttrib {.importcpp: "ColorAttrib::make_off()", header: "colorAttrib.h".} ## \
## Constructs a new ColorAttrib object that indicates geometry should be
## rendered in white.

proc make_default*(_: typedesc[ColorAttrib]): RenderAttrib {.importcpp: "ColorAttrib::make_default()", header: "colorAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc get_color*(this: ColorAttrib): LColor {.importcpp: "#->get_color()".} ## \
## If the type is T_flat or T_off, this returns the color that will be applied
## to geometry.  If the type is T_vertex, this is meaningless.

proc get_class_slot*(_: typedesc[ColorAttrib]): int {.importcpp: "ColorAttrib::get_class_slot()", header: "colorAttrib.h".}

proc get_class_type*(_: typedesc[ColorAttrib]): TypeHandle {.importcpp: "ColorAttrib::get_class_type()", header: "colorAttrib.h".}

proc make_off*(_: typedesc[ColorBlendAttrib]): RenderAttrib {.importcpp: "ColorBlendAttrib::make_off()", header: "colorBlendAttrib.h".} ## \
## Constructs a new ColorBlendAttrib object that disables special-effect
## blending, allowing normal transparency to be used instead.

proc make_default*(_: typedesc[ColorBlendAttrib]): RenderAttrib {.importcpp: "ColorBlendAttrib::make_default()", header: "colorBlendAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc get_color*(this: ColorBlendAttrib): LColor {.importcpp: "#->get_color()".} ## \
## Returns the constant color associated with the attrib.

proc involves_constant_color*(this: ColorBlendAttrib): bool {.importcpp: "#->involves_constant_color()".} ## \
## Returns true if the this attrib uses the constant color, false otherwise.

proc involves_color_scale*(this: ColorBlendAttrib): bool {.importcpp: "#->involves_color_scale()".} ## \
## Returns true if the this attrib uses the color scale attrib, false
## otherwise.

proc get_class_slot*(_: typedesc[ColorBlendAttrib]): int {.importcpp: "ColorBlendAttrib::get_class_slot()", header: "colorBlendAttrib.h".}

proc get_class_type*(_: typedesc[ColorBlendAttrib]): TypeHandle {.importcpp: "ColorBlendAttrib::get_class_type()", header: "colorBlendAttrib.h".}

proc make_identity*(_: typedesc[ColorScaleAttrib]): RenderAttrib {.importcpp: "ColorScaleAttrib::make_identity()", header: "colorScaleAttrib.h".} ## \
## Constructs an identity scale attrib.

proc make*(_: typedesc[ColorScaleAttrib], scale: LVecBase4): RenderAttrib {.importcpp: "ColorScaleAttrib::make(#)", header: "colorScaleAttrib.h".} ## \
## Constructs a new ColorScaleAttrib object that indicates geometry should be
## scaled by the indicated factor.

proc make_off*(_: typedesc[ColorScaleAttrib]): RenderAttrib {.importcpp: "ColorScaleAttrib::make_off()", header: "colorScaleAttrib.h".} ## \
## Constructs a new ColorScaleAttrib object that ignores any ColorScaleAttrib
## inherited from above.  You may also specify an additional color scale to
## apply to geometry below (using set_scale()).

proc make_default*(_: typedesc[ColorScaleAttrib]): RenderAttrib {.importcpp: "ColorScaleAttrib::make_default()", header: "colorScaleAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc is_off*(this: ColorScaleAttrib): bool {.importcpp: "#->is_off()".} ## \
## Returns true if the ColorScaleAttrib will ignore any color scales inherited
## from above, false otherwise.  This is not the same thing as !has_scale(); a
## ColorScaleAttrib may have the "off" flag set and also have another scale
## specified.

proc is_identity*(this: ColorScaleAttrib): bool {.importcpp: "#->is_identity()".} ## \
## Returns true if the ColorScaleAttrib is an identity attrib, false if it is
## either an off attrib or it has a scale.

proc has_scale*(this: ColorScaleAttrib): bool {.importcpp: "#->has_scale()".} ## \
## Returns true if the ColorScaleAttrib has a non-identity scale, false
## otherwise (in which case it might be an off attrib or an identity attrib).

proc has_rgb_scale*(this: ColorScaleAttrib): bool {.importcpp: "#->has_rgb_scale()".} ## \
## Returns true if the ColorScaleAttrib has a non-identity scale in the RGB
## components (ignoring alpha), or false otherwise.

proc has_alpha_scale*(this: ColorScaleAttrib): bool {.importcpp: "#->has_alpha_scale()".} ## \
## Returns true if the ColorScaleAttrib has a non-identity scale in the alpha
## component (ignoring RGB), or false otherwise.

proc get_scale*(this: ColorScaleAttrib): LVecBase4 {.importcpp: "#->get_scale()".} ## \
## Returns the scale to be applied to colors.

proc set_scale*(this: ColorScaleAttrib, scale: LVecBase4): RenderAttrib {.importcpp: "#->set_scale(#)".} ## \
## Returns a new ColorScaleAttrib, just like this one, but with the scale
## changed to the indicated value.

proc get_class_slot*(_: typedesc[ColorScaleAttrib]): int {.importcpp: "ColorScaleAttrib::get_class_slot()", header: "colorScaleAttrib.h".}

proc get_class_type*(_: typedesc[ColorScaleAttrib]): TypeHandle {.importcpp: "ColorScaleAttrib::get_class_type()", header: "colorScaleAttrib.h".}

proc make*(_: typedesc[ColorWriteAttrib], channels: int): RenderAttrib {.importcpp: "ColorWriteAttrib::make(#)", header: "colorWriteAttrib.h".} ## \
## Constructs a new ColorWriteAttrib object.

proc make_default*(_: typedesc[ColorWriteAttrib]): RenderAttrib {.importcpp: "ColorWriteAttrib::make_default()", header: "colorWriteAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc get_channels*(this: ColorWriteAttrib): int {.importcpp: "#->get_channels()".} ## \
## Returns the mask of color channels that are enabled by this attrib.

proc get_class_slot*(_: typedesc[ColorWriteAttrib]): int {.importcpp: "ColorWriteAttrib::get_class_slot()", header: "colorWriteAttrib.h".}

proc get_class_type*(_: typedesc[ColorWriteAttrib]): TypeHandle {.importcpp: "ColorWriteAttrib::get_class_type()", header: "colorWriteAttrib.h".}

proc make*(_: typedesc[CompassEffect], reference: NodePath, properties: int): RenderEffect {.importcpp: "CompassEffect::make(#, #)", header: "compassEffect.h".} ## \
## Constructs a new CompassEffect object.  If the reference is an empty
## NodePath, it means the CompassEffect is relative to the root of the scene
## graph; otherwise, it's relative to the indicated node.  The properties
## bitmask specifies the set of properties that the compass node inherits from
## the reference instead of from its parent.

proc make*(_: typedesc[CompassEffect], reference: NodePath): RenderEffect {.importcpp: "CompassEffect::make(#)", header: "compassEffect.h".} ## \
## Constructs a new CompassEffect object.  If the reference is an empty
## NodePath, it means the CompassEffect is relative to the root of the scene
## graph; otherwise, it's relative to the indicated node.  The properties
## bitmask specifies the set of properties that the compass node inherits from
## the reference instead of from its parent.

proc get_reference*(this: CompassEffect): NodePath {.importcpp: "#->get_reference()".} ## \
## Returns the reference node from which the CompassEffect inherits its
## transform.  If this is empty, it means the root of the scene graph.

proc get_properties*(this: CompassEffect): int {.importcpp: "#->get_properties()".} ## \
## Returns the bitmask of properties that this CompassEffect object inherits
## from its reference node (or from the root).

proc get_class_type*(_: typedesc[CompassEffect]): TypeHandle {.importcpp: "CompassEffect::get_class_type()", header: "compassEffect.h".}

proc initCullBinEnums*(): CullBinEnums {.importcpp: "CullBinEnums()".}

proc initCullBinEnums*(param0: CullBinEnums): CullBinEnums {.importcpp: "CullBinEnums(#)".}

proc newGeomNode*(name: string): GeomNode {.importcpp: "new GeomNode(nimStringToStdString(#))", header: stringConversionCode.}

proc set_preserved*(this: GeomNode, value: bool) {.importcpp: "#->set_preserved(#)".} ## \
## Sets the "preserved" flag.  When this is true, the GeomNode will be left
## untouched by any flatten operations.

proc get_preserved*(this: GeomNode): bool {.importcpp: "#->get_preserved()".} ## \
## Returns the "preserved" flag.  When this is true, the GeomNode will be left
## untouched by any flatten operations.

proc get_num_geoms*(this: GeomNode): int {.importcpp: "#->get_num_geoms()".} ## \
## Returns the number of geoms in the node.

proc get_geom*(this: GeomNode, n: int): Geom {.importcpp: "#->get_geom(#)".} ## \
## Returns the nth geom of the node.  This object should not be modified,
## since the same object might be shared between multiple different GeomNodes,
## but see modify_geom().

proc modify_geom*(this: GeomNode, n: int): Geom {.importcpp: "#->modify_geom(#)".} ## \
## Returns the nth geom of the node, suitable for modifying it.  If the nth
## Geom has multiple reference counts to it, reassigns it to an identical copy
## first, and returns the new copy--this provides a "copy on write" that
## ensures that the Geom that is returned is unique to this GeomNode and is
## not shared with any other GeomNodes.
##
## Note that if this method is called in a downstream stage (for instance,
## during cull or draw), then it will propagate the new list of Geoms upstream
## all the way to pipeline stage 0, which may step on changes that were made
## independently in pipeline stage 0. Use with caution.

proc get_geom_state*(this: GeomNode, n: int): RenderState {.importcpp: "#->get_geom_state(#)".} ## \
## Returns the RenderState associated with the nth geom of the node.  This is
## just the RenderState directly associated with the Geom; the actual state in
## which the Geom is rendered will also be affected by RenderStates that
## appear on the scene graph in nodes above this GeomNode.

proc set_geom_state*(this: GeomNode, n: int, state: RenderState) {.importcpp: "#->set_geom_state(#, #)".} ## \
## Changes the RenderState associated with the nth geom of the node.  This is
## just the RenderState directly associated with the Geom; the actual state in
## which the Geom is rendered will also be affected by RenderStates that
## appear on the scene graph in nodes above this GeomNode.
##
## Note that if this method is called in a downstream stage (for instance,
## during cull or draw), then it will propagate the new list of Geoms upstream
## all the way to pipeline stage 0, which may step on changes that were made
## independently in pipeline stage 0. Use with caution.

proc add_geom*(this: GeomNode, geom: Geom, state: RenderState) {.importcpp: "#->add_geom(#, #)".} ## \
## Adds a new Geom to the node.  The geom is given the indicated state (which
## may be RenderState::make_empty(), to completely inherit its state from the
## scene graph).

proc add_geom*(this: GeomNode, geom: Geom) {.importcpp: "#->add_geom(#)".} ## \
## Adds a new Geom to the node.  The geom is given the indicated state (which
## may be RenderState::make_empty(), to completely inherit its state from the
## scene graph).

proc add_geoms_from*(this: GeomNode, other: GeomNode) {.importcpp: "#->add_geoms_from(#)".} ## \
## Copies the Geoms (and their associated RenderStates) from the indicated
## GeomNode into this one.

proc set_geom*(this: GeomNode, n: int, geom: Geom) {.importcpp: "#->set_geom(#, #)".} ## \
## Replaces the nth Geom of the node with a new pointer.  There must already
## be a Geom in this slot.
##
## Note that if this method is called in a downstream stage (for instance,
## during cull or draw), then it will propagate the new list of Geoms upstream
## all the way to pipeline stage 0, which may step on changes that were made
## independently in pipeline stage 0. Use with caution.

proc remove_geom*(this: GeomNode, n: int) {.importcpp: "#->remove_geom(#)".} ## \
## Removes the nth geom from the node.

proc remove_all_geoms*(this: GeomNode) {.importcpp: "#->remove_all_geoms()".} ## \
## Removes all the geoms from the node at once.

proc check_valid*(this: GeomNode): bool {.importcpp: "#->check_valid()".} ## \
## Verifies that the each Geom within the GeomNode reference vertices that
## actually exist within its GeomVertexData.  Returns true if the GeomNode
## appears to be valid, false otherwise.

proc decompose*(this: GeomNode) {.importcpp: "#->decompose()".} ## \
## Calls decompose() on each Geom with the GeomNode.  This decomposes higher-
## order primitive types, like triangle strips, into lower-order types like
## indexed triangles.  Normally there is no reason to do this, but it can be
## useful as an early preprocessing step, to allow a later call to unify() to
## proceed more quickly.
##
## See also SceneGraphReducer::decompose(), which is the normal way this is
## called.

proc unify*(this: GeomNode, max_indices: int, preserve_order: bool) {.importcpp: "#->unify(#, #)".} ## \
## Attempts to unify all of the Geoms contained within this node into a single
## Geom, or at least as few Geoms as possible.  In turn, the individual
## GeomPrimitives contained within each resulting Geom are also unified.  The
## goal is to reduce the number of GeomPrimitives within the node as far as
## possible.  This may result in composite primitives, such as triangle strips
## and triangle fans, being decomposed into triangles.  See also
## Geom::unify().
##
## max_indices represents the maximum number of indices that will be put in
## any one GeomPrimitive.  If preserve_order is true, then the primitives will
## not be reordered during the operation, even if this results in a suboptimal
## result.
##
## In order for this to be successful, the primitives must reference the same
## GeomVertexData, have the same fundamental primitive type, and have
## compatible shade models.

proc write_geoms*(this: GeomNode, `out`: ostream, indent_level: int) {.importcpp: "#->write_geoms(#, #)".} ## \
## Writes a short description of all the Geoms in the node.

proc write_verbose*(this: GeomNode, `out`: ostream, indent_level: int) {.importcpp: "#->write_verbose(#, #)".} ## \
## Writes a detailed description of all the Geoms in the node.

proc get_class_type*(_: typedesc[GeomNode]): TypeHandle {.importcpp: "GeomNode::get_class_type()", header: "geomNode.h".}

proc make*(_: typedesc[CullBinAttrib], bin_name: string, draw_order: int): RenderAttrib {.importcpp: "CullBinAttrib::make(nimStringToStdString(#), #)", header: "cullBinAttrib.h".} ## \
## Constructs a new CullBinAttrib assigning geometry into the named bin.  If
## the bin name is the empty string, the default bin is used.
##
## The draw_order specifies further ordering information which is relevant
## only to certain kinds of bins (in particular CullBinFixed type bins).

proc make_default*(_: typedesc[CullBinAttrib]): RenderAttrib {.importcpp: "CullBinAttrib::make_default()", header: "cullBinAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc get_bin_name*(this: CullBinAttrib): string {.importcpp: "nimStringFromStdString(#->get_bin_name())", header: stringConversionCode.} ## \
## Returns the name of the bin this attribute specifies.  If this is the empty
## string, it refers to the default bin.

proc get_draw_order*(this: CullBinAttrib): int {.importcpp: "#->get_draw_order()".} ## \
## Returns the draw order this attribute specifies.  Some bins (in particular,
## CullBinFixed bins) use this to further specify the order in which objects
## should be rendered.

proc get_class_slot*(_: typedesc[CullBinAttrib]): int {.importcpp: "CullBinAttrib::get_class_slot()", header: "cullBinAttrib.h".}

proc get_class_type*(_: typedesc[CullBinAttrib]): TypeHandle {.importcpp: "CullBinAttrib::get_class_type()", header: "cullBinAttrib.h".}

proc remove_bin*(this: CullBinManager, bin_index: int) {.importcpp: "#.remove_bin(#)".} ## \
## Permanently removes the indicated bin.  This operation is not protected
## from the pipeline and will disturb whatever is currently rendering in draw.
## You should not call this during the normal course of rendering a frame; it
## is intended only as an aid to development, to allow the developer to
## interactively fiddle with the set of bins.

proc get_num_bins*(this: CullBinManager): int {.importcpp: "#.get_num_bins()".} ## \
## Returns the number of bins in the world.

proc get_bin*(this: CullBinManager, n: int): int {.importcpp: "#.get_bin(#)".} ## \
## Returns the bin_index of the nth bin in the set, where n is a number
## between 0 and get_num_bins(). This returns the list of bin_index numbers,
## in sorted order (that is, in the order in which the bins should be
## rendered).

proc find_bin*(this: CullBinManager, name: string): int {.importcpp: "#.find_bin(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the bin_index associated with the bin of the given name, or -1 if
## no bin has that name.

proc get_bin_name*(this: CullBinManager, bin_index: int): string {.importcpp: "nimStringFromStdString(#.get_bin_name(#))", header: stringConversionCode.} ## \
## Returns the name of the bin with the indicated bin_index (where bin_index
## was retrieved by get_bin() or find_bin()).  The bin's name may not be
## changed during the life of the bin.

proc get_bin_sort*(this: CullBinManager, bin_index: int): int {.importcpp: "#.get_bin_sort(#)".} ## \
## Returns the sort order of the bin with the indicated bin_index (where
## bin_index was retrieved by get_bin() or find_bin()).
##
## The bins are rendered in increasing order by their sort order; this number
## may be changed from time to time to reorder the bins.

proc get_bin_sort*(this: CullBinManager, name: string): int {.importcpp: "#.get_bin_sort(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the sort order of the bin with the indicated name.
##
## The bins are rendered in increasing order by their sort order; this number
## may be changed from time to time to reorder the bins.

proc set_bin_sort*(this: CullBinManager, bin_index: int, sort: int) {.importcpp: "#.set_bin_sort(#, #)".} ## \
## Changes the sort order of the bin with the indicated bin_index (where
## bin_index was retrieved by get_bin() or find_bin()).
##
## The bins are rendered in increasing order by their sort order; this number
## may be changed from time to time to reorder the bins.

proc set_bin_sort*(this: CullBinManager, name: string, sort: int) {.importcpp: "#.set_bin_sort(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Changes the sort order of the bin with the indicated name.
##
## The bins are rendered in increasing order by their sort order; this number
## may be changed from time to time to reorder the bins.

proc get_bin_active*(this: CullBinManager, bin_index: int): bool {.importcpp: "#.get_bin_active(#)".} ## \
## Returns the active flag of the bin with the indicated bin_index (where
## bin_index was retrieved by get_bin() or find_bin()).
##
## When a bin is marked inactive, all geometry assigned to it is not rendered.

proc get_bin_active*(this: CullBinManager, name: string): bool {.importcpp: "#.get_bin_active(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the active flag of the bin with the indicated name.
##
## When a bin is marked inactive, all geometry assigned to it is not rendered.

proc set_bin_active*(this: CullBinManager, bin_index: int, active: bool) {.importcpp: "#.set_bin_active(#, #)".} ## \
## Changes the active flag of the bin with the indicated bin_index (where
## bin_index was retrieved by get_bin() or find_bin()).
##
## When a bin is marked inactive, all geometry assigned to it is not rendered.

proc set_bin_active*(this: CullBinManager, name: string, active: bool) {.importcpp: "#.set_bin_active(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Changes the active flag of the bin with the indicated name.
##
## When a bin is marked inactive, all geometry assigned to it is not rendered.

proc get_bin_flash_active*(this: CullBinManager, bin_index: int): bool {.importcpp: "#.get_bin_flash_active(#)".} ## \
## Returns true if the bin with the given bin_index is configured to flash at
## a predetermined color (where bin_index was retrieved by get_bin() or
## find_bin()).
##
## This method is not available in release builds.

proc get_bin_flash_color*(this: CullBinManager, bin_index: int): LColor {.importcpp: "#.get_bin_flash_color(#)".} ## \
## Returns the color that this bin has been configured to flash to, if
## configured.
##
## This method is not available in release builds.

proc set_bin_flash_active*(this: CullBinManager, bin_index: int, active: bool) {.importcpp: "#.set_bin_flash_active(#, #)".} ## \
## When set to true, the given bin_index is configured to flash at a
## predetermined color (where bin_index was retrieved by get_bin() or
## find_bin()).
##
## This method is not available in release builds.

proc set_bin_flash_color*(this: CullBinManager, bin_index: int, color: LColor) {.importcpp: "#.set_bin_flash_color(#, #)".} ## \
## Changes the flash color for the given bin index.
##
## This method is not available in release builds.

proc write*(this: CullBinManager, `out`: ostream) {.importcpp: "#.write(#)".}

proc get_global_ptr*(_: typedesc[CullBinManager]): CullBinManager {.importcpp: "CullBinManager::get_global_ptr()", header: "cullBinManager.h".} ## \
## Returns the pointer to the global CullBinManager object.

proc make*(_: typedesc[CullFaceAttrib]): RenderAttrib {.importcpp: "CullFaceAttrib::make()", header: "cullFaceAttrib.h".} ## \
## Constructs a new CullFaceAttrib object that specifies how to cull geometry.
## By Panda convention, vertices are ordered counterclockwise when seen from
## the front, so the M_cull_clockwise will cull backfacing polygons.
##
## M_cull_unchanged is an identity attrib; if this is applied to vertices
## without any other intervening attrib, it is the same as applying the
## default attrib.

proc make_reverse*(_: typedesc[CullFaceAttrib]): RenderAttrib {.importcpp: "CullFaceAttrib::make_reverse()", header: "cullFaceAttrib.h".} ## \
## Constructs a new CullFaceAttrib object that reverses the effects of any
## other CullFaceAttrib objects in the scene graph.  M_cull_clockwise will be
## treated as M_cull_counter_clockwise, and vice-versa.  M_cull_none is
## unchanged.

proc make_default*(_: typedesc[CullFaceAttrib]): RenderAttrib {.importcpp: "CullFaceAttrib::make_default()", header: "cullFaceAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc get_reverse*(this: CullFaceAttrib): bool {.importcpp: "#->get_reverse()".} ## \
## Returns the 'reverse' flag.  If this is true, the actual cull direction
## (clockwise vs.  counterclockwise) is the reverse of what is specified here.
## This allows support for make_reverse(), which defines a CullFaceAttrib that
## reverses whatever the sense of culling would have been.

proc get_class_slot*(_: typedesc[CullFaceAttrib]): int {.importcpp: "CullFaceAttrib::get_class_slot()", header: "cullFaceAttrib.h".}

proc get_class_type*(_: typedesc[CullFaceAttrib]): TypeHandle {.importcpp: "CullFaceAttrib::get_class_type()", header: "cullFaceAttrib.h".}

proc node*(this: CullTraverserData): PandaNode {.importcpp: "#.node()".} ## \
## Returns the node traversed to so far.

proc get_modelview_transform*(this: CullTraverserData, trav: CullTraverser): TransformState {.importcpp: "#.get_modelview_transform(#)".} ## \
## Returns the modelview transform: the relative transform from the camera to
## the model.

proc get_internal_transform*(this: CullTraverserData, trav: CullTraverser): TransformState {.importcpp: "#.get_internal_transform(#)".} ## \
## Returns the internal transform: the modelview transform in the GSG's
## internal coordinate system.

proc get_net_transform*(this: CullTraverserData, trav: CullTraverser): TransformState {.importcpp: "#.get_net_transform(#)".} ## \
## Returns the net transform: the relative transform from root of the scene
## graph to the current node.

proc apply_transform_and_state*(this: CullTraverserData, trav: CullTraverser) {.importcpp: "#.apply_transform_and_state(#)".} ## \
## Applies the transform and state from the current node onto the current
## data.  This also evaluates billboards, etc.

proc apply_transform*(this: CullTraverserData, node_transform: TransformState) {.importcpp: "#.apply_transform(#)".} ## \
## Applies the indicated transform changes onto the current data.

proc initCullTraverserData*(param0: CullTraverserData): CullTraverserData {.importcpp: "CullTraverserData(#)".}

proc set_display_region*(this: SceneSetup, display_region: DisplayRegion) {.importcpp: "#->set_display_region(#)".} ## \
## Specifies the display region for the scene.

proc get_display_region*(this: SceneSetup): DisplayRegion {.importcpp: "#->get_display_region()".} ## \
## Returns the display region for the scene.

proc set_viewport_size*(this: SceneSetup, width: int, height: int) {.importcpp: "#->set_viewport_size(#, #)".} ## \
## Specifies the size of the viewport (display region), in pixels.

proc get_viewport_width*(this: SceneSetup): int {.importcpp: "#->get_viewport_width()".} ## \
## Returns the width of the viewport (display region) in pixels.

proc get_viewport_height*(this: SceneSetup): int {.importcpp: "#->get_viewport_height()".} ## \
## Returns the height of the viewport (display region) in pixels.

proc set_scene_root*(this: SceneSetup, scene_root: NodePath) {.importcpp: "#->set_scene_root(#)".} ## \
## Specifies the root node of the scene.

proc get_scene_root*(this: SceneSetup): NodePath {.importcpp: "#->get_scene_root()".} ## \
## Returns the root node of the scene.

proc set_camera_path*(this: SceneSetup, camera_path: NodePath) {.importcpp: "#->set_camera_path(#)".} ## \
## Specifies the NodePath to the camera.

proc get_camera_path*(this: SceneSetup): NodePath {.importcpp: "#->get_camera_path()".} ## \
## Returns the NodePath to the camera.

proc set_camera_node*(this: SceneSetup, camera_node: Camera) {.importcpp: "#->set_camera_node(#)".} ## \
## Specifies the camera used to render the scene.

proc get_camera_node*(this: SceneSetup): Camera {.importcpp: "#->get_camera_node()".} ## \
## Returns the camera used to render the scene.

proc set_lens*(this: SceneSetup, lens: Lens) {.importcpp: "#->set_lens(#)".} ## \
## Indicates the particular Lens used for rendering.

proc get_lens*(this: SceneSetup): Lens {.importcpp: "#->get_lens()".} ## \
## Returns the particular Lens used for rendering.

proc set_inverted*(this: SceneSetup, inverted: bool) {.importcpp: "#->set_inverted(#)".} ## \
## Changes the current setting of the inverted flag.  When this is true, the
## scene is rendered into the window upside-down and backwards, that is,
## inverted as if viewed through a mirror placed on the floor.

proc get_inverted*(this: SceneSetup): bool {.importcpp: "#->get_inverted()".} ## \
## Returns the current setting of the inverted flag.  When this is true, the
## scene is rendered into the window upside-down, flipped like a mirror along
## the X axis.

proc get_cull_center*(this: SceneSetup): NodePath {.importcpp: "#->get_cull_center()".} ## \
## Returns the point from which the culling operations will be performed.
## This is normally the camera, but if camera->set_cull_center() has been
## specified, it will be that special node instead.

proc get_cull_bounds*(this: SceneSetup): BoundingVolume {.importcpp: "#->get_cull_bounds()".} ## \
## Returns the bounding volume that should be used to perform view-frustum
## culling (in the space of get_cull_center()).  This is normally the current
## lens' bounding volume, but it may be overridden with
## Camera::set_cull_bounds().

proc set_initial_state*(this: SceneSetup, initial_state: RenderState) {.importcpp: "#->set_initial_state(#)".} ## \
## Sets the initial state which is applied to all nodes in the scene, as if it
## were set at the top of the scene graph.

proc get_initial_state*(this: SceneSetup): RenderState {.importcpp: "#->get_initial_state()".} ## \
## Returns the initial state as set by a previous call to set_initial_state().

proc set_camera_transform*(this: SceneSetup, camera_transform: TransformState) {.importcpp: "#->set_camera_transform(#)".} ## \
## Specifies the position of the camera relative to the starting node.

proc get_camera_transform*(this: SceneSetup): TransformState {.importcpp: "#->get_camera_transform()".} ## \
## Returns the position of the camera relative to the starting node.

proc set_world_transform*(this: SceneSetup, world_transform: TransformState) {.importcpp: "#->set_world_transform(#)".} ## \
## Specifies the position of the starting node relative to the camera.  This
## is the inverse of the camera transform.

proc get_world_transform*(this: SceneSetup): TransformState {.importcpp: "#->get_world_transform()".} ## \
## Returns the position of the starting node relative to the camera.  This is
## the inverse of the camera transform.

proc set_cs_transform*(this: SceneSetup, cs_transform: TransformState) {.importcpp: "#->set_cs_transform(#)".} ## \
## Specifies the transform from the camera's coordinate system to the GSG's
## internal coordinate system.

proc get_cs_transform*(this: SceneSetup): TransformState {.importcpp: "#->get_cs_transform()".} ## \
## Returns the transform from the camera's coordinate system to the GSG's
## internal coordinate system.

proc set_cs_world_transform*(this: SceneSetup, cs_world_transform: TransformState) {.importcpp: "#->set_cs_world_transform(#)".} ## \
## Specifies the position from the starting node relative to the camera, in
## the GSG's internal coordinate system.

proc get_cs_world_transform*(this: SceneSetup): TransformState {.importcpp: "#->get_cs_world_transform()".} ## \
## Returns the position from the starting node relative to the camera, in the
## GSG's internal coordinate system.

proc get_class_type*(_: typedesc[SceneSetup]): TypeHandle {.importcpp: "SceneSetup::get_class_type()", header: "sceneSetup.h".}

proc newSceneSetup*(param0: SceneSetup): SceneSetup {.importcpp: "new SceneSetup(#)".}

proc newFog*(name: string): Fog {.importcpp: "new Fog(nimStringToStdString(#))", header: stringConversionCode.}

proc get_color*(this: Fog): LColor {.importcpp: "#->get_color()".} ## \
## Returns the color of the fog.

proc set_color*(this: Fog, color: LColor) {.importcpp: "#->set_color(#)".} ## \
## Sets the color of the fog.  The alpha component is not used.

proc set_color*(this: Fog, r: float32, g: float32, b: float32) {.importcpp: "#->set_color(#, #, #)".} ## \
## Sets the color of the fog.

proc set_linear_range*(this: Fog, onset: float32, opaque: float32) {.importcpp: "#->set_linear_range(#, #)".} ## \
## Specifies the effects of the fog in linear distance units.  This is only
## used if the mode is M_linear.
##
## This specifies a fog that begins at distance onset units from the origin,
## and becomes totally opaque at distance opaque units from the origin, along
## the forward axis (usually Y).
##
## This function also implicitly sets the mode the M_linear, if it is not
## already set.

proc get_linear_onset_point*(this: Fog): LPoint3 {.importcpp: "#->get_linear_onset_point()".} ## \
## Returns the point in space at which the fog begins.  This is only used if
## the mode is M_linear.

proc set_linear_onset_point*(this: Fog, linear_onset_point: LPoint3) {.importcpp: "#->set_linear_onset_point(#)".} ## \
## Specifies the point in space at which the fog begins.  This is only used if
## the mode is M_linear.

proc set_linear_onset_point*(this: Fog, x: float32, y: float32, z: float32) {.importcpp: "#->set_linear_onset_point(#, #, #)".} ## \
## Specifies the point in space at which the fog begins.  This is only used if
## the mode is M_linear.

proc get_linear_opaque_point*(this: Fog): LPoint3 {.importcpp: "#->get_linear_opaque_point()".} ## \
## Returns the point in space at which the fog completely obscures geometry.
## This is only used if the mode is M_linear.

proc set_linear_opaque_point*(this: Fog, linear_opaque_point: LPoint3) {.importcpp: "#->set_linear_opaque_point(#)".} ## \
## Specifies the point in space at which the fog completely obscures geometry.
## This is only used if the mode is M_linear.

proc set_linear_opaque_point*(this: Fog, x: float32, y: float32, z: float32) {.importcpp: "#->set_linear_opaque_point(#, #, #)".} ## \
## Specifies the point in space at which the fog completely obscures geometry.
## This is only used if the mode is M_linear.

proc set_linear_fallback*(this: Fog, angle: float32, onset: float32, opaque: float32) {.importcpp: "#->set_linear_fallback(#, #, #)".} ## \
## Fog effects are traditionally defined in camera-relative space, but the
## Panda Fog node has a special mode in which it can define a linear fog
## effect in an arbitrary coordinate space.
##
## This is done by specifying 3-d onset and opaque points, and parenting the
## Fog object somewhere within the scene graph.  In this mode, the fog will be
## rendered as if it extended along the vector from the onset point to the
## opaque point, in 3-d space.
##
## However, the underlying fog effect supported by hardware is generally only
## one-dimensional, and must be rendered based on linear distance from the
## camera plane.  Thus, this in-the-world effect is most effective when the
## fog vector from onset point to opaque point is most nearly parallel to the
## camera's eye vector.
##
## As the angle between the fog vector and the eye vector increases, the
## accuracy of the effect diminishes, up to a complete breakdown of the effect
## at a 90 degree angle.
##
## This function exists to define the workaround to this problem.  The linear
## fallback parameters given here specify how the fog should be rendered when
## the parameters are exceeded in this way.
##
## The angle parameter is the minimum angle, in degrees, of the fog vector to
## the eye vector, at which the fallback effect should be employed.  The onset
## and opaque parameters specify the camera-relative onset and opaque
## distances to pass to the rendering hardware when employing the fallback
## effect.  This supercedes the 3-d onset point and opaque points.

proc get_exp_density*(this: Fog): float32 {.importcpp: "#->get_exp_density()".} ## \
## Returns the density of the fog for exponential calculations.  This is only
## used if the mode is not M_linear.

proc set_exp_density*(this: Fog, exp_density: float32) {.importcpp: "#->set_exp_density(#)".} ## \
## Sets the density of the fog for exponential calculations.  This is only
## used if the mode is not M_linear.
##
## If the mode is currently set to M_linear, this function implicitly sets it
## to M_exponential.

proc get_class_type*(_: typedesc[Fog]): TypeHandle {.importcpp: "Fog::get_class_type()", header: "fog.h".}

proc make*(_: typedesc[FogAttrib], fog: Fog): RenderAttrib {.importcpp: "FogAttrib::make(#)", header: "fogAttrib.h".} ## \
## Constructs a new FogAttrib object suitable for rendering the indicated fog
## onto geometry.

proc make_off*(_: typedesc[FogAttrib]): RenderAttrib {.importcpp: "FogAttrib::make_off()", header: "fogAttrib.h".} ## \
## Constructs a new FogAttrib object suitable for rendering unfogd geometry.

proc make_default*(_: typedesc[FogAttrib]): RenderAttrib {.importcpp: "FogAttrib::make_default()", header: "fogAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc is_off*(this: FogAttrib): bool {.importcpp: "#->is_off()".} ## \
## Returns true if the FogAttrib is an 'off' FogAttrib, indicating that it
## should disable fog.

proc get_fog*(this: FogAttrib): Fog {.importcpp: "#->get_fog()".} ## \
## If the FogAttrib is not an 'off' FogAttrib, returns the fog that is
## associated.  Otherwise, return NULL.

proc get_class_slot*(_: typedesc[FogAttrib]): int {.importcpp: "FogAttrib::get_class_slot()", header: "fogAttrib.h".}

proc get_class_type*(_: typedesc[FogAttrib]): TypeHandle {.importcpp: "FogAttrib::get_class_type()", header: "fogAttrib.h".}

proc newCullTraverser*(): CullTraverser {.importcpp: "new CullTraverser()".}

proc newCullTraverser*(copy: CullTraverser): CullTraverser {.importcpp: "new CullTraverser(#)".}

proc get_gsg*(this: CullTraverser): GraphicsStateGuardianBase {.importcpp: "#->get_gsg()".} ## \
## Returns the GraphicsStateGuardian in effect.

proc get_current_thread*(this: CullTraverser): Thread {.importcpp: "#->get_current_thread()".} ## \
## Returns the currently-executing thread object, as passed to the
## CullTraverser constructor.

proc set_scene*(this: CullTraverser, scene_setup: SceneSetup, gsg: GraphicsStateGuardianBase, dr_incomplete_render: bool) {.importcpp: "#->set_scene(#, #, #)".} ## \
## Sets the SceneSetup object that indicates the initial camera position, etc.
## This must be called before traversal begins.

proc get_scene*(this: CullTraverser): SceneSetup {.importcpp: "#->get_scene()".} ## \
## Returns the SceneSetup object.

proc has_tag_state_key*(this: CullTraverser): bool {.importcpp: "#->has_tag_state_key()".} ## \
## Returns true if a nonempty tag state key has been specified for the scene's
## camera, false otherwise.

proc get_tag_state_key*(this: CullTraverser): string {.importcpp: "nimStringFromStdString(#->get_tag_state_key())", header: stringConversionCode.} ## \
## Returns the tag state key that has been specified for the scene's camera,
## if any.

proc get_camera_transform*(this: CullTraverser): TransformState {.importcpp: "#->get_camera_transform()".} ## \
## Returns the position of the camera relative to the starting node.

proc get_world_transform*(this: CullTraverser): TransformState {.importcpp: "#->get_world_transform()".} ## \
## Returns the position of the starting node relative to the camera.  This is
## the inverse of the camera transform.
##
## Note that this value is always the position of the starting node, not the
## current node, even if it is sampled during a traversal.  To get the
## transform of the current node use
## CullTraverserData::get_modelview_transform().

proc get_initial_state*(this: CullTraverser): RenderState {.importcpp: "#->get_initial_state()".} ## \
## Returns the initial RenderState at the top of the scene graph we are
## traversing, or the empty state if the initial state was never set.

proc get_depth_offset_decals*(this: CullTraverser): bool {.importcpp: "#->get_depth_offset_decals()".} ## \
## Returns true, as depth offsets are the only way that we implement decals
## nowadays.

proc set_view_frustum*(this: CullTraverser, view_frustum: GeometricBoundingVolume) {.importcpp: "#->set_view_frustum(#)".} ## \
## Specifies the bounding volume that corresponds to the view frustum.  Any
## primitives that fall entirely outside of this volume are not drawn.

proc get_view_frustum*(this: CullTraverser): GeometricBoundingVolume {.importcpp: "#->get_view_frustum()".} ## \
## Returns the bounding volume that corresponds to the view frustum, or NULL
## if the view frustum is not in use or has not been set.
##
## Note that the view frustum returned here is always in the coordinate space
## of the starting node, not the current node, even if it is sampled during a
## traversal.  To get the view frustum in the current node's coordinate space,
## check in the current CullTraverserData.

proc get_effective_incomplete_render*(this: CullTraverser): bool {.importcpp: "#->get_effective_incomplete_render()".} ## \
## Returns true if the cull traversal is effectively in incomplete_render
## state, considering both the GSG's incomplete_render and the current
## DisplayRegion's incomplete_render flags.  This returns the flag during the
## cull traversal; see GSG::get_effective_incomplete_render() for this same
## flag during the draw traversal.

proc traverse*(this: CullTraverser, data: CullTraverserData) {.importcpp: "#->traverse(#)".} ## \
## Traverses from the next node with the given data, which has been
## constructed with the node but has not yet been converted into the node's
## space.

proc traverse*(this: CullTraverser, root: NodePath) {.importcpp: "#->traverse(#)".} ## \
## Begins the traversal from the indicated node.

proc traverse_below*(this: CullTraverser, data: CullTraverserData) {.importcpp: "#->traverse_below(#)".} ## \
## Traverses all the children of the indicated node, with the given data,
## which has been converted into the node's space.

proc end_traverse*(this: CullTraverser) {.importcpp: "#->end_traverse()".} ## \
## Should be called when the traverser has finished traversing its scene, this
## gives it a chance to do any necessary finalization.

proc flush_level*(_: typedesc[CullTraverser]) {.importcpp: "CullTraverser::flush_level()", header: "cullTraverser.h".} ## \
## Flushes the PStatCollectors used during traversal.

proc draw_bounding_volume*(this: CullTraverser, vol: BoundingVolume, internal_transform: TransformState) {.importcpp: "#->draw_bounding_volume(#, #)".} ## \
## Draws an appropriate visualization of the indicated bounding volume.

proc get_class_type*(_: typedesc[CullTraverser]): TypeHandle {.importcpp: "CullTraverser::get_class_type()", header: "cullTraverser.h".}

proc get_gsg*(this: GeomDrawCallbackData): GraphicsStateGuardianBase {.importcpp: "#.get_gsg()".} ## \
## Returns a pointer to the current GSG.

proc get_force*(this: GeomDrawCallbackData): bool {.importcpp: "#.get_force()".} ## \
## Returns true if any required data should be forced into memory if necessary
## to render the object, or false if the object should be omitted if some of
## the data is not available (at least until the data becomes available
## later).

proc set_lost_state*(this: GeomDrawCallbackData, lost_state: bool) {.importcpp: "#.set_lost_state(#)".} ## \
## Sets the lost_state flag.  If this is true, the callback does not have to
## be quite so careful to clean up after itself; Panda will assume that the
## graphics state is in an unknown state after the callback has finished, and
## will issue all the necessary calls to restore it.  If this is false, Panda
## will assume the callback will leave the graphics state exactly as it came
## in, and won't bother to try to restore it.  The default is true.

proc get_lost_state*(this: GeomDrawCallbackData): bool {.importcpp: "#.get_lost_state()".} ## \
## Returns the lost_state flag.  See set_lost_state().

proc get_class_type*(_: typedesc[GeomDrawCallbackData]): TypeHandle {.importcpp: "GeomDrawCallbackData::get_class_type()", header: "geomDrawCallbackData.h".}

proc make_default*(_: typedesc[RescaleNormalAttrib]): RenderAttrib {.importcpp: "RescaleNormalAttrib::make_default()", header: "rescaleNormalAttrib.h".} ## \
## Constructs a RescaleNormalAttrib object that's suitable for putting at the
## top of a scene graph.  This will contain whatever attrib was suggested by
## the user's rescale-normals Config variable.

proc get_class_slot*(_: typedesc[RescaleNormalAttrib]): int {.importcpp: "RescaleNormalAttrib::get_class_slot()", header: "rescaleNormalAttrib.h".}

proc get_class_type*(_: typedesc[RescaleNormalAttrib]): TypeHandle {.importcpp: "RescaleNormalAttrib::get_class_type()", header: "rescaleNormalAttrib.h".}

proc make_next*(this: CullResult): CullResult {.importcpp: "#->make_next()".} ## \
## Returns a newly-allocated CullResult object that contains a copy of just
## the subset of the data from this CullResult object that is worth keeping
## around for next frame.

proc finish_cull*(this: CullResult, scene_setup: SceneSetup, current_thread: Thread) {.importcpp: "#->finish_cull(#, #)".} ## \
## Called after all the geoms have been added, this indicates that the cull
## process is finished for this frame and gives the bins a chance to do any
## post-processing (like sorting) before moving on to draw.

proc draw*(this: CullResult, current_thread: Thread) {.importcpp: "#->draw(#)".} ## \
## Asks all the bins to draw themselves in the correct order.

proc make_result_graph*(this: CullResult): PandaNode {.importcpp: "#->make_result_graph()".} ## \
## Returns a special scene graph constructed to represent the results of the
## cull.  This will be a hierarchy of nodes, one node for each bin, each of
## which will in term be a parent of a number of GeomNodes, representing the
## geometry drawn in each bin.
##
## This is useful mainly for high-level debugging and abstraction tools; it
## should not be mistaken for the low-level cull result itself.  For the low-
## level cull result, use draw() to efficiently draw the culled scene.

proc get_class_type*(_: typedesc[CullResult]): TypeHandle {.importcpp: "CullResult::get_class_type()", header: "cullResult.h".}

proc newCullResult*(param0: CullResult): CullResult {.importcpp: "new CullResult(#)".}

proc make*(_: typedesc[DecalEffect]): RenderEffect {.importcpp: "DecalEffect::make()", header: "decalEffect.h".} ## \
## Constructs a new DecalEffect object.

proc get_class_type*(_: typedesc[DecalEffect]): TypeHandle {.importcpp: "DecalEffect::get_class_type()", header: "decalEffect.h".}

proc make*(_: typedesc[DepthOffsetAttrib], offset: int): RenderAttrib {.importcpp: "DepthOffsetAttrib::make(#)", header: "depthOffsetAttrib.h".} ## \
## Constructs a new DepthOffsetAttrib object that indicates the relative
## amount of bias to write to the depth buffer for subsequent geometry.

proc make*(_: typedesc[DepthOffsetAttrib]): RenderAttrib {.importcpp: "DepthOffsetAttrib::make()", header: "depthOffsetAttrib.h".} ## \
## Constructs a new DepthOffsetAttrib object that indicates the relative
## amount of bias to write to the depth buffer for subsequent geometry.

proc make*(_: typedesc[DepthOffsetAttrib], offset: int, min_value: float32, max_value: float32): RenderAttrib {.importcpp: "DepthOffsetAttrib::make(#, #, #)", header: "depthOffsetAttrib.h".} ## \
## Constructs a new DepthOffsetAttrib object that indicates the bias, and also
## specifies a minimum and maximum (or, more precisely, nearest and farthest)
## values to write to the depth buffer, in the range 0 .. 1.  This range is 0,
## 1 by default; setting it to some other range can be used to create
## additional depth buffer effects.

proc make_default*(_: typedesc[DepthOffsetAttrib]): RenderAttrib {.importcpp: "DepthOffsetAttrib::make_default()", header: "depthOffsetAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc get_offset*(this: DepthOffsetAttrib): int {.importcpp: "#->get_offset()".} ## \
## Returns the depth offset represented by this attrib.

proc get_min_value*(this: DepthOffsetAttrib): float32 {.importcpp: "#->get_min_value()".} ## \
## Returns the value for the minimum (closest) depth value to be stored in the
## buffer, in the range 0 .. 1.

proc get_max_value*(this: DepthOffsetAttrib): float32 {.importcpp: "#->get_max_value()".} ## \
## Returns the value for the maximum (farthest) depth value to be stored in
## the buffer, in the range 0 .. 1.

proc get_class_slot*(_: typedesc[DepthOffsetAttrib]): int {.importcpp: "DepthOffsetAttrib::get_class_slot()", header: "depthOffsetAttrib.h".}

proc get_class_type*(_: typedesc[DepthOffsetAttrib]): TypeHandle {.importcpp: "DepthOffsetAttrib::get_class_type()", header: "depthOffsetAttrib.h".}

proc make_default*(_: typedesc[DepthTestAttrib]): RenderAttrib {.importcpp: "DepthTestAttrib::make_default()", header: "depthTestAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc get_class_slot*(_: typedesc[DepthTestAttrib]): int {.importcpp: "DepthTestAttrib::get_class_slot()", header: "depthTestAttrib.h".}

proc get_class_type*(_: typedesc[DepthTestAttrib]): TypeHandle {.importcpp: "DepthTestAttrib::get_class_type()", header: "depthTestAttrib.h".}

proc make_default*(_: typedesc[DepthWriteAttrib]): RenderAttrib {.importcpp: "DepthWriteAttrib::make_default()", header: "depthWriteAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc get_class_slot*(_: typedesc[DepthWriteAttrib]): int {.importcpp: "DepthWriteAttrib::get_class_slot()", header: "depthWriteAttrib.h".}

proc get_class_type*(_: typedesc[DepthWriteAttrib]): TypeHandle {.importcpp: "DepthWriteAttrib::get_class_type()", header: "depthWriteAttrib.h".}

proc as_node*(this: Light): PandaNode {.importcpp: "#.as_node()".}

proc is_ambient_light*(this: Light): bool {.importcpp: "#.is_ambient_light()".} ## \
## Returns true if this is an AmbientLight, false if it is some other kind of
## light.

proc get_color*(this: Light): LColor {.importcpp: "#.get_color()".} ## \
## Returns the basic color of the light.

proc set_color*(this: Light, color: LColor) {.importcpp: "#.set_color(#)".} ## \
## Sets the basic color of the light.

proc has_color_temperature*(this: Light): bool {.importcpp: "#.has_color_temperature()".} ## \
## Returns true if the color was specified as a temperature in kelvins, and
## get_color_temperature is defined.
##
## @since 1.10.0

proc get_color_temperature*(this: Light): float32 {.importcpp: "#.get_color_temperature()".} ## \
## Returns the basic color temperature of the light, assuming
## has_color_temperature() returns true.
##
## @since 1.10.0

proc set_color_temperature*(this: Light, temperature: float32) {.importcpp: "#.set_color_temperature(#)".} ## \
## Sets the color temperature of the light in kelvins.  This will recalculate
## the light's color.
##
## The default value is 6500 K, corresponding to a perfectly white light
## assuming a D65 white point.
##
## @since 1.10.0

proc get_exponent*(this: Light): float32 {.importcpp: "#.get_exponent()".} ## \
## For spotlights, returns the exponent that controls the amount of light
## falloff from the center of the spotlight.  For other kinds of lights,
## returns 0.

proc get_specular_color*(this: Light): LColor {.importcpp: "#.get_specular_color()".} ## \
## Returns the color of specular highlights generated by the light.  This
## value is meaningless for ambient lights.

proc get_attenuation*(this: Light): LVecBase3 {.importcpp: "#.get_attenuation()".} ## \
## Returns the terms of the attenuation equation for the light.  These are, in
## order, the constant, linear, and quadratic terms based on the distance from
## the point to the vertex.

proc set_priority*(this: Light, priority: int) {.importcpp: "#.set_priority(#)".} ## \
## Changes the relative importance of this light relative to the other lights
## that are applied simultaneously.
##
## The priority number is used to decide which of the requested lights are to
## be selected for rendering when more lights are requested than the hardware
## will support.  The highest-priority n lights are selected for rendering.
##
## This is similar to TextureStage::set_priority().

proc get_priority*(this: Light): int {.importcpp: "#.get_priority()".} ## \
## Returns the priority associated with this light.  See set_priority().

proc get_class_priority*(this: Light): int {.importcpp: "#.get_class_priority()".}

proc get_class_type*(_: typedesc[Light]): TypeHandle {.importcpp: "Light::get_class_type()", header: "light.h".}

proc make*(_: typedesc[LightAttrib]): RenderAttrib {.importcpp: "LightAttrib::make()", header: "lightAttrib.h".} ## \
## The following is the new, more general interface to the LightAttrib.

proc make_default*(_: typedesc[LightAttrib]): RenderAttrib {.importcpp: "LightAttrib::make_default()", header: "lightAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc get_num_lights*(this: LightAttrib): int {.importcpp: "#->get_num_lights()".} ## \
## Returns the number of lights listed in the attribute.
##
## @deprecated LightAttribs nowadays have a separate list of on_lights and
## off_lights, so this method no longer makes sense.  Query the lists
## independently.

proc get_light*(this: LightAttrib, n: int): Light {.importcpp: "#->get_light(#)".} ## \
## Returns the nth light listed in the attribute.
##
## @deprecated LightAttribs nowadays have a separate list of on_lights and
## off_lights, so this method no longer makes sense.  Query the lists
## independently.

proc has_light*(this: LightAttrib, light: Light): bool {.importcpp: "#->has_light(#)".} ## \
## Returns true if the indicated light is listed in the attrib, false
## otherwise.
##
## @deprecated LightAttribs nowadays have a separate list of on_lights and
## off_lights, so this method no longer makes sense.  Query the lists
## independently.

proc add_light*(this: LightAttrib, light: Light): RenderAttrib {.importcpp: "#->add_light(#)".} ## \
## Returns a new LightAttrib, just like this one, but with the indicated light
## added to the list of lights.
##
## @deprecated Use add_on_light() or add_off_light() instead.

proc remove_light*(this: LightAttrib, light: Light): RenderAttrib {.importcpp: "#->remove_light(#)".} ## \
## Returns a new LightAttrib, just like this one, but with the indicated light
## removed from the list of lights.
##
## @deprecated Use remove_on_light() or remove_off_light() instead.

proc make_all_off*(_: typedesc[LightAttrib]): RenderAttrib {.importcpp: "LightAttrib::make_all_off()", header: "lightAttrib.h".} ## \
## Constructs a new LightAttrib object that turns off all lights (and hence
## disables lighting).

proc get_num_on_lights*(this: LightAttrib): clonglong {.importcpp: "#->get_num_on_lights()".} ## \
## Returns the number of lights that are turned on by the attribute.

proc get_num_non_ambient_lights*(this: LightAttrib): clonglong {.importcpp: "#->get_num_non_ambient_lights()".} ## \
## Returns the number of non-ambient lights that are turned on by this
## attribute.

proc get_on_light*(this: LightAttrib, n: clonglong): NodePath {.importcpp: "#->get_on_light(#)".} ## \
## Returns the nth light turned on by the attribute, sorted in render order.

proc has_on_light*(this: LightAttrib, light: NodePath): bool {.importcpp: "#->has_on_light(#)".} ## \
## Returns true if the indicated light is turned on by the attrib, false
## otherwise.

proc has_any_on_light*(this: LightAttrib): bool {.importcpp: "#->has_any_on_light()".} ## \
## Returns true if any light is turned on by the attrib, false otherwise.

proc get_num_off_lights*(this: LightAttrib): clonglong {.importcpp: "#->get_num_off_lights()".} ## \
## Returns the number of lights that are turned off by the attribute.

proc get_off_light*(this: LightAttrib, n: clonglong): NodePath {.importcpp: "#->get_off_light(#)".} ## \
## Returns the nth light turned off by the attribute, sorted in arbitrary
## (pointer) order.

proc has_off_light*(this: LightAttrib, light: NodePath): bool {.importcpp: "#->has_off_light(#)".} ## \
## Returns true if the indicated light is turned off by the attrib, false
## otherwise.

proc has_all_off*(this: LightAttrib): bool {.importcpp: "#->has_all_off()".} ## \
## Returns true if this attrib turns off all lights (although it may also turn
## some on).

proc is_identity*(this: LightAttrib): bool {.importcpp: "#->is_identity()".} ## \
## Returns true if this is an identity attrib: it does not change the set of
## lights in use.

proc add_on_light*(this: LightAttrib, light: NodePath): RenderAttrib {.importcpp: "#->add_on_light(#)".} ## \
## Returns a new LightAttrib, just like this one, but with the indicated light
## added to the list of lights turned on by this attrib.

proc remove_on_light*(this: LightAttrib, light: NodePath): RenderAttrib {.importcpp: "#->remove_on_light(#)".} ## \
## Returns a new LightAttrib, just like this one, but with the indicated light
## removed from the list of lights turned on by this attrib.

proc replace_on_light*(this: LightAttrib, source: NodePath, dest: NodePath): RenderAttrib {.importcpp: "#->replace_on_light(#, #)".} ## \
## Returns a new LightAttrib, just like this one, but with the indicated light
## replaced with the given other light.

proc add_off_light*(this: LightAttrib, light: NodePath): RenderAttrib {.importcpp: "#->add_off_light(#)".} ## \
## Returns a new LightAttrib, just like this one, but with the indicated light
## added to the list of lights turned off by this attrib.

proc remove_off_light*(this: LightAttrib, light: NodePath): RenderAttrib {.importcpp: "#->remove_off_light(#)".} ## \
## Returns a new LightAttrib, just like this one, but with the indicated light
## removed from the list of lights turned off by this attrib.

proc replace_off_light*(this: LightAttrib, source: NodePath, dest: NodePath): RenderAttrib {.importcpp: "#->replace_off_light(#, #)".} ## \
## Returns a new LightAttrib, just like this one, but with the indicated light
## replaced with the given other light.

proc get_most_important_light*(this: LightAttrib): NodePath {.importcpp: "#->get_most_important_light()".} ## \
## Returns the most important light (that is, the light with the highest
## priority) in the LightAttrib, excluding any ambient lights.  Returns an
## empty NodePath if no non-ambient lights are found.

proc get_ambient_contribution*(this: LightAttrib): LColor {.importcpp: "#->get_ambient_contribution()".} ## \
## Returns the total contribution of all the ambient lights.

proc get_class_slot*(_: typedesc[LightAttrib]): int {.importcpp: "LightAttrib::get_class_slot()", header: "lightAttrib.h".}

proc get_class_type*(_: typedesc[LightAttrib]): TypeHandle {.importcpp: "LightAttrib::get_class_type()", header: "lightAttrib.h".}

proc make_default*(_: typedesc[LightRampAttrib]): RenderAttrib {.importcpp: "LightRampAttrib::make_default()", header: "lightRampAttrib.h".} ## \
## Constructs a new LightRampAttrib object.  This is the standard OpenGL
## lighting ramp, which clamps the final light total to the 0-1 range.

proc make_identity*(_: typedesc[LightRampAttrib]): RenderAttrib {.importcpp: "LightRampAttrib::make_identity()", header: "lightRampAttrib.h".} ## \
## Constructs a new LightRampAttrib object.  This differs from the usual
## OpenGL lighting model in that it does not clamp the final lighting total to
## (0,1).

proc make_single_threshold*(_: typedesc[LightRampAttrib], thresh0: float32, lev0: float32): RenderAttrib {.importcpp: "LightRampAttrib::make_single_threshold(#, #)", header: "lightRampAttrib.h".} ## \
## Constructs a new LightRampAttrib object.  This causes the luminance of the
## diffuse lighting contribution to be quantized using a single threshold:
##
## @code
## if (original_luminance > threshold0) {
## luminance = level0;
## } else {
## luminance = 0.0;
## }
## @endcode

proc make_double_threshold*(_: typedesc[LightRampAttrib], thresh0: float32, lev0: float32, thresh1: float32, lev1: float32): RenderAttrib {.importcpp: "LightRampAttrib::make_double_threshold(#, #, #, #)", header: "lightRampAttrib.h".} ## \
## Constructs a new LightRampAttrib object.  This causes the luminance of the
## diffuse lighting contribution to be quantized using two thresholds:
##
## @code
## if (original_luminance > threshold1) {
## luminance = level1;
## } else if (original_luminance > threshold0) {
## luminance = level0;
## } else {
## luminance = 0.0;
## }
## @endcode

proc make_hdr0*(_: typedesc[LightRampAttrib]): RenderAttrib {.importcpp: "LightRampAttrib::make_hdr0()", header: "lightRampAttrib.h".} ## \
## Constructs a new LightRampAttrib object.  This causes an HDR tone mapping
## operation to be applied.
##
## Normally, brightness values greater than 1 cannot be distinguished from
## each other, causing very brightly lit objects to wash out white and all
## detail to be erased.  HDR tone mapping remaps brightness values in the
## range 0-infinity into the range (0,1), making it possible to distinguish
## detail in scenes whose brightness exceeds 1.
##
## However, the monitor has finite contrast.  Normally, all of that contrast
## is used to represent brightnesses in the range 0-1.  The HDR0 tone mapping
## operator 'steals' one quarter of that contrast to represent brightnesses in
## the range 1-infinity.
##
## @code
## FINAL_RGB = (RGB^3 + RGB^2 + RGB) / (RGB^3 + RGB^2 + RGB + 1)
## @endcode

proc make_hdr1*(_: typedesc[LightRampAttrib]): RenderAttrib {.importcpp: "LightRampAttrib::make_hdr1()", header: "lightRampAttrib.h".} ## \
## Constructs a new LightRampAttrib object.  This causes an HDR tone mapping
## operation to be applied.
##
## Normally, brightness values greater than 1 cannot be distinguished from
## each other, causing very brightly lit objects to wash out white and all
## detail to be erased.  HDR tone mapping remaps brightness values in the
## range 0-infinity into the range (0,1), making it possible to distinguish
## detail in scenes whose brightness exceeds 1.
##
## However, the monitor has finite contrast.  Normally, all of that contrast
## is used to represent brightnesses in the range 0-1.  The HDR1 tone mapping
## operator 'steals' one third of that contrast to represent brightnesses in
## the range 1-infinity.
##
## @code
## FINAL_RGB = (RGB^2 + RGB) / (RGB^2 + RGB + 1)
## @endcode

proc make_hdr2*(_: typedesc[LightRampAttrib]): RenderAttrib {.importcpp: "LightRampAttrib::make_hdr2()", header: "lightRampAttrib.h".} ## \
## Constructs a new LightRampAttrib object.  This causes an HDR tone mapping
## operation to be applied.
##
## Normally, brightness values greater than 1 cannot be distinguished from
## each other, causing very brightly lit objects to wash out white and all
## detail to be erased.  HDR tone mapping remaps brightness values in the
## range 0-infinity into the range (0,1), making it possible to distinguish
## detail in scenes whose brightness exceeds 1.
##
## However, the monitor has finite contrast.  Normally, all of that contrast
## is used to represent brightnesses in the range 0-1.  The HDR2 tone mapping
## operator 'steals' one half of that contrast to represent brightnesses in
## the range 1-infinity.
##
## @code
## FINAL_RGB = (RGB) / (RGB + 1)
## @endcode

proc get_level*(this: LightRampAttrib, n: int): float32 {.importcpp: "#->get_level(#)".} ## \
## Returns the nth lighting level.

proc get_threshold*(this: LightRampAttrib, n: int): float32 {.importcpp: "#->get_threshold(#)".} ## \
## Returns the nth threshold level.

proc get_class_slot*(_: typedesc[LightRampAttrib]): int {.importcpp: "LightRampAttrib::get_class_slot()", header: "lightRampAttrib.h".}

proc get_class_type*(_: typedesc[LightRampAttrib]): TypeHandle {.importcpp: "LightRampAttrib::get_class_type()", header: "lightRampAttrib.h".}

converter upcast_to_TypedReferenceCount*(this: Loader): TypedReferenceCount {.importcpp: "(PT(TypedReferenceCount)(#))".}

converter upcast_to_Namable*(this: Loader): Namable {.importcpp: "((Namable *)(#.p()))".}

proc newLoader*(param0: Loader): Loader {.importcpp: "new Loader(#)".}

proc newLoader*(name: string): Loader {.importcpp: "new Loader(nimStringToStdString(#))", header: stringConversionCode.}

proc newLoader*(): Loader {.importcpp: "new Loader()".}

proc set_task_manager*(this: Loader, task_manager: AsyncTaskManager) {.importcpp: "#->set_task_manager(#)".} ## \
## Specifies the task manager that is used for asynchronous loads.  The
## default is the global task manager.

proc get_task_manager*(this: Loader): AsyncTaskManager {.importcpp: "#->get_task_manager()".} ## \
## Returns the task manager that is used for asynchronous loads.

proc set_task_chain*(this: Loader, task_chain: string) {.importcpp: "#->set_task_chain(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the task chain that is used for asynchronous loads.  The default
## is the initial name of the Loader object.

proc get_task_chain*(this: Loader): string {.importcpp: "nimStringFromStdString(#->get_task_chain())", header: stringConversionCode.} ## \
## Returns the task chain that is used for asynchronous loads.

proc stop_threads*(this: Loader) {.importcpp: "#->stop_threads()".} ## \
## Stop any threads used for asynchronous loads.

proc remove*(this: Loader, task: AsyncTask): bool {.importcpp: "#->remove(#)".} ## \
## Removes a pending asynchronous load request.  Returns true if successful,
## false otherwise.
## @deprecated use task.cancel() to cancel the request instead.

proc load_sync*(this: Loader, filename: Filename, options: LoaderOptions): PandaNode {.importcpp: "#->load_sync(#, #)".} ## \
## Loads the file immediately, waiting for it to complete.
##
## If search is true, the file is searched for along the model path;
## otherwise, only the exact filename is loaded.

proc load_sync*(this: Loader, filename: Filename): PandaNode {.importcpp: "#->load_sync(#)".} ## \
## Loads the file immediately, waiting for it to complete.
##
## If search is true, the file is searched for along the model path;
## otherwise, only the exact filename is loaded.

proc make_async_request*(this: Loader, filename: Filename, options: LoaderOptions): AsyncTask {.importcpp: "#->make_async_request(#, #)".} ## \
## Returns a new AsyncTask object suitable for adding to load_async() to start
## an asynchronous model load.

proc make_async_request*(this: Loader, filename: Filename): AsyncTask {.importcpp: "#->make_async_request(#)".} ## \
## Returns a new AsyncTask object suitable for adding to load_async() to start
## an asynchronous model load.

proc load_async*(this: Loader, request: AsyncTask) {.importcpp: "#->load_async(#)".} ## \
## Begins an asynchronous load request.  To use this call, first call
## make_async_request() to create a new ModelLoadRequest object with the
## filename you wish to load, and then add that object to the Loader with
## load_async.  This function will return immediately, and the model will be
## loaded in the background.
##
## To determine when the model has completely loaded, you may poll
## request->is_ready() from time to time, or set the done_event on the request
## object and listen for that event.  When the model is ready, you may
## retrieve it via request->get_model().

proc save_sync*(this: Loader, filename: Filename, options: LoaderOptions, node: PandaNode): bool {.importcpp: "#->save_sync(#, #, #)".} ## \
## Saves the file immediately, waiting for it to complete.

proc make_async_save_request*(this: Loader, filename: Filename, options: LoaderOptions, node: PandaNode): AsyncTask {.importcpp: "#->make_async_save_request(#, #, #)".} ## \
## Returns a new AsyncTask object suitable for adding to save_async() to start
## an asynchronous model save.

proc save_async*(this: Loader, request: AsyncTask) {.importcpp: "#->save_async(#)".} ## \
## Begins an asynchronous save request.  To use this call, first call
## make_async_save_request() to create a new ModelSaveRequest object with the
## filename you wish to load, and then add that object to the Loader with
## save_async.  This function will return immediately, and the model will be
## loaded in the background.
##
## To determine when the model has completely loaded, you may poll
## request->is_ready() from time to time, or set the done_event on the request
## object and listen for that event.  When the request is ready, you may
## retrieve the success or failure via request->get_success().

proc load_bam_stream*(this: Loader, `in`: istream): PandaNode {.importcpp: "#->load_bam_stream(#)".} ## \
## Attempts to read a bam file from the indicated stream and return the scene
## graph defined there.

proc output*(this: Loader, `out`: ostream) {.importcpp: "#->output(#)".}

proc get_global_ptr*(_: typedesc[Loader]): Loader {.importcpp: "Loader::get_global_ptr()", header: "loader.h".} ## \
## Returns a pointer to the global Loader.  This is the Loader that most code
## should use for loading models.

proc get_class_type*(_: typedesc[Loader]): TypeHandle {.importcpp: "Loader::get_class_type()", header: "loader.h".}

proc get_name*(this: LoaderFileType): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.}

proc get_extension*(this: LoaderFileType): string {.importcpp: "nimStringFromStdString(#.get_extension())", header: stringConversionCode.}

proc get_additional_extensions*(this: LoaderFileType): string {.importcpp: "nimStringFromStdString(#.get_additional_extensions())", header: stringConversionCode.} ## \
## Returns a space-separated list of extension, in addition to the one
## returned by get_extension(), that are recognized by this loader.

proc supports_compressed*(this: LoaderFileType): bool {.importcpp: "#.supports_compressed()".} ## \
## Returns true if this file type can transparently load compressed files
## (with a .pz or .gz extension), false otherwise.

proc get_allow_disk_cache*(this: LoaderFileType, options: LoaderOptions): bool {.importcpp: "#.get_allow_disk_cache(#)".} ## \
## Returns true if the loader flags allow retrieving the model from the on-
## disk bam cache (if it is enabled), false otherwise.

proc get_allow_ram_cache*(this: LoaderFileType, options: LoaderOptions): bool {.importcpp: "#.get_allow_ram_cache(#)".} ## \
## Returns true if the loader flags allow retrieving the model from the in-
## memory ModelPool cache, false otherwise.

proc supports_load*(this: LoaderFileType): bool {.importcpp: "#.supports_load()".} ## \
## Returns true if the file type can be used to load files, and load_file() is
## supported.  Returns false if load_file() is unimplemented and will always
## fail.

proc supports_save*(this: LoaderFileType): bool {.importcpp: "#.supports_save()".} ## \
## Returns true if the file type can be used to save files, and save_file() is
## supported.  Returns false if save_file() is unimplemented and will always
## fail.

proc get_class_type*(_: typedesc[LoaderFileType]): TypeHandle {.importcpp: "LoaderFileType::get_class_type()", header: "loaderFileType.h".}

proc get_num_types*(this: LoaderFileTypeRegistry): int {.importcpp: "#.get_num_types()".} ## \
## Returns the total number of types registered.

proc get_type*(this: LoaderFileTypeRegistry, n: int): LoaderFileType {.importcpp: "#.get_type(#)".} ## \
## Returns the nth type registered.

proc get_type_from_extension*(this: LoaderFileTypeRegistry, extension: string): LoaderFileType {.importcpp: "#.get_type_from_extension(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Determines the type of the file based on the indicated extension (without a
## leading dot).  Returns NULL if the extension matches no known file types.

proc write*(this: LoaderFileTypeRegistry, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes a list of supported file types to the indicated output stream, one
## per line.

proc write*(this: LoaderFileTypeRegistry, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a list of supported file types to the indicated output stream, one
## per line.

proc get_global_ptr*(_: typedesc[LoaderFileTypeRegistry]): LoaderFileTypeRegistry {.importcpp: "LoaderFileTypeRegistry::get_global_ptr()", header: "loaderFileTypeRegistry.h".} ## \
## Returns a pointer to the global LoaderFileTypeRegistry object.

proc initLoaderFileTypeRegistry*(param0: LoaderFileTypeRegistry): LoaderFileTypeRegistry {.importcpp: "LoaderFileTypeRegistry(#)".}

proc make*(_: typedesc[MaterialAttrib], material: Material): RenderAttrib {.importcpp: "MaterialAttrib::make(#)", header: "materialAttrib.h".} ## \
## Constructs a new MaterialAttrib object suitable for rendering the indicated
## material onto geometry.

proc make_off*(_: typedesc[MaterialAttrib]): RenderAttrib {.importcpp: "MaterialAttrib::make_off()", header: "materialAttrib.h".} ## \
## Constructs a new MaterialAttrib object suitable for rendering unmateriald
## geometry.

proc make_default*(_: typedesc[MaterialAttrib]): RenderAttrib {.importcpp: "MaterialAttrib::make_default()", header: "materialAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc is_off*(this: MaterialAttrib): bool {.importcpp: "#->is_off()".} ## \
## Returns true if the MaterialAttrib is an 'off' MaterialAttrib, indicating
## that it should disable the use of materials.

proc get_material*(this: MaterialAttrib): Material {.importcpp: "#->get_material()".} ## \
## If the MaterialAttrib is not an 'off' MaterialAttrib, returns the material
## that is associated.  Otherwise, return NULL.

proc get_class_slot*(_: typedesc[MaterialAttrib]): int {.importcpp: "MaterialAttrib::get_class_slot()", header: "materialAttrib.h".}

proc get_class_type*(_: typedesc[MaterialAttrib]): TypeHandle {.importcpp: "MaterialAttrib::get_class_type()", header: "materialAttrib.h".}

proc newModelFlattenRequest*(param0: ModelFlattenRequest): ModelFlattenRequest {.importcpp: "new ModelFlattenRequest(#)".}

proc newModelFlattenRequest*(orig: PandaNode): ModelFlattenRequest {.importcpp: "new ModelFlattenRequest(#)".} ## \
## Create a new ModelFlattenRequest, and add it to the loader via
## load_async(), to begin an asynchronous load.

proc get_orig*(this: ModelFlattenRequest): PandaNode {.importcpp: "#->get_orig()".} ## \
## Returns the original, unflattened node.

proc is_ready*(this: ModelFlattenRequest): bool {.importcpp: "#->is_ready()".} ## \
## Returns true if this request has completed, false if it is still pending.
## When this returns true, you may retrieve the model loaded by calling
## result().
## Equivalent to `req.done() and not req.cancelled()`.
## @see done()

proc get_model*(this: ModelFlattenRequest): PandaNode {.importcpp: "#->get_model()".} ## \
## Returns the flattened copy of the model.  It is an error to call this
## unless done() returns true.
## @deprecated Use result() instead.

proc get_class_type*(_: typedesc[ModelFlattenRequest]): TypeHandle {.importcpp: "ModelFlattenRequest::get_class_type()", header: "modelFlattenRequest.h".}

proc newModelLoadRequest*(param0: ModelLoadRequest): ModelLoadRequest {.importcpp: "new ModelLoadRequest(#)".}

proc newModelLoadRequest*(name: string, filename: Filename, options: LoaderOptions, loader: Loader): ModelLoadRequest {.importcpp: "new ModelLoadRequest(nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Create a new ModelLoadRequest, and add it to the loader via load_async(),
## to begin an asynchronous load.

proc get_filename*(this: ModelLoadRequest): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the filename associated with this asynchronous ModelLoadRequest.

proc get_options*(this: ModelLoadRequest): LoaderOptions {.importcpp: "#->get_options()".} ## \
## Returns the LoaderOptions associated with this asynchronous
## ModelLoadRequest.

proc get_loader*(this: ModelLoadRequest): Loader {.importcpp: "#->get_loader()".} ## \
## Returns the Loader object associated with this asynchronous
## ModelLoadRequest.

proc is_ready*(this: ModelLoadRequest): bool {.importcpp: "#->is_ready()".} ## \
## Returns true if this request has completed, false if it is still pending or
## if it has been cancelled.  When this returns true, you may retrieve the
## model loaded by calling get_model().
## Equivalent to `req.done() and not req.cancelled()`.
## @see done()

proc get_model*(this: ModelLoadRequest): PandaNode {.importcpp: "#->get_model()".} ## \
## Returns the model that was loaded asynchronously, if any, or null if there
## was an error.  It is an error to call this unless done() returns true.
## @deprecated Use result() instead.

proc get_class_type*(_: typedesc[ModelLoadRequest]): TypeHandle {.importcpp: "ModelLoadRequest::get_class_type()", header: "modelLoadRequest.h".}

proc newModelNode*(name: string): ModelNode {.importcpp: "new ModelNode(nimStringToStdString(#))", header: stringConversionCode.}

proc set_preserve_attributes*(this: ModelNode, attrib_mask: int) {.importcpp: "#->set_preserve_attributes(#)".} ## \
## Sets the preserve_attributes flag.  This restricts the ability of a flatten
## operation to affect the render attributes stored on this node.
##
## The value should be the union of bits from SceneGraphReducer::AttribTypes
## that represent the attributes that should *not* be changed.

proc get_preserve_attributes*(this: ModelNode): int {.importcpp: "#->get_preserve_attributes()".} ## \
## Returns the current setting of the preserve_attributes flag.  See
## set_preserve_attributes().

proc set_transform_limit*(this: ModelNode, limit: float32) {.importcpp: "#->set_transform_limit(#)".}

proc get_class_type*(_: typedesc[ModelNode]): TypeHandle {.importcpp: "ModelNode::get_class_type()", header: "modelNode.h".}

proc newModelRoot*(fullpath: Filename, timestamp: int): ModelRoot {.importcpp: "new ModelRoot(#, #)".}

proc newModelRoot*(name: string): ModelRoot {.importcpp: "new ModelRoot(nimStringToStdString(#))", header: stringConversionCode.}

proc get_model_ref_count*(this: ModelRoot): int {.importcpp: "#->get_model_ref_count()".} ## \
## Returns the number of copies that exist of this particular ModelRoot node.
## Each time ModelRoot::copy_subgraph() or make_copy() is called (or some
## other copying mechanism, such as NodePath.copy_to(), is used), this count
## will increment by one in all copies; when one of the copies is destructed,
## this count will decrement.

proc get_fullpath*(this: ModelRoot): Filename {.importcpp: "#->get_fullpath()".} ## \
## Returns the full pathname of the model represented by this node, as found
## on disk.  This is mainly useful for reference purposes, but is also used to
## index the ModelRoot into the ModelPool.

proc set_fullpath*(this: ModelRoot, fullpath: Filename) {.importcpp: "#->set_fullpath(#)".} ## \
## Sets the full pathname of the model represented by this node, as found on
## disk.  This is mainly useful for reference purposes, but is also used to
## index the ModelRoot into the ModelPool.
##
## This is normally set automatically when a model is loaded, and should not
## be set directly by the user.  If you change this on a loaded model, then
## ModelPool::release_model() may fail.

proc get_timestamp*(this: ModelRoot): int {.importcpp: "#->get_timestamp()".} ## \
## Returns the timestamp of the file on disk that was read for this model, at
## the time it was read, if it is known.  Returns 0 if the timestamp is not
## known or could not be provided.  This can be used as a quick (but fallible)
## check to verify whether the file might have changed since the model was
## read.

proc set_timestamp*(this: ModelRoot, timestamp: int) {.importcpp: "#->set_timestamp(#)".} ## \
## Sets the timestamp of the file on disk that was read for this model.  This
## is normally set automatically when a model is loaded, and should not be set
## directly by the user.

proc get_class_type*(_: typedesc[ModelRoot]): TypeHandle {.importcpp: "ModelRoot::get_class_type()", header: "modelRoot.h".}

proc has_model*(_: typedesc[ModelPool], filename: Filename): bool {.importcpp: "ModelPool::has_model(#)", header: "modelPool.h".} ## \
## Returns true if the model has ever been loaded, false otherwise.  Note that
## this does not guarantee that the model is still up-to-date.

proc verify_model*(_: typedesc[ModelPool], filename: Filename): bool {.importcpp: "ModelPool::verify_model(#)", header: "modelPool.h".} ## \
## Loads the given filename up as a model, if it has not already been loaded,
## and returns true to indicate success, or false to indicate failure.  If
## this returns true, it is probable that a subsequent call to load_model()
## with the same model name will return a valid PandaNode.
##
## However, even if this returns true, it is still possible for a subsequent
## call to load_model() to fail.  This can happen if cache-check-timestamps is
## true, and the on-disk file is subsequently modified to replace it with an
## invalid model.

proc get_model*(_: typedesc[ModelPool], filename: Filename, verify: bool): ModelRoot {.importcpp: "ModelPool::get_model(#, #)", header: "modelPool.h".} ## \
## Returns the model that has already been previously loaded, or NULL
## otherwise.  If verify is true, it will check if the file is still up-to-
## date (and hasn't been modified in the meantime), and if not, will still
## return NULL.

proc load_model*(_: typedesc[ModelPool], filename: Filename, options: LoaderOptions): ModelRoot {.importcpp: "ModelPool::load_model(#, #)", header: "modelPool.h".} ## \
## Loads the given filename up as a model, if it has not already been loaded,
## and returns the new model.  If a model with the same filename was
## previously loaded, returns that one instead (unless cache-check-timestamps
## is true and the file has recently changed).  If the model file cannot be
## found, or cannot be loaded for some reason, returns NULL.

proc load_model*(_: typedesc[ModelPool], filename: Filename): ModelRoot {.importcpp: "ModelPool::load_model(#)", header: "modelPool.h".} ## \
## Loads the given filename up as a model, if it has not already been loaded,
## and returns the new model.  If a model with the same filename was
## previously loaded, returns that one instead (unless cache-check-timestamps
## is true and the file has recently changed).  If the model file cannot be
## found, or cannot be loaded for some reason, returns NULL.

proc add_model*(_: typedesc[ModelPool], filename: Filename, model: ModelRoot) {.importcpp: "ModelPool::add_model(#, #)", header: "modelPool.h".} ## \
## Adds the indicated already-loaded model to the pool.  The model will
## replace any previously-loaded model in the pool that had the same filename.
##
## @deprecated Use the one-parameter add_model(model) instead.

proc add_model*(_: typedesc[ModelPool], model: ModelRoot) {.importcpp: "ModelPool::add_model(#)", header: "modelPool.h".} ## \
## Adds the indicated already-loaded model to the pool.  The model will
## replace any previously-loaded model in the pool that had the same filename.

proc release_model*(_: typedesc[ModelPool], filename: Filename) {.importcpp: "ModelPool::release_model(#)", header: "modelPool.h".} ## \
## Removes the indicated model from the pool, indicating it will never be
## loaded again; the model may then be freed.  If this function is never
## called, a reference count will be maintained on every model every loaded,
## and models will never be freed.
##
## @deprecated Use release_model(model) instead.

proc release_model*(_: typedesc[ModelPool], model: ModelRoot) {.importcpp: "ModelPool::release_model(#)", header: "modelPool.h".} ## \
## Removes the indicated model from the pool, indicating it will never be
## loaded again; the model may then be freed.  If this function (and
## garbage_collect()) is never called, a reference count will be maintained on
## every model every loaded, and models will never be freed.
##
## The model's get_fullpath() value should not have been changed during its
## lifetime, or this function may fail to locate it in the pool.

proc release_all_models*(_: typedesc[ModelPool]) {.importcpp: "ModelPool::release_all_models()", header: "modelPool.h".} ## \
## Releases all models in the pool and restores the pool to the empty state.

proc garbage_collect*(_: typedesc[ModelPool]): int {.importcpp: "ModelPool::garbage_collect()", header: "modelPool.h".} ## \
## Releases only those models in the pool that have a reference count of
## exactly 1; i.e.  only those models that are not being used outside of the
## pool.  Returns the number of models released.

proc list_contents*(_: typedesc[ModelPool]) {.importcpp: "ModelPool::list_contents()", header: "modelPool.h".} ## \
## Lists the contents of the model pool to cout.

proc list_contents*(_: typedesc[ModelPool], `out`: ostream) {.importcpp: "ModelPool::list_contents(#)", header: "modelPool.h".} ## \
## Lists the contents of the model pool to the indicated output stream.

proc write*(_: typedesc[ModelPool], `out`: ostream) {.importcpp: "ModelPool::write(#)", header: "modelPool.h".} ## \
## Lists the contents of the model pool to the indicated output stream.  Helps
## with debugging.

proc newModelSaveRequest*(param0: ModelSaveRequest): ModelSaveRequest {.importcpp: "new ModelSaveRequest(#)".}

proc newModelSaveRequest*(name: string, filename: Filename, options: LoaderOptions, node: PandaNode, loader: Loader): ModelSaveRequest {.importcpp: "new ModelSaveRequest(nimStringToStdString(#), #, #, #, #)", header: stringConversionCode.} ## \
## Create a new ModelSaveRequest, and add it to the loader via save_async(),
## to begin an asynchronous save.

proc get_filename*(this: ModelSaveRequest): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the filename associated with this asynchronous ModelSaveRequest.

proc get_options*(this: ModelSaveRequest): LoaderOptions {.importcpp: "#->get_options()".} ## \
## Returns the LoaderOptions associated with this asynchronous
## ModelSaveRequest.

proc get_node*(this: ModelSaveRequest): PandaNode {.importcpp: "#->get_node()".} ## \
## Returns the node that was passed to the constructor.

proc get_loader*(this: ModelSaveRequest): Loader {.importcpp: "#->get_loader()".} ## \
## Returns the Loader object associated with this asynchronous
## ModelSaveRequest.

proc is_ready*(this: ModelSaveRequest): bool {.importcpp: "#->is_ready()".} ## \
## Returns true if this request has completed, false if it is still pending.
## When this returns true, you may retrieve the success flag with
## get_success().
## Equivalent to `req.done() and not req.cancelled()`.
## @see done()

proc get_success*(this: ModelSaveRequest): bool {.importcpp: "#->get_success()".} ## \
## Returns the true if the model was saved successfully, false otherwise.  It
## is an error to call this unless done() returns true.

proc get_class_type*(_: typedesc[ModelSaveRequest]): TypeHandle {.importcpp: "ModelSaveRequest::get_class_type()", header: "modelSaveRequest.h".}

proc make*(_: typedesc[TextureAttrib]): RenderAttrib {.importcpp: "TextureAttrib::make()", header: "textureAttrib.h".} ## \
## The following methods define the new multitexture mode for TextureAttrib.
## Each TextureAttrib can add or remove individual texture stages from the
## complete set of textures that are to be applied; this is similar to the
## mechanism of LightAttrib.

proc make*(_: typedesc[TextureAttrib], tex: Texture): RenderAttrib {.importcpp: "TextureAttrib::make(#)", header: "textureAttrib.h".} ## \
## Constructs a new TextureAttrib object suitable for rendering the indicated
## texture onto geometry, using the default TextureStage.

proc make_off*(_: typedesc[TextureAttrib]): RenderAttrib {.importcpp: "TextureAttrib::make_off()", header: "textureAttrib.h".} ## \
## Constructs a new TextureAttrib object suitable for rendering untextured
## geometry.

proc make_default*(_: typedesc[TextureAttrib]): RenderAttrib {.importcpp: "TextureAttrib::make_default()", header: "textureAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc is_off*(this: TextureAttrib): bool {.importcpp: "#->is_off()".} ## \
## Returns true if the TextureAttrib is an 'off' TextureAttrib, indicating
## that it should disable texturing.
##
## If multitexture is in effect, a TextureAttrib may not be strictly "on" or
## "off"; therefore, to get a more precise answer to this question, you should
## consider using has_all_off() or get_num_off_stages() or has_off_stage()
## instead.

proc get_texture*(this: TextureAttrib): Texture {.importcpp: "#->get_texture()".} ## \
## If the TextureAttrib is not an 'off' TextureAttrib, returns the base-level
## texture that is associated.  Otherwise, return NULL.

proc make_all_off*(_: typedesc[TextureAttrib]): RenderAttrib {.importcpp: "TextureAttrib::make_all_off()", header: "textureAttrib.h".} ## \
## Constructs a new TextureAttrib object that turns off all stages (and hence
## disables texturing).

proc get_num_on_stages*(this: TextureAttrib): int {.importcpp: "#->get_num_on_stages()".} ## \
## Returns the number of stages that are turned on by the attribute.

proc get_on_stage*(this: TextureAttrib, n: int): TextureStage {.importcpp: "#->get_on_stage(#)".} ## \
## Returns the nth stage turned on by the attribute, sorted in render order.

proc get_num_on_ff_stages*(this: TextureAttrib): int {.importcpp: "#->get_num_on_ff_stages()".} ## \
## Returns the number of on-stages that are relevant to the classic fixed
## function pipeline.  This excludes texture stages such as normal maps.

proc get_on_ff_stage*(this: TextureAttrib, n: int): TextureStage {.importcpp: "#->get_on_ff_stage(#)".} ## \
## Returns the nth stage turned on by the attribute, sorted in render order,
## including only those relevant to the classic fixed function pipeline.  This
## excludes texture stages such as normal maps.

proc get_ff_tc_index*(this: TextureAttrib, n: int): int {.importcpp: "#->get_ff_tc_index(#)".} ## \
## For each TextureStage listed in get_on_ff_stage(), this returns a unique
## index number for the texture coordinate name used by that TextureStage.  It
## is guaranteed to remain the same index number for each texcoord name (for a
## given set of TextureStages), even if the texture render order changes.

proc has_on_stage*(this: TextureAttrib, stage: TextureStage): bool {.importcpp: "#->has_on_stage(#)".} ## \
## Returns true if the indicated stage is turned on by the attrib, false
## otherwise.

proc get_on_texture*(this: TextureAttrib, stage: TextureStage): Texture {.importcpp: "#->get_on_texture(#)".} ## \
## Returns the texture associated with the indicated stage, or NULL if no
## texture is associated.

proc get_on_sampler*(this: TextureAttrib, stage: TextureStage): SamplerState {.importcpp: "#->get_on_sampler(#)".} ## \
## Returns the sampler associated with the indicated stage, or the one
## associated with its texture if no custom stage has been specified.  It is
## an error to call this if the stage does not exist.

proc get_on_stage_override*(this: TextureAttrib, stage: TextureStage): int {.importcpp: "#->get_on_stage_override(#)".} ## \
## Returns the override value associated with the indicated stage.

proc find_on_stage*(this: TextureAttrib, stage: TextureStage): int {.importcpp: "#->find_on_stage(#)".} ## \
## Returns the index number of the indicated TextureStage within the list of
## on_stages, or -1 if the indicated stage is not listed.

proc get_num_off_stages*(this: TextureAttrib): int {.importcpp: "#->get_num_off_stages()".} ## \
## Returns the number of stages that are turned off by the attribute.

proc get_off_stage*(this: TextureAttrib, n: int): TextureStage {.importcpp: "#->get_off_stage(#)".} ## \
## Returns the nth stage turned off by the attribute, sorted in arbitrary
## (pointer) order.

proc has_off_stage*(this: TextureAttrib, stage: TextureStage): bool {.importcpp: "#->has_off_stage(#)".} ## \
## Returns true if the indicated stage is turned off by the attrib, false
## otherwise.

proc has_all_off*(this: TextureAttrib): bool {.importcpp: "#->has_all_off()".} ## \
## Returns true if this attrib turns off all stages (although it may also turn
## some on).

proc is_identity*(this: TextureAttrib): bool {.importcpp: "#->is_identity()".} ## \
## Returns true if this is an identity attrib: it does not change the set of
## stages in use.

proc add_on_stage*(this: TextureAttrib, stage: TextureStage, tex: Texture, sampler: SamplerState, override: int): RenderAttrib {.importcpp: "#->add_on_stage(#, #, #, #)".} ## \
## Returns a new TextureAttrib, just like this one, but with the indicated
## stage added to the list of stages turned on by this attrib.

proc add_on_stage*(this: TextureAttrib, stage: TextureStage, tex: Texture, sampler: SamplerState): RenderAttrib {.importcpp: "#->add_on_stage(#, #, #)".} ## \
## Returns a new TextureAttrib, just like this one, but with the indicated
## stage added to the list of stages turned on by this attrib.

proc add_on_stage*(this: TextureAttrib, stage: TextureStage, tex: Texture, override: int): RenderAttrib {.importcpp: "#->add_on_stage(#, #, #)".} ## \
## Returns a new TextureAttrib, just like this one, but with the indicated
## stage added to the list of stages turned on by this attrib.

proc add_on_stage*(this: TextureAttrib, stage: TextureStage, tex: Texture): RenderAttrib {.importcpp: "#->add_on_stage(#, #)".} ## \
## Returns a new TextureAttrib, just like this one, but with the indicated
## stage added to the list of stages turned on by this attrib.

proc remove_on_stage*(this: TextureAttrib, stage: TextureStage): RenderAttrib {.importcpp: "#->remove_on_stage(#)".} ## \
## Returns a new TextureAttrib, just like this one, but with the indicated
## stage removed from the list of stages turned on by this attrib.

proc add_off_stage*(this: TextureAttrib, stage: TextureStage, override: int): RenderAttrib {.importcpp: "#->add_off_stage(#, #)".} ## \
## Returns a new TextureAttrib, just like this one, but with the indicated
## stage added to the list of stages turned off by this attrib.

proc add_off_stage*(this: TextureAttrib, stage: TextureStage): RenderAttrib {.importcpp: "#->add_off_stage(#)".} ## \
## Returns a new TextureAttrib, just like this one, but with the indicated
## stage added to the list of stages turned off by this attrib.

proc remove_off_stage*(this: TextureAttrib, stage: TextureStage): RenderAttrib {.importcpp: "#->remove_off_stage(#)".} ## \
## Returns a new TextureAttrib, just like this one, but with the indicated
## stage removed from the list of stages turned off by this attrib.

proc unify_texture_stages*(this: TextureAttrib, stage: TextureStage): RenderAttrib {.importcpp: "#->unify_texture_stages(#)".} ## \
## Returns a new TextureAttrib, just like this one, but with any included
## TextureAttribs that happen to have the same name as the given object
## replaced with the object.

proc replace_texture*(this: TextureAttrib, tex: Texture, new_tex: Texture): RenderAttrib {.importcpp: "#->replace_texture(#, #)".} ## \
## Returns a new TextureAttrib, just like this one, but with all references to
## the given texture replaced with the new texture.
##
## @since 1.10.4

proc get_class_slot*(_: typedesc[TextureAttrib]): int {.importcpp: "TextureAttrib::get_class_slot()", header: "textureAttrib.h".}

proc get_class_type*(_: typedesc[TextureAttrib]): TypeHandle {.importcpp: "TextureAttrib::get_class_type()", header: "textureAttrib.h".}

proc make*(_: typedesc[TexGenAttrib]): RenderAttrib {.importcpp: "TexGenAttrib::make()", header: "texGenAttrib.h".} ## \
## Constructs a TexGenAttrib that generates no stages at all.

proc make_default*(_: typedesc[TexGenAttrib]): RenderAttrib {.importcpp: "TexGenAttrib::make_default()", header: "texGenAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc remove_stage*(this: TexGenAttrib, stage: TextureStage): RenderAttrib {.importcpp: "#->remove_stage(#)".} ## \
## Returns a new TexGenAttrib just like this one, with the indicated stage
## removed.

proc is_empty*(this: TexGenAttrib): bool {.importcpp: "#->is_empty()".} ## \
## Returns true if no stages are defined in the TexGenAttrib, false if at
## least one is.

proc has_stage*(this: TexGenAttrib, stage: TextureStage): bool {.importcpp: "#->has_stage(#)".} ## \
## Returns true if there is a mode associated with the indicated stage, or
## false otherwise (in which case get_transform(stage) will return M_off).

proc has_gen_texcoord_stage*(this: TexGenAttrib, stage: TextureStage): bool {.importcpp: "#->has_gen_texcoord_stage(#)".} ## \
## Returns true if the indicated TextureStage will have texture coordinates
## generated for it automatically (and thus there is no need to upload the
## texture coordinates encoded in the vertices).

proc get_constant_value*(this: TexGenAttrib, stage: TextureStage): LTexCoord3 {.importcpp: "#->get_constant_value(#)".} ## \
## Returns the constant value associated with the named texture stage.  This
## is only meaningful if the mode is M_constant.

proc get_geom_rendering*(this: TexGenAttrib, geom_rendering: int): int {.importcpp: "#->get_geom_rendering(#)".} ## \
## Returns the union of the Geom::GeomRendering bits that will be required
## once this TexGenAttrib is applied to a geom which includes the indicated
## geom_rendering bits.

proc get_class_slot*(_: typedesc[TexGenAttrib]): int {.importcpp: "TexGenAttrib::get_class_slot()", header: "texGenAttrib.h".}

proc get_class_type*(_: typedesc[TexGenAttrib]): TypeHandle {.importcpp: "TexGenAttrib::get_class_type()", header: "texGenAttrib.h".}

proc newOccluderNode*(name: string): OccluderNode {.importcpp: "new OccluderNode(nimStringToStdString(#))", header: stringConversionCode.} ## \
## The default constructor creates a default occlusion polygon in the XZ plane
## (or XY plane in a y-up coordinate system).  Use the normal Panda set_pos(),
## set_hpr(), set_scale() to position it appropriately, or replace the
## vertices with set_vertices().

proc set_double_sided*(this: OccluderNode, value: bool) {.importcpp: "#->set_double_sided(#)".} ## \
## If true, the back-face will also be used to occlude

proc is_double_sided*(this: OccluderNode): bool {.importcpp: "#->is_double_sided()".} ## \
## Is this occluder double-sided

proc set_min_coverage*(this: OccluderNode, value: float32) {.importcpp: "#->set_min_coverage(#)".} ## \
## Minimum screen coverage needed before occluder used.  Range should be 0 to
## 1. For example, setting to 0.2 would mean that the occluder needs to cover
## 20% of the screen to be considered.

proc get_min_coverage*(this: OccluderNode): float32 {.importcpp: "#->get_min_coverage()".} ## \
## Returns the minimum screen coverage.

proc set_vertices*(this: OccluderNode, v0: LPoint3, v1: LPoint3, v2: LPoint3, v3: LPoint3) {.importcpp: "#->set_vertices(#, #, #, #)".} ## \
## Replaces the four vertices of the occluder polygon.  The vertices should be
## defined in a counterclockwise orientation when looking at the face of the
## occluder.

proc get_num_vertices*(this: OccluderNode): clonglong {.importcpp: "#->get_num_vertices()".} ## \
## Returns the number of vertices in the occluder polygon.  This should always
## return 4.

proc get_vertex*(this: OccluderNode, n: clonglong): LPoint3 {.importcpp: "#->get_vertex(#)".} ## \
## Returns the nth vertex of the occluder polygon.

proc set_vertex*(this: OccluderNode, n: clonglong, v: LPoint3) {.importcpp: "#->set_vertex(#, #)".} ## \
## Sets the nth vertex of the occluder polygon.

proc get_class_type*(_: typedesc[OccluderNode]): TypeHandle {.importcpp: "OccluderNode::get_class_type()", header: "occluderNode.h".}

proc make*(_: typedesc[OccluderEffect]): RenderEffect {.importcpp: "OccluderEffect::make()", header: "occluderEffect.h".} ## \
## Constructs a new OccluderEffect object that does nothing.

proc get_num_on_occluders*(this: OccluderEffect): int {.importcpp: "#->get_num_on_occluders()".} ## \
## Returns the number of occluders that are enabled by the effectute.

proc get_on_occluder*(this: OccluderEffect, n: int): NodePath {.importcpp: "#->get_on_occluder(#)".} ## \
## Returns the nth occluder enabled by the effectute, sorted in render order.

proc has_on_occluder*(this: OccluderEffect, occluder: NodePath): bool {.importcpp: "#->has_on_occluder(#)".} ## \
## Returns true if the indicated occluder is enabled by the effect, false
## otherwise.

proc is_identity*(this: OccluderEffect): bool {.importcpp: "#->is_identity()".} ## \
## Returns true if this is an identity effect: it does not change the set of
## occluders in use.

proc add_on_occluder*(this: OccluderEffect, occluder: NodePath): RenderEffect {.importcpp: "#->add_on_occluder(#)".} ## \
## Returns a new OccluderEffect, just like this one, but with the indicated
## occluder added to the list of occluders enabled by this effect.

proc remove_on_occluder*(this: OccluderEffect, occluder: NodePath): RenderEffect {.importcpp: "#->remove_on_occluder(#)".} ## \
## Returns a new OccluderEffect, just like this one, but with the indicated
## occluder removed from the list of occluders enabled by this effect.

proc get_class_type*(_: typedesc[OccluderEffect]): TypeHandle {.importcpp: "OccluderEffect::get_class_type()", header: "occluderEffect.h".}

proc newPolylightNode*(param0: PolylightNode): PolylightNode {.importcpp: "new PolylightNode(#)".}

proc newPolylightNode*(name: string): PolylightNode {.importcpp: "new PolylightNode(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Use PolylightNode() to construct a new PolylightNode object.

proc enable*(this: PolylightNode) {.importcpp: "#->enable()".} ## \
## Enable this light

proc disable*(this: PolylightNode) {.importcpp: "#->disable()".} ## \
## Disable this light

proc set_pos*(this: PolylightNode, position: LPoint3) {.importcpp: "#->set_pos(#)".} ## \
## Set this light's position

proc set_pos*(this: PolylightNode, x: float32, y: float32, z: float32) {.importcpp: "#->set_pos(#, #, #)".} ## \
## Set this light's position

proc get_pos*(this: PolylightNode): LPoint3 {.importcpp: "#->get_pos()".} ## \
## Returns position as a LPoint3

proc set_color*(this: PolylightNode, color: LColor) {.importcpp: "#->set_color(#)".} ## \
## Set the light's color...

proc set_color*(this: PolylightNode, r: float32, g: float32, b: float32) {.importcpp: "#->set_color(#, #, #)".} ## \
## Set the light's color... 3 floats between 0 and 1

proc get_color*(this: PolylightNode): LColor {.importcpp: "#->get_color()".} ## \
## Returns the light's color as LColor

proc get_color_scenegraph*(this: PolylightNode): LColor {.importcpp: "#->get_color_scenegraph()".} ## \
## This differs from get_color in that when applying the light color we need
## to make sure that a color flattening external to the PolylightNode is not
## ignored.

proc set_radius*(this: PolylightNode, r: float32) {.importcpp: "#->set_radius(#)".} ## \
## Set radius of the spherical light volume

proc get_radius*(this: PolylightNode): float32 {.importcpp: "#->get_radius()".} ## \
## Get radius of the spherical light volume

proc set_a0*(this: PolylightNode, a0: float32) {.importcpp: "#->set_a0(#)".} ## \
## Set the quadratic attenuation factor a0 fd = 1 / ( a0 + a1*distance +
## a2*distance*distance)

proc set_a1*(this: PolylightNode, a1: float32) {.importcpp: "#->set_a1(#)".} ## \
## Set the quadratic attenuation factor a1 fd = 1 / ( a0 + a1*distance +
## a2*distance*distance)

proc set_a2*(this: PolylightNode, a2: float32) {.importcpp: "#->set_a2(#)".} ## \
## Set the quadratic attenuation factor a2 fd = 1 / ( a0 + a1*distance +
## a2*distance*distance)

proc get_a0*(this: PolylightNode): float32 {.importcpp: "#->get_a0()".} ## \
## Get the quadratic attenuation factor a0 fd = 1 / ( a0 + a1*distance +
## a2*distance*distance)

proc get_a1*(this: PolylightNode): float32 {.importcpp: "#->get_a1()".} ## \
## Get the quadratic attenuation factor a1 fd = 1 / ( a0 + a1*distance +
## a2*distance*distance)

proc get_a2*(this: PolylightNode): float32 {.importcpp: "#->get_a2()".} ## \
## Get the quadratic attenuation factor a2 fd = 1 / ( a0 + a1*distance +
## a2*distance*distance)

proc flicker_on*(this: PolylightNode) {.importcpp: "#->flicker_on()".} ## \
## Set flickering to true so at every loop this light's color is varied based
## on flicker_type

proc flicker_off*(this: PolylightNode) {.importcpp: "#->flicker_off()".} ## \
## Turn flickering off

proc is_flickering*(this: PolylightNode): bool {.importcpp: "#->is_flickering()".} ## \
## Check is this light is flickering

proc set_offset*(this: PolylightNode, offset: float32) {.importcpp: "#->set_offset(#)".} ## \
## Set the offset value for the random and sin flicker variations... used to
## tweak the flicker This value is added to the variation

proc get_offset*(this: PolylightNode): float32 {.importcpp: "#->get_offset()".} ## \
## Get the offset value for the random and sin flicker variations

proc set_scale*(this: PolylightNode, scale: float32) {.importcpp: "#->set_scale(#)".} ## \
## Set the scale value for the random and sin flicker variations... used to
## tweak the flicker This value is multiplied with the variation

proc get_scale*(this: PolylightNode): float32 {.importcpp: "#->get_scale()".} ## \
## Get the scale value for the random and sin flicker variations

proc set_step_size*(this: PolylightNode, step: float32) {.importcpp: "#->set_step_size(#)".} ## \
## Set the step size for the sin function in flicker This is the increment
## size for the value supplied to the sin function

proc get_step_size*(this: PolylightNode): float32 {.importcpp: "#->get_step_size()".} ## \
## Get the step size for the sin function in flicker This is the increment
## size for the value supplied to the sin function

proc set_freq*(this: PolylightNode, f: float32) {.importcpp: "#->set_freq(#)".} ## \
## Set frequency of sin flicker

proc get_freq*(this: PolylightNode): float32 {.importcpp: "#->get_freq()".} ## \
## Get frequency of sin flicker

proc `==`*(this: PolylightNode, other: PolylightNode): bool {.importcpp: "#->operator ==(#)".} ## \
## Comparison methods

proc `!=`*(this: PolylightNode, other: PolylightNode): bool {.importcpp: "#->operator !=(#)".}

proc `<`*(this: PolylightNode, other: PolylightNode): bool {.importcpp: "#->operator <(#)".}

proc compare_to*(this: PolylightNode, other: PolylightNode): int {.importcpp: "#->compare_to(#)".} ## \
## Returns a number less than zero if this PolylightNode sorts before the
## other one, greater than zero if it sorts after, or zero if they are
## equivalent.
##
## Two PolylightNodes are considered equivalent if they consist of exactly the
## same properties Otherwise, they are different; different PolylightNodes
## will be ranked in a consistent but undefined ordering; the ordering is
## useful only for placing the PolylightNodes in a sorted container like an
## STL set.

proc is_enabled*(this: PolylightNode): bool {.importcpp: "#->is_enabled()".} ## \
## Is this light is enabled/disabled?

proc get_class_type*(_: typedesc[PolylightNode]): TypeHandle {.importcpp: "PolylightNode::get_class_type()", header: "polylightNode.h".}

proc make*(_: typedesc[PolylightEffect]): RenderEffect {.importcpp: "PolylightEffect::make()", header: "polylightEffect.h".} ## \
## Constructs a new PolylightEffect object.

proc add_light*(this: PolylightEffect, newlight: NodePath): RenderEffect {.importcpp: "#->add_light(#)".} ## \
## Add a PolylightNode object to this effect and return a new effect

proc remove_light*(this: PolylightEffect, newlight: NodePath): RenderEffect {.importcpp: "#->remove_light(#)".} ## \
## Remove a light from this effect.  Return the new updated effect

proc set_weight*(this: PolylightEffect, w: float32): RenderEffect {.importcpp: "#->set_weight(#)".} ## \
## Set weight and return a new effect... the reason this couldnt be done
## through make was because that would return a new effect without the
## lightgroup which is static and cant be accessed Here, we just pass that to
## the make

proc set_effect_center*(this: PolylightEffect, ec: LPoint3): RenderEffect {.importcpp: "#->set_effect_center(#)".} ## \
## Set weight and return a new effect... the reason this couldnt be done
## through make was because that would return a new effect without the
## lightgroup which is static and cant be accessed Here, we just pass that to
## the make

proc get_weight*(this: PolylightEffect): float32 {.importcpp: "#->get_weight()".} ## \
## Get the weight value

proc get_effect_center*(this: PolylightEffect): LPoint3 {.importcpp: "#->get_effect_center()".} ## \
## Return the value of the _effect_center

proc has_light*(this: PolylightEffect, light: NodePath): bool {.importcpp: "#->has_light(#)".} ## \
## Returns true if the indicated light is listed in the PolylightEffect, false
## otherwise.

proc get_class_type*(_: typedesc[PolylightEffect]): TypeHandle {.importcpp: "PolylightEffect::get_class_type()", header: "polylightEffect.h".}

proc make*(_: typedesc[ShaderAttrib], shader: Shader, priority: int): RenderAttrib {.importcpp: "ShaderAttrib::make(#, #)", header: "shaderAttrib.h".} ## \
## Constructs a new ShaderAttrib object with nothing set.

proc make*(_: typedesc[ShaderAttrib], shader: Shader): RenderAttrib {.importcpp: "ShaderAttrib::make(#)", header: "shaderAttrib.h".} ## \
## Constructs a new ShaderAttrib object with nothing set.

proc make*(_: typedesc[ShaderAttrib]): RenderAttrib {.importcpp: "ShaderAttrib::make()", header: "shaderAttrib.h".} ## \
## Constructs a new ShaderAttrib object with nothing set.

proc make_off*(_: typedesc[ShaderAttrib]): RenderAttrib {.importcpp: "ShaderAttrib::make_off()", header: "shaderAttrib.h".} ## \
## Constructs a new ShaderAttrib object that disables the use of shaders (it
## does not clear out all shader data, however.)

proc make_default*(_: typedesc[ShaderAttrib]): RenderAttrib {.importcpp: "ShaderAttrib::make_default()", header: "shaderAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc has_shader*(this: ShaderAttrib): bool {.importcpp: "#->has_shader()".} ## \
## If true, the shader field of this attribute overrides the shader field of
## the parent attribute.

proc auto_shader*(this: ShaderAttrib): bool {.importcpp: "#->auto_shader()".} ## \
## If true, then this ShaderAttrib does not contain an explicit shader -
## instead, it requests the automatic generation of a shader.

proc get_shader_priority*(this: ShaderAttrib): int {.importcpp: "#->get_shader_priority()".}

proc get_instance_count*(this: ShaderAttrib): int {.importcpp: "#->get_instance_count()".} ## \
## Returns the number of geometry instances.  A value of 0 means not to use
## instancing at all.

proc auto_normal_on*(this: ShaderAttrib): bool {.importcpp: "#->auto_normal_on()".}

proc auto_glow_on*(this: ShaderAttrib): bool {.importcpp: "#->auto_glow_on()".}

proc auto_gloss_on*(this: ShaderAttrib): bool {.importcpp: "#->auto_gloss_on()".}

proc auto_ramp_on*(this: ShaderAttrib): bool {.importcpp: "#->auto_ramp_on()".}

proc auto_shadow_on*(this: ShaderAttrib): bool {.importcpp: "#->auto_shadow_on()".}

proc set_shader*(this: ShaderAttrib, s: Shader, priority: int): RenderAttrib {.importcpp: "#->set_shader(#, #)".}

proc set_shader*(this: ShaderAttrib, s: Shader): RenderAttrib {.importcpp: "#->set_shader(#)".}

proc set_shader_off*(this: ShaderAttrib, priority: int): RenderAttrib {.importcpp: "#->set_shader_off(#)".}

proc set_shader_off*(this: ShaderAttrib): RenderAttrib {.importcpp: "#->set_shader_off()".}

proc set_shader_auto*(this: ShaderAttrib, priority: int): RenderAttrib {.importcpp: "#->set_shader_auto(#)".}

proc set_shader_auto*(this: ShaderAttrib): RenderAttrib {.importcpp: "#->set_shader_auto()".}

proc clear_shader*(this: ShaderAttrib): RenderAttrib {.importcpp: "#->clear_shader()".}

proc set_shader_input*(this: ShaderAttrib, input: ShaderInput): RenderAttrib {.importcpp: "#->set_shader_input(#)".} ## \
## Shader Inputs

proc set_instance_count*(this: ShaderAttrib, instance_count: int): RenderAttrib {.importcpp: "#->set_instance_count(#)".} ## \
## Sets the geometry instance count.  Do not confuse this with instanceTo,
## which is used for animation instancing, and has nothing to do with this.  A
## value of 0 means not to use instancing at all.

proc set_flag*(this: ShaderAttrib, flag: int, value: bool): RenderAttrib {.importcpp: "#->set_flag(#, #)".}

proc clear_flag*(this: ShaderAttrib, flag: int): RenderAttrib {.importcpp: "#->clear_flag(#)".}

proc clear_shader_input*(this: ShaderAttrib, id: InternalName): RenderAttrib {.importcpp: "#->clear_shader_input(#)".}

proc clear_shader_input*(this: ShaderAttrib, id: string): RenderAttrib {.importcpp: "#->clear_shader_input(nimStringToStdString(#))", header: stringConversionCode.}

proc clear_all_shader_inputs*(this: ShaderAttrib): RenderAttrib {.importcpp: "#->clear_all_shader_inputs()".} ## \
## Clears all the shader inputs on the attrib.

proc get_flag*(this: ShaderAttrib, flag: int): bool {.importcpp: "#->get_flag(#)".}

proc has_shader_input*(this: ShaderAttrib, id: InternalName): bool {.importcpp: "#->has_shader_input(#)".} ## \
## Returns true if there is a ShaderInput of the given name.

proc get_shader*(this: ShaderAttrib): Shader {.importcpp: "#->get_shader()".} ## \
## Returns the shader object associated with the node.  If get_override
## returns true, but get_shader returns NULL, that means that this attribute
## should disable the shader.

proc get_shader_input*(this: ShaderAttrib, id: InternalName): ShaderInput {.importcpp: "#->get_shader_input(#)".} ## \
## Returns the ShaderInput of the given name.  If no such name is found, this
## function does not return NULL --- it returns the "blank" ShaderInput.

proc get_shader_input*(this: ShaderAttrib, id: string): ShaderInput {.importcpp: "#->get_shader_input(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the ShaderInput of the given name.  If no such name is found, this
## function does not return NULL --- it returns the "blank" ShaderInput.

proc get_shader_input_nodepath*(this: ShaderAttrib, id: InternalName): NodePath {.importcpp: "#->get_shader_input_nodepath(#)".} ## \
## Returns the ShaderInput as a nodepath.  Assertion fails if there is none,
## or if it is not a nodepath.

proc get_shader_input_vector*(this: ShaderAttrib, id: InternalName): LVecBase4 {.importcpp: "#->get_shader_input_vector(#)".} ## \
## Returns the ShaderInput as a vector.  Assertion fails if there is none, or
## if it is not a vector.

proc get_shader_input_texture*(this: ShaderAttrib, id: InternalName, sampler: SamplerState): Texture {.importcpp: "#->get_shader_input_texture(#, #)".} ## \
## Returns the ShaderInput as a texture.  Assertion fails if there is none, or
## if it is not a texture.
##
## If sampler is not NULL, the sampler state to use for this texture is
## assigned to it.

proc get_shader_input_texture*(this: ShaderAttrib, id: InternalName): Texture {.importcpp: "#->get_shader_input_texture(#)".} ## \
## Returns the ShaderInput as a texture.  Assertion fails if there is none, or
## if it is not a texture.
##
## If sampler is not NULL, the sampler state to use for this texture is
## assigned to it.

proc get_shader_input_matrix*(this: ShaderAttrib, id: InternalName, matrix: LMatrix4): LMatrix4 {.importcpp: "#->get_shader_input_matrix(#, #)".} ## \
## Returns the ShaderInput as a matrix.  Assertion fails if there is none, or
## if it is not a matrix or NodePath.

proc get_shader_input_buffer*(this: ShaderAttrib, id: InternalName): ShaderBuffer {.importcpp: "#->get_shader_input_buffer(#)".} ## \
## Returns the ShaderInput as a ShaderBuffer.  Assertion fails if there is
## none, or if it is not a ShaderBuffer.

proc register_with_read_factory*(_: typedesc[ShaderAttrib]) {.importcpp: "ShaderAttrib::register_with_read_factory()", header: "shaderAttrib.h".} ## \
## Factory method to generate a Shader object

proc get_class_slot*(_: typedesc[ShaderAttrib]): int {.importcpp: "ShaderAttrib::get_class_slot()", header: "shaderAttrib.h".}

proc get_class_type*(_: typedesc[ShaderAttrib]): TypeHandle {.importcpp: "ShaderAttrib::get_class_type()", header: "shaderAttrib.h".}

proc make*(_: typedesc[ShowBoundsEffect], tight: bool): RenderEffect {.importcpp: "ShowBoundsEffect::make(#)", header: "showBoundsEffect.h".} ## \
## Constructs a new ShowBoundsEffect object.

proc make*(_: typedesc[ShowBoundsEffect]): RenderEffect {.importcpp: "ShowBoundsEffect::make()", header: "showBoundsEffect.h".} ## \
## Constructs a new ShowBoundsEffect object.

proc get_tight*(this: ShowBoundsEffect): bool {.importcpp: "#->get_tight()".} ## \
## Returns true if the "tight" flag was set, meaning the effect should compute
## and draw the tight bounding-box of the node's vertices every frame.

proc get_class_type*(_: typedesc[ShowBoundsEffect]): TypeHandle {.importcpp: "ShowBoundsEffect::get_class_type()", header: "showBoundsEffect.h".}

proc make*(_: typedesc[TexProjectorEffect]): RenderEffect {.importcpp: "TexProjectorEffect::make()", header: "texProjectorEffect.h".} ## \
## Constructs a TexProjectorEffect that modifies no stages at all.

proc add_stage*(this: TexProjectorEffect, stage: TextureStage, `from`: NodePath, to: NodePath, lens_index: int): RenderEffect {.importcpp: "#->add_stage(#, #, #, #)".} ## \
## Returns a new TexProjectorEffect just like this one, with the indicated
## projection for the given stage.  If this stage already exists, its
## projection definition is replaced.
##
## The relative transform between the "from" and the "to" nodes is
## automatically applied to the texture transform each frame.
##
## Furthermore, if the "to" node is a LensNode, its projection matrix is also
## applied to the texture transform.  In this case, the lens_index may be used
## to select the particular lens that should be used.

proc add_stage*(this: TexProjectorEffect, stage: TextureStage, `from`: NodePath, to: NodePath): RenderEffect {.importcpp: "#->add_stage(#, #, #)".} ## \
## Returns a new TexProjectorEffect just like this one, with the indicated
## projection for the given stage.  If this stage already exists, its
## projection definition is replaced.
##
## The relative transform between the "from" and the "to" nodes is
## automatically applied to the texture transform each frame.
##
## Furthermore, if the "to" node is a LensNode, its projection matrix is also
## applied to the texture transform.  In this case, the lens_index may be used
## to select the particular lens that should be used.

proc remove_stage*(this: TexProjectorEffect, stage: TextureStage): RenderEffect {.importcpp: "#->remove_stage(#)".} ## \
## Returns a new TexProjectorEffect just like this one, with the indicated
## stage removed.

proc is_empty*(this: TexProjectorEffect): bool {.importcpp: "#->is_empty()".} ## \
## Returns true if no stages are defined in the TexProjectorEffect, false if
## at least one is.

proc has_stage*(this: TexProjectorEffect, stage: TextureStage): bool {.importcpp: "#->has_stage(#)".} ## \
## Returns true if there is a transform associated with the indicated stage,
## or false otherwise (in which case get_transform(stage) will return the
## identity transform).

proc get_from*(this: TexProjectorEffect, stage: TextureStage): NodePath {.importcpp: "#->get_from(#)".} ## \
## Returns the "from" node associated with the TexProjectorEffect on the
## indicated stage.  The relative transform between the "from" and the "to"
## nodes is automatically applied to the texture transform each frame.

proc get_to*(this: TexProjectorEffect, stage: TextureStage): NodePath {.importcpp: "#->get_to(#)".} ## \
## Returns the "to" node associated with the TexProjectorEffect on the
## indicated stage.  The relative transform between the "from" and the "to"
## nodes is automatically applied to the texture transform each frame.
##
## Furthermore, if the "to" node is a LensNode, its projection matrix is also
## applied to the texture transform.

proc get_lens_index*(this: TexProjectorEffect, stage: TextureStage): int {.importcpp: "#->get_lens_index(#)".} ## \
## Returns the lens_index associated with the TexProjectorEffect on the
## indicated stage.  This is only used if the "to" node is a LensNode, in
## which case it specifies the particular lens that should be used.

proc get_class_type*(_: typedesc[TexProjectorEffect]): TypeHandle {.importcpp: "TexProjectorEffect::get_class_type()", header: "texProjectorEffect.h".}

proc make_screen*(_: typedesc[ScissorEffect], frame: LVecBase4, clip: bool): RenderEffect {.importcpp: "ScissorEffect::make_screen(#, #)", header: "scissorEffect.h".} ## \
## Constructs a new screen-relative ScissorEffect.  The frame defines a left,
## right, bottom, top region, relative to the DisplayRegion.  See
## ScissorAttrib.

proc make_screen*(_: typedesc[ScissorEffect], frame: LVecBase4): RenderEffect {.importcpp: "ScissorEffect::make_screen(#)", header: "scissorEffect.h".} ## \
## Constructs a new screen-relative ScissorEffect.  The frame defines a left,
## right, bottom, top region, relative to the DisplayRegion.  See
## ScissorAttrib.

proc make_node*(_: typedesc[ScissorEffect], a: LPoint3, b: LPoint3, c: LPoint3, d: LPoint3, node: NodePath): RenderEffect {.importcpp: "ScissorEffect::make_node(#, #, #, #, #)", header: "scissorEffect.h".} ## \
## Constructs a new node-relative ScissorEffect.  The four points are
## understood to be relative to the indicated node, or the current node if the
## indicated NodePath is empty, and determine four points surrounding the
## scissor region.

proc make_node*(_: typedesc[ScissorEffect], a: LPoint3, b: LPoint3, c: LPoint3, d: LPoint3): RenderEffect {.importcpp: "ScissorEffect::make_node(#, #, #, #)", header: "scissorEffect.h".} ## \
## Constructs a new node-relative ScissorEffect.  The four points are
## understood to be relative to the indicated node, or the current node if the
## indicated NodePath is empty, and determine four points surrounding the
## scissor region.

proc make_node*(_: typedesc[ScissorEffect], a: LPoint3, b: LPoint3, node: NodePath): RenderEffect {.importcpp: "ScissorEffect::make_node(#, #, #)", header: "scissorEffect.h".} ## \
## Constructs a new node-relative ScissorEffect.  The two points are
## understood to be relative to the indicated node, or the current node if the
## NodePath is empty, and determine the diagonally opposite corners of the
## scissor region.

proc make_node*(_: typedesc[ScissorEffect], a: LPoint3, b: LPoint3): RenderEffect {.importcpp: "ScissorEffect::make_node(#, #)", header: "scissorEffect.h".} ## \
## Constructs a new node-relative ScissorEffect.  The two points are
## understood to be relative to the indicated node, or the current node if the
## NodePath is empty, and determine the diagonally opposite corners of the
## scissor region.

proc make_node*(_: typedesc[ScissorEffect], clip: bool): RenderEffect {.importcpp: "ScissorEffect::make_node(#)", header: "scissorEffect.h".} ## \
## Constructs a new node-relative ScissorEffect, with no points.  This empty
## ScissorEffect does nothing.  You must then call add_point a number of times
## to add the points you require.

proc make_node*(_: typedesc[ScissorEffect]): RenderEffect {.importcpp: "ScissorEffect::make_node()", header: "scissorEffect.h".} ## \
## Constructs a new node-relative ScissorEffect, with no points.  This empty
## ScissorEffect does nothing.  You must then call add_point a number of times
## to add the points you require.

proc add_point*(this: ScissorEffect, point: LPoint3, node: NodePath): RenderEffect {.importcpp: "#->add_point(#, #)".} ## \
## Returns a new ScissorEffect with the indicated point added.  It is only
## valid to call this on a "node" type ScissorEffect.  The full set of points,
## projected into screen space, defines the bounding volume of the rectangular
## scissor region.
##
## Each point may be relative to a different node, if desired.

proc add_point*(this: ScissorEffect, point: LPoint3): RenderEffect {.importcpp: "#->add_point(#)".} ## \
## Returns a new ScissorEffect with the indicated point added.  It is only
## valid to call this on a "node" type ScissorEffect.  The full set of points,
## projected into screen space, defines the bounding volume of the rectangular
## scissor region.
##
## Each point may be relative to a different node, if desired.

proc is_screen*(this: ScissorEffect): bool {.importcpp: "#->is_screen()".} ## \
## Returns true if the ScissorEffect is a screen-based effect, meaning
## get_frame() has a meaningful value, but get_a() and get_b() do not.

proc get_frame*(this: ScissorEffect): LVecBase4 {.importcpp: "#->get_frame()".} ## \
## If is_screen() returns true, this method may be called to query the screen-
## based scissor frame.  This is a series of left, right, bottom, top,
## representing the scissor frame relative to the current DisplayRegion.  See
## ScissorAttrib.

proc get_num_points*(this: ScissorEffect): int {.importcpp: "#->get_num_points()".} ## \
## Returns the number of node-based scissor points.  See get_point().

proc get_point*(this: ScissorEffect, n: int): LPoint3 {.importcpp: "#->get_point(#)".} ## \
## If is_screen() returns false, then get_num_points() and get_point() may be
## called to query the node-based scissor frame.  These return n points (at
## least two), which are understood to be in the space of this node, and which
## define any opposite corners of the scissor frame.

proc get_node*(this: ScissorEffect, n: int): NodePath {.importcpp: "#->get_node(#)".} ## \
## Returns the node to which the nth point is relative, or empty NodePath to
## indicate the current node.

proc get_clip*(this: ScissorEffect): bool {.importcpp: "#->get_clip()".} ## \
## Returns true if this ScissorEffect actually enables scissoring, or false if
## it culls only.

proc get_class_type*(_: typedesc[ScissorEffect]): TypeHandle {.importcpp: "ScissorEffect::get_class_type()", header: "scissorEffect.h".}

proc initSceneGraphReducer*(gsg: GraphicsStateGuardianBase): SceneGraphReducer {.importcpp: "SceneGraphReducer(#)".}

proc initSceneGraphReducer*(): SceneGraphReducer {.importcpp: "SceneGraphReducer()".}

proc initSceneGraphReducer*(param0: SceneGraphReducer): SceneGraphReducer {.importcpp: "SceneGraphReducer(#)".}

proc set_gsg*(this: SceneGraphReducer, gsg: GraphicsStateGuardianBase) {.importcpp: "#.set_gsg(#)".} ## \
## Specifies the particular GraphicsStateGuardian that this object will
## attempt to optimize to.  The GSG may specify parameters such as maximum
## number of vertices per vertex data, max number of vertices per primitive,
## and whether triangle strips are preferred.  It also affects the types of
## vertex column data that is created by premunge().

proc clear_gsg*(this: SceneGraphReducer) {.importcpp: "#.clear_gsg()".} ## \
## Specifies that no particular GraphicsStateGuardian will be used to guide
## the optimization.  The SceneGraphReducer will instead use config variables
## such as max-collect-vertices and max-collect-indices.

proc get_gsg*(this: SceneGraphReducer): GraphicsStateGuardianBase {.importcpp: "#.get_gsg()".} ## \
## Returns the particular GraphicsStateGuardian that this object will attempt
## to optimize to.  See set_gsg().

proc set_combine_radius*(this: SceneGraphReducer, combine_radius: float32) {.importcpp: "#.set_combine_radius(#)".} ## \
## Specifies the radius that is used in conjunction with CS_within_radius to
## decide whether a subgraph's siblings should be combined into a single node
## or not.
##
## If the CS_within_radius bit is included in the combine_siblings_bits
## parameter passed to flatten, than any nodes whose bounding volume is
## smaller than the indicated radius will be combined together (as if CS_other
## were set).

proc get_combine_radius*(this: SceneGraphReducer): float32 {.importcpp: "#.get_combine_radius()".} ## \
## Returns the radius that is used in conjunction with CS_within_radius.  See
## set_combine_radius().

proc apply_attribs*(this: SceneGraphReducer, node: PandaNode, attrib_types: int) {.importcpp: "#.apply_attribs(#, #)".} ## \
## Walks the scene graph, accumulating attribs of the indicated types,
## applying them to the vertices, and removing them from the scene graph.
## This has a performance optimization benefit in itself, but is especially
## useful to pave the way for a call to flatten() and greatly improve the
## effectiveness of the flattening operation.
##
## Multiply instanced geometry is duplicated before the attribs are applied.
##
## Of course, this operation does make certain dynamic operations impossible.

proc apply_attribs*(this: SceneGraphReducer, node: PandaNode) {.importcpp: "#.apply_attribs(#)".} ## \
## Walks the scene graph, accumulating attribs of the indicated types,
## applying them to the vertices, and removing them from the scene graph.
## This has a performance optimization benefit in itself, but is especially
## useful to pave the way for a call to flatten() and greatly improve the
## effectiveness of the flattening operation.
##
## Multiply instanced geometry is duplicated before the attribs are applied.
##
## Of course, this operation does make certain dynamic operations impossible.

proc flatten*(this: SceneGraphReducer, root: PandaNode, combine_siblings_bits: int): int {.importcpp: "#.flatten(#, #)".} ## \
## Simplifies the graph by removing unnecessary nodes and nodes.
##
## In general, a node (and its parent node) is a candidate for removal if the
## node has no siblings and the node has no special properties.
##
## If combine_siblings_bits is nonzero, some sibling nodes (according to the
## bits set in combine_siblings_bits) may also be collapsed into a single
## node.  This will further reduce scene graph complexity, sometimes
## substantially, at the cost of reduced spatial separation.
##
## Returns the number of nodes removed from the graph.

proc remove_column*(this: SceneGraphReducer, root: PandaNode, column: InternalName): int {.importcpp: "#.remove_column(#, #)".} ## \
## Removes the indicated data column from any GeomVertexDatas found at the
## indicated root and below.  Returns the number of GeomNodes modified.

proc make_compatible_state*(this: SceneGraphReducer, root: PandaNode): int {.importcpp: "#.make_compatible_state(#)".} ## \
## Searches for GeomNodes that contain multiple Geoms that differ only in
## their ColorAttribs.  If such a GeomNode is found, then all the colors are
## pushed down into the vertices.  This makes it feasible for the geoms to be
## unified later.

proc make_compatible_format*(this: SceneGraphReducer, root: PandaNode, collect_bits: int): int {.importcpp: "#.make_compatible_format(#, #)".} ## \
## Walks through the tree at this node and below and unifies the
## GeomVertexFormat for any GeomVertexData objects that are found, so that all
## eligible vdatas (according to collect_bits; see collect_vertex_data) will
## share the same vertex format.
##
## This will add unused columns where necessary to match formats.  It can
## result in suboptimal performance if used needlessly.
##
## There is usually no reason to call this explicitly, since
## collect_vertex_data() will do this anyway if it has not been done already.
## However, calling it ahead of time can make that future call to
## collect_vertex_data() run a little bit faster.
##
## The return value is the number of vertex datas modified.

proc make_compatible_format*(this: SceneGraphReducer, root: PandaNode): int {.importcpp: "#.make_compatible_format(#)".} ## \
## Walks through the tree at this node and below and unifies the
## GeomVertexFormat for any GeomVertexData objects that are found, so that all
## eligible vdatas (according to collect_bits; see collect_vertex_data) will
## share the same vertex format.
##
## This will add unused columns where necessary to match formats.  It can
## result in suboptimal performance if used needlessly.
##
## There is usually no reason to call this explicitly, since
## collect_vertex_data() will do this anyway if it has not been done already.
## However, calling it ahead of time can make that future call to
## collect_vertex_data() run a little bit faster.
##
## The return value is the number of vertex datas modified.

proc decompose*(this: SceneGraphReducer, root: PandaNode) {.importcpp: "#.decompose(#)".} ## \
## Calls decompose() on every GeomNode at this level and below.
##
## There is usually no reason to call this explicitly, since unify() will do
## this anyway if it needs to be done.  However, calling it ahead of time can
## make that future call to unify() run a little bit faster.
##
## This operation has no effect if the config variable preserve-triangle-
## strips has been set true.

proc collect_vertex_data*(this: SceneGraphReducer, root: PandaNode, collect_bits: int): int {.importcpp: "#.collect_vertex_data(#, #)".} ## \
## Collects all different GeomVertexData blocks that have compatible formats
## at this node and below into a single, unified block (or at least multiple
## larger blocks).  This is intended to reduce rendering overhead incurred by
## switching vertex buffers.  It can also make a subsequent call to unify()
## much more effective than it would have been otherwise.
##
## The set of bits passed in collect_bits indicates which properties are used
## to differentiate GeomVertexData blocks.  If it is 0, then more blocks will
## be combined together than if it is nonzero.

proc collect_vertex_data*(this: SceneGraphReducer, root: PandaNode): int {.importcpp: "#.collect_vertex_data(#)".} ## \
## Collects all different GeomVertexData blocks that have compatible formats
## at this node and below into a single, unified block (or at least multiple
## larger blocks).  This is intended to reduce rendering overhead incurred by
## switching vertex buffers.  It can also make a subsequent call to unify()
## much more effective than it would have been otherwise.
##
## The set of bits passed in collect_bits indicates which properties are used
## to differentiate GeomVertexData blocks.  If it is 0, then more blocks will
## be combined together than if it is nonzero.

proc make_nonindexed*(this: SceneGraphReducer, root: PandaNode, nonindexed_bits: int): int {.importcpp: "#.make_nonindexed(#, #)".} ## \
## Converts indexed geometry to nonindexed geometry at the indicated node and
## below, by duplicating vertices where necessary.  The parameter
## nonindexed_bits is a union of bits defined in
## SceneGraphReducer::MakeNonindexed, which specifes which types of geometry
## to avoid making nonindexed.

proc make_nonindexed*(this: SceneGraphReducer, root: PandaNode): int {.importcpp: "#.make_nonindexed(#)".} ## \
## Converts indexed geometry to nonindexed geometry at the indicated node and
## below, by duplicating vertices where necessary.  The parameter
## nonindexed_bits is a union of bits defined in
## SceneGraphReducer::MakeNonindexed, which specifes which types of geometry
## to avoid making nonindexed.

proc unify*(this: SceneGraphReducer, root: PandaNode, preserve_order: bool) {.importcpp: "#.unify(#, #)".} ## \
## Calls unify() on every GeomNode at this level and below.  This attempts to
## reduce the total number of individual Geoms and GeomPrimitives by combining
## these objects wherever possible.  See GeomNode::unify().

proc remove_unused_vertices*(this: SceneGraphReducer, root: PandaNode) {.importcpp: "#.remove_unused_vertices(#)".} ## \
## Removes any vertices in GeomVertexDatas that are no longer used at this
## level and below.  This requires remapping vertex indices in all of the
## GeomPrimitives, to remove holes in the GeomVertexDatas.  It is normally not
## necessary to call this explicitly.

proc premunge*(this: SceneGraphReducer, root: PandaNode, initial_state: RenderState) {.importcpp: "#.premunge(#, #)".} ## \
## Walks the scene graph rooted at this node and below, and uses the indicated
## GSG to premunge every Geom found to optimize it for eventual rendering on
## the indicated GSG.  If there is no GSG indicated for the SceneGraphReducer,
## this is a no-op.
##
## This operation will also apply to stashed children.

proc check_live_flatten*(this: SceneGraphReducer, node: PandaNode): bool {.importcpp: "#.check_live_flatten(#)".} ## \
## In a non-release build, returns false if the node is correctly not in a
## live scene graph.  (Calling flatten on a node that is part of a live scene
## graph, for instance, a node somewhere under render, can cause problems in a
## multithreaded environment.)
##
## If allow_live_flatten is true, or in a release build, this always returns
## true.

proc newPortalNode*(name: string): PortalNode {.importcpp: "new PortalNode(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Default constructor, just an empty node, no geo This is used to read portal
## from model.  You can also use this from python to create an empty portal.
## Then you can set the vertices yourself, with addVertex.

proc newPortalNode*(name: string, pos: LPoint3, scale: float32): PortalNode {.importcpp: "new PortalNode(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Create a default rectangle as portal.  Use this to create an arbitrary
## portal and setup from Python

proc newPortalNode*(name: string, pos: LPoint3): PortalNode {.importcpp: "new PortalNode(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Create a default rectangle as portal.  Use this to create an arbitrary
## portal and setup from Python

proc set_portal_geom*(this: PortalNode, flag: bool) {.importcpp: "#->set_portal_geom(#)".} ## \
## Sets the state of the "portal geom" flag for this PortalNode.  Normally,
## this is false; when this is set true, the PortalSolids in this node will
## test for portals with actual renderable geometry, in addition to whatever
## PortalSolids may be indicated by the from_portal_mask.
##
## Setting this to true causes this to test *all* GeomNodes for portals.  It
## is an all-or-none thing; there is no way to portal with only some
## GeomNodes, as GeomNodes have no into_portal_mask.

proc get_portal_geom*(this: PortalNode): bool {.importcpp: "#->get_portal_geom()".} ## \
## Returns the current state of the portal_geom flag.  See set_portal_geom().

proc clear_vertices*(this: PortalNode) {.importcpp: "#->clear_vertices()".} ## \
## Resets the vertices of the portal to the empty list.

proc add_vertex*(this: PortalNode, vertex: LPoint3) {.importcpp: "#->add_vertex(#)".} ## \
## Adds a new vertex to the portal polygon.  The vertices should be defined in
## a counterclockwise orientation when viewing through the portal.

proc get_num_vertices*(this: PortalNode): int {.importcpp: "#->get_num_vertices()".} ## \
## Returns the number of vertices in the portal polygon.

proc get_vertex*(this: PortalNode, n: int): LPoint3 {.importcpp: "#->get_vertex(#)".} ## \
## Returns the nth vertex of the portal polygon.

proc set_cell_in*(this: PortalNode, cell: NodePath) {.importcpp: "#->set_cell_in(#)".} ## \
## Sets the cell that this portal belongs to

proc get_cell_in*(this: PortalNode): NodePath {.importcpp: "#->get_cell_in()".} ## \
## Sets the cell that this portal belongs to

proc set_cell_out*(this: PortalNode, cell: NodePath) {.importcpp: "#->set_cell_out(#)".} ## \
## Sets the cell that this portal leads out to

proc get_cell_out*(this: PortalNode): NodePath {.importcpp: "#->get_cell_out()".} ## \
## Sets the cell that this portal leads out to

proc set_clip_plane*(this: PortalNode, value: bool) {.importcpp: "#->set_clip_plane(#)".} ## \
## this is set if the portal will clip against its left and right planes

proc is_clip_plane*(this: PortalNode): bool {.importcpp: "#->is_clip_plane()".} ## \
## Is this portal clipping against its left-right planes

proc set_visible*(this: PortalNode, value: bool) {.importcpp: "#->set_visible(#)".} ## \
## this is set if the portal is facing camera

proc is_visible*(this: PortalNode): bool {.importcpp: "#->is_visible()".} ## \
## Is this portal facing the camera

proc set_max_depth*(this: PortalNode, value: int) {.importcpp: "#->set_max_depth(#)".} ## \
## Set the maximum depth this portal will be visible at

proc get_max_depth*(this: PortalNode): int {.importcpp: "#->get_max_depth()".} ## \
## Returns the maximum depth this portal will be visible at

proc set_open*(this: PortalNode, value: bool) {.importcpp: "#->set_open(#)".} ## \
## Python sets this based on curent camera zone

proc is_open*(this: PortalNode): bool {.importcpp: "#->is_open()".} ## \
## Is this portal open from current camera zone

proc get_class_type*(_: typedesc[PortalNode]): TypeHandle {.importcpp: "PortalNode::get_class_type()", header: "portalNode.h".}

proc make_off*(_: typedesc[ScissorAttrib]): RenderAttrib {.importcpp: "ScissorAttrib::make_off()", header: "scissorAttrib.h".} ## \
## Constructs a new ScissorAttrib object that removes the scissor region and
## fills the DisplayRegion.

proc make*(_: typedesc[ScissorAttrib], frame: LVecBase4): RenderAttrib {.importcpp: "ScissorAttrib::make(#)", header: "scissorAttrib.h".} ## \
## Constructs a ScissorAttrib that restricts rendering to the indicated frame
## within the current DisplayRegion.  (0,0) is the lower-left corner of the
## DisplayRegion, and (1,1) is the upper-right corner.

proc make*(_: typedesc[ScissorAttrib], left: float32, right: float32, bottom: float32, top: float32): RenderAttrib {.importcpp: "ScissorAttrib::make(#, #, #, #)", header: "scissorAttrib.h".} ## \
## Constructs a ScissorAttrib that restricts rendering to the indicated frame
## within the current DisplayRegion.  (0,0) is the lower-left corner of the
## DisplayRegion, and (1,1) is the upper-right corner.

proc make_default*(_: typedesc[ScissorAttrib]): RenderAttrib {.importcpp: "ScissorAttrib::make_default()", header: "scissorAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc is_off*(this: ScissorAttrib): bool {.importcpp: "#->is_off()".} ## \
## Returns true if the ScissorAttrib is an 'off' ScissorAttrib, indicating
## that scissor testing is disabled.

proc get_frame*(this: ScissorAttrib): LVecBase4 {.importcpp: "#->get_frame()".} ## \
## Returns the left, right, bottom, top coordinates of the scissor frame.
## This defines a frame within the current DisplayRegion, where 0,0 is the
## lower-left corner of the DisplayRegion, and 1,1 is the upper-right corner.

proc get_class_slot*(_: typedesc[ScissorAttrib]): int {.importcpp: "ScissorAttrib::get_class_slot()", header: "scissorAttrib.h".}

proc get_class_type*(_: typedesc[ScissorAttrib]): TypeHandle {.importcpp: "ScissorAttrib::get_class_type()", header: "scissorAttrib.h".}

proc make_default*(_: typedesc[ShadeModelAttrib]): RenderAttrib {.importcpp: "ShadeModelAttrib::make_default()", header: "shadeModelAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc get_class_slot*(_: typedesc[ShadeModelAttrib]): int {.importcpp: "ShadeModelAttrib::get_class_slot()", header: "shadeModelAttrib.h".}

proc get_class_type*(_: typedesc[ShadeModelAttrib]): TypeHandle {.importcpp: "ShadeModelAttrib::get_class_type()", header: "shadeModelAttrib.h".}

proc make_off*(_: typedesc[StencilAttrib]): RenderAttrib {.importcpp: "StencilAttrib::make_off()", header: "stencilAttrib.h".} ## \
## Constructs a StencilAttrib that has stenciling turned off.

proc make_default*(_: typedesc[StencilAttrib]): RenderAttrib {.importcpp: "StencilAttrib::make_default()", header: "stencilAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc get_class_slot*(_: typedesc[StencilAttrib]): int {.importcpp: "StencilAttrib::get_class_slot()", header: "stencilAttrib.h".}

proc get_class_type*(_: typedesc[StencilAttrib]): TypeHandle {.importcpp: "StencilAttrib::get_class_type()", header: "stencilAttrib.h".}

proc has_shader*(_: typedesc[ShaderPool], filename: Filename): bool {.importcpp: "ShaderPool::has_shader(#)", header: "shaderPool.h".} ## \
## Returns true if the shader has ever been loaded, false otherwise.

proc verify_shader*(_: typedesc[ShaderPool], filename: Filename): bool {.importcpp: "ShaderPool::verify_shader(#)", header: "shaderPool.h".} ## \
## Loads the given filename up into a shader, if it has not already been
## loaded, and returns true to indicate success, or false to indicate failure.
## If this returns true, it is guaranteed that a subsequent call to
## load_shader() with the same shader name will return a valid Shader pointer.

proc load_shader*(_: typedesc[ShaderPool], filename: Filename): Shader {.importcpp: "ShaderPool::load_shader(#)", header: "shaderPool.h".} ## \
## Loads the given filename up into a shader, if it has not already been
## loaded, and returns the new shader.  If a shader with the same filename was
## previously loaded, returns that one instead.  If the shader file cannot be
## found, returns NULL.

proc add_shader*(_: typedesc[ShaderPool], filename: Filename, shader: Shader) {.importcpp: "ShaderPool::add_shader(#, #)", header: "shaderPool.h".} ## \
## Adds the indicated already-loaded shader to the pool.  The shader will
## always replace any previously-loaded shader in the pool that had the same
## filename.

proc release_shader*(_: typedesc[ShaderPool], filename: Filename) {.importcpp: "ShaderPool::release_shader(#)", header: "shaderPool.h".} ## \
## Removes the indicated shader from the pool, indicating it will never be
## loaded again; the shader may then be freed.  If this function is never
## called, a reference count will be maintained on every shader every loaded,
## and shaders will never be freed.

proc release_all_shaders*(_: typedesc[ShaderPool]) {.importcpp: "ShaderPool::release_all_shaders()", header: "shaderPool.h".} ## \
## Releases all shaders in the pool and restores the pool to the empty state.

proc garbage_collect*(_: typedesc[ShaderPool]): int {.importcpp: "ShaderPool::garbage_collect()", header: "shaderPool.h".} ## \
## Releases only those shaders in the pool that have a reference count of
## exactly 1; i.e.  only those shaders that are not being used outside of the
## pool.  Returns the number of shaders released.

proc list_contents*(_: typedesc[ShaderPool], `out`: ostream) {.importcpp: "ShaderPool::list_contents(#)", header: "shaderPool.h".} ## \
## Lists the contents of the shader pool to the indicated output stream.

proc write*(_: typedesc[ShaderPool], `out`: ostream) {.importcpp: "ShaderPool::write(#)", header: "shaderPool.h".} ## \
## Lists the contents of the shader pool to the indicated output stream.

converter upcast_to_TypedWritableReferenceCount*(this: MovieAudio): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcast_to_Namable*(this: MovieAudio): Namable {.importcpp: "((Namable *)(#.p()))".}

proc newMovieAudio*(param0: MovieAudio): MovieAudio {.importcpp: "new MovieAudio(#)".}

proc newMovieAudio*(name: string): MovieAudio {.importcpp: "new MovieAudio(nimStringToStdString(#))", header: stringConversionCode.} ## \
## This constructor returns a null audio stream --- a stream of total silence,
## at 8000 samples per second.  To get more interesting audio, you need to
## construct a subclass of this class.

proc newMovieAudio*(): MovieAudio {.importcpp: "new MovieAudio()".} ## \
## This constructor returns a null audio stream --- a stream of total silence,
## at 8000 samples per second.  To get more interesting audio, you need to
## construct a subclass of this class.

proc open*(this: MovieAudio): MovieAudioCursor {.importcpp: "#->open()".} ## \
## Open this audio, returning a MovieAudioCursor

proc get*(_: typedesc[MovieAudio], name: Filename): MovieAudio {.importcpp: "MovieAudio::get(#)", header: "movieAudio.h".} ## \
## Obtains a MovieAudio that references a file.  Just calls
## MovieTypeRegistry::make_audio().

proc get_filename*(this: MovieAudio): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the movie's filename.  A movie is not guaranteed to have a
## filename, if not, then this function returns a null filename.

proc get_class_type*(_: typedesc[MovieAudio]): TypeHandle {.importcpp: "MovieAudio::get_class_type()", header: "movieAudio.h".}

proc newFlacAudio*(name: Filename): FlacAudio {.importcpp: "new FlacAudio(#)".} ## \
## xxx

proc newFlacAudio*(param0: FlacAudio): FlacAudio {.importcpp: "new FlacAudio(#)".}

proc make*(_: typedesc[FlacAudio], name: Filename): MovieAudio {.importcpp: "FlacAudio::make(#)", header: "flacAudio.h".} ## \
## Obtains a MovieAudio that references a file.

proc get_class_type*(_: typedesc[FlacAudio]): TypeHandle {.importcpp: "FlacAudio::get_class_type()", header: "flacAudio.h".}

proc newMovieAudioCursor*(src: MovieAudio): MovieAudioCursor {.importcpp: "new MovieAudioCursor(#)".} ## \
## This constructor returns a null audio stream --- a stream of total silence,
## at 8000 samples per second.  To get more interesting audio, you need to
## construct a subclass of this class.

proc newMovieAudioCursor*(param0: MovieAudioCursor): MovieAudioCursor {.importcpp: "new MovieAudioCursor(#)".}

proc get_source*(this: MovieAudioCursor): MovieAudio {.importcpp: "#->get_source()".} ## \
## Returns the MovieAudio which this cursor references.

proc audio_rate*(this: MovieAudioCursor): int {.importcpp: "#->audio_rate()".} ## \
## Returns the audio sample rate.

proc audio_channels*(this: MovieAudioCursor): int {.importcpp: "#->audio_channels()".} ## \
## Returns the number of audio channels (ie, two for stereo, one for mono).

proc length*(this: MovieAudioCursor): float64 {.importcpp: "#->length()".} ## \
## Returns the length of the movie.  Attempting to read audio samples beyond
## the specified length will produce silent samples.
##
## Some kinds of Movie, such as internet TV station, might not have a
## predictable length.  In that case, the length will be set to a very large
## number: 1.0E10.
##
## Some AVI files have incorrect length values encoded into them - they may be
## a second or two long or short.  When playing such an AVI using the Movie
## class, you may see a slightly truncated video, or a slightly elongated
## video (padded with black frames).  There are utilities out there to fix the
## length values in AVI files.
##
## An audio consumer needs to check the length, the ready status, and the
## aborted flag.

proc can_seek*(this: MovieAudioCursor): bool {.importcpp: "#->can_seek()".} ## \
## Returns true if the movie can seek.  If this is true, seeking is still not
## guaranteed to be fast: for some movies, seeking is implemented by rewinding
## to the beginning and then fast-forwarding to the desired location.  Even if
## the movie cannot seek, the seek method can still advance to an arbitrary
## location by reading samples and discarding them.  However, to move
## backward, can_seek must return true.

proc can_seek_fast*(this: MovieAudioCursor): bool {.importcpp: "#->can_seek_fast()".} ## \
## Returns true if seek operations are constant time.

proc tell*(this: MovieAudioCursor): float64 {.importcpp: "#->tell()".} ## \
## Returns the current offset within the file.

proc skip_samples*(this: MovieAudioCursor, n: int) {.importcpp: "#->skip_samples(#)".} ## \
## Skip audio samples from the stream.  This is mostly for debugging purposes.

proc aborted*(this: MovieAudioCursor): bool {.importcpp: "#->aborted()".} ## \
## If aborted is true, it means that the "ready" samples are not being
## replenished.  See the method "ready" for an explanation.

proc ready*(this: MovieAudioCursor): int {.importcpp: "#->ready()".} ## \
## Returns the number of audio samples that are ready to read.  This is
## primarily relevant for sources like microphones which produce samples at a
## fixed rate.  If you try to read more samples than are ready, the result
## will be silent samples.
##
## Some audio streams do not have a limit on how fast they can produce
## samples.  Such streams will always return 0x40000000 as the ready-count.
## This may well exceed the length of the audio stream.  You therefore need to
## check length separately.
##
## If the aborted flag is set, that means the ready count is no longer being
## replenished.  For example, a MovieAudioCursor might be reading from an
## internet radio station, and it might buffer data to avoid underruns.  If it
## loses connection to the radio station, it will set the aborted flag to
## indicate that the buffer is no longer being replenished.  But it is still
## ok to read the samples that are in the buffer, at least until they run out.
## Once those are gone, there will be no more.
##
## An audio consumer needs to check the length, the ready status, and the
## aborted flag.

proc seek*(this: MovieAudioCursor, offset: float64) {.importcpp: "#->seek(#)".} ## \
## Skips to the specified offset within the file.
##
## If the movie reports that it cannot seek, then this method can still
## advance by reading samples and discarding them.  However, to move backward,
## can_seek must be true.
##
## If the movie reports that it can_seek, it doesn't mean that it can do so
## quickly.  It may have to rewind the movie and then fast forward to the
## desired location.  Only if can_seek_fast returns true can seek operations
## be done in constant time.
##
## Seeking may not be precise, because AVI files often have inaccurate
## indices.  After seeking, tell will indicate that the cursor is at the
## target location.  However, in truth, the data you read may come from a
## slightly offset location.

proc read_samples*(this: MovieAudioCursor, n: int): string {.importcpp: "nimStringFromStdString(#->read_samples(#))", header: stringConversionCode.} ## \
## Read audio samples from the stream and returns them as a string.  The
## samples are stored little-endian in the string.  N is the number of samples
## you wish to read.  Multiple-channel audio will be interleaved.
##
## This is not particularly efficient, but it may be a convenient way to
## manipulate samples in python.

proc read_samples*(this: MovieAudioCursor, n: int, dg: Datagram) {.importcpp: "#->read_samples(#, #)".} ## \
## Read audio samples from the stream into a Datagram.  N is the number of
## samples you wish to read.  Multiple-channel audio will be interleaved.
##
## This is not particularly efficient, but it may be a convenient way to
## manipulate samples in python.

proc get_class_type*(_: typedesc[MovieAudioCursor]): TypeHandle {.importcpp: "MovieAudioCursor::get_class_type()", header: "movieAudioCursor.h".}

proc newFlacAudioCursor*(src: FlacAudio, stream: istream): FlacAudioCursor {.importcpp: "new FlacAudioCursor(#, #)".} ## \
## Reads the .wav header from the indicated stream.  This leaves the read
## pointer positioned at the start of the data.

proc newFlacAudioCursor*(param0: FlacAudioCursor): FlacAudioCursor {.importcpp: "new FlacAudioCursor(#)".}

proc get_class_type*(_: typedesc[FlacAudioCursor]): TypeHandle {.importcpp: "FlacAudioCursor::get_class_type()", header: "flacAudioCursor.h".}

converter upcast_to_TypedWritableReferenceCount*(this: MovieVideo): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcast_to_Namable*(this: MovieVideo): Namable {.importcpp: "((Namable *)(#.p()))".}

proc newMovieVideo*(param0: MovieVideo): MovieVideo {.importcpp: "new MovieVideo(#)".}

proc newMovieVideo*(name: string): MovieVideo {.importcpp: "new MovieVideo(nimStringToStdString(#))", header: stringConversionCode.} ## \
## This constructor returns a null video stream --- a stream of plain blue and
## white frames that last one second each.  To get more interesting video, you
## need to construct a subclass of this class.

proc newMovieVideo*(): MovieVideo {.importcpp: "new MovieVideo()".} ## \
## This constructor returns a null video stream --- a stream of plain blue and
## white frames that last one second each.  To get more interesting video, you
## need to construct a subclass of this class.

proc open*(this: MovieVideo): MovieVideoCursor {.importcpp: "#->open()".} ## \
## Open this video, returning a MovieVideoCursor of the appropriate type.
## Returns NULL on error.

proc get*(_: typedesc[MovieVideo], name: Filename): MovieVideo {.importcpp: "MovieVideo::get(#)", header: "movieVideo.h".} ## \
## Obtains a MovieVideo that references a file.  Just calls
## MovieTypeRegistry::make_video().

proc get_filename*(this: MovieVideo): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the movie's filename.  A movie is not guaranteed to have a
## filename, if not, then this function returns an empty filename.

proc get_subfile_info*(this: MovieVideo): SubfileInfo {.importcpp: "#->get_subfile_info()".} ## \
## If the movie is to be loaded from a subfile on disk, this returns the
## subfile info.  Check info.is_empty() to see if this is valid data.

proc get_class_type*(_: typedesc[MovieVideo]): TypeHandle {.importcpp: "MovieVideo::get_class_type()", header: "movieVideo.h".}

proc newInkblotVideo*(param0: InkblotVideo): InkblotVideo {.importcpp: "new InkblotVideo(#)".}

proc newInkblotVideo*(x: int, y: int, fps: int): InkblotVideo {.importcpp: "new InkblotVideo(#, #, #)".} ## \
## xxx

proc get_class_type*(_: typedesc[InkblotVideo]): TypeHandle {.importcpp: "InkblotVideo::get_class_type()", header: "inkblotVideo.h".}

proc get_source*(this: MovieVideoCursor): MovieVideo {.importcpp: "#->get_source()".} ## \
## Get the MovieVideo which this cursor references.

proc size_x*(this: MovieVideoCursor): int {.importcpp: "#->size_x()".} ## \
## Get the horizontal size of the movie.

proc size_y*(this: MovieVideoCursor): int {.importcpp: "#->size_y()".} ## \
## Get the vertical size of the movie.

proc get_num_components*(this: MovieVideoCursor): int {.importcpp: "#->get_num_components()".} ## \
## Returns 4 if the movie has an alpha channel, 3 otherwise.

proc length*(this: MovieVideoCursor): float64 {.importcpp: "#->length()".} ## \
## Returns the length of the movie.
##
## Some kinds of Movie, such as internet TV station, might not have a
## predictable length.  In that case, the length will be set to a very large
## number: 1.0E10. If the internet TV station goes offline, the video or audio
## stream will set its abort flag.  Reaching the end of the movie (ie, the
## specified length) normally does not cause the abort flag to be set.
##
## The video and audio streams produced by get_video and get_audio are always
## of unlimited duration - you can always read another video frame or another
## audio sample.  This is true even if the specified length is reached, or an
## abort is flagged.  If either stream runs out of data, it will synthesize
## blank video frames and silent audio samples as necessary to satisfy read
## requests.
##
## Some AVI files have incorrect length values encoded into them - usually,
## they're a second or two long or short.  When playing such an AVI using the
## Movie class, you may see a slightly truncated video, or a slightly
## elongated video (padded with black frames).  There are utilities out there
## to fix the length values in AVI files.

proc can_seek*(this: MovieVideoCursor): bool {.importcpp: "#->can_seek()".} ## \
## Returns true if the movie can seek.  If this is true, seeking is still not
## guaranteed to be fast: for some movies, seeking is implemented by rewinding
## to the beginning and then fast-forwarding to the desired location.  Even if
## the movie cannot seek, the fetch methods can still advance to an arbitrary
## location by reading frames and discarding them.  However, to move backward,
## can_seek must return true.

proc can_seek_fast*(this: MovieVideoCursor): bool {.importcpp: "#->can_seek_fast()".} ## \
## Returns true if seek operations are constant time.

proc aborted*(this: MovieVideoCursor): bool {.importcpp: "#->aborted()".} ## \
## Returns true if the video has aborted prematurely.  For example, this could
## occur if the Movie was actually an internet TV station, and the connection
## was lost.  Reaching the normal end of the video does not constitute an
## 'abort' condition.

proc ready*(this: MovieVideoCursor): bool {.importcpp: "#->ready()".} ## \
## Returns true if the cursor is a streaming source, and if a video frame is
## ready to be read.  For non- streaming sources, this is always false.

proc streaming*(this: MovieVideoCursor): bool {.importcpp: "#->streaming()".} ## \
## Returns true if the video frames are being "pushed" at us by something that
## operates at its own speed - for example, a webcam.  In this case, the
## frames come when they're ready to come.  Attempting to read too soon will
## produce nothing, reading too late will cause frames to be dropped.  In this
## case, the ready flag can be used to determine whether or not a frame is
## ready for reading.
##
## When streaming, you should still pay attention to last_start, but the value
## of next_start is only a guess.

proc setup_texture*(this: MovieVideoCursor, tex: Texture) {.importcpp: "#->setup_texture(#)".} ## \
## Set up the specified Texture object to contain content from this movie.
## This should be called once, not every frame.

proc set_time*(this: MovieVideoCursor, timestamp: float64, loop_count: int): bool {.importcpp: "#->set_time(#, #)".} ## \
## Updates the cursor to the indicated time.  If loop_count >= 1, the time is
## clamped to the movie's length * loop_count.  If loop_count <= 0, the time
## is understood to be modulo the movie's length.
##
## Returns true if a new frame is now available, false otherwise.  If this
## returns true, you should immediately follow this with exactly *one* call to
## fetch_buffer().
##
## If the movie reports that it can_seek, you may also specify a time value
## less than the previous value you passed to set_time().  Otherwise, you may
## only specify a time value greater than or equal to the previous value.
##
## If the movie reports that it can_seek, it doesn't mean that it can do so
## quickly.  It may have to rewind the movie and then fast forward to the
## desired location.  Only if can_seek_fast returns true can it seek rapidly.

proc get_class_type*(_: typedesc[MovieVideoCursor]): TypeHandle {.importcpp: "MovieVideoCursor::get_class_type()", header: "movieVideoCursor.h".}

proc newMovieVideoCursor*(param0: MovieVideoCursor): MovieVideoCursor {.importcpp: "new MovieVideoCursor(#)".}

proc newInkblotVideoCursor*(src: InkblotVideo): InkblotVideoCursor {.importcpp: "new InkblotVideoCursor(#)".} ## \
## xxx

proc newInkblotVideoCursor*(param0: InkblotVideoCursor): InkblotVideoCursor {.importcpp: "new InkblotVideoCursor(#)".}

proc get_class_type*(_: typedesc[InkblotVideoCursor]): TypeHandle {.importcpp: "InkblotVideoCursor::get_class_type()", header: "inkblotVideoCursor.h".}

proc get_num_options*(_: typedesc[MicrophoneAudio]): int {.importcpp: "MicrophoneAudio::get_num_options()", header: "microphoneAudio.h".} ## \
## Returns the number of microphone options.  An "option" consists of a device
## plus a set of configuration parameters.  For example, "Soundblaster Audigy
## Line in at 44,100 samples/sec" would be an option.

proc get_option*(_: typedesc[MicrophoneAudio], n: int): MicrophoneAudio {.importcpp: "MicrophoneAudio::get_option(#)", header: "microphoneAudio.h".} ## \
## Returns the nth microphone option.

proc get_channels*(this: MicrophoneAudio): int {.importcpp: "#->get_channels()".} ## \
## Returns the number of channels.

proc get_rate*(this: MicrophoneAudio): int {.importcpp: "#->get_rate()".} ## \
## Returns the sample rate.

proc get_class_type*(_: typedesc[MicrophoneAudio]): TypeHandle {.importcpp: "MicrophoneAudio::get_class_type()", header: "microphoneAudio.h".}

proc newOpusAudio*(name: Filename): OpusAudio {.importcpp: "new OpusAudio(#)".} ## \
## xxx

proc newOpusAudio*(param0: OpusAudio): OpusAudio {.importcpp: "new OpusAudio(#)".}

proc make*(_: typedesc[OpusAudio], name: Filename): MovieAudio {.importcpp: "OpusAudio::make(#)", header: "opusAudio.h".} ## \
## Obtains a MovieAudio that references a file.

proc get_class_type*(_: typedesc[OpusAudio]): TypeHandle {.importcpp: "OpusAudio::get_class_type()", header: "opusAudio.h".}

proc newOpusAudioCursor*(src: OpusAudio, stream: istream): OpusAudioCursor {.importcpp: "new OpusAudioCursor(#, #)".} ## \
## Reads the .wav header from the indicated stream.  This leaves the read
## pointer positioned at the start of the data.

proc newOpusAudioCursor*(param0: OpusAudioCursor): OpusAudioCursor {.importcpp: "new OpusAudioCursor(#)".}

proc get_class_type*(_: typedesc[OpusAudioCursor]): TypeHandle {.importcpp: "OpusAudioCursor::get_class_type()", header: "opusAudioCursor.h".}

proc newUserDataAudio*(param0: UserDataAudio): UserDataAudio {.importcpp: "new UserDataAudio(#)".}

proc newUserDataAudio*(rate: int, channels: int, remove_after_read: bool): UserDataAudio {.importcpp: "new UserDataAudio(#, #, #)".} ## \
## This constructor returns a UserDataAudio --- a means to supply raw audio
## samples manually.

proc newUserDataAudio*(rate: int, channels: int): UserDataAudio {.importcpp: "new UserDataAudio(#, #)".} ## \
## This constructor returns a UserDataAudio --- a means to supply raw audio
## samples manually.

proc append*(this: UserDataAudio, src: DatagramIterator, len: int) {.importcpp: "#->append(#, #)".} ## \
## Appends audio samples to the buffer from a datagram.  This is intended to
## make it easy to send streaming raw audio over a network.

proc append*(this: UserDataAudio, src: DatagramIterator) {.importcpp: "#->append(#)".} ## \
## Appends audio samples to the buffer from a datagram.  This is intended to
## make it easy to send streaming raw audio over a network.

proc append*(this: UserDataAudio, str: string) {.importcpp: "#->append(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Appends audio samples to the buffer from a string.  The samples must be
## stored little-endian in the string.  This is not particularly efficient,
## but it may be convenient to deal with samples in python.

proc done*(this: UserDataAudio) {.importcpp: "#->done()".} ## \
## Promises not to append any more samples, ie, this marks the end of the
## audio stream.

proc get_class_type*(_: typedesc[UserDataAudio]): TypeHandle {.importcpp: "UserDataAudio::get_class_type()", header: "userDataAudio.h".}

proc newUserDataAudioCursor*(src: UserDataAudio): UserDataAudioCursor {.importcpp: "new UserDataAudioCursor(#)".}

proc newUserDataAudioCursor*(param0: UserDataAudioCursor): UserDataAudioCursor {.importcpp: "new UserDataAudioCursor(#)".}

proc get_class_type*(_: typedesc[UserDataAudioCursor]): TypeHandle {.importcpp: "UserDataAudioCursor::get_class_type()", header: "userDataAudioCursor.h".}

proc newVorbisAudio*(name: Filename): VorbisAudio {.importcpp: "new VorbisAudio(#)".} ## \
## xxx

proc newVorbisAudio*(param0: VorbisAudio): VorbisAudio {.importcpp: "new VorbisAudio(#)".}

proc make*(_: typedesc[VorbisAudio], name: Filename): MovieAudio {.importcpp: "VorbisAudio::make(#)", header: "vorbisAudio.h".} ## \
## Obtains a MovieAudio that references a file.

proc get_class_type*(_: typedesc[VorbisAudio]): TypeHandle {.importcpp: "VorbisAudio::get_class_type()", header: "vorbisAudio.h".}

proc newVorbisAudioCursor*(src: VorbisAudio, stream: istream): VorbisAudioCursor {.importcpp: "new VorbisAudioCursor(#, #)".} ## \
## Reads the .wav header from the indicated stream.  This leaves the read
## pointer positioned at the start of the data.

proc newVorbisAudioCursor*(param0: VorbisAudioCursor): VorbisAudioCursor {.importcpp: "new VorbisAudioCursor(#)".}

proc get_class_type*(_: typedesc[VorbisAudioCursor]): TypeHandle {.importcpp: "VorbisAudioCursor::get_class_type()", header: "vorbisAudioCursor.h".}

proc newWavAudio*(name: Filename): WavAudio {.importcpp: "new WavAudio(#)".} ## \
## xxx

proc newWavAudio*(param0: WavAudio): WavAudio {.importcpp: "new WavAudio(#)".}

proc make*(_: typedesc[WavAudio], name: Filename): MovieAudio {.importcpp: "WavAudio::make(#)", header: "wavAudio.h".} ## \
## Obtains a MovieAudio that references a file.

proc get_class_type*(_: typedesc[WavAudio]): TypeHandle {.importcpp: "WavAudio::get_class_type()", header: "wavAudio.h".}

proc newWavAudioCursor*(src: WavAudio, stream: istream): WavAudioCursor {.importcpp: "new WavAudioCursor(#, #)".} ## \
## Reads the .wav header from the indicated stream.  This leaves the read
## pointer positioned at the start of the data.

proc newWavAudioCursor*(param0: WavAudioCursor): WavAudioCursor {.importcpp: "new WavAudioCursor(#)".}

proc get_class_type*(_: typedesc[WavAudioCursor]): TypeHandle {.importcpp: "WavAudioCursor::get_class_type()", header: "wavAudioCursor.h".}

proc initCardMaker*(param0: CardMaker): CardMaker {.importcpp: "CardMaker(#)".}

proc initCardMaker*(name: string): CardMaker {.importcpp: "CardMaker(nimStringToStdString(#))", header: stringConversionCode.}

proc reset*(this: CardMaker) {.importcpp: "#.reset()".} ## \
## Resets all the parameters to their initial defaults.

proc set_uv_range*(this: CardMaker, ll: LTexCoord, ur: LTexCoord) {.importcpp: "#.set_uv_range(#, #)".} ## \
## Sets the range of UV's that will be applied to the vertices.  If
## set_has_uvs() is true (as it is by default), the vertices will be generated
## with the indicated range of UV's, which will be useful if a texture is
## applied.

proc set_uv_range*(this: CardMaker, ll: LTexCoord, lr: LTexCoord, ur: LTexCoord, ul: LTexCoord) {.importcpp: "#.set_uv_range(#, #, #, #)".} ## \
## Sets the range of UV's that will be applied to the vertices.  If
## set_has_uvs() is true (as it is by default), the vertices will be generated
## with the indicated range of UV's, which will be useful if a texture is
## applied.

proc set_uv_range*(this: CardMaker, ll: LTexCoord3, lr: LTexCoord3, ur: LTexCoord3, ul: LTexCoord3) {.importcpp: "#.set_uv_range(#, #, #, #)".} ## \
## Sets the range of UV's that will be applied to the vertices.  If
## set_has_uvs() is true (as it is by default), the vertices will be generated
## with the indicated range of UV's, which will be useful if a texture is
## applied.

proc set_uv_range*(this: CardMaker, x: LVector4, y: LVector4, z: LVector4) {.importcpp: "#.set_uv_range(#, #, #)".} ## \
## Sets the range of UV's that will be applied to the vertices.  If
## set_has_uvs() is true (as it is by default), the vertices will be generated
## with the indicated range of UV's, which will be useful if a texture is
## applied.

proc set_uv_range*(this: CardMaker, tex: Texture) {.importcpp: "#.set_uv_range(#)".} ## \
## Sets the range of UV's that will be applied to the vertices appropriately
## to show the non-pad region of the texture.

proc set_uv_range_cube*(this: CardMaker, face: int) {.importcpp: "#.set_uv_range_cube(#)".} ## \
## Sets the range of UV's that will be applied to the vertices appropriately
## for a cube-map face.

proc set_has_uvs*(this: CardMaker, flag: bool) {.importcpp: "#.set_has_uvs(#)".} ## \
## Sets the flag indicating whether vertices will be generated with UV's or
## not.

proc set_has_3d_uvs*(this: CardMaker, flag: bool) {.importcpp: "#.set_has_3d_uvs(#)".} ## \
## Sets the flag indicating whether vertices will be generated with
## 3-component UVW's (true) or 2-component UV's (the default, false).
## Normally, this will be implicitly set by setting the uv_range.

proc set_frame*(this: CardMaker, frame: LVecBase4) {.importcpp: "#.set_frame(#)".} ## \
## Sets the size of the card.

proc set_frame*(this: CardMaker, ll: LVertex, lr: LVertex, ur: LVertex, ul: LVertex) {.importcpp: "#.set_frame(#, #, #, #)".} ## \
## Sets the size of the card.

proc set_frame*(this: CardMaker, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#.set_frame(#, #, #, #)".} ## \
## Sets the size of the card.

proc set_frame_fullscreen_quad*(this: CardMaker) {.importcpp: "#.set_frame_fullscreen_quad()".} ## \
## Sets the card to (-1,1,-1,1), which is appropriate if you plan to parent it
## to render2d and use it as a fullscreen quad.

proc set_color*(this: CardMaker, color: LColor) {.importcpp: "#.set_color(#)".}

proc set_color*(this: CardMaker, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_color(#, #, #, #)".} ## \
## Sets the color of the card.

proc set_has_normals*(this: CardMaker, flag: bool) {.importcpp: "#.set_has_normals(#)".} ## \
## Sets the flag indicating whether vertices will be generated with normals or
## not.  Normals are required if you intend to enable lighting on the card,
## but are just wasted space and bandwidth otherwise, so there is a (slight)
## optimization for disabling them.  If enabled, the normals will be generated
## perpendicular to the card's face.

proc set_source_geometry*(this: CardMaker, node: PandaNode, frame: LVecBase4) {.importcpp: "#.set_source_geometry(#, #)".} ## \
## Sets a node that will be copied (and scaled and translated) to generate the
## frame, instead of generating a new polygon.  The node may contain arbitrary
## geometry that describes a flat polygon contained within the indicated left,
## right, bottom, top frame.
##
## When generate() is called, the geometry in this node will be scaled and
## translated appropriately to give it the size and aspect ratio specified by
## set_frame().

proc clear_source_geometry*(this: CardMaker) {.importcpp: "#.clear_source_geometry()".} ## \
## Removes the node specified by an earlier call to set_source_geometry().

proc generate*(this: CardMaker): PandaNode {.importcpp: "#.generate()".} ## \
## Generates a GeomNode that renders the specified geometry.

proc initFisheyeMaker*(param0: FisheyeMaker): FisheyeMaker {.importcpp: "FisheyeMaker(#)".}

proc initFisheyeMaker*(name: string): FisheyeMaker {.importcpp: "FisheyeMaker(nimStringToStdString(#))", header: stringConversionCode.}

proc reset*(this: FisheyeMaker) {.importcpp: "#.reset()".} ## \
## Resets all the parameters to their initial defaults.

proc set_fov*(this: FisheyeMaker, fov: float32) {.importcpp: "#.set_fov(#)".} ## \
## Specifies the field of view of the fisheye projection.  A sphere map will
## have a 360-degree field of view (and this is the default).

proc set_num_vertices*(this: FisheyeMaker, num_vertices: int) {.importcpp: "#.set_num_vertices(#)".} ## \
## Specifies the approximate number of vertices to be used to generate the
## rose.  This is the approximate number of vertices that will be located
## within the rose's unit circle, not counting the inscribing square (if any).
## The actual number of vertices used may be +/- 25% of this value.

proc set_square_inscribed*(this: FisheyeMaker, square_inscribed: bool, square_radius: float32) {.importcpp: "#.set_square_inscribed(#, #)".} ## \
## Sets the flag that indicates whether the rose should be inscribed within a
## square.  When this is true, an additional square is generated to inscribed
## the circular rose, with the indicated "radius" (the sides of the square
## will be 2 * square_radius).  The texture coordinates of the square will
## uniformly map to the back pole of the cube map.
##
## This is mainly useful to provide a good uniform background color for a
## sphere map so that it does not have a sharp circular edge that might
## produce artifacts due to numerical imprecision when mapping.

proc set_reflection*(this: FisheyeMaker, reflection: bool) {.importcpp: "#.set_reflection(#)".} ## \
## Sets the flag indicating whether the texture image should be mirrored
## (true) or normal (false).  When this is true, the 3-D texture coordinates
## will be reversed so that the image is appropriate for a reflection.  This
## is the best choice for generating a sphere map from a cube map.  The
## default is false.

proc generate*(this: FisheyeMaker): PandaNode {.importcpp: "#.generate()".} ## \
## Generates a GeomNode that renders the specified geometry.

proc newFrameRateMeter*(param0: FrameRateMeter): FrameRateMeter {.importcpp: "new FrameRateMeter(#)".}

proc newFrameRateMeter*(name: string): FrameRateMeter {.importcpp: "new FrameRateMeter(nimStringToStdString(#))", header: stringConversionCode.}

proc setup_window*(this: FrameRateMeter, window: GraphicsOutput) {.importcpp: "#->setup_window(#)".} ## \
## Sets up the frame rate meter to create a DisplayRegion to render itself
## into the indicated window.

proc clear_window*(this: FrameRateMeter) {.importcpp: "#->clear_window()".} ## \
## Undoes the effect of a previous call to setup_window().

proc get_window*(this: FrameRateMeter): GraphicsOutput {.importcpp: "#->get_window()".} ## \
## Returns the GraphicsOutput that was passed to setup_window(), or NULL if
## setup_window() has not been called.

proc get_display_region*(this: FrameRateMeter): DisplayRegion {.importcpp: "#->get_display_region()".} ## \
## Returns the DisplayRegion that the meter has created to render itself into
## the window to setup_window(), or NULL if setup_window() has not been
## called.

proc set_update_interval*(this: FrameRateMeter, update_interval: float64) {.importcpp: "#->set_update_interval(#)".} ## \
## Specifies the number of seconds that should elapse between updates to the
## frame rate indication.  This should be reasonably slow (e.g.  0.2 to 1.0)
## so that the calculation of the frame rate text does not itself dominate the
## frame rate.

proc get_update_interval*(this: FrameRateMeter): float64 {.importcpp: "#->get_update_interval()".} ## \
## Returns the number of seconds that will elapse between updates to the frame
## rate indication.

proc set_text_pattern*(this: FrameRateMeter, text_pattern: string) {.importcpp: "#->set_text_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the sprintf() pattern that is used to format the text.  The string
## "%f" or some variant will be replaced with the current frame rate in frames
## per second.

proc get_text_pattern*(this: FrameRateMeter): string {.importcpp: "nimStringFromStdString(#->get_text_pattern())", header: stringConversionCode.} ## \
## Returns the sprintf() pattern that is used to format the text.

proc set_clock_object*(this: FrameRateMeter, clock_object: ClockObject) {.importcpp: "#->set_clock_object(#)".} ## \
## Sets the clock that is used to determine the frame rate.  The default is
## the application's global clock (ClockObject::get_global_clock()).

proc get_clock_object*(this: FrameRateMeter): ClockObject {.importcpp: "#->get_clock_object()".} ## \
## Returns the clock that is used to determine the frame rate.

proc update*(this: FrameRateMeter) {.importcpp: "#->update()".} ## \
## You can call this to explicitly force the FrameRateMeter to update itself
## with the latest frame rate information.  Normally, it is not necessary to
## call this explicitly.

proc get_class_type*(_: typedesc[FrameRateMeter]): TypeHandle {.importcpp: "FrameRateMeter::get_class_type()", header: "frameRateMeter.h".}

proc initGeoMipTerrain*(name: string): GeoMipTerrain {.importcpp: "GeoMipTerrain(nimStringToStdString(#))", header: stringConversionCode.}

proc heightfield*(this: GeoMipTerrain): PNMImage {.importcpp: "#.heightfield()".} ## \
## Returns a reference to the heightfield (a PNMImage) contained inside
## GeoMipTerrain.  You can use the reference to alter the heightfield.

proc set_heightfield*(this: GeoMipTerrain, filename: Filename, `type`: PNMFileType): bool {.importcpp: "#.set_heightfield(#, #)".} ## \
## Loads the specified heightmap image file into the heightfield.  Returns
## true if succeeded, or false if an error has occured.  If the heightmap is
## not a power of two plus one, it is scaled up using a gaussian filter.

proc set_heightfield*(this: GeoMipTerrain, filename: Filename): bool {.importcpp: "#.set_heightfield(#)".} ## \
## Loads the specified heightmap image file into the heightfield.  Returns
## true if succeeded, or false if an error has occured.  If the heightmap is
## not a power of two plus one, it is scaled up using a gaussian filter.

proc set_heightfield*(this: GeoMipTerrain, image: PNMImage): bool {.importcpp: "#.set_heightfield(#)".} ## \
## Loads the specified heightmap image file into the heightfield.  Returns
## true if succeeded, or false if an error has occured.  If the heightmap is
## not a power of two plus one, it is scaled up using a gaussian filter.

proc color_map*(this: GeoMipTerrain): PNMImage {.importcpp: "#.color_map()".} ## \
## Returns a reference to the color map (a PNMImage) contained inside
## GeoMipTerrain.  You can use the reference to alter the color map.

proc set_color_map*(this: GeoMipTerrain, filename: Filename, `type`: PNMFileType): bool {.importcpp: "#.set_color_map(#, #)".} ## \
## Loads the specified image as color map.  The next time generate() is
## called, the terrain is painted with this color map using the vertex color
## column.  Returns a boolean indicating whether the operation has succeeded.

proc set_color_map*(this: GeoMipTerrain, filename: Filename): bool {.importcpp: "#.set_color_map(#)".} ## \
## Loads the specified image as color map.  The next time generate() is
## called, the terrain is painted with this color map using the vertex color
## column.  Returns a boolean indicating whether the operation has succeeded.

proc set_color_map*(this: GeoMipTerrain, image: PNMImage): bool {.importcpp: "#.set_color_map(#)".}

proc set_color_map*(this: GeoMipTerrain, image: Texture): bool {.importcpp: "#.set_color_map(#)".}

proc set_color_map*(this: GeoMipTerrain, path: string): bool {.importcpp: "#.set_color_map(nimStringToStdString(#))", header: stringConversionCode.}

proc has_color_map*(this: GeoMipTerrain): bool {.importcpp: "#.has_color_map()".} ## \
## Returns whether a color map has been set.

proc clear_color_map*(this: GeoMipTerrain) {.importcpp: "#.clear_color_map()".} ## \
## Clears the color map.

proc calc_ambient_occlusion*(this: GeoMipTerrain, radius: float32, contrast: float32, brightness: float32) {.importcpp: "#.calc_ambient_occlusion(#, #, #)".} ## \
## Calculates an approximate for the ambient occlusion and stores it in the
## color map, so that it will be written to the vertex colors.  Any existing
## color map will be discarded.  You need to call this before generating the
## geometry.

proc calc_ambient_occlusion*(this: GeoMipTerrain, radius: float32, contrast: float32) {.importcpp: "#.calc_ambient_occlusion(#, #)".} ## \
## Calculates an approximate for the ambient occlusion and stores it in the
## color map, so that it will be written to the vertex colors.  Any existing
## color map will be discarded.  You need to call this before generating the
## geometry.

proc calc_ambient_occlusion*(this: GeoMipTerrain, radius: float32) {.importcpp: "#.calc_ambient_occlusion(#)".} ## \
## Calculates an approximate for the ambient occlusion and stores it in the
## color map, so that it will be written to the vertex colors.  Any existing
## color map will be discarded.  You need to call this before generating the
## geometry.

proc calc_ambient_occlusion*(this: GeoMipTerrain) {.importcpp: "#.calc_ambient_occlusion()".} ## \
## Calculates an approximate for the ambient occlusion and stores it in the
## color map, so that it will be written to the vertex colors.  Any existing
## color map will be discarded.  You need to call this before generating the
## geometry.

proc get_elevation*(this: GeoMipTerrain, x: float64, y: float64): float64 {.importcpp: "#.get_elevation(#, #)".} ## \
## Fetches the elevation at (x, y), where the input coordinate is specified in
## pixels.  This ignores the current LOD level and instead provides an
## accurate number.  Linear blending is used for non-integral coordinates.
## Terrain scale is NOT taken into account!  To get accurate normals, please
## multiply this with the terrain Z scale!
##
## trueElev = terr.get_elevation(x,y) * terr.get_sz();

proc get_normal*(this: GeoMipTerrain, x: int, y: int): LVector3 {.importcpp: "#.get_normal(#, #)".} ## \
## Fetches the terrain normal at (x, y), where the input coordinate is
## specified in pixels.  This ignores the current LOD level and instead
## provides an accurate number.  Terrain scale is NOT taken into account!  To
## get accurate normals, please divide it by the terrain scale and normalize
## it again, like this:
##
## LVector3 normal (terr.get_normal(x, y)); normal.set(normal.get_x() /
## root.get_sx(), normal.get_y() / root.get_sy(), normal.get_z() /
## root.get_sz()); normal.normalize();

proc get_normal*(this: GeoMipTerrain, mx: int, my: int, x: int, y: int): LVector3 {.importcpp: "#.get_normal(#, #, #, #)".} ## \
## Fetches the terrain normal at (x,y), where the input coordinate is
## specified in pixels.  This ignores the current LOD level and instead
## provides an accurate number.  Terrain scale is NOT taken into account!  To
## get accurate normals, please divide it by the terrain scale and normalize
## it again!

proc set_bruteforce*(this: GeoMipTerrain, bf: bool) {.importcpp: "#.set_bruteforce(#)".} ## \
## Sets a boolean specifying whether the terrain will be rendered bruteforce.
## If the terrain is rendered bruteforce, there will be no Level of Detail,
## and the update() call will only update the terrain if it is marked dirty.

proc get_bruteforce*(this: GeoMipTerrain): bool {.importcpp: "#.get_bruteforce()".} ## \
## Returns a boolean whether the terrain is rendered bruteforce or not.  See
## set_bruteforce for more information.

proc set_auto_flatten*(this: GeoMipTerrain, mode: int) {.importcpp: "#.set_auto_flatten(#)".} ## \
## The terrain can be automatically flattened (using flatten_light,
## flatten_medium, or flatten_strong) after each update.  This only affects
## future updates, it doesn't flatten the current terrain.

proc set_focal_point*(this: GeoMipTerrain, fp: LPoint2d) {.importcpp: "#.set_focal_point(#)".} ## \
## The focal point is the point at which the terrain will have the highest
## quality (lowest level of detail). Parts farther away from the focal point
## will have a lower quality (higher level of detail). The focal point is
## not taken in respect if bruteforce is set true.

proc set_focal_point*(this: GeoMipTerrain, fp: LPoint2f) {.importcpp: "#.set_focal_point(#)".}

proc set_focal_point*(this: GeoMipTerrain, fp: LPoint3d) {.importcpp: "#.set_focal_point(#)".}

proc set_focal_point*(this: GeoMipTerrain, fp: LPoint3f) {.importcpp: "#.set_focal_point(#)".}

proc set_focal_point*(this: GeoMipTerrain, fnp: NodePath) {.importcpp: "#.set_focal_point(#)".}

proc set_focal_point*(this: GeoMipTerrain, x: float64, y: float64) {.importcpp: "#.set_focal_point(#, #)".} ## \
## Sets the focal point.  GeoMipTerrain generates high-resolution terrain
## around the focal point, and progressively lower and lower resolution
## terrain as you get farther away.  If a point is supplied and not a
## NodePath, make sure it's relative to the terrain.  Only the x and y
## coordinates of the focal point are taken in respect.

proc get_focal_point*(this: GeoMipTerrain): NodePath {.importcpp: "#.get_focal_point()".} ## \
## Returns the focal point, as a NodePath.  If you have set it to be just a
## point, it will return an empty node at the focal position.

proc get_root*(this: GeoMipTerrain): NodePath {.importcpp: "#.get_root()".} ## \
## Returns the root of the terrain.  This is a single PandaNode to which all
## the rest of the terrain is parented.  The generate and update operations
## replace the nodes which are parented to this root, but they don't replace
## this root itself.

proc set_block_size*(this: GeoMipTerrain, newbs: int) {.importcpp: "#.set_block_size(#)".} ## \
## Sets the block size.  If it is not a power of two, the closest power of two
## is used.

proc get_block_size*(this: GeoMipTerrain): int {.importcpp: "#.get_block_size()".} ## \
## Gets the block size.

proc get_max_level*(this: GeoMipTerrain): int {.importcpp: "#.get_max_level()".} ## \
## Returns the highest level possible for this block size.  When a block is at
## this level, it will be the worst quality possible.

proc set_min_level*(this: GeoMipTerrain, minlevel: int) {.importcpp: "#.set_min_level(#)".} ## \
## Sets the minimum level of detail at which blocks may be generated by
## generate() or update(). The default value is 0, which is the highest
## quality.  This value is also taken in respect when generating the terrain
## bruteforce.

proc get_min_level*(this: GeoMipTerrain): int {.importcpp: "#.get_min_level()".} ## \
## Gets the minimum level of detail at which blocks may be generated by
## generate() or update(). The default value is 0, which is the highest
## quality.

proc is_dirty*(this: GeoMipTerrain): bool {.importcpp: "#.is_dirty()".} ## \
## Returns a bool indicating whether the terrain is marked 'dirty', that means
## the terrain has to be regenerated on the next update() call, because for
## instance the heightfield has changed.  Once the terrain has been
## regenerated, the dirty flag automatically gets reset internally.

proc set_factor*(this: GeoMipTerrain, factor: float32) {.importcpp: "#.set_factor(#)".} ## \
## DEPRECATED method.  Use set_near/far instead.  Sets the quality factor at
## which blocks must be generated.  The higher this level, the better quality
## the terrain will be, but more expensive to render.  A value of 0 makes the
## terrain the lowest quality possible, depending on blocksize.  The default
## value is 100.

proc set_near_far*(this: GeoMipTerrain, input_near: float64, input_far: float64) {.importcpp: "#.set_near_far(#, #)".} ## \
## Sets the near and far LOD distances in one call.

proc set_near*(this: GeoMipTerrain, input_near: float64) {.importcpp: "#.set_near(#)".} ## \
## Sets the near LOD distance, at which the terrain will be rendered at
## highest quality.  This distance is in the terrain's coordinate space!

proc set_far*(this: GeoMipTerrain, input_far: float64) {.importcpp: "#.set_far(#)".} ## \
## Sets the far LOD distance, at which the terrain will be rendered at lowest
## quality.  This distance is in the terrain's coordinate space!

proc get_block_node_path*(this: GeoMipTerrain, mx: int, my: int): NodePath {.importcpp: "#.get_block_node_path(#, #)".} ## \
## Returns the NodePath of the specified block.  If auto-flatten is enabled
## and the node is getting removed during the flattening process, it will
## still return a NodePath with the appropriate terrain chunk, but it will be
## in a temporary scenegraph.  Please note that this returns a const object
## and you can not modify the node.  Modify the heightfield instead.

proc get_block_from_pos*(this: GeoMipTerrain, x: float64, y: float64): LVecBase2 {.importcpp: "#.get_block_from_pos(#, #)".} ## \
## Gets the coordinates of the block at the specified position.  This position
## must be relative to the terrain, not to render.  Returns an array
## containing two values: the block x and the block y coords.  If the
## positions are out of range, the closest block is taken.  Note that the
## VecBase returned does not represent a vector, position, or rotation, but it
## contains the block index of the block which you can use in
## GeoMipTerrain::get_block_node_path.

proc set_border_stitching*(this: GeoMipTerrain, stitching: bool) {.importcpp: "#.set_border_stitching(#)".} ## \
## If this value is true, the LOD level at the borders of the terrain will be
## 0. This is useful if you have multiple terrains attached and you want to
## stitch them together, to fix seams.  This setting also has effect when
## bruteforce is enabled, although in that case you are probably better off
## with setting the minlevels to the same value.

proc get_border_stitching*(this: GeoMipTerrain): bool {.importcpp: "#.get_border_stitching()".} ## \
## Returns the current stitching setting.  False by default, unless
## set_stitching has been set.

proc get_far*(this: GeoMipTerrain): float64 {.importcpp: "#.get_far()".} ## \
## Returns the far LOD distance in the terrain coordinate space

proc get_near*(this: GeoMipTerrain): float64 {.importcpp: "#.get_near()".} ## \
## Returns the near LOD distance in the terrain coordinate space

proc get_flatten_mode*(this: GeoMipTerrain): int {.importcpp: "#.get_flatten_mode()".} ## \
## Returns the automatic-flatten mode (e.g., off, flatten_light,
## flatten_medium, or flatten_strong)

proc make_slope_image*(this: GeoMipTerrain): PNMImage {.importcpp: "#.make_slope_image()".} ## \
## Returns a new grayscale image containing the slope angles.  A white pixel
## value means a vertical slope, while a black pixel will mean that the
## terrain is entirely flat at that pixel.  You can translate it to degrees by
## mapping the greyscale values from 0 to 90 degrees.  The resulting image
## will have the same size as the heightfield image.  The scale will be taken
## into respect -- meaning, if you change the terrain scale, the slope image
## will need to be regenerated in order to be correct.

proc generate*(this: GeoMipTerrain) {.importcpp: "#.generate()".} ## \
## (Re)generates the entire terrain, erasing the current.  This call un-
## flattens the terrain, so make sure you have set auto-flatten if you want to
## keep your terrain flattened.

proc update*(this: GeoMipTerrain): bool {.importcpp: "#.update()".} ## \
## Loops through all of the terrain blocks, and checks whether they need to be
## updated.  If that is indeed the case, it regenerates the mipmap.  Returns a
## true when the terrain has changed.  Returns false when the terrain isn't
## updated at all.  If there is no terrain yet, it generates the entire
## terrain.  This call un-flattens the terrain, so make sure you have set
## auto-flatten if you want to keep your terrain flattened.

proc get_class_type*(_: typedesc[GeoMipTerrain]): TypeHandle {.importcpp: "GeoMipTerrain::get_class_type()", header: "geoMipTerrain.h".}

proc initHeightfieldTesselator*(param0: HeightfieldTesselator): HeightfieldTesselator {.importcpp: "HeightfieldTesselator(#)".}

proc initHeightfieldTesselator*(name: string): HeightfieldTesselator {.importcpp: "HeightfieldTesselator(nimStringToStdString(#))", header: stringConversionCode.}

proc heightfield*(this: HeightfieldTesselator): PNMImage {.importcpp: "#.heightfield()".} ## \
## Returns a reference to the heightfield (a PNMImage) contained inside the
## HeightfieldTesselator.  You can use the reference to alter the heightfield.

proc set_heightfield*(this: HeightfieldTesselator, filename: Filename, `type`: PNMFileType): bool {.importcpp: "#.set_heightfield(#, #)".} ## \
## Loads the specified greyscale image file into the heightfield.

proc set_heightfield*(this: HeightfieldTesselator, filename: Filename): bool {.importcpp: "#.set_heightfield(#)".} ## \
## Loads the specified greyscale image file into the heightfield.

proc set_poly_count*(this: HeightfieldTesselator, n: int) {.importcpp: "#.set_poly_count(#)".} ## \
## Sets the polygon-count target.  The tesselator usually manages to come
## within about 20% of the target, plus or minus.

proc set_visibility_radius*(this: HeightfieldTesselator, r: int) {.importcpp: "#.set_visibility_radius(#)".} ## \
## Sets the visibility radius.  Polygons that are completely outside the
## radius (relative to the focal point) are cropped away.  The cropping is
## imperfect (all approximations are conservative), so this should be used in
## conjunction with a far clipping plane, fog, or some other visibility
## limiting mechanism.  The units are in pixels.

proc set_focal_point*(this: HeightfieldTesselator, x: int, y: int) {.importcpp: "#.set_focal_point(#, #)".} ## \
## Sets the focal point.  The tesselator generates high-resolution terrain
## around the focal point, and progressively lower and lower resolution
## terrain as you get farther away.  The units are in pixels.

proc set_horizontal_scale*(this: HeightfieldTesselator, h: float64) {.importcpp: "#.set_horizontal_scale(#)".} ## \
## Sets the horizontal scale.  The default scale is 1.0, meaning that each
## pixel in the heightfield is 1x1 panda units wide.

proc set_vertical_scale*(this: HeightfieldTesselator, v: float64) {.importcpp: "#.set_vertical_scale(#)".} ## \
## Sets the vertical scale.  The default scale is 255.0, meaning that each as
## the gray value ranges from (0-1), the elevation ranges from (0-255) feet.

proc set_max_triangles*(this: HeightfieldTesselator, n: int) {.importcpp: "#.set_max_triangles(#)".} ## \
## Sets the max triangles per geom.

proc get_elevation*(this: HeightfieldTesselator, x: float64, y: float64): float64 {.importcpp: "#.get_elevation(#, #)".} ## \
## Fetches the elevation at (x,y), where the input coordinate is specified in
## pixels.  This ignores the current tesselation level and instead provides an
## accurate number.  Linear blending is used for non-integral coordinates.

proc generate*(this: HeightfieldTesselator): NodePath {.importcpp: "#.generate()".} ## \
## Generates a tree of nodes that represents the heightfield.  This can be
## reparented into the scene.

proc initLineSegs*(param0: LineSegs): LineSegs {.importcpp: "LineSegs(#)".}

proc initLineSegs*(name: string): LineSegs {.importcpp: "LineSegs(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Constructs a LineSegs object, which can be used to create any number of
## disconnected lines or points of various thicknesses and colors through the
## visible scene.  After creating the object, call move_to() and draw_to()
## repeatedly to describe the path, then call create() to create a GeomNode
## which will render the described path.

proc initLineSegs*(): LineSegs {.importcpp: "LineSegs()".} ## \
## Constructs a LineSegs object, which can be used to create any number of
## disconnected lines or points of various thicknesses and colors through the
## visible scene.  After creating the object, call move_to() and draw_to()
## repeatedly to describe the path, then call create() to create a GeomNode
## which will render the described path.

proc reset*(this: LineSegs) {.importcpp: "#.reset()".} ## \
## Removes any lines in progress and resets to the initial empty state.

proc set_color*(this: LineSegs, color: LColor) {.importcpp: "#.set_color(#)".} ## \
## Establishes the color that will be assigned to all vertices created by
## future calls to move_to() and draw_to().

proc set_color*(this: LineSegs, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_color(#, #, #, #)".} ## \
## Establishes the color that will be assigned to all vertices created by
## future calls to move_to() and draw_to().

proc set_color*(this: LineSegs, r: float32, g: float32, b: float32) {.importcpp: "#.set_color(#, #, #)".} ## \
## Establishes the color that will be assigned to all vertices created by
## future calls to move_to() and draw_to().

proc set_thickness*(this: LineSegs, thick: float32) {.importcpp: "#.set_thickness(#)".} ## \
## Establishes the line thickness or point size in pixels that will be
## assigned to all lines and points created by future calls to create().

proc move_to*(this: LineSegs, v: LVecBase3) {.importcpp: "#.move_to(#)".} ## \
## Moves the pen to the given point without drawing a line.  When followed by
## draw_to(), this marks the first point of a line segment; when followed by
## move_to() or create(), this creates a single point.

proc move_to*(this: LineSegs, x: float32, y: float32, z: float32) {.importcpp: "#.move_to(#, #, #)".} ## \
## Moves the pen to the given point without drawing a line.  When followed by
## draw_to(), this marks the first point of a line segment; when followed by
## move_to() or create(), this creates a single point.

proc draw_to*(this: LineSegs, v: LVecBase3) {.importcpp: "#.draw_to(#)".} ## \
## Draws a line segment from the pen's last position (the last call to move_to
## or draw_to) to the indicated point.  move_to() and draw_to() only update
## tables; the actual drawing is performed when create() is called.

proc draw_to*(this: LineSegs, x: float32, y: float32, z: float32) {.importcpp: "#.draw_to(#, #, #)".} ## \
## Draws a line segment from the pen's last position (the last call to move_to
## or draw_to) to the indicated point.  move_to() and draw_to() only update
## tables; the actual drawing is performed when create() is called.

proc get_current_position*(this: LineSegs): LVertex {.importcpp: "#.get_current_position()".} ## \
## Returns the pen's current position.  The next call to draw_to() will draw a
## line segment from this point.

proc is_empty*(this: LineSegs): bool {.importcpp: "#.is_empty()".} ## \
## Returns true if move_to() or draw_to() have not been called since the last
## reset() or create(), false otherwise.

proc create*(this: LineSegs, previous: GeomNode, dynamic: bool): GeomNode {.importcpp: "#.create(#, #)".} ## \
## Appends to an existing GeomNode a new Geom that will render the series of
## line segments and points described via calls to move_to() and draw_to().
## The lines and points are created with the color and thickness established
## by calls to set_color() and set_thickness().
##
## If dynamic is true, the line segments will be created with the dynamic Geom
## setting, optimizing them for runtime vertex animation.

proc create*(this: LineSegs, previous: GeomNode): GeomNode {.importcpp: "#.create(#)".} ## \
## Appends to an existing GeomNode a new Geom that will render the series of
## line segments and points described via calls to move_to() and draw_to().
## The lines and points are created with the color and thickness established
## by calls to set_color() and set_thickness().
##
## If dynamic is true, the line segments will be created with the dynamic Geom
## setting, optimizing them for runtime vertex animation.

proc create*(this: LineSegs, dynamic: bool): GeomNode {.importcpp: "#.create(#)".} ## \
## Creates a new GeomNode that will render the series of line segments and
## points described via calls to move_to() and draw_to().  The lines and
## points are created with the color and thickness established by calls to
## set_color() and set_thickness().
##
## If dynamic is true, the line segments will be created with the dynamic Geom
## setting, optimizing them for runtime vertex animation.

proc create*(this: LineSegs): GeomNode {.importcpp: "#.create()".} ## \
## Creates a new GeomNode that will render the series of line segments and
## points described via calls to move_to() and draw_to().  The lines and
## points are created with the color and thickness established by calls to
## set_color() and set_thickness().
##
## If dynamic is true, the line segments will be created with the dynamic Geom
## setting, optimizing them for runtime vertex animation.

proc get_num_vertices*(this: LineSegs): int {.importcpp: "#.get_num_vertices()".} ## \
## Returns the total number of line segment and point vertices generated by
## the last call to create().  The positions of these vertices may be read and
## adjusted through get_vertex() and set_vertex().

proc get_vertex*(this: LineSegs, n: int): LVertex {.importcpp: "#.get_vertex(#)".} ## \
## Returns the nth point or vertex of the line segment sequence generated by
## the last call to create().  The first move_to() generates vertex 0;
## subsequent move_to() and draw_to() calls generate consecutively higher
## vertex numbers.

proc set_vertex*(this: LineSegs, n: int, vert: LVertex) {.importcpp: "#.set_vertex(#, #)".} ## \
## Moves the nth point or vertex of the line segment sequence generated by the
## last call to create().  The first move_to() generates vertex 0; subsequent
## move_to() and draw_to() calls generate consecutively higher vertex numbers.

proc set_vertex*(this: LineSegs, vertex: int, x: float32, y: float32, z: float32) {.importcpp: "#.set_vertex(#, #, #, #)".} ## \
## Moves the nth point or vertex of the line segment sequence generated by the
## last call to create().  The first move_to() generates vertex 0; subsequent
## move_to() and draw_to() calls generate consecutively higher vertex numbers.

proc get_vertex_color*(this: LineSegs, vertex: int): LColor {.importcpp: "#.get_vertex_color(#)".} ## \
## Returns the color of the nth point or vertex.

proc set_vertex_color*(this: LineSegs, vertex: int, c: LColor) {.importcpp: "#.set_vertex_color(#, #)".} ## \
## Changes the vertex color of the nth point or vertex.  See set_vertex().

proc set_vertex_color*(this: LineSegs, vertex: int, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_vertex_color(#, #, #, #, #)".} ## \
## Changes the vertex color of the nth point or vertex.  See set_vertex().

proc set_vertex_color*(this: LineSegs, vertex: int, r: float32, g: float32, b: float32) {.importcpp: "#.set_vertex_color(#, #, #, #)".} ## \
## Changes the vertex color of the nth point or vertex.  See set_vertex().

proc initMeshDrawer*(): MeshDrawer {.importcpp: "MeshDrawer()".} ## \
## Creates the MeshDrawer low level system.

proc set_budget*(this: MeshDrawer, budget: int) {.importcpp: "#.set_budget(#)".} ## \
## Sets the total triangle budget of the drawer.  This will not be exceeded.
## Don't set some thing too large because it will be slow

proc get_budget*(this: MeshDrawer): int {.importcpp: "#.get_budget()".} ## \
## Gets the total triangle budget of the drawer

proc get_root*(this: MeshDrawer): NodePath {.importcpp: "#.get_root()".} ## \
## Returns the root NodePath.  You should use this node to reparent mesh
## drawer onto the scene might also want to disable depth draw or enable
## transparency.

proc begin*(this: MeshDrawer, camera: NodePath, render: NodePath) {.importcpp: "#.begin(#, #)".} ## \
## Pass the current camera node and the root node.  Passing the camera is
## required to generate bill boards that face it.

proc tri*(this: MeshDrawer, v1: LVector3, c1: LVector4, uv1: LVector2, v2: LVector3, c2: LVector4, uv2: LVector2, v3: LVector3, c3: LVector4, uv3: LVector2) {.importcpp: "#.tri(#, #, #, #, #, #, #, #, #)".} ## \
## Draws a triangle with the given parameters.

proc particle*(this: MeshDrawer, pos: LVector3, frame: LVector4, size: float32, color: LVector4, rotation: float32) {.importcpp: "#.particle(#, #, #, #, #)".} ## \
## Draws a particle that is sort of like a bill board but has an extra
## rotation component.  Frame contains u,v,u-size,v-size quadruple.

proc blended_particle*(this: MeshDrawer, pos: LVector3, frame1: LVector4, frame2: LVector4, blend: float32, size: float32, color: LVector4, rotation: float32) {.importcpp: "#.blended_particle(#, #, #, #, #, #, #)".} ## \
## Works just like particle but accepts 2 frames and a blend (from 0 to 1)
## component between them Frame contains u,v,u-size,v-size quadruple.

proc billboard*(this: MeshDrawer, pos: LVector3, frame: LVector4, size: float32, color: LVector4) {.importcpp: "#.billboard(#, #, #, #)".} ## \
## Draws a billboard - particle with no rotation.  Billboards always face the
## camera.  Frame contains u,v,u-size,v-size quadruple.

proc segment*(this: MeshDrawer, start: LVector3, stop: LVector3, frame: LVector4, thickness: float32, color: LVector4) {.importcpp: "#.segment(#, #, #, #, #)".} ## \
## Draws a segment a line with a thickness.  That has billboarding effect.
## Frame contains u,v,u-size,v-size quadruple.

proc cross_segment*(this: MeshDrawer, start: LVector3, stop: LVector3, frame: LVector4, thickness: float32, color: LVector4) {.importcpp: "#.cross_segment(#, #, #, #, #)".} ## \
## Draws a segment a line with a thickness.  This segment does not use the
## bill boarding behavior and instead draws 2 planes in a cross.  Stars at
## start and ends at stop.  Frame contains u,v,u-size,v-size quadruple.

proc uneven_segment*(this: MeshDrawer, start: LVector3, stop: LVector3, frame: LVector4, thickness_start: float32, color_start: LVector4, thickness_stop: float32, color_stop: LVector4) {.importcpp: "#.uneven_segment(#, #, #, #, #, #, #)".} ## \
## Draws a segment a line with different thickness and color on both sides.
## Stars at start and ends at stop.  Frame contains u,v,u-size,v-size
## quadruple.

proc link_segment*(this: MeshDrawer, pos: LVector3, frame: LVector4, thickness: float32, color: LVector4) {.importcpp: "#.link_segment(#, #, #, #)".} ## \
## Stars or continues linked segment.  Control position, frame, thickness and
## color with parameters.  Frame contains u,v,u-size,v-size quadruple.

proc link_segment_end*(this: MeshDrawer, frame: LVector4, color: LVector4) {.importcpp: "#.link_segment_end(#, #)".} ## \
## Finish drawing linked segments, needs at least two calls to link_segment
## before it can end the linked segment.  Frame contains u,v,u-size,v-size
## quadruple.

proc explosion*(this: MeshDrawer, pos: LVector3, frame: LVector4, size: float32, color: LVector4, seed: int, number: int, distance: float32) {.importcpp: "#.explosion(#, #, #, #, #, #, #)".} ## \
## Draws number of particles in a sphere like emitter.  Frame contains
## u,v,u-size,v-size quadruple.

proc stream*(this: MeshDrawer, start: LVector3, stop: LVector3, frame: LVector4, size: float32, color: LVector4, number: int, offset: float32) {.importcpp: "#.stream(#, #, #, #, #, #, #)".} ## \
## Draws a number of particles in a big line with a shift dictated by the
## offset.  Frame contains u,v,u-size,v-size quadruple.

proc geometry*(this: MeshDrawer, node: NodePath) {.importcpp: "#.geometry(#)".} ## \
## Draws the geometry that is inside this node path into the MeshDrawer
## object.  This performs a similar functions as RigidBodyCombiner but for
## very dynamic situations that share the same texture like physcal chunks of
## explosions.  It can be a little slow

proc get_class_type*(_: typedesc[MeshDrawer]): TypeHandle {.importcpp: "MeshDrawer::get_class_type()", header: "meshDrawer.h".}

proc initMeshDrawer2D*(): MeshDrawer2D {.importcpp: "MeshDrawer2D()".} ## \
## Creates the MeshDrawer2D low level system.

proc set_budget*(this: MeshDrawer2D, budget: int) {.importcpp: "#.set_budget(#)".} ## \
## Sets the total triangle budget of the drawer.

proc get_budget*(this: MeshDrawer2D): int {.importcpp: "#.get_budget()".} ## \
## Gets the total triangle budget of the drawer.

proc get_root*(this: MeshDrawer2D): NodePath {.importcpp: "#.get_root()".} ## \
## Returns the root NodePath.

proc quad_raw*(this: MeshDrawer2D, v1: LVector3, c1: LVector4, uv1: LVector2, v2: LVector3, c2: LVector4, uv2: LVector2, v3: LVector3, c3: LVector4, uv3: LVector2, v4: LVector3, c4: LVector4, uv4: LVector2) {.importcpp: "#.quad_raw(#, #, #, #, #, #, #, #, #, #, #, #)".} ## \
## Draws a 2D rectangle.  Ignores the clipping rectangle.

proc rectangle_raw*(this: MeshDrawer2D, x: float32, y: float32, w: float32, h: float32, u: float32, v: float32, us: float32, vs: float32, color: LVector4) {.importcpp: "#.rectangle_raw(#, #, #, #, #, #, #, #, #)".}

proc set_clip*(this: MeshDrawer2D, x: float32, y: float32, w: float32, h: float32) {.importcpp: "#.set_clip(#, #, #, #)".} ## \
## Sets the clipping rectangle.

proc rectangle*(this: MeshDrawer2D, x: float32, y: float32, w: float32, h: float32, u: float32, v: float32, us: float32, vs: float32, color: LVector4) {.importcpp: "#.rectangle(#, #, #, #, #, #, #, #, #)".} ## \
## Draws a 2D rectangle which can be clipped.

proc rectangle_border*(this: MeshDrawer2D, x: float32, y: float32, w: float32, h: float32, r: float32, t: float32, l: float32, b: float32, tr: float32, tt: float32, tl: float32, tb: float32, u: float32, v: float32, us: float32, vs: float32, color: LVector4) {.importcpp: "#.rectangle_border(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".} ## \
## Draws a 2d rectangle, with borders and corders, taken from the surrounding
## texture

proc rectangle_border_tiled*(this: MeshDrawer2D, x: float32, y: float32, w: float32, h: float32, r: float32, t: float32, l: float32, b: float32, tr: float32, tt: float32, tl: float32, tb: float32, u: float32, v: float32, us: float32, vs: float32, color: LVector4) {.importcpp: "#.rectangle_border_tiled(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".} ## \
## Draws a 2d rectangle, with borders and corders, taken from the surrounding
## texture

proc rectangle_tiled*(this: MeshDrawer2D, x: float32, y: float32, w: float32, h: float32, u: float32, v: float32, us: float32, vs: float32, color: LVector4) {.importcpp: "#.rectangle_tiled(#, #, #, #, #, #, #, #, #)".} ## \
## Draws a tiled rectangle, size of tiles is in us and vs

proc begin*(this: MeshDrawer2D) {.importcpp: "#.begin()".} ## \
## Opens up the geom for drawing, don't forget to call MeshDrawer2D::end()

proc get_class_type*(_: typedesc[MeshDrawer2D]): TypeHandle {.importcpp: "MeshDrawer2D::get_class_type()", header: "meshDrawer2D.h".}

proc newMovieTexture*(video: MovieVideo): MovieTexture {.importcpp: "new MovieTexture(#)".} ## \
## Creates a texture playing the specified movie.

proc newMovieTexture*(name: string): MovieTexture {.importcpp: "new MovieTexture(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates a blank movie texture.  Movies must be added using do_read_one or
## do_load_one.

proc get_video_length*(this: MovieTexture): float64 {.importcpp: "#->get_video_length()".} ## \
## Returns the length of the video.

proc get_video_width*(this: MovieTexture): int {.importcpp: "#->get_video_width()".} ## \
## Returns the width in texels of the source video stream.  This is not
## necessarily the width of the actual texture, since the texture may have
## been expanded to raise it to a power of 2.

proc get_video_height*(this: MovieTexture): int {.importcpp: "#->get_video_height()".} ## \
## Returns the height in texels of the source video stream.  This is not
## necessarily the height of the actual texture, since the texture may have
## been expanded to raise it to a power of 2.

proc get_color_cursor*(this: MovieTexture, page: int): MovieVideoCursor {.importcpp: "#->get_color_cursor(#)".} ## \
## Returns the MovieVideoCursor that is feeding the color channels for the
## indicated page, where 0 <= page < get_num_pages().

proc get_alpha_cursor*(this: MovieTexture, page: int): MovieVideoCursor {.importcpp: "#->get_alpha_cursor(#)".} ## \
## Returns the MovieVideoCursor that is feeding the alpha channel for the
## indicated page, where 0 <= page < get_num_pages().

proc restart*(this: MovieTexture) {.importcpp: "#->restart()".} ## \
## Start playing the movie from where it was last paused.  Has no effect if
## the movie is not paused, or if the movie's cursor is already at the end.

proc stop*(this: MovieTexture) {.importcpp: "#->stop()".} ## \
## Stops a currently playing or looping movie right where it is.  The movie's
## cursor remains frozen at the point where it was stopped.

proc play*(this: MovieTexture) {.importcpp: "#->play()".} ## \
## Plays the movie from the beginning.

proc set_time*(this: MovieTexture, t: float64) {.importcpp: "#->set_time(#)".} ## \
## Sets the movie's cursor.

proc get_time*(this: MovieTexture): float64 {.importcpp: "#->get_time()".} ## \
## Returns the current value of the movie's cursor.  If the movie's loop count
## is greater than one, then its length is effectively multiplied for the
## purposes of this function.  In other words, the return value will be in the
## range 0.0 to (length * loopcount).

proc set_loop*(this: MovieTexture, enable: bool) {.importcpp: "#->set_loop(#)".} ## \
## If true, sets the movie's loop count to 1 billion.  If false, sets the
## movie's loop count to one.

proc get_loop*(this: MovieTexture): bool {.importcpp: "#->get_loop()".} ## \
## Returns true if the movie's loop count is not equal to one.

proc set_loop_count*(this: MovieTexture, count: int) {.importcpp: "#->set_loop_count(#)".} ## \
## Sets the movie's loop count to the desired value.

proc get_loop_count*(this: MovieTexture): int {.importcpp: "#->get_loop_count()".} ## \
## Returns the movie's loop count.

proc set_play_rate*(this: MovieTexture, play_rate: float64) {.importcpp: "#->set_play_rate(#)".} ## \
## Sets the movie's play-rate.  This is the speed at which the movie's cursor
## advances.  The default is to advance 1.0 movie-seconds per real-time
## second.

proc get_play_rate*(this: MovieTexture): float64 {.importcpp: "#->get_play_rate()".} ## \
## Gets the movie's play-rate.

proc is_playing*(this: MovieTexture): bool {.importcpp: "#->is_playing()".} ## \
## Returns true if the movie's cursor is advancing.

proc synchronize_to*(this: MovieTexture, sound: AudioSound) {.importcpp: "#->synchronize_to(#)".} ## \
## Synchronize this texture to a sound.  Typically, you would load the texture
## and the sound from the same AVI file.

proc unsynchronize*(this: MovieTexture) {.importcpp: "#->unsynchronize()".} ## \
## Stop synchronizing with a sound.

proc get_class_type*(_: typedesc[MovieTexture]): TypeHandle {.importcpp: "MovieTexture::get_class_type()", header: "movieTexture.h".}

proc initMultitexReducer*(): MultitexReducer {.importcpp: "MultitexReducer()".}

proc initMultitexReducer*(param0: MultitexReducer): MultitexReducer {.importcpp: "MultitexReducer(#)".}

proc clear*(this: MultitexReducer) {.importcpp: "#.clear()".}

proc scan*(this: MultitexReducer, node: NodePath) {.importcpp: "#.scan(#)".} ## \
## Starts scanning the hierarchy beginning at the indicated node.  Any
## GeomNodes discovered in the hierarchy with multitexture will be added to
## internal structures in the MultitexReducer so that a future call to
## flatten() will operate on all of these at once.
##
## This version of this method does not accumulate state from the parents of
## the indicated node; thus, only multitexture effects that have been applied
## at node and below will be considered.

proc scan*(this: MultitexReducer, node: NodePath, state_from: NodePath) {.importcpp: "#.scan(#, #)".} ## \
## Starts scanning the hierarchy beginning at the indicated node.  Any
## GeomNodes discovered in the hierarchy with multitexture will be added to
## internal structures in the MultitexReducer so that a future call to
## flatten() will operate on all of these at once.
##
## The second parameter represents the NodePath from which to accumulate the
## state that is considered for the multitexture.  Pass an empty NodePath to
## accumulate all the state from the root of the graph, or you may specify
## some other node here in order to not consider nodes above that as
## contributing to the state to be flattened.  This is particularly useful if
## you have some texture stage which is applied globally to a scene (for
## instance, a caustics effect), which you don't want to be considered for
## flattening by the MultitexReducer.

proc scan*(this: MultitexReducer, node: PandaNode, state: RenderState, transform: TransformState) {.importcpp: "#.scan(#, #, #)".}

proc set_target*(this: MultitexReducer, stage: TextureStage) {.importcpp: "#.set_target(#)".}

proc set_use_geom*(this: MultitexReducer, use_geom: bool) {.importcpp: "#.set_use_geom(#)".}

proc set_allow_tex_mat*(this: MultitexReducer, allow_tex_mat: bool) {.importcpp: "#.set_allow_tex_mat(#)".}

proc flatten*(this: MultitexReducer, window: GraphicsOutput) {.importcpp: "#.flatten(#)".}

proc newNodeVertexTransform*(node: PandaNode, prev: VertexTransform): NodeVertexTransform {.importcpp: "new NodeVertexTransform(#, #)".}

proc newNodeVertexTransform*(node: PandaNode): NodeVertexTransform {.importcpp: "new NodeVertexTransform(#)".}

proc get_node*(this: NodeVertexTransform): PandaNode {.importcpp: "#->get_node()".} ## \
## Returns the PandaNode whose transform supplies this object.

proc get_prev*(this: NodeVertexTransform): VertexTransform {.importcpp: "#->get_prev()".} ## \
## Returns the VertexTransform object whose matrix will be composed with the
## result of this node's transform.

proc get_class_type*(_: typedesc[NodeVertexTransform]): TypeHandle {.importcpp: "NodeVertexTransform::get_class_type()", header: "nodeVertexTransform.h".}

proc newShaderTerrainMesh*(): ShaderTerrainMesh {.importcpp: "new ShaderTerrainMesh()".} ## \
## @brief Constructs a new Terrain Mesh
## @details This constructs a new terrain mesh. By default, no transform is set
## on the mesh, causing it to range over the unit box from (0, 0, 0) to
## (1, 1, 1). Usually you want to set a custom transform with NodePath::set_scale()

proc set_heightfield*(this: ShaderTerrainMesh, heightfield: Texture) {.importcpp: "#->set_heightfield(#)".} ## \
## @brief Sets the heightfield texture
## @details This sets the heightfield texture. It should be 16bit
## single channel, and have a power-of-two resolution greater than 32.
## Common sizes are 2048x2048 or 4096x4096.
##
## You should call generate() after setting the heightfield.
##
## @param filename Heightfield texture

proc get_heightfield*(this: ShaderTerrainMesh): Texture {.importcpp: "#->get_heightfield()".} ## \
## @brief Returns the heightfield
## @details This returns the terrain heightfield, previously set with
## set_heightfield()
##
## @return Path to the heightfield

proc set_chunk_size*(this: ShaderTerrainMesh, chunk_size: clonglong) {.importcpp: "#->set_chunk_size(#)".} ## \
## @brief Sets the chunk size
## @details This sets the chunk size of the terrain. A chunk is basically the
## smallest unit in LOD. If the chunk size is too small, the terrain will
## perform bad, since there will be way too many chunks. If the chunk size
## is too big, you will not get proper LOD, and might also get bad performance.
##
## For terrains of the size 4096x4096 or 8192x8192, a chunk size of 32 seems
## to produce good results. For smaller resolutions, you should try out a
## size of 16 or even 8 for very small terrains.
##
## The amount of chunks generated for the last level equals to
## (heightfield_size / chunk_size) ** 2. The chunk size has to be a power
## of two.
##
## @param chunk_size Size of the chunks, has to be a power of two

proc get_chunk_size*(this: ShaderTerrainMesh): clonglong {.importcpp: "#->get_chunk_size()".} ## \
## @brief Returns the chunk size
## @details This returns the chunk size, previously set with set_chunk_size()
## @return Chunk size

proc set_generate_patches*(this: ShaderTerrainMesh, generate_patches: bool) {.importcpp: "#->set_generate_patches(#)".} ## \
## @brief Sets whether to generate patches
## @details If this option is set to true, GeomPatches will be used instead of
## GeomTriangles. This is required when the terrain is used with tesselation
## shaders, since patches are required for tesselation, whereas triangles
## are required for regular rendering.
##
## If this option is set to true while not using a tesselation shader, the
## terrain will not get rendered, or even produce errors. The same applies
## when this is option is not set, but the terrain is used with tesselation
## shaders.
##
## @param generate_patches [description]

proc get_generate_patches*(this: ShaderTerrainMesh): bool {.importcpp: "#->get_generate_patches()".} ## \
## @brief Returns whether to generate patches
## @details This returns whether patches are generated, previously set with
## set_generate_patches()
##
## @return Whether to generate patches

proc set_update_enabled*(this: ShaderTerrainMesh, update_enabled: bool) {.importcpp: "#->set_update_enabled(#)".} ## \
## @brief Sets whether to enable terrain updates
## @details This flag controls whether the terrain should be updated. If this value
## is set to false, no updating of the terrain will happen. This can be useful
## to debug the culling algorithm used by the terrain.
##
## @param update_enabled Whether to update the terrain

proc get_update_enabled*(this: ShaderTerrainMesh): bool {.importcpp: "#->get_update_enabled()".} ## \
## @brief Returns whether the terrain is getting updated
## @details This returns whether the terrain is getting updates, previously set with
## set_update_enabled()
##
## @return Whether to update the terrain

proc set_target_triangle_width*(this: ShaderTerrainMesh, target_triangle_width: float32) {.importcpp: "#->set_target_triangle_width(#)".} ## \
## @brief Sets the desired triangle width
## @details This sets the desired width a triangle should have in pixels.
## A value of 10.0 for example will make the terrain tesselate everything
## in a way that each triangle edge roughly is 10 pixels wide.
## Of course this will not always accurately match, however you can use this
## setting to control the LOD algorithm of the terrain.
##
## @param target_triangle_width Desired triangle width in pixels

proc get_target_triangle_width*(this: ShaderTerrainMesh): float32 {.importcpp: "#->get_target_triangle_width()".} ## \
## @brief Returns the target triangle width
## @details This returns the target triangle width, previously set with
## ShaderTerrainMesh::set_target_triangle_width()
##
## @return Target triangle width

proc uv_to_world*(this: ShaderTerrainMesh, coord: LTexCoord): LPoint3 {.importcpp: "#->uv_to_world(#)".} ## \
## @brief Transforms a texture coordinate to world space
## @details This transforms a texture coordinatefrom uv-space (0 to 1) to world
## space. This takes the terrains transform into account, and also samples the
## heightmap. This method should be called after generate().
##
## @param coord Coordinate in uv-space from 0, 0 to 1, 1
## @return World-Space point

proc uv_to_world*(this: ShaderTerrainMesh, u: float32, v: float32): LPoint3 {.importcpp: "#->uv_to_world(#, #)".} ## \
## @see ShaderTerrainMesh::uv_to_world(LTexCoord)

proc generate*(this: ShaderTerrainMesh): bool {.importcpp: "#->generate()".} ## \
## @brief Generates the terrain mesh
## @details This generates the terrain mesh, initializing all chunks of the
## internal used quadtree. At this point, a heightfield and a chunk size should
## have been set, otherwise an error is thrown.
##
## If anything goes wrong, like a missing heightfield, then an error is printed
## and false is returned.
##
## @return true if the terrain was initialized, false if an error occured

proc get_class_type*(_: typedesc[ShaderTerrainMesh]): TypeHandle {.importcpp: "ShaderTerrainMesh::get_class_type()", header: "shaderTerrainMesh.h".}

proc newSceneGraphAnalyzerMeter*(param0: SceneGraphAnalyzerMeter): SceneGraphAnalyzerMeter {.importcpp: "new SceneGraphAnalyzerMeter(#)".}

proc newSceneGraphAnalyzerMeter*(name: string, node: PandaNode): SceneGraphAnalyzerMeter {.importcpp: "new SceneGraphAnalyzerMeter(nimStringToStdString(#), #)", header: stringConversionCode.}

proc setup_window*(this: SceneGraphAnalyzerMeter, window: GraphicsOutput) {.importcpp: "#->setup_window(#)".} ## \
## Sets up the frame rate meter to create a DisplayRegion to render itself
## into the indicated window.

proc clear_window*(this: SceneGraphAnalyzerMeter) {.importcpp: "#->clear_window()".} ## \
## Undoes the effect of a previous call to setup_window().

proc get_window*(this: SceneGraphAnalyzerMeter): GraphicsOutput {.importcpp: "#->get_window()".} ## \
## Returns the GraphicsOutput that was passed to setup_window(), or NULL if
## setup_window() has not been called.

proc get_display_region*(this: SceneGraphAnalyzerMeter): DisplayRegion {.importcpp: "#->get_display_region()".} ## \
## Returns the DisplayRegion that the meter has created to render itself into
## the window to setup_window(), or NULL if setup_window() has not been
## called.

proc set_update_interval*(this: SceneGraphAnalyzerMeter, update_interval: float64) {.importcpp: "#->set_update_interval(#)".} ## \
## Specifies the number of seconds that should elapse between updates to the
## meter.  This should be reasonably slow (e.g.  0.5 to 2.0) so that the
## calculation of the scene graph analysis does not itself dominate the frame
## rate.

proc get_update_interval*(this: SceneGraphAnalyzerMeter): float64 {.importcpp: "#->get_update_interval()".} ## \
## Returns the number of seconds that will elapse between updates to the frame
## rate indication.

proc set_node*(this: SceneGraphAnalyzerMeter, node: PandaNode) {.importcpp: "#->set_node(#)".} ## \
## Sets the node to be analyzed.

proc get_node*(this: SceneGraphAnalyzerMeter): PandaNode {.importcpp: "#->get_node()".} ## \
## Returns the node to be analyzed.

proc update*(this: SceneGraphAnalyzerMeter) {.importcpp: "#->update()".} ## \
## You can call this to explicitly force the SceneGraphAnalyzerMeter to update
## itself with the latest scene graph analysis information.  Normally, it is
## not necessary to call this explicitly.

proc get_class_type*(_: typedesc[SceneGraphAnalyzerMeter]): TypeHandle {.importcpp: "SceneGraphAnalyzerMeter::get_class_type()", header: "sceneGraphAnalyzerMeter.h".}

proc newRigidBodyCombiner*(name: string): RigidBodyCombiner {.importcpp: "new RigidBodyCombiner(nimStringToStdString(#))", header: stringConversionCode.}

proc collect*(this: RigidBodyCombiner) {.importcpp: "#->collect()".} ## \
## Walks through the entire subgraph of nodes rooted at this node, accumulates
## all of the RenderAttribs and Geoms below this node, flattening them into
## just one Geom (or as few as possible, if there are multiple different
## states).
##
## Nodes that have transforms on them at the time of collect(), or any
## ModelNodes with the preserve_transform flag, will be identified as "moving"
## nodes, and their transforms will be monitored as they change in future
## frames and each new transform directly applied to the vertices.
##
## This call must be made after adding any nodes to or removing any nodes from
## the subgraph rooted at this node.  It should not be made too often, as it
## is a relatively expensive call.  If you need to hide children of this node,
## consider scaling them to zero (or very near zero), or moving them behind
## the camera, instead.

proc get_internal_scene*(this: RigidBodyCombiner): NodePath {.importcpp: "#->get_internal_scene()".} ## \
## Returns a special NodePath that represents the internal node of this
## object.  This is the node that is actually sent to the graphics card for
## rendering; it contains the collection of the children of this node into as
## few Geoms as possible.
##
## This node is filled up by the last call to collect().

proc get_class_type*(_: typedesc[RigidBodyCombiner]): TypeHandle {.importcpp: "RigidBodyCombiner::get_class_type()", header: "rigidBodyCombiner.h".}

converter upcast_to_CullTraverser*(this: PipeOcclusionCullTraverser): CullTraverser {.importcpp: "(PT(CullTraverser)(#))".}

proc newPipeOcclusionCullTraverser*(host: GraphicsOutput): PipeOcclusionCullTraverser {.importcpp: "new PipeOcclusionCullTraverser(#)".}

proc set_scene*(this: PipeOcclusionCullTraverser, scene_setup: SceneSetup, gsg: GraphicsStateGuardianBase, dr_incomplete_render: bool) {.importcpp: "#->set_scene(#, #, #)".}

proc end_traverse*(this: PipeOcclusionCullTraverser) {.importcpp: "#->end_traverse()".} ## \
## Should be called when the traverser has finished traversing its scene, this
## gives it a chance to do any necessary finalization.

proc get_buffer*(this: PipeOcclusionCullTraverser): GraphicsOutput {.importcpp: "#->get_buffer()".}

proc get_texture*(this: PipeOcclusionCullTraverser): Texture {.importcpp: "#->get_texture()".} ## \
## Returns a Texture that can be used to visualize the efforts of the
## occlusion cull.

proc get_class_type*(_: typedesc[PipeOcclusionCullTraverser]): TypeHandle {.importcpp: "PipeOcclusionCullTraverser::get_class_type()", header: "pipeOcclusionCullTraverser.h".}

proc initPfmVizzer*(pfm: PfmFile): PfmVizzer {.importcpp: "PfmVizzer(#)".} ## \
## The PfmVizzer constructor receives a reference to a PfmFile which it will
## operate on.  It does not keep ownership of this reference; it is your
## responsibility to ensure the PfmFile does not destruct during the lifetime
## of the PfmVizzer.

proc initPfmVizzer*(param0: PfmVizzer): PfmVizzer {.importcpp: "PfmVizzer(#)".}

proc get_pfm*(this: PfmVizzer): PfmFile {.importcpp: "#.get_pfm()".} ## \
## Returns the reference to the PfmFile manipulated by this PfmVizzer.

proc project*(this: PfmVizzer, lens: Lens, undist_lut: PfmFile) {.importcpp: "#.project(#, #)".} ## \
## Adjusts each (x, y, z) point of the Pfm file by projecting it through the
## indicated lens, converting each point to a (u, v, w) texture coordinate.
## The resulting file can be generated to a mesh (with set_vis_inverse(true)
## and generate_vis_mesh()) that will apply the lens distortion to an
## arbitrary texture image.

proc project*(this: PfmVizzer, lens: Lens) {.importcpp: "#.project(#)".} ## \
## Adjusts each (x, y, z) point of the Pfm file by projecting it through the
## indicated lens, converting each point to a (u, v, w) texture coordinate.
## The resulting file can be generated to a mesh (with set_vis_inverse(true)
## and generate_vis_mesh()) that will apply the lens distortion to an
## arbitrary texture image.

proc extrude*(this: PfmVizzer, lens: Lens) {.importcpp: "#.extrude(#)".} ## \
## Converts each (u, v, depth) point of the Pfm file to an (x, y, z) point, by
## reversing project().  If the original file is only a 1-d file, assumes that
## it is a depth map with implicit (u, v) coordinates.
##
## This method is only valid for a linear lens (e.g.  a PerspectiveLens or
## OrthographicLens).  Non-linear lenses don't necessarily compute a sensible
## depth coordinate.

proc set_vis_inverse*(this: PfmVizzer, vis_inverse: bool) {.importcpp: "#.set_vis_inverse(#)".} ## \
## Sets the vis_inverse flag.  When this flag is true, vis meshes and point
## clouds are generated with the 3-d depth value in the texture coordinates,
## and the 2-d index value in the vertex position.  When it is false, meshes
## are generated normally, with the 3-d depth value in the vertex position and
## the 2-d index value in the texture coordinates.
##
## This may be used in lieu of the lower-level add_vis_column().

proc get_vis_inverse*(this: PfmVizzer): bool {.importcpp: "#.get_vis_inverse()".} ## \
## Returns the vis_inverse flag.  See set_vis_inverse().

proc set_flat_texcoord_name*(this: PfmVizzer, flat_texcoord_name: InternalName) {.importcpp: "#.set_flat_texcoord_name(#)".} ## \
## If the flat_texcoord_name is specified, it is the name of an additional
## vertex column that will be created for the "flat" texture coordinates, i.e.
## the original 0..1 values that correspond to the 2-D index position of each
## point in the original pfm file.
##
## These are the same values that will be assigned to the default texture
## coordinates if the vis_inverse flag is *not* true.
##
## This may be used in lieu of the lower-level add_vis_column().

proc clear_flat_texcoord_name*(this: PfmVizzer) {.importcpp: "#.clear_flat_texcoord_name()".} ## \
## Resets the flat_texcoord_name to empty, so that additional texture
## coordinates are not created.
##
## This may be used in lieu of the lower-level add_vis_column().

proc get_flat_texcoord_name*(this: PfmVizzer): InternalName {.importcpp: "#.get_flat_texcoord_name()".} ## \
## Returns the flat_texcoord_name.  See set_flat_texcoord_name().

proc set_vis_2d*(this: PfmVizzer, vis_2d: bool) {.importcpp: "#.set_vis_2d(#)".} ## \
## Sets the vis_2d flag.  When this flag is true, only the first two (x, y)
## value of each depth point is considered meaningful; the z component is
## ignored.  This is only relevant for generating visualizations.
##
## This may be used in lieu of the lower-level add_vis_column().

proc get_vis_2d*(this: PfmVizzer): bool {.importcpp: "#.get_vis_2d()".} ## \
## Returns the vis_2d flag.  See set_vis_2d().

proc set_keep_beyond_lens*(this: PfmVizzer, keep_beyond_lens: bool) {.importcpp: "#.set_keep_beyond_lens(#)".} ## \
## Sets the keep_beyond_lens flag.  When this flag is true, points that fall
## outside of the normal lens range in project() or in add_vis_column() will
## be retained anyway; when it is false, these points will be discarded.

proc get_keep_beyond_lens*(this: PfmVizzer): bool {.importcpp: "#.get_keep_beyond_lens()".} ## \
## Returns the keep_beyond_lens flag.  See set_keep_beyond_lens().

proc set_vis_blend*(this: PfmVizzer, vis_blend: PNMImage) {.importcpp: "#.set_vis_blend(#)".} ## \
## Specifies a blending map--a grayscale image--that will be applied to the
## vertex color during generate_vis_mesh() and generate_vis_points().  The
## image size must exactly match the mesh size of the PfmVizzer.
##
## Ownership of the pointer is not kept by the PfmVizzer; it is your
## responsibility to ensure it does not destruct during the lifetime of the
## PfmVizzer (or at least not before your subsequent call to
## generate_vis_mesh()).

proc clear_vis_blend*(this: PfmVizzer) {.importcpp: "#.clear_vis_blend()".} ## \
## Removes the blending map set by a prior call to set_vis_blend().

proc get_vis_blend*(this: PfmVizzer): PNMImage {.importcpp: "#.get_vis_blend()".} ## \
## Returns the blending map set by the most recent call to set_vis_blend(), or
## NULL if there is no blending map in effect.

proc set_aux_pfm*(this: PfmVizzer, pfm: PfmFile) {.importcpp: "#.set_aux_pfm(#)".} ## \
## Assigns an auxiliary PfmFile to this PfmVizzer.  This file will be queried
## by column types CT_aux_vertex1/2/3, but has no other meaning to the vizzer.
## This size of this PfmFile should exactly match the base PfmFile.  No
## reference count is held and no copy is made; the caller is responsible for
## ensuring that the auxiliary PfmFile will persist throughout the lifetime of
## the PfmVizzer it is assigned to.

proc clear_aux_pfm*(this: PfmVizzer) {.importcpp: "#.clear_aux_pfm()".} ## \
## Removes the auxiliary PfmFile from this PfmVizzer.

proc get_aux_pfm*(this: PfmVizzer): PfmFile {.importcpp: "#.get_aux_pfm()".} ## \
## Returns the reference to the auxiliary PfmFile queried by this PfmVizzer.
## This contains the values that will be reflected in CT_aux_vertex3 etc.  See
## set_aux_pfm().

proc clear_vis_columns*(this: PfmVizzer) {.importcpp: "#.clear_vis_columns()".} ## \
## Removes all of the previously-added vis columns in preparation for building
## a new list.  See add_vis_column().

proc generate_vis_points*(this: PfmVizzer): NodePath {.importcpp: "#.generate_vis_points()".} ## \
## Creates a point cloud with the points of the pfm as 3-d coordinates in
## space, and texture coordinates ranging from 0 .. 1 based on the position
## within the pfm grid.

proc generate_vis_mesh*(this: PfmVizzer): NodePath {.importcpp: "#.generate_vis_mesh()".} ## \
## Creates a triangle mesh with the points of the pfm as 3-d coordinates in
## space, and texture coordinates ranging from 0 .. 1 based on the position
## within the pfm grid.

proc calc_max_u_displacement*(this: PfmVizzer): float64 {.importcpp: "#.calc_max_u_displacement()".} ## \
## Computes the maximum amount of shift, in pixels either left or right, of
## any pixel in the distortion map.  This can be passed to
## make_displacement(); see that function for more information.

proc calc_max_v_displacement*(this: PfmVizzer): float64 {.importcpp: "#.calc_max_v_displacement()".} ## \
## Computes the maximum amount of shift, in pixels either up or down, of any
## pixel in the distortion map.  This can be passed to make_displacement();
## see that function for more information.

proc make_displacement*(this: PfmVizzer, result: PNMImage, max_u: float64, max_v: float64, for_32bit: bool) {.importcpp: "#.make_displacement(#, #, #, #)".} ## \
## Assuming the underlying PfmFile is a 2-d distortion mesh, with the U and V
## in the first two components and the third component unused, this computes
## an AfterEffects-style displacement map that represents the same distortion.
## The indicated PNMImage will be filled in with a displacement map image,
## with horizontal shift in the red channel and vertical shift in the green
## channel, where a fully bright (or fully black) pixel indicates a shift of
## max_u or max_v pixels.
##
## Use calc_max_u_displacement() and calc_max_v_displacement() to compute
## suitable values for max_u and max_v.
##
## This generates an integer 16-bit displacement image.  It is a good idea,
## though not necessarily essential, to check "Preserve RGB" in the interpret
## footage section for each displacement image.  Set for_32bit true if this is
## meant to be used in a 32-bit project file, and false if it is meant to be
## used in a 16-bit project file.

proc make_displacement*(this: PfmVizzer, result: PfmFile, max_u: float64, max_v: float64, for_32bit: bool) {.importcpp: "#.make_displacement(#, #, #, #)".} ## \
## Assuming the underlying PfmFile is a 2-d distortion mesh, with the U and V
## in the first two components and the third component unused, this computes
## an AfterEffects-style displacement map that represents the same distortion.
## The indicated PNMImage will be filled in with a displacement map image,
## with horizontal shift in the red channel and vertical shift in the green
## channel, where a fully bright (or fully black) pixel indicates a shift of
## max_u or max_v pixels.
##
## Use calc_max_u_displacement() and calc_max_v_displacement() to compute
## suitable values for max_u and max_v.
##
## This generates a 32-bit floating-point displacement image.  It is essential
## to check "Preserve RGB" in the interpret footage section for each
## displacement image.  Set for_32bit true if this is meant to be used in a
## 32-bit project file, and false if it is meant to be used in a 16-bit
## project file.

converter upcast_to_TypedWritableReferenceCount*(this: AnimGroup): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcast_to_Namable*(this: AnimGroup): Namable {.importcpp: "((Namable *)(#.p()))".}

proc newAnimGroup*(parent: AnimGroup, name: string): AnimGroup {.importcpp: "new AnimGroup(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates the AnimGroup, and adds it to the indicated parent.  The only way
## to delete it subsequently is to delete the entire hierarchy.

proc newAnimGroup*(param0: AnimGroup): AnimGroup {.importcpp: "new AnimGroup(#)".}

proc get_num_children*(this: AnimGroup): int {.importcpp: "#->get_num_children()".} ## \
## Returns the number of child nodes of the group.

proc get_child*(this: AnimGroup, n: int): AnimGroup {.importcpp: "#->get_child(#)".} ## \
## Returns the nth child of the group.

proc get_child_named*(this: AnimGroup, name: string): AnimGroup {.importcpp: "#->get_child_named(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the first child found with the indicated name, or NULL if no such
## child exists.  This method searches only the children of this particular
## AnimGroup; it does not recursively search the entire graph.  See also
## find_child().

proc find_child*(this: AnimGroup, name: string): AnimGroup {.importcpp: "#->find_child(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the first descendant found with the indicated name, or NULL if no
## such descendant exists.  This method searches the entire graph beginning at
## this AnimGroup; see also get_child_named().

proc sort_descendants*(this: AnimGroup) {.importcpp: "#->sort_descendants()".} ## \
## Sorts the children nodes at each level of the hierarchy into alphabetical
## order.  This should be done after creating the hierarchy, to guarantee that
## the correct names will match up together when the AnimBundle is later bound
## to a PlayerRoot.

proc output*(this: AnimGroup, `out`: ostream) {.importcpp: "#->output(#)".} ## \
## Writes a one-line description of the group.

proc write*(this: AnimGroup, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".} ## \
## Writes a brief description of the group and all of its descendants.

proc get_class_type*(_: typedesc[AnimGroup]): TypeHandle {.importcpp: "AnimGroup::get_class_type()", header: "animGroup.h".}

proc newAnimBundle*(param0: AnimBundle): AnimBundle {.importcpp: "new AnimBundle(#)".}

proc newAnimBundle*(name: string, fps: float32, num_frames: int): AnimBundle {.importcpp: "new AnimBundle(nimStringToStdString(#), #, #)", header: stringConversionCode.}

proc copy_bundle*(this: AnimBundle): AnimBundle {.importcpp: "#->copy_bundle()".} ## \
## Returns a full copy of the bundle and its entire tree of nested AnimGroups.
## However, the actual data stored in the leaves--that is, animation tables,
## such as those stored in an AnimChannelMatrixXfmTable--will be shared.

proc get_base_frame_rate*(this: AnimBundle): float64 {.importcpp: "#->get_base_frame_rate()".} ## \
## Returns the ideal number of frames per second of the animation, when it is
## running at normal speed.  This may not be the same as the actual playing
## frame rate, as it might have been adjusted through set_play_rate() on the
## AnimControl object.  See AnimControl::get_effective_frame_rate().

proc get_num_frames*(this: AnimBundle): int {.importcpp: "#->get_num_frames()".} ## \
## Returns the number of frames of animation, or 0 if the animation has no
## fixed number of frames.

proc get_class_type*(_: typedesc[AnimBundle]): TypeHandle {.importcpp: "AnimBundle::get_class_type()", header: "animBundle.h".}

proc newAnimBundleNode*(name: string, bundle: AnimBundle): AnimBundleNode {.importcpp: "new AnimBundleNode(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## The AnimBundle and its node should be constructed together.  Generally, the
## derived classes of AnimBundleNode will automatically create a AnimBundle of
## the appropriate type, and pass it up to this constructor.

proc get_bundle*(this: AnimBundleNode): AnimBundle {.importcpp: "#->get_bundle()".}

proc find_anim_bundle*(_: typedesc[AnimBundleNode], root: PandaNode): AnimBundle {.importcpp: "AnimBundleNode::find_anim_bundle(#)", header: "animBundleNode.h".} ## \
## Recursively walks the scene graph beginning at the indicated node (which
## need not be an AnimBundleNode), and returns the first AnimBundle found.
## Returns NULL if no AnimBundle can be found.

proc get_class_type*(_: typedesc[AnimBundleNode]): TypeHandle {.importcpp: "AnimBundleNode::get_class_type()", header: "animBundleNode.h".}

converter upcast_to_TypedWritableReferenceCount*(this: PartGroup): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcast_to_Namable*(this: PartGroup): Namable {.importcpp: "((Namable *)(#.p()))".}

proc newPartGroup*(parent: PartGroup, name: string): PartGroup {.importcpp: "new PartGroup(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates the PartGroup, and adds it to the indicated parent.  The only way
## to delete it subsequently is to delete the entire hierarchy.

proc is_character_joint*(this: PartGroup): bool {.importcpp: "#->is_character_joint()".} ## \
## Returns true if this part is a CharacterJoint, false otherwise.  This is a
## tiny optimization over is_of_type(CharacterType::get_class_type()).

proc make_copy*(this: PartGroup): PartGroup {.importcpp: "#->make_copy()".} ## \
## Allocates and returns a new copy of the node.  Children are not copied, but
## see copy_subgraph().

proc copy_subgraph*(this: PartGroup): PartGroup {.importcpp: "#->copy_subgraph()".} ## \
## Allocates and returns a new copy of this node and of all of its children.

proc get_num_children*(this: PartGroup): int {.importcpp: "#->get_num_children()".} ## \
## Returns the number of child nodes of the group.

proc get_child*(this: PartGroup, n: int): PartGroup {.importcpp: "#->get_child(#)".} ## \
## Returns the nth child of the group.

proc get_child_named*(this: PartGroup, name: string): PartGroup {.importcpp: "#->get_child_named(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the first child found with the indicated name, or NULL if no such
## child exists.  This method searches only the children of this particular
## PartGroup; it does not recursively search the entire graph.  See also
## find_child().

proc find_child*(this: PartGroup, name: string): PartGroup {.importcpp: "#->find_child(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the first descendant found with the indicated name, or NULL if no
## such descendant exists.  This method searches the entire graph beginning at
## this PartGroup; see also get_child_named().

proc sort_descendants*(this: PartGroup) {.importcpp: "#->sort_descendants()".} ## \
## Sorts the children nodes at each level of the hierarchy into alphabetical
## order.  This should be done after creating the hierarchy, to guarantee that
## the correct names will match up together when the AnimBundle is later bound
## to a PlayerRoot.

proc apply_freeze*(this: PartGroup, transform: TransformState): bool {.importcpp: "#->apply_freeze(#)".} ## \
## Freezes this particular joint so that it will always hold the specified
## transform.  Returns true if this is a joint that can be so frozen, false
## otherwise.
##
## This is normally only called internally by PartBundle::freeze_joint(), but
## you may also call it directly.

proc apply_freeze_matrix*(this: PartGroup, pos: LVecBase3, hpr: LVecBase3, scale: LVecBase3): bool {.importcpp: "#->apply_freeze_matrix(#, #, #)".} ## \
## Freezes this particular joint so that it will always hold the specified
## transform.  Returns true if this is a joint that can be so frozen, false
## otherwise.
##
## This is normally only called internally by PartBundle::freeze_joint(), but
## you may also call it directly.

proc apply_freeze_scalar*(this: PartGroup, value: float32): bool {.importcpp: "#->apply_freeze_scalar(#)".} ## \
## Freezes this particular joint so that it will always hold the specified
## transform.  Returns true if this is a joint that can be so frozen, false
## otherwise.
##
## This is normally only called internally by PartBundle::freeze_joint(), but
## you may also call it directly.

proc apply_control*(this: PartGroup, node: PandaNode): bool {.importcpp: "#->apply_control(#)".} ## \
## Specifies a node to influence this particular joint so that it will always
## hold the node's transform.  Returns true if this is a joint that can be so
## controlled, false otherwise.
##
## This is normally only called internally by PartBundle::control_joint(), but
## you may also call it directly.

proc clear_forced_channel*(this: PartGroup): bool {.importcpp: "#->clear_forced_channel()".} ## \
## Undoes the effect of a previous call to apply_freeze() or apply_control().
## Returns true if the joint was modified, false otherwise.
##
## This is normally only called internally by PartBundle::release_joint(), but
## you may also call it directly.

proc get_forced_channel*(this: PartGroup): AnimChannelBase {.importcpp: "#->get_forced_channel()".} ## \
## Returns the AnimChannelBase that has been forced to this joint by a
## previous call to apply_freeze() or apply_control(), or NULL if no such
## channel has been applied.

proc write*(this: PartGroup, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".} ## \
## Writes a brief description of the group and all of its descendants.

proc write_with_value*(this: PartGroup, `out`: ostream, indent_level: int) {.importcpp: "#->write_with_value(#, #)".} ## \
## Writes a brief description of the group, showing its current value, and
## that of all of its descendants.

proc get_class_type*(_: typedesc[PartGroup]): TypeHandle {.importcpp: "PartGroup::get_class_type()", header: "partGroup.h".}

converter upcast_to_TypedReferenceCount*(this: AnimControl): TypedReferenceCount {.importcpp: "(PT(TypedReferenceCount)(#))".}

converter upcast_to_AnimInterface*(this: AnimControl): AnimInterface {.importcpp: "((AnimInterface *)(#.p()))".}

converter upcast_to_Namable*(this: AnimControl): Namable {.importcpp: "((Namable *)(#.p()))".}

proc is_pending*(this: AnimControl): bool {.importcpp: "#->is_pending()".} ## \
## Returns true if the AnimControl is being bound asynchronously, and has not
## yet finished.  If this is true, the AnimControl's interface is still
## available and will be perfectly useful (though get_anim() might return
## NULL), but nothing visible will happen immediately.

proc wait_pending*(this: AnimControl) {.importcpp: "#->wait_pending()".} ## \
## Blocks the current thread until the AnimControl has finished loading and is
## fully bound.

proc has_anim*(this: AnimControl): bool {.importcpp: "#->has_anim()".} ## \
## Returns true if the AnimControl was successfully loaded, or false if there
## was a problem.  This may return false while is_pending() is true.

proc set_pending_done_event*(this: AnimControl, done_event: string) {.importcpp: "#->set_pending_done_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies an event name that will be thrown when the AnimControl is
## finished binding asynchronously.  If the AnimControl has already finished
## binding, the event will be thrown immediately.

proc get_pending_done_event*(this: AnimControl): string {.importcpp: "nimStringFromStdString(#->get_pending_done_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the AnimControl is finished
## binding asynchronously.

proc get_part*(this: AnimControl): PartBundle {.importcpp: "#->get_part()".} ## \
## Returns the PartBundle bound in with this AnimControl.

proc get_anim*(this: AnimControl): AnimBundle {.importcpp: "#->get_anim()".} ## \
## Returns the AnimBundle bound in with this AnimControl.

proc get_channel_index*(this: AnimControl): int {.importcpp: "#->get_channel_index()".} ## \
## Returns the particular channel index associated with this AnimControl.
## This channel index is the slot on which each AnimGroup is bound to its
## associated PartGroup, for each joint in the animation.
##
## It will be true that
## get_part()->find_child("n")->get_bound(get_channel_index()) ==
## get_anim()->find_child("n"), for each joint "n".

proc get_bound_joints*(this: AnimControl): BitArray {.importcpp: "#->get_bound_joints()".} ## \
## Returns the subset of joints controlled by this AnimControl.  Most of the
## time, this will be BitArray::all_on(), for a normal full-body animation.
## For a subset animation, however, this will be just a subset of those bits,
## corresponding to the set of joints and sliders actually bound (as
## enumerated by bind_hierarchy() in depth-first LIFO order).

proc set_anim_model*(this: AnimControl, model: PandaNode) {.importcpp: "#->set_anim_model(#)".} ## \
## Associates the indicated PandaNode with the AnimControl.  By convention,
## this node represents the root node of the model file that corresponds to
## this AnimControl's animation file, though nothing in this code makes this
## assumption or indeed does anything with this node.
##
## The purpose of this is simply to allow the AnimControl to keep a reference
## count on the ModelRoot node that generated it, so that the model will not
## disappear from the model pool until it is no longer referenced.

proc get_anim_model*(this: AnimControl): PandaNode {.importcpp: "#->get_anim_model()".} ## \
## Retrieves the pointer set via set_anim_model().  See set_anim_model().

proc output*(this: AnimControl, `out`: ostream) {.importcpp: "#->output(#)".}

proc get_class_type*(_: typedesc[AnimControl]): TypeHandle {.importcpp: "AnimControl::get_class_type()", header: "animControl.h".}

proc get_type*(this: AnimChannelBase): TypeHandle {.importcpp: "#->get_type()".}

proc get_class_type*(_: typedesc[AnimChannelBase]): TypeHandle {.importcpp: "AnimChannelBase::get_class_type()", header: "animChannelBase.h".}

proc set_value*(this: AnimChannelMatrixDynamic, value: LMatrix4) {.importcpp: "#->set_value(#)".} ## \
## Explicitly sets the matrix value.

proc set_value*(this: AnimChannelMatrixDynamic, value: TransformState) {.importcpp: "#->set_value(#)".} ## \
## Explicitly sets the matrix value, using the indicated TransformState object
## as a convenience.

proc set_value_node*(this: AnimChannelMatrixDynamic, node: PandaNode) {.importcpp: "#->set_value_node(#)".} ## \
## Specifies a node whose transform will be queried each frame to implicitly
## specify the transform of this joint.

proc get_value_transform*(this: AnimChannelMatrixDynamic): TransformState {.importcpp: "#->get_value_transform()".} ## \
## Returns the explicit TransformState value that was set via set_value(), if
## any.

proc get_value_node*(this: AnimChannelMatrixDynamic): PandaNode {.importcpp: "#->get_value_node()".} ## \
## Returns the node that was set via set_value_node(), if any.

proc get_class_type*(_: typedesc[AnimChannelMatrixDynamic]): TypeHandle {.importcpp: "AnimChannelMatrixDynamic::get_class_type()", header: "animChannelMatrixDynamic.h".}

proc newAnimChannelMatrixXfmTable*(parent: AnimGroup, name: string): AnimChannelMatrixXfmTable {.importcpp: "new AnimChannelMatrixXfmTable(#, nimStringToStdString(#))", header: stringConversionCode.}

proc is_valid_id*(_: typedesc[AnimChannelMatrixXfmTable], table_id: char): bool {.importcpp: "AnimChannelMatrixXfmTable::is_valid_id(#)", header: "animChannelMatrixXfmTable.h".} ## \
## Returns true if the given letter is one of the nine valid table id's.

proc clear_all_tables*(this: AnimChannelMatrixXfmTable) {.importcpp: "#->clear_all_tables()".} ## \
## Removes all the tables from the channel, and resets it to its initial
## state.

proc has_table*(this: AnimChannelMatrixXfmTable, table_id: char): bool {.importcpp: "#->has_table(#)".} ## \
## Returns true if the indicated subtable has been assigned.

proc clear_table*(this: AnimChannelMatrixXfmTable, table_id: char) {.importcpp: "#->clear_table(#)".} ## \
## Removes the indicated table from the definition.

proc get_class_type*(_: typedesc[AnimChannelMatrixXfmTable]): TypeHandle {.importcpp: "AnimChannelMatrixXfmTable::get_class_type()", header: "animChannelMatrixXfmTable.h".}

proc set_value*(this: AnimChannelScalarDynamic, value: float32) {.importcpp: "#->set_value(#)".} ## \
## Explicitly sets the value.  This will remove any node assigned via
## set_value_node().

proc set_value_node*(this: AnimChannelScalarDynamic, node: PandaNode) {.importcpp: "#->set_value_node(#)".} ## \
## Specifies a node whose transform will be queried each frame to implicitly
## specify the transform of this joint.  This will override the values set by
## set_value().

proc get_class_type*(_: typedesc[AnimChannelScalarDynamic]): TypeHandle {.importcpp: "AnimChannelScalarDynamic::get_class_type()", header: "animChannelScalarDynamic.h".}

proc newAnimChannelScalarTable*(parent: AnimGroup, name: string): AnimChannelScalarTable {.importcpp: "new AnimChannelScalarTable(#, nimStringToStdString(#))", header: stringConversionCode.}

proc has_table*(this: AnimChannelScalarTable): bool {.importcpp: "#->has_table()".} ## \
## Returns true if the data table has been assigned.

proc clear_table*(this: AnimChannelScalarTable) {.importcpp: "#->clear_table()".} ## \
## Empties the data table.

proc get_class_type*(_: typedesc[AnimChannelScalarTable]): TypeHandle {.importcpp: "AnimChannelScalarTable::get_class_type()", header: "animChannelScalarTable.h".}

proc initAnimControlCollection*(): AnimControlCollection {.importcpp: "AnimControlCollection()".} ## \
## Returns the AnimControl associated with the given name, or NULL if no such
## control has been associated.

proc initAnimControlCollection*(param0: AnimControlCollection): AnimControlCollection {.importcpp: "AnimControlCollection(#)".}

proc store_anim*(this: AnimControlCollection, control: AnimControl, name: string) {.importcpp: "#.store_anim(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Associates the given AnimControl with this collection under the given name.
## The AnimControl will remain associated until a new AnimControl is
## associated with the same name later, or until unbind_anim() is called with
## this name.

proc find_anim*(this: AnimControlCollection, name: string): AnimControl {.importcpp: "#.find_anim(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the AnimControl associated with the given name, or NULL if no such
## control has been associated.

proc unbind_anim*(this: AnimControlCollection, name: string): bool {.importcpp: "#.unbind_anim(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the AnimControl associated with the given name, if any.  Returns
## true if an AnimControl was removed, false if there was no AnimControl with
## the indicated name.

proc get_num_anims*(this: AnimControlCollection): int {.importcpp: "#.get_num_anims()".} ## \
## Returns the number of AnimControls associated with this collection.

proc get_anim*(this: AnimControlCollection, n: int): AnimControl {.importcpp: "#.get_anim(#)".} ## \
## Returns the nth AnimControl associated with this collection.

proc get_anim_name*(this: AnimControlCollection, n: int): string {.importcpp: "nimStringFromStdString(#.get_anim_name(#))", header: stringConversionCode.} ## \
## Returns the name of the nth AnimControl associated with this collection.

proc clear_anims*(this: AnimControlCollection) {.importcpp: "#.clear_anims()".} ## \
## Disassociates all anims from this collection.

proc play*(this: AnimControlCollection, anim_name: string): bool {.importcpp: "#.play(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Starts the named animation playing.

proc play*(this: AnimControlCollection, anim_name: string, `from`: float64, to: float64): bool {.importcpp: "#.play(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Starts the named animation playing.

proc loop*(this: AnimControlCollection, anim_name: string, restart: bool): bool {.importcpp: "#.loop(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Starts the named animation looping.

proc loop*(this: AnimControlCollection, anim_name: string, restart: bool, `from`: float64, to: float64): bool {.importcpp: "#.loop(nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Starts the named animation looping.

proc stop*(this: AnimControlCollection, anim_name: string): bool {.importcpp: "#.stop(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Stops the named animation.

proc pose*(this: AnimControlCollection, anim_name: string, frame: float64): bool {.importcpp: "#.pose(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Sets to a particular frame in the named animation.

proc play_all*(this: AnimControlCollection) {.importcpp: "#.play_all()".} ## \
## These functions operate on all anims at once.

proc play_all*(this: AnimControlCollection, `from`: float64, to: float64) {.importcpp: "#.play_all(#, #)".} ## \
## Starts all animations playing.

proc loop_all*(this: AnimControlCollection, restart: bool) {.importcpp: "#.loop_all(#)".} ## \
## Starts all animations looping.

proc loop_all*(this: AnimControlCollection, restart: bool, `from`: float64, to: float64) {.importcpp: "#.loop_all(#, #, #)".} ## \
## Starts all animations looping.

proc stop_all*(this: AnimControlCollection): bool {.importcpp: "#.stop_all()".} ## \
## Stops all currently playing animations.  Returns true if any animations
## were stopped, false if none were playing.

proc pose_all*(this: AnimControlCollection, frame: float64) {.importcpp: "#.pose_all(#)".} ## \
## Sets all animations to the indicated frame.

proc get_frame*(this: AnimControlCollection): int {.importcpp: "#.get_frame()".} ## \
## Returns the current frame in the last-started animation.

proc get_frame*(this: AnimControlCollection, anim_name: string): int {.importcpp: "#.get_frame(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the current frame in the named animation, or 0 if the animation is
## not found.

proc get_num_frames*(this: AnimControlCollection): int {.importcpp: "#.get_num_frames()".} ## \
## Returns the total number of frames in the last-started animation.

proc get_num_frames*(this: AnimControlCollection, anim_name: string): int {.importcpp: "#.get_num_frames(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the total number of frames in the named animation, or 0 if the
## animation is not found.

proc is_playing*(this: AnimControlCollection): bool {.importcpp: "#.is_playing()".} ## \
## Returns true if the last-started animation is currently playing, false
## otherwise.

proc is_playing*(this: AnimControlCollection, anim_name: string): bool {.importcpp: "#.is_playing(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if the named animation is currently playing, false otherwise.

proc which_anim_playing*(this: AnimControlCollection): string {.importcpp: "nimStringFromStdString(#.which_anim_playing())", header: stringConversionCode.} ## \
## Returns the name of the bound AnimControl currently playing, if any.  If
## more than one AnimControl is currently playing, returns all of the names
## separated by spaces.

proc output*(this: AnimControlCollection, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: AnimControlCollection, `out`: ostream) {.importcpp: "#.write(#)".}

proc newAnimPreloadTable*(): AnimPreloadTable {.importcpp: "new AnimPreloadTable()".}

proc get_num_anims*(this: AnimPreloadTable): int {.importcpp: "#->get_num_anims()".} ## \
## Returns the number of animation records in the table.

proc find_anim*(this: AnimPreloadTable, basename: string): int {.importcpp: "#->find_anim(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the index number in the table of the animation record with the
## indicated name, or -1 if the name is not present.  By convention, the
## basename is the filename of the egg or bam file, without the directory part
## and without the extension.  That is, it is
## Filename::get_basename_wo_extension().

proc get_basename*(this: AnimPreloadTable, n: int): string {.importcpp: "nimStringFromStdString(#->get_basename(#))", header: stringConversionCode.} ## \
## Returns the basename stored for the nth animation record.  See find_anim().

proc get_base_frame_rate*(this: AnimPreloadTable, n: int): float32 {.importcpp: "#->get_base_frame_rate(#)".} ## \
## Returns the frame rate stored for the nth animation record.

proc get_num_frames*(this: AnimPreloadTable, n: int): int {.importcpp: "#->get_num_frames(#)".} ## \
## Returns the number of frames stored for the nth animation record.

proc clear_anims*(this: AnimPreloadTable) {.importcpp: "#->clear_anims()".} ## \
## Removes all animation records from the table.

proc remove_anim*(this: AnimPreloadTable, n: int) {.importcpp: "#->remove_anim(#)".} ## \
## Removes the nth animation records from the table.  This renumbers indexes
## for following animations.

proc add_anim*(this: AnimPreloadTable, basename: string, base_frame_rate: float32, num_frames: int) {.importcpp: "#->add_anim(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Adds a new animation record to the table.  If there is already a record of
## this name, no operation is performed (the original record is unchanged).
## See find_anim().  This will invalidate existing index numbers.

proc add_anims_from*(this: AnimPreloadTable, other: AnimPreloadTable) {.importcpp: "#->add_anims_from(#)".} ## \
## Copies the animation records from the other table into this one.  If a
## given record name exists in both tables, the record in this one supercedes.

proc output*(this: AnimPreloadTable, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: AnimPreloadTable, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc get_class_type*(_: typedesc[AnimPreloadTable]): TypeHandle {.importcpp: "AnimPreloadTable::get_class_type()", header: "animPreloadTable.h".}

proc auto_bind*(root_node: PandaNode, controls: AnimControlCollection, hierarchy_match_flags: int) {.importcpp: "auto_bind(#, #, #)".}

proc auto_bind*(root_node: PandaNode, controls: AnimControlCollection) {.importcpp: "auto_bind(#, #)".}

proc initPartSubset*(): PartSubset {.importcpp: "PartSubset()".}

proc initPartSubset*(copy: PartSubset): PartSubset {.importcpp: "PartSubset(#)".}

proc add_include_joint*(this: PartSubset, name: GlobPattern) {.importcpp: "#.add_include_joint(#)".} ## \
## Adds the named joint to the list of joints that will be explicitly included
## in the subset.  Any joint at or below a named node will be included in the
## subset (unless a lower node is also listed in the exclude list).
##
## Since the name is a GlobPattern, it may of course include filename globbing
## characters like * and ?.

proc add_exclude_joint*(this: PartSubset, name: GlobPattern) {.importcpp: "#.add_exclude_joint(#)".} ## \
## Adds the named joint to the list of joints that will be explicitly
## exlcluded from the subset.  Any joint at or below a named node will not be
## included in the subset (unless a lower node is also listed in the include
## list).
##
## Since the name is a GlobPattern, it may of course include filename globbing
## characters like * and ?.

proc append*(this: PartSubset, other: PartSubset) {.importcpp: "#.append(#)".} ## \
## Appends the include and exclude list from the other object onto this
## object's lists.

proc output*(this: PartSubset, `out`: ostream) {.importcpp: "#.output(#)".}

proc is_include_empty*(this: PartSubset): bool {.importcpp: "#.is_include_empty()".} ## \
## Returns true if the include list is completely empty, false otherwise.  If
## it is empty, it is the same thing as including all joints.

proc matches_include*(this: PartSubset, joint_name: string): bool {.importcpp: "#.matches_include(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if the indicated name matches a name on the include list,
## false otherwise.

proc matches_exclude*(this: PartSubset, joint_name: string): bool {.importcpp: "#.matches_exclude(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if the indicated name matches a name on the exclude list,
## false otherwise.

proc newBindAnimRequest*(param0: BindAnimRequest): BindAnimRequest {.importcpp: "new BindAnimRequest(#)".}

proc newBindAnimRequest*(name: string, filename: Filename, options: LoaderOptions, loader: Loader, control: AnimControl, hierarchy_match_flags: int, subset: PartSubset): BindAnimRequest {.importcpp: "new BindAnimRequest(nimStringToStdString(#), #, #, #, #, #, #)", header: stringConversionCode.}

proc get_class_type*(_: typedesc[BindAnimRequest]): TypeHandle {.importcpp: "BindAnimRequest::get_class_type()", header: "bindAnimRequest.h".}

proc newPartBundle*(name: string): PartBundle {.importcpp: "new PartBundle(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Normally, a PartBundle constructor should not be called directly--it will
## get created when a PartBundleNode is created.

proc newPartBundle*(): PartBundle {.importcpp: "new PartBundle()".} ## \
## Normally, a PartBundle constructor should not be called directly--it will
## get created when a PartBundleNode is created.

proc get_anim_preload*(this: PartBundle): AnimPreloadTable {.importcpp: "#->get_anim_preload()".} ## \
## Returns the AnimPreloadTable associated with the PartBundle.  This table,
## if present, can be used for the benefit of load_bind_anim() to allow
## asynchronous binding.

proc modify_anim_preload*(this: PartBundle): AnimPreloadTable {.importcpp: "#->modify_anim_preload()".} ## \
## Returns a modifiable pointer to the AnimPreloadTable associated with the
## PartBundle, if any.

proc set_anim_preload*(this: PartBundle, table: AnimPreloadTable) {.importcpp: "#->set_anim_preload(#)".} ## \
## Replaces the AnimPreloadTable associated with the PartBundle.

proc clear_anim_preload*(this: PartBundle) {.importcpp: "#->clear_anim_preload()".} ## \
## Removes any AnimPreloadTable associated with the PartBundle.

proc merge_anim_preloads*(this: PartBundle, other: PartBundle) {.importcpp: "#->merge_anim_preloads(#)".} ## \
## Copies the contents of the other PartBundle's preload table into this one.

proc set_anim_blend_flag*(this: PartBundle, anim_blend_flag: bool) {.importcpp: "#->set_anim_blend_flag(#)".} ## \
## Defines the way the character responds to multiple calls to
## set_control_effect()).  By default, this flag is set false, which disallows
## multiple animations.  When this flag is false, it is not necessary to
## explicitly set the control_effect when starting an animation; starting the
## animation will implicitly remove the control_effect from the previous
## animation and set it on the current one.
##
## However, if this flag is set true, the control_effect must be explicitly
## set via set_control_effect() whenever an animation is to affect the
## character.

proc get_anim_blend_flag*(this: PartBundle): bool {.importcpp: "#->get_anim_blend_flag()".} ## \
## Returns whether the character allows multiple different animations to be
## bound simultaneously.  See set_anim_blend_flag().

proc set_frame_blend_flag*(this: PartBundle, frame_blend_flag: bool) {.importcpp: "#->set_frame_blend_flag(#)".} ## \
## Specifies whether the character interpolates (blends) between two
## sequential frames of an active animation, showing a smooth intra-frame
## motion, or whether it holds each frame until the next frame is ready,
## showing precisely the specified animation.
##
## When this value is false, the character holds each frame until the next is
## ready.  When this is true, the character will interpolate between two
## consecutive frames of animation for each frame the animation is onscreen,
## according to the amount of time elapsed between the frames.
##
## The default value of this flag is determined by the interpolate-frames
## Config.prc variable.
##
## Use set_blend_type() to change the algorithm that the character uses to
## interpolate matrix positions.

proc get_frame_blend_flag*(this: PartBundle): bool {.importcpp: "#->get_frame_blend_flag()".} ## \
## Returns whether the character interpolates (blends) between two sequential
## animation frames, or whether it holds the current frame until the next one
## is ready.  See set_frame_blend_flag().

proc set_root_xform*(this: PartBundle, root_xform: LMatrix4) {.importcpp: "#->set_root_xform(#)".} ## \
## Specifies the transform matrix which is implicitly applied at the root of
## the animated hierarchy.

proc xform*(this: PartBundle, mat: LMatrix4) {.importcpp: "#->xform(#)".} ## \
## Applies the indicated transform to the root of the animated hierarchy.

proc get_root_xform*(this: PartBundle): LMatrix4 {.importcpp: "#->get_root_xform()".} ## \
## Returns the transform matrix which is implicitly applied at the root of the
## animated hierarchy.

proc apply_transform*(this: PartBundle, transform: TransformState): PartBundle {.importcpp: "#->apply_transform(#)".} ## \
## Returns a PartBundle that is a duplicate of this one, but with the
## indicated transform applied.  If this is called multiple times with the
## same TransformState pointer, it returns the same PartBundle each time.

proc get_num_nodes*(this: PartBundle): int {.importcpp: "#->get_num_nodes()".} ## \
## Returns the number of PartBundleNodes that contain a pointer to this
## PartBundle.

proc get_node*(this: PartBundle, n: int): PartBundleNode {.importcpp: "#->get_node(#)".} ## \
## Returns the nth PartBundleNode associated with this PartBundle.

proc newPartBundleNode*(name: string, bundle: PartBundle): PartBundleNode {.importcpp: "new PartBundleNode(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## The PartBundle and its node should be constructed together.  Generally, the
## derived classes of PartBundleNode will automatically create a PartBundle of
## the appropriate type, and pass it up to this constructor.

proc get_num_bundles*(this: PartBundleNode): int {.importcpp: "#->get_num_bundles()".}

proc get_bundle*(this: PartBundleNode, n: int): PartBundle {.importcpp: "#->get_bundle(#)".}

proc get_bundle_handle*(this: PartBundleNode, n: int): PartBundleHandle {.importcpp: "#->get_bundle_handle(#)".} ## \
## Returns the PartBundleHandle that wraps around the actual nth PartBundle.
## While the PartBundle pointer might later change due to a future flatten
## operation, the PartBundleHandle will not.

proc newPartBundleHandle*(bundle: PartBundle): PartBundleHandle {.importcpp: "new PartBundleHandle(#)".}

proc newPartBundleHandle*(param0: PartBundleHandle): PartBundleHandle {.importcpp: "new PartBundleHandle(#)".}

proc get_bundle*(this: PartBundleHandle): PartBundle {.importcpp: "#->get_bundle()".} ## \
## Returns the actual PartBundle embedded within the handle.

proc set_bundle*(this: PartBundleHandle, bundle: PartBundle) {.importcpp: "#->set_bundle(#)".} ## \
## Changes the actual PartBundle embedded within the handle.

proc get_class_type*(_: typedesc[PartBundleNode]): TypeHandle {.importcpp: "PartBundleNode::get_class_type()", header: "partBundleNode.h".}

proc clear_control_effects*(this: PartBundle) {.importcpp: "#->clear_control_effects()".} ## \
## Sets the control effect of all AnimControls to zero (but does not "stop"
## the AnimControls).  The character will no longer be affected by any
## animation, and will return to its default pose (unless restore-initial-pose
## is false).
##
## The AnimControls which are no longer associated will not be using any CPU
## cycles, but they may still be in the "playing" state; if they are later
## reassociated with the PartBundle they will resume at their current frame as
## if they'd been running all along.

proc set_control_effect*(this: PartBundle, control: AnimControl, effect: float32) {.importcpp: "#->set_control_effect(#, #)".} ## \
## Sets the amount by which the character is affected by the indicated
## AnimControl (and its associated animation).  Normally, this will only be
## zero or one.  Zero indicates the animation does not affect the character,
## and one means it does.
##
## If the _anim_blend_flag is not false (see set_anim_blend_flag()), it is
## possible to have multiple AnimControls in effect simultaneously.  In this
## case, the effect is a weight that indicates the relative importance of each
## AnimControl to the final animation.

proc get_control_effect*(this: PartBundle, control: AnimControl): float32 {.importcpp: "#->get_control_effect(#)".} ## \
## Returns the amount by which the character is affected by the indicated
## AnimControl and its associated animation.  See set_control_effect().

proc output*(this: PartBundle, `out`: ostream) {.importcpp: "#->output(#)".} ## \
## Writes a one-line description of the bundle.

proc bind_anim*(this: PartBundle, anim: AnimBundle, hierarchy_match_flags: int, subset: PartSubset): AnimControl {.importcpp: "#->bind_anim(#, #, #)".} ## \
## Binds the animation to the bundle, if possible, and returns a new
## AnimControl that can be used to start and stop the animation.  If the anim
## hierarchy does not match the part hierarchy, returns NULL.
##
## If hierarchy_match_flags is 0, only an exact match is accepted; otherwise,
## it may contain a union of PartGroup::HierarchyMatchFlags values indicating
## conditions that will be tolerated (but warnings will still be issued).
##
## If subset is specified, it restricts the binding only to the named subtree
## of joints.
##
## The AnimControl is not stored within the PartBundle; it is the user's
## responsibility to maintain the pointer.  The animation will automatically
## unbind itself when the AnimControl destructs (i.e.  its reference count
## goes to zero).

proc bind_anim*(this: PartBundle, anim: AnimBundle, hierarchy_match_flags: int): AnimControl {.importcpp: "#->bind_anim(#, #)".} ## \
## Binds the animation to the bundle, if possible, and returns a new
## AnimControl that can be used to start and stop the animation.  If the anim
## hierarchy does not match the part hierarchy, returns NULL.
##
## If hierarchy_match_flags is 0, only an exact match is accepted; otherwise,
## it may contain a union of PartGroup::HierarchyMatchFlags values indicating
## conditions that will be tolerated (but warnings will still be issued).
##
## If subset is specified, it restricts the binding only to the named subtree
## of joints.
##
## The AnimControl is not stored within the PartBundle; it is the user's
## responsibility to maintain the pointer.  The animation will automatically
## unbind itself when the AnimControl destructs (i.e.  its reference count
## goes to zero).

proc bind_anim*(this: PartBundle, anim: AnimBundle): AnimControl {.importcpp: "#->bind_anim(#)".} ## \
## Binds the animation to the bundle, if possible, and returns a new
## AnimControl that can be used to start and stop the animation.  If the anim
## hierarchy does not match the part hierarchy, returns NULL.
##
## If hierarchy_match_flags is 0, only an exact match is accepted; otherwise,
## it may contain a union of PartGroup::HierarchyMatchFlags values indicating
## conditions that will be tolerated (but warnings will still be issued).
##
## If subset is specified, it restricts the binding only to the named subtree
## of joints.
##
## The AnimControl is not stored within the PartBundle; it is the user's
## responsibility to maintain the pointer.  The animation will automatically
## unbind itself when the AnimControl destructs (i.e.  its reference count
## goes to zero).

proc load_bind_anim*(this: PartBundle, loader: Loader, filename: Filename, hierarchy_match_flags: int, subset: PartSubset, allow_async: bool): AnimControl {.importcpp: "#->load_bind_anim(#, #, #, #, #)".} ## \
## Binds an animation to the bundle.  The animation is loaded from the disk
## via the indicated Loader object.  In other respects, this behaves similarly
## to bind_anim(), with the addition of asynchronous support.
##
## If allow_aysnc is true, the load will be asynchronous if possible.  This
## requires that the animation basename can be found in the PartBundle's
## preload table (see get_anim_preload()).
##
## In an asynchronous load, the animation file will be loaded and bound in a
## sub-thread.  This means that the animation will not necessarily be
## available at the time this method returns.  You may still use the returned
## AnimControl immediately, though, but no visible effect will occur until the
## animation eventually becomes available.
##
## You can test AnimControl::is_pending() to see if the animation has been
## loaded yet, or wait for it to finish with AnimControl::wait_pending() or
## even PartBundle::wait_pending().  You can also set an event to be triggered
## when the animation finishes loading with
## AnimControl::set_pending_done_event().

proc wait_pending*(this: PartBundle) {.importcpp: "#->wait_pending()".} ## \
## Blocks the current thread until all currently-pending AnimControls, with a
## nonzero control effect, have been loaded and are properly bound.

proc freeze_joint*(this: PartBundle, joint_name: string, pos: LVecBase3, hpr: LVecBase3, scale: LVecBase3): bool {.importcpp: "#->freeze_joint(nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Specifies that the joint with the indicated name should be frozen with the
## specified transform.  It will henceforth always hold this fixed transform,
## regardless of any animations that may subsequently be bound to the joint.
##
## Returns true if the joint is successfully frozen, or false if the named
## child is not a joint (or slider) or does not exist.

proc freeze_joint*(this: PartBundle, joint_name: string, value: float32): bool {.importcpp: "#->freeze_joint(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Specifies that the joint with the indicated name should be frozen with the
## specified transform.  It will henceforth always hold this fixed transform,
## regardless of any animations that may subsequently be bound to the joint.
##
## Returns true if the joint is successfully frozen, or false if the named
## child is not a joint (or slider) or does not exist.

proc freeze_joint*(this: PartBundle, joint_name: string, transform: TransformState): bool {.importcpp: "#->freeze_joint(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Specifies that the joint with the indicated name should be frozen with the
## specified transform.  It will henceforth always hold this fixed transform,
## regardless of any animations that may subsequently be bound to the joint.
##
## Returns true if the joint is successfully frozen, or false if the named
## child is not a joint (or slider) or does not exist.

proc control_joint*(this: PartBundle, joint_name: string, node: PandaNode): bool {.importcpp: "#->control_joint(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Specifies that the joint with the indicated name should be animated with
## the transform on the indicated node.  It will henceforth always follow the
## node's transform, regardless of any animations that may subsequently be
## bound to the joint.
##
## Returns true if the joint is successfully controlled, or false if the named
## child is not a joint (or slider) or does not exist.

proc release_joint*(this: PartBundle, joint_name: string): bool {.importcpp: "#->release_joint(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Releases the named joint from the effects of a previous call to
## freeze_joint() or control_joint(). It will henceforth once again follow
## whatever transforms are dictated by the animation.
##
## Returns true if the joint is released, or false if the named child was not
## previously controlled or frozen, or it does not exist.

proc update*(this: PartBundle): bool {.importcpp: "#->update()".} ## \
## Updates all the parts in the bundle to reflect the data for the current
## frame (as set in each of the AnimControls).
##
## Returns true if any part has changed as a result of this, or false
## otherwise.

proc force_update*(this: PartBundle): bool {.importcpp: "#->force_update()".} ## \
## Updates all the parts in the bundle to reflect the data for the current
## frame, whether we believe it needs it or not.

proc get_class_type*(_: typedesc[PartBundle]): TypeHandle {.importcpp: "PartBundle::get_class_type()", header: "partBundle.h".}

proc get_max_bound*(this: MovingPartBase): int {.importcpp: "#->get_max_bound()".} ## \
## Returns the number of channels that might be bound to this PartGroup.  This
## might not be the actual number of channels, since there might be holes in
## the list; it is one more than the index number of the highest bound
## channel.  Thus, it is called get_max_bound() instead of get_num_bound().

proc get_bound*(this: MovingPartBase, n: int): AnimChannelBase {.importcpp: "#->get_bound(#)".} ## \
## Returns the nth bound channel on this PartGroup.  n can be determined by
## iterating from 0 to one less than get_max_bound(); or n might be
## AnimControl::get_channel_index().
##
## This will return NULL if there is no channel bound on the indicated index.
## It is an error to call this if n is less than zero or greater than or equal
## to get_max_bound().

proc output_value*(this: MovingPartBase, `out`: ostream) {.importcpp: "#->output_value(#)".}

proc get_class_type*(_: typedesc[MovingPartBase]): TypeHandle {.importcpp: "MovingPartBase::get_class_type()", header: "movingPartBase.h".}

proc get_class_type*(_: typedesc[MovingPartMatrix]): TypeHandle {.importcpp: "MovingPartMatrix::get_class_type()", header: "movingPartMatrix.h".}

proc get_class_type*(_: typedesc[MovingPartScalar]): TypeHandle {.importcpp: "MovingPartScalar::get_class_type()", header: "movingPartScalar.h".}

proc set_client_name*(this: PStatClient, name: string) {.importcpp: "#.set_client_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the name of the client.  This is reported to the PStatsServer, and
## will presumably be written in the title bar or something.

proc get_client_name*(this: PStatClient): string {.importcpp: "nimStringFromStdString(#.get_client_name())", header: stringConversionCode.} ## \
## Retrieves the name of the client as set.

proc set_max_rate*(this: PStatClient, rate: float64) {.importcpp: "#.set_max_rate(#)".} ## \
## Controls the number of packets that will be sent to the server.  Normally,
## one packet is sent per frame, but this can flood the server with more
## packets than it can handle if the frame rate is especially good (e.g.  if
## nothing is onscreen at the moment).  Set this parameter to a reasonable
## number to prevent this from happening.
##
## This number specifies the maximum number of packets that will be sent to
## the server per second, per thread.

proc get_max_rate*(this: PStatClient): float64 {.importcpp: "#.get_max_rate()".} ## \
## Returns the maximum number of packets that will be sent to the server per
## second, per thread.  See set_max_rate().

proc get_num_collectors*(this: PStatClient): int {.importcpp: "#.get_num_collectors()".} ## \
## Returns the total number of collectors the Client knows about.

proc get_collector*(this: PStatClient, index: int): PStatCollector {.importcpp: "#.get_collector(#)".} ## \
## Returns the nth collector.

proc get_collector_name*(this: PStatClient, index: int): string {.importcpp: "nimStringFromStdString(#.get_collector_name(#))", header: stringConversionCode.} ## \
## Returns the name of the indicated collector.

proc get_collector_fullname*(this: PStatClient, index: int): string {.importcpp: "nimStringFromStdString(#.get_collector_fullname(#))", header: stringConversionCode.} ## \
## Returns the "full name" of the indicated collector.  This will be the
## concatenation of all of the collector's parents' names (except Frame) and
## the collector's own name.

proc get_num_threads*(this: PStatClient): int {.importcpp: "#.get_num_threads()".} ## \
## Returns the total number of threads the Client knows about.

proc get_thread*(this: PStatClient, index: int): PStatThread {.importcpp: "#.get_thread(#)".} ## \
## Returns the nth thread.

proc get_thread_name*(this: PStatClient, index: int): string {.importcpp: "nimStringFromStdString(#.get_thread_name(#))", header: stringConversionCode.} ## \
## Returns the name of the indicated thread.

proc get_thread_sync_name*(this: PStatClient, index: int): string {.importcpp: "nimStringFromStdString(#.get_thread_sync_name(#))", header: stringConversionCode.} ## \
## Returns the sync_name of the indicated thread.

proc get_thread_object*(this: PStatClient, index: int): Thread {.importcpp: "#.get_thread_object(#)".} ## \
## Returns the Panda Thread object associated with the indicated PStatThread.

proc get_main_thread*(this: PStatClient): PStatThread {.importcpp: "#.get_main_thread()".} ## \
## Returns a handle to the client's Main thread.  This is the thread that
## started the application.

proc get_current_thread*(this: PStatClient): PStatThread {.importcpp: "#.get_current_thread()".} ## \
## Returns a handle to the currently-executing thread.  This is the thread
## that PStatCollectors will be counted in if they do not specify otherwise.

proc get_real_time*(this: PStatClient): float64 {.importcpp: "#.get_real_time()".} ## \
## Returns the time according to to the PStatClient's clock object.  It keeps
## its own clock, instead of using the global clock object, so the stats won't
## get mucked up if you put the global clock in non-real-time mode or
## something.

proc initPStatCollector*(copy: PStatCollector): PStatCollector {.importcpp: "PStatCollector(#)".}

proc initPStatCollector*(parent: PStatCollector, name: string): PStatCollector {.importcpp: "PStatCollector(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates a new PStatCollector, ready to start accumulating data.  The name
## of the collector uniquely identifies it among the other collectors; if two
## collectors share the same name then they are really the same collector.
##
## The parent is the collector that conceptually includes all of the time
## measured for this collector.  For instance, a particular character's
## animation time is owned by the "Animation" collector, which is in turn
## owned by the "Frame" collector.  It is not strictly necessary that all of
## the time spent in a particular collector is completely nested within time
## spent in its parent's collector.  If parent is the empty string, the
## collector is owned by "Frame".
##
## This constructor does not take a client pointer; it always creates the new
## collector on the same client as its parent.

proc initPStatCollector*(name: string, client: PStatClient): PStatCollector {.importcpp: "PStatCollector(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Creates a new PStatCollector, ready to start accumulating data.  The name
## of the collector uniquely identifies it among the other collectors; if two
## collectors share the same name then they are really the same collector.
##
## The name may also be a compound name, something like "Cull:Sort", which
## indicates that this is a collector named "Sort", a child of the collector
## named "Cull". The parent may also be named explicitly by reference in the
## other flavor of the constructor; see further comments on this for that
## constructor.
##
## If the client pointer is non-null, it specifies a particular client to
## register the collector with; otherwise, the global client is used.

proc initPStatCollector*(name: string): PStatCollector {.importcpp: "PStatCollector(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates a new PStatCollector, ready to start accumulating data.  The name
## of the collector uniquely identifies it among the other collectors; if two
## collectors share the same name then they are really the same collector.
##
## The name may also be a compound name, something like "Cull:Sort", which
## indicates that this is a collector named "Sort", a child of the collector
## named "Cull". The parent may also be named explicitly by reference in the
## other flavor of the constructor; see further comments on this for that
## constructor.
##
## If the client pointer is non-null, it specifies a particular client to
## register the collector with; otherwise, the global client is used.

proc is_valid*(this: PStatCollector): bool {.importcpp: "#.is_valid()".} ## \
## Returns true if collector is valid and may be used, or false if it was
## constructed with the default constructor (in which case any attempt to use
## it will crash).

proc get_name*(this: PStatCollector): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the local name of this collector.  This is the rightmost part of
## the fullname, after the rightmost colon.

proc get_fullname*(this: PStatCollector): string {.importcpp: "nimStringFromStdString(#.get_fullname())", header: stringConversionCode.} ## \
## Returns the full name of this collector.  This includes the names of all
## the collector's parents, concatenated together with colons.

proc output*(this: PStatCollector, `out`: ostream) {.importcpp: "#.output(#)".}

proc is_active*(this: PStatCollector): bool {.importcpp: "#.is_active()".} ## \
## Returns true if this particular collector is active on the default thread,
## and we are currently transmitting PStats data.

proc is_active*(this: PStatCollector, thread: PStatThread): bool {.importcpp: "#.is_active(#)".} ## \
## Returns true if this particular collector is active on the indicated
## thread, and we are currently transmitting PStats data.

proc is_started*(this: PStatCollector): bool {.importcpp: "#.is_started()".} ## \
## Returns true if this particular collector has been started on the default
## thread, or false otherwise.

proc is_started*(this: PStatCollector, thread: PStatThread): bool {.importcpp: "#.is_started(#)".} ## \
## Returns true if this particular collector has been started on the indicated
## thread, or false otherwise.

proc start*(this: PStatCollector) {.importcpp: "#.start()".} ## \
## Starts this particular timer ticking.  This should be called before the
## code you want to measure.

proc start*(this: PStatCollector, thread: PStatThread) {.importcpp: "#.start(#)".} ## \
## Starts this timer ticking within a particular thread.

proc start*(this: PStatCollector, thread: PStatThread, as_of: float64) {.importcpp: "#.start(#, #)".} ## \
## Marks that the timer should have been started as of the indicated time.
## This must be a time based on the PStatClient's clock (see
## PStatClient::get_clock()), and care should be taken that all such calls
## exhibit a monotonically increasing series of time values.

proc stop*(this: PStatCollector) {.importcpp: "#.stop()".} ## \
## Stops this timer.  This should be called after the code you want to
## measure.

proc stop*(this: PStatCollector, thread: PStatThread) {.importcpp: "#.stop(#)".} ## \
## Stops this timer within a particular thread.

proc stop*(this: PStatCollector, thread: PStatThread, as_of: float64) {.importcpp: "#.stop(#, #)".} ## \
## Marks that the timer should have been stopped as of the indicated time.
## This must be a time based on the PStatClient's clock (see
## PStatClient::get_clock()), and care should be taken that all such calls
## exhibit a monotonically increasing series of time values.

proc clear_level*(this: PStatCollector) {.importcpp: "#.clear_level()".} ## \
## Removes the level setting associated with this collector for the main
## thread.  The collector will no longer show up on any level graphs in the
## main thread.  This implicitly calls flush_level().

proc clear_level*(this: PStatCollector, thread: PStatThread) {.importcpp: "#.clear_level(#)".} ## \
## Removes the level setting associated with this collector for the indicated
## thread.  The collector will no longer show up on any level graphs in this
## thread.

proc set_level*(this: PStatCollector, thread: PStatThread, level: float64) {.importcpp: "#.set_level(#, #)".} ## \
## Sets the level setting associated with this collector for the indicated
## thread to the indicated value.

proc set_level*(this: PStatCollector, level: float64) {.importcpp: "#.set_level(#)".} ## \
## Sets the level setting associated with this collector for the main thread
## to the indicated value.  This implicitly calls flush_level().

proc add_level*(this: PStatCollector, thread: PStatThread, increment: float64) {.importcpp: "#.add_level(#, #)".} ## \
## Adds the indicated increment (which may be negative) to the level setting
## associated with this collector for the indicated thread.  If the collector
## did not already have a level setting for this thread, it is initialized to
## 0.

proc add_level*(this: PStatCollector, increment: float64) {.importcpp: "#.add_level(#)".} ## \
## Adds the indicated increment (which may be negative) to the level setting
## associated with this collector for the main thread.  If the collector did
## not already have a level setting for the main thread, it is initialized to
## 0.
##
## As an optimization, the data is not immediately set to the PStatClient.  It
## will be sent the next time flush_level() is called.

proc sub_level*(this: PStatCollector, thread: PStatThread, decrement: float64) {.importcpp: "#.sub_level(#, #)".} ## \
## Subtracts the indicated decrement (which may be negative) to the level
## setting associated with this collector for the indicated thread.  If the
## collector did not already have a level setting for this thread, it is
## initialized to 0.

proc sub_level*(this: PStatCollector, decrement: float64) {.importcpp: "#.sub_level(#)".} ## \
## Subtracts the indicated decrement (which may be negative) to the level
## setting associated with this collector for the main thread.  If the
## collector did not already have a level setting for the main thread, it is
## initialized to 0.
##
## As an optimization, the data is not immediately set to the PStatClient.  It
## will be sent the next time flush_level() is called.

proc add_level_now*(this: PStatCollector, increment: float64) {.importcpp: "#.add_level_now(#)".} ## \
## Calls add_level() and immediately calls flush_level().

proc sub_level_now*(this: PStatCollector, decrement: float64) {.importcpp: "#.sub_level_now(#)".} ## \
## Calls sub_level() and immediately calls flush_level().

proc flush_level*(this: PStatCollector) {.importcpp: "#.flush_level()".} ## \
## Updates the PStatClient with the recent results from add_level() and
## sub_level().

proc get_level*(this: PStatCollector): float64 {.importcpp: "#.get_level()".} ## \
## Returns the current level value of the given collector in the main thread.
## This implicitly calls flush_level().

proc get_level*(this: PStatCollector, thread: PStatThread): float64 {.importcpp: "#.get_level(#)".} ## \
## Returns the current level value of the given collector.

proc clear_thread_level*(this: PStatCollector) {.importcpp: "#.clear_thread_level()".} ## \
## Removes the level setting associated with this collector for the current
## thread.  The collector will no longer show up on any level graphs in the
## current thread.

proc set_thread_level*(this: PStatCollector, level: float64) {.importcpp: "#.set_thread_level(#)".} ## \
## Sets the level setting associated with this collector for the current
## thread to the indicated value.

proc add_thread_level*(this: PStatCollector, increment: float64) {.importcpp: "#.add_thread_level(#)".} ## \
## Adds the indicated increment (which may be negative) to the level setting
## associated with this collector for the current thread.  If the collector
## did not already have a level setting for the current thread, it is
## initialized to 0.

proc sub_thread_level*(this: PStatCollector, decrement: float64) {.importcpp: "#.sub_thread_level(#)".} ## \
## Subtracts the indicated decrement (which may be negative) to the level
## setting associated with this collector for the current thread.  If the
## collector did not already have a level setting for the current thread, it
## is initialized to 0.

proc get_thread_level*(this: PStatCollector): float64 {.importcpp: "#.get_thread_level()".} ## \
## Returns the current level value of the given collector in the current
## thread.

proc get_index*(this: PStatCollector): int {.importcpp: "#.get_index()".} ## \
## Returns the index number of this particular collector within the
## PStatClient.

proc initPStatThread*(client: PStatClient, index: int): PStatThread {.importcpp: "PStatThread(#, #)".} ## \
## Normally, this constructor is called only from PStatClient.  Use one of the
## constructors below to create your own Thread.

proc initPStatThread*(copy: PStatThread): PStatThread {.importcpp: "PStatThread(#)".}

proc initPStatThread*(thread: Thread, client: PStatClient): PStatThread {.importcpp: "PStatThread(#, #)".} ## \
## Creates a new named thread.  This will be used to unify tasks that share a
## common thread, and differentiate tasks that occur in different threads.

proc initPStatThread*(thread: Thread): PStatThread {.importcpp: "PStatThread(#)".} ## \
## Creates a new named thread.  This will be used to unify tasks that share a
## common thread, and differentiate tasks that occur in different threads.

proc new_frame*(this: PStatThread) {.importcpp: "#.new_frame()".} ## \
## This must be called at the start of every "frame", whatever a frame may be
## deemed to be, to accumulate all the stats that have collected so far for
## the thread and ship them off to the server.
##
## Calling PStatClient::thread_tick() will automatically call this for any
## threads with the indicated sync name.

proc get_thread*(this: PStatThread): Thread {.importcpp: "#.get_thread()".} ## \
## Returns the Panda Thread object associated with this particular
## PStatThread.

proc get_index*(this: PStatThread): int {.importcpp: "#.get_index()".} ## \
## Returns the index number of this particular thread within the PStatClient.

proc connect*(_: typedesc[PStatClient], hostname: string, port: int): bool {.importcpp: "PStatClient::connect(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Attempts to establish a connection to the indicated PStatServer.  Returns
## true if successful, false on failure.

proc connect*(_: typedesc[PStatClient], hostname: string): bool {.importcpp: "PStatClient::connect(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Attempts to establish a connection to the indicated PStatServer.  Returns
## true if successful, false on failure.

proc connect*(_: typedesc[PStatClient]): bool {.importcpp: "PStatClient::connect()", header: "pStatClient.h".} ## \
## Attempts to establish a connection to the indicated PStatServer.  Returns
## true if successful, false on failure.

proc disconnect*(_: typedesc[PStatClient]) {.importcpp: "PStatClient::disconnect()", header: "pStatClient.h".} ## \
## Closes the connection previously established.

proc is_connected*(_: typedesc[PStatClient]): bool {.importcpp: "PStatClient::is_connected()", header: "pStatClient.h".} ## \
## Returns true if the client believes it is connected to a working
## PStatServer, false otherwise.

proc resume_after_pause*(_: typedesc[PStatClient]) {.importcpp: "PStatClient::resume_after_pause()", header: "pStatClient.h".} ## \
## Resumes the PStatClient after the simulation has been paused for a while.
## This allows the stats to continue exactly where it left off, instead of
## leaving a big gap that would represent a chug.

proc main_tick*(_: typedesc[PStatClient]) {.importcpp: "PStatClient::main_tick()", header: "pStatClient.h".} ## \
## A convenience function to call new_frame() on the global PStatClient's main
## thread, and any other threads with a sync_name of "Main".

proc thread_tick*(_: typedesc[PStatClient], sync_name: string) {.importcpp: "PStatClient::thread_tick(nimStringToStdString(#))", header: stringConversionCode.} ## \
## A convenience function to call new_frame() on any threads with the
## indicated sync_name

proc client_main_tick*(this: PStatClient) {.importcpp: "#.client_main_tick()".} ## \
## A convenience function to call new_frame() on the given PStatClient's main
## thread, and any other threads with a sync_name of "Main".

proc client_thread_tick*(this: PStatClient, sync_name: string) {.importcpp: "#.client_thread_tick(nimStringToStdString(#))", header: stringConversionCode.} ## \
## A convenience function to call new_frame() on all of the threads with the
## indicated sync name.

proc client_connect*(this: PStatClient, hostname: string, port: int): bool {.importcpp: "#.client_connect(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## The nonstatic implementation of connect().

proc client_disconnect*(this: PStatClient) {.importcpp: "#.client_disconnect()".} ## \
## The nonstatic implementation of disconnect().

proc client_is_connected*(this: PStatClient): bool {.importcpp: "#.client_is_connected()".} ## \
## The nonstatic implementation of is_connected().

proc client_resume_after_pause*(this: PStatClient) {.importcpp: "#.client_resume_after_pause()".} ## \
## Resumes the PStatClient after the simulation has been paused for a while.
## This allows the stats to continue exactly where it left off, instead of
## leaving a big gap that would represent a chug.

proc get_global_pstats*(_: typedesc[PStatClient]): PStatClient {.importcpp: "PStatClient::get_global_pstats()", header: "pStatClient.h".} ## \
## Returns a pointer to the global PStatClient object.  It's legal to declare
## your own PStatClient locally, but it's also convenient to have a global one
## that everyone can register with.  This is the global one.

proc newPStatCollectorForward*(col: PStatCollector): PStatCollectorForward {.importcpp: "new PStatCollectorForward(#)".}

proc newCharacterJoint*(character: Character, root: PartBundle, parent: PartGroup, name: string, default_value: LMatrix4): CharacterJoint {.importcpp: "new CharacterJoint(#, #, #, nimStringToStdString(#), #)", header: stringConversionCode.}

proc add_net_transform*(this: CharacterJoint, node: PandaNode): bool {.importcpp: "#->add_net_transform(#)".} ## \
## Adds the indicated node to the list of nodes that will be updated each
## frame with the joint's net transform from the root.  Returns true if the
## node is successfully added, false if it had already been added.
##
## A CharacterJointEffect for this joint's Character will automatically be
## added to the specified node.

proc remove_net_transform*(this: CharacterJoint, node: PandaNode): bool {.importcpp: "#->remove_net_transform(#)".} ## \
## Removes the indicated node from the list of nodes that will be updated each
## frame with the joint's net transform from the root.  Returns true if the
## node is successfully removed, false if it was not on the list.
##
## If the node has a CharacterJointEffect that matches this joint's Character,
## it will be cleared.

proc has_net_transform*(this: CharacterJoint, node: PandaNode): bool {.importcpp: "#->has_net_transform(#)".} ## \
## Returns true if the node is on the list of nodes that will be updated each
## frame with the joint's net transform from the root, false otherwise.

proc clear_net_transforms*(this: CharacterJoint) {.importcpp: "#->clear_net_transforms()".} ## \
## Removes all nodes from the list of nodes that will be updated each frame
## with the joint's net transform from the root.

proc get_net_transforms*(this: CharacterJoint): NodePathCollection {.importcpp: "#->get_net_transforms()".} ## \
## Returns a list of the net transforms set for this node.  Note that this
## returns a list of NodePaths, even though the net transforms are actually a
## list of PandaNodes.

proc add_local_transform*(this: CharacterJoint, node: PandaNode): bool {.importcpp: "#->add_local_transform(#)".} ## \
## Adds the indicated node to the list of nodes that will be updated each
## frame with the joint's local transform from its parent.  Returns true if
## the node is successfully added, false if it had already been added.
##
## The Character pointer should be the Character object that owns this joint;
## this will be used to create a CharacterJointEffect for this node.  If it is
## NULL, no such effect will be created.
##
## A CharacterJointEffect for this joint's Character will automatically be
## added to the specified node.

proc remove_local_transform*(this: CharacterJoint, node: PandaNode): bool {.importcpp: "#->remove_local_transform(#)".} ## \
## Removes the indicated node from the list of nodes that will be updated each
## frame with the joint's local transform from its parent.  Returns true if
## the node is successfully removed, false if it was not on the list.
##
## If the node has a CharacterJointEffect that matches this joint's Character,
## it will be cleared.

proc has_local_transform*(this: CharacterJoint, node: PandaNode): bool {.importcpp: "#->has_local_transform(#)".} ## \
## Returns true if the node is on the list of nodes that will be updated each
## frame with the joint's local transform from its parent, false otherwise.

proc clear_local_transforms*(this: CharacterJoint) {.importcpp: "#->clear_local_transforms()".} ## \
## Removes all nodes from the list of nodes that will be updated each frame
## with the joint's local transform from its parent.

proc get_local_transforms*(this: CharacterJoint): NodePathCollection {.importcpp: "#->get_local_transforms()".} ## \
## Returns a list of the local transforms set for this node.  Note that this
## returns a list of NodePaths, even though the local transforms are actually
## a list of PandaNodes.

proc get_transform*(this: CharacterJoint): LMatrix4 {.importcpp: "#->get_transform()".} ## \
## Returns the transform matrix of the joint

proc get_transform*(this: CharacterJoint, transform: LMatrix4) {.importcpp: "#->get_transform(#)".} ## \
## Copies the joint's current transform into the indicated matrix.

proc get_transform_state*(this: CharacterJoint): TransformState {.importcpp: "#->get_transform_state()".}

proc get_net_transform*(this: CharacterJoint, transform: LMatrix4) {.importcpp: "#->get_net_transform(#)".} ## \
## Copies the joint's current net transform (composed from the root of the
## character joint hierarchy) into the indicated matrix.

proc get_character*(this: CharacterJoint): Character {.importcpp: "#->get_character()".} ## \
## Returns the Character that owns this joint.

proc get_class_type*(_: typedesc[CharacterJoint]): TypeHandle {.importcpp: "CharacterJoint::get_class_type()", header: "characterJoint.h".}

proc newCharacterSlider*(parent: PartGroup, name: string): CharacterSlider {.importcpp: "new CharacterSlider(#, nimStringToStdString(#))", header: stringConversionCode.}

proc newCharacterSlider*(parent: PartGroup, name: string, default_value: float32): CharacterSlider {.importcpp: "new CharacterSlider(#, nimStringToStdString(#), #)", header: stringConversionCode.}

proc get_class_type*(_: typedesc[CharacterSlider]): TypeHandle {.importcpp: "CharacterSlider::get_class_type()", header: "characterSlider.h".}

proc newCharacterVertexSlider*(char_slider: CharacterSlider): CharacterVertexSlider {.importcpp: "new CharacterVertexSlider(#)".} ## \
## Constructs a new object that converts vertices from the indicated joint's
## coordinate space, into the other indicated joint's space.

proc get_char_slider*(this: CharacterVertexSlider): CharacterSlider {.importcpp: "#->get_char_slider()".} ## \
## Returns the CharacterSlider object for which this object returns the slider
## value.

proc get_class_type*(_: typedesc[CharacterVertexSlider]): TypeHandle {.importcpp: "CharacterVertexSlider::get_class_type()", header: "characterVertexSlider.h".}

proc newJointVertexTransform*(joint: CharacterJoint): JointVertexTransform {.importcpp: "new JointVertexTransform(#)".} ## \
## Constructs a new object that converts vertices from the indicated joint's
## coordinate space, into the other indicated joint's space.

proc get_joint*(this: JointVertexTransform): CharacterJoint {.importcpp: "#->get_joint()".} ## \
## Returns the joint for which this object returns the transform.

proc get_class_type*(_: typedesc[JointVertexTransform]): TypeHandle {.importcpp: "JointVertexTransform::get_class_type()", header: "jointVertexTransform.h".}

proc newCharacter*(param0: Character): Character {.importcpp: "new Character(#)".}

proc newCharacter*(name: string): Character {.importcpp: "new Character(nimStringToStdString(#))", header: stringConversionCode.}

proc get_bundle*(this: Character, i: int): CharacterJointBundle {.importcpp: "#->get_bundle(#)".}

proc merge_bundles*(this: Character, old_bundle: PartBundle, other_bundle: PartBundle) {.importcpp: "#->merge_bundles(#, #)".} ## \
## Merges old_bundle with new_bundle.  old_bundle must be one of the
## PartBundles within this node.  At the end of this call, the old_bundle
## pointer within this node will be replaced with the new_bundle pointer, and
## all geometry within this node will be updated to reference new_bundle.
##
## @deprecated Use the newer version of this method, below.

proc merge_bundles*(this: Character, old_bundle_handle: PartBundleHandle, other_bundle_handle: PartBundleHandle) {.importcpp: "#->merge_bundles(#, #)".} ## \
## Merges old_bundle_handle->get_bundle() with new_bundle.  old_bundle_handle
## must be one of the PartBundleHandle within this node.  At the end of this
## call, the bundle pointer within the old_bundle_handle will be replaced with
## that within the new_bundle_handle pointer, and all geometry within this
## node will be updated to reference new_bundle.
##
## Normally, this is called when the two bundles have the same, or nearly the
## same, hierarchies.  In this case, new_bundle will simply be assigned over
## the old_bundle position.  However, if any joints are present in one bundle
## or the other, new_bundle will be modified to contain the union of all
## joints.
##
## The geometry below this node is also updated to reference new_bundle,
## instead of the original old_bundle.
##
## This method is intended to unify two different models that share a common
## skeleton, for instance, different LOD's of the same model.

proc set_lod_animation*(this: Character, center: LPoint3, far_distance: float32, near_distance: float32, delay_factor: float32) {.importcpp: "#->set_lod_animation(#, #, #, #)".} ## \
## Activates a special mode in which the character animates less frequently as
## it gets further from the camera.  This is intended as a simple optimization
## to minimize the effort of computing animation for lots of characters that
## may not necessarily be very important to animate every frame.
##
## If the character is closer to the camera than near_distance, then it is
## animated its normal rate, every frame.  If the character is exactly
## far_distance away, it is animated only every delay_factor seconds (which
## should be a number greater than 0).  If the character is between
## near_distance and far_distance, its animation rate is linearly interpolated
## according to its distance between the two.  The interpolation function
## continues beyond far_distance, so that the character is animated
## increasingly less frequently as it gets farther away.
##
## The distance calculations are made from center, which is a fixed point
## relative to the character node, to the camera's lod center or cull center
## node (or to the camera node itself).
##
## If multiple cameras are viewing the character in any given frame, the
## closest one counts.

proc clear_lod_animation*(this: Character) {.importcpp: "#->clear_lod_animation()".} ## \
## Undoes the effect of a recent call to set_lod_animation().  Henceforth, the
## character will animate every frame, regardless of its distance from the
## camera.

proc find_joint*(this: Character, name: string): CharacterJoint {.importcpp: "#->find_joint(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a pointer to the joint with the given name, if there is such a
## joint, or NULL if there is no such joint.  This will not return a pointer
## to a slider.

proc find_slider*(this: Character, name: string): CharacterSlider {.importcpp: "#->find_slider(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a pointer to the slider with the given name, if there is such a
## slider, or NULL if there is no such slider.  This will not return a pointer
## to a joint.

proc write_parts*(this: Character, `out`: ostream) {.importcpp: "#->write_parts(#)".} ## \
## Writes a list of the Character's joints and sliders, in their hierchical
## structure, to the indicated output stream.

proc write_part_values*(this: Character, `out`: ostream) {.importcpp: "#->write_part_values(#)".} ## \
## Writes a list of the Character's joints and sliders, along with each
## current position, in their hierchical structure, to the indicated output
## stream.

proc update_to_now*(this: Character) {.importcpp: "#->update_to_now()".} ## \
## Advances the character's frame to the current time, and then calls
## update().  This can be used by show code to force an update of the
## character's position to the current frame, regardless of whether the
## character is currently onscreen and animating.
##
## @deprecated Call update() instead.

proc update*(this: Character) {.importcpp: "#->update()".} ## \
## Recalculates the Character's joints and vertices for the current frame.
## Normally this is performed automatically during the render and need not be
## called explicitly.

proc force_update*(this: Character) {.importcpp: "#->force_update()".} ## \
## Recalculates the character even if we think it doesn't need it.

proc get_class_type*(_: typedesc[Character]): TypeHandle {.importcpp: "Character::get_class_type()", header: "character.h".}

proc newCharacterJointBundle*(name: string): CharacterJointBundle {.importcpp: "new CharacterJointBundle(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Normally, there is no need to create a CharacterJointBundle directly.  The
## Character node will automatically create one for itself.

proc newCharacterJointBundle*(): CharacterJointBundle {.importcpp: "new CharacterJointBundle()".} ## \
## Normally, there is no need to create a CharacterJointBundle directly.  The
## Character node will automatically create one for itself.

proc get_node*(this: CharacterJointBundle, n: int): Character {.importcpp: "#->get_node(#)".} ## \
## Returns the nth Character associated with this PartBundle.

proc get_class_type*(_: typedesc[CharacterJointBundle]): TypeHandle {.importcpp: "CharacterJointBundle::get_class_type()", header: "characterJointBundle.h".}

proc make*(_: typedesc[CharacterJointEffect], character: Character): RenderEffect {.importcpp: "CharacterJointEffect::make(#)", header: "characterJointEffect.h".} ## \
## Constructs a new CharacterJointEffect object that references the indicated
## character.  When a relative get_transform() is called on the node that
## contains the CharacterJointEffect, it will implicitly call
## character->update() first.

proc get_character*(this: CharacterJointEffect): Character {.importcpp: "#->get_character()".} ## \
## Returns the Character that will get update() called on it when this node's
## relative transform is queried, or NULL if there is no such character.

proc get_class_type*(_: typedesc[CharacterJointEffect]): TypeHandle {.importcpp: "CharacterJointEffect::get_class_type()", header: "characterJointEffect.h".}

proc get_collision_origin*(this: CollisionSolid): LPoint3 {.importcpp: "#->get_collision_origin()".}

proc set_tangible*(this: CollisionSolid, tangible: bool) {.importcpp: "#->set_tangible(#)".} ## \
## Sets the current state of the 'tangible' flag.  Set this true to make the
## solid tangible, so that a CollisionHandlerPusher will not allow another
## object to intersect it, or false to make it intangible, so that a
## CollisionHandlerPusher will ignore it except to throw an event.

proc is_tangible*(this: CollisionSolid): bool {.importcpp: "#->is_tangible()".} ## \
## Returns whether the solid is considered 'tangible' or not.  An intangible
## solid has no effect in a CollisionHandlerPusher (except to throw an event);
## it's useful for defining 'trigger' planes and spheres, that cause an effect
## when passed through.

proc set_effective_normal*(this: CollisionSolid, effective_normal: LVector3) {.importcpp: "#->set_effective_normal(#)".} ## \
## Records a false normal for this CollisionSolid that will be reported by the
## collision system with all collisions into it, instead of its actual normal.
## This is useful as a workaround for the problem of an avatar wanting to
## stand on a sloping ground; by storing a false normal, the ground appears to
## be perfectly level, and the avatar does not tend to slide down it.

proc clear_effective_normal*(this: CollisionSolid) {.importcpp: "#->clear_effective_normal()".} ## \
## Removes the normal previously set by set_effective_normal().

proc has_effective_normal*(this: CollisionSolid): bool {.importcpp: "#->has_effective_normal()".} ## \
## Returns true if a special normal was set by set_effective_normal(), false
## otherwise.

proc get_effective_normal*(this: CollisionSolid): LVector3 {.importcpp: "#->get_effective_normal()".} ## \
## Returns the normal that was set by set_effective_normal().  It is an error
## to call this unless has_effective_normal() returns true.

proc set_respect_effective_normal*(this: CollisionSolid, respect_effective_normal: bool) {.importcpp: "#->set_respect_effective_normal(#)".} ## \
## This is only meaningful for CollisionSolids that will be added to a
## traverser as colliders.  It is normally true, but if set false, it means
## that this particular solid does not care about the "effective" normal of
## other solids it meets, but rather always uses the true normal.

proc get_respect_effective_normal*(this: CollisionSolid): bool {.importcpp: "#->get_respect_effective_normal()".} ## \
## See set_respect_effective_normal().

proc get_bounds*(this: CollisionSolid): BoundingVolume {.importcpp: "#->get_bounds()".} ## \
## Returns the solid's bounding volume.

proc set_bounds*(this: CollisionSolid, bounding_volume: BoundingVolume) {.importcpp: "#->set_bounds(#)".} ## \
## Returns the solid's bounding volume.

proc output*(this: CollisionSolid, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: CollisionSolid, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: CollisionSolid, `out`: ostream) {.importcpp: "#->write(#)".}

proc get_class_type*(_: typedesc[CollisionSolid]): TypeHandle {.importcpp: "CollisionSolid::get_class_type()", header: "collisionSolid.h".}

proc newCollisionBox*(min: LPoint3, max: LPoint3): CollisionBox {.importcpp: "new CollisionBox(#, #)".} ## \
## Create the Box by Specifying the Diagonal Points

proc newCollisionBox*(center: LPoint3, x: float32, y: float32, z: float32): CollisionBox {.importcpp: "new CollisionBox(#, #, #, #)".} ## \
## Create the Box by giving a Center and distances of each of the sides of
## box from the Center.

proc get_num_points*(this: CollisionBox): int {.importcpp: "#->get_num_points()".} ## \
## Returns 8: the number of vertices of a rectangular solid.

proc get_point_aabb*(this: CollisionBox, n: int): LPoint3 {.importcpp: "#->get_point_aabb(#)".} ## \
## Returns the nth vertex of the Axis Aligned Bounding Box.

proc get_point*(this: CollisionBox, n: int): LPoint3 {.importcpp: "#->get_point(#)".} ## \
## Returns the nth vertex of the OBB.

proc get_num_planes*(this: CollisionBox): int {.importcpp: "#->get_num_planes()".} ## \
## Returns 6: the number of faces of a rectangular solid.

proc set_plane*(this: CollisionBox, n: int): LPlane {.importcpp: "#->set_plane(#)".} ## \
## Creates the nth face of the rectangular solid.

proc get_plane*(this: CollisionBox, n: int): LPlane {.importcpp: "#->get_plane(#)".} ## \
## Returns the nth face of the rectangular solid.

proc set_center*(this: CollisionBox, center: LPoint3) {.importcpp: "#->set_center(#)".}

proc set_center*(this: CollisionBox, x: float32, y: float32, z: float32) {.importcpp: "#->set_center(#, #, #)".}

proc get_center*(this: CollisionBox): LPoint3 {.importcpp: "#->get_center()".}

proc get_min*(this: CollisionBox): LPoint3 {.importcpp: "#->get_min()".}

proc get_max*(this: CollisionBox): LPoint3 {.importcpp: "#->get_max()".}

proc get_dimensions*(this: CollisionBox): LVector3 {.importcpp: "#->get_dimensions()".}

proc get_class_type*(_: typedesc[CollisionBox]): TypeHandle {.importcpp: "CollisionBox::get_class_type()", header: "collisionBox.h".}

proc newCollisionCapsule*(a: LPoint3, db: LPoint3, radius: float32): CollisionCapsule {.importcpp: "new CollisionCapsule(#, #, #)".}

proc newCollisionCapsule*(ax: float32, ay: float32, az: float32, bx: float32, by: float32, bz: float32, radius: float32): CollisionCapsule {.importcpp: "new CollisionCapsule(#, #, #, #, #, #, #)".}

proc set_point_a*(this: CollisionCapsule, a: LPoint3) {.importcpp: "#->set_point_a(#)".}

proc set_point_a*(this: CollisionCapsule, x: float32, y: float32, z: float32) {.importcpp: "#->set_point_a(#, #, #)".}

proc get_point_a*(this: CollisionCapsule): LPoint3 {.importcpp: "#->get_point_a()".}

proc set_point_b*(this: CollisionCapsule, b: LPoint3) {.importcpp: "#->set_point_b(#)".}

proc set_point_b*(this: CollisionCapsule, x: float32, y: float32, z: float32) {.importcpp: "#->set_point_b(#, #, #)".}

proc get_point_b*(this: CollisionCapsule): LPoint3 {.importcpp: "#->get_point_b()".}

proc set_radius*(this: CollisionCapsule, radius: float32) {.importcpp: "#->set_radius(#)".}

proc get_radius*(this: CollisionCapsule): float32 {.importcpp: "#->get_radius()".}

proc get_class_type*(_: typedesc[CollisionCapsule]): TypeHandle {.importcpp: "CollisionCapsule::get_class_type()", header: "collisionCapsule.h".}

proc get_class_type*(_: typedesc[CollisionHandler]): TypeHandle {.importcpp: "CollisionHandler::get_class_type()", header: "collisionHandler.h".}

proc newCollisionHandler*(param0: CollisionHandler): CollisionHandler {.importcpp: "new CollisionHandler(#)".}

proc newCollisionNode*(name: string): CollisionNode {.importcpp: "new CollisionNode(nimStringToStdString(#))", header: stringConversionCode.}

proc clear_solids*(this: CollisionNode) {.importcpp: "#->clear_solids()".} ## \
## Removes all solids from the node.

proc get_num_solids*(this: CollisionNode): clonglong {.importcpp: "#->get_num_solids()".}

proc get_solid*(this: CollisionNode, n: clonglong): CollisionSolid {.importcpp: "#->get_solid(#)".}

proc modify_solid*(this: CollisionNode, n: clonglong): CollisionSolid {.importcpp: "#->modify_solid(#)".}

proc set_solid*(this: CollisionNode, n: clonglong, solid: CollisionSolid) {.importcpp: "#->set_solid(#, #)".} ## \
## Replaces the solid with the indicated index.

proc insert_solid*(this: CollisionNode, n: clonglong, solid: CollisionSolid) {.importcpp: "#->insert_solid(#, #)".} ## \
## Inserts the indicated solid to the node at the indicated position.

proc remove_solid*(this: CollisionNode, n: clonglong) {.importcpp: "#->remove_solid(#)".} ## \
## Removes the solid with the indicated index.  This will shift all subsequent
## indices down by one.

proc add_solid*(this: CollisionNode, solid: CollisionSolid): clonglong {.importcpp: "#->add_solid(#)".} ## \
## Adds the indicated solid to the node.  Returns the index of the new solid
## within the node's list of solids.

proc get_collider_sort*(this: CollisionNode): int {.importcpp: "#->get_collider_sort()".} ## \
## Returns the collider_sort value that has been set for this particular node.
## See set_collider_sort().

proc set_collider_sort*(this: CollisionNode, sort: int) {.importcpp: "#->set_collider_sort(#)".} ## \
## Sets a particular collider_sort value on this node.  This controls the
## order in which colliders (that is, "from nodes") are grouped together for
## the collision traversal.
##
## If there are 32 or fewer colliders added to any particular
## CollisionTraverser, then this value has no meaning.  It is only useful if
## there are many colliders, which may force the CollisionTraverser to make
## multiple passes through the data; in that case, it may be a useful
## optimization to group colliders that have similar bounding volumes together
## (by giving them similar sort values).

proc get_class_type*(_: typedesc[CollisionNode]): TypeHandle {.importcpp: "CollisionNode::get_class_type()", header: "collisionNode.h".}

proc initCollisionTraverser*(param0: CollisionTraverser): CollisionTraverser {.importcpp: "CollisionTraverser(#)".}

proc initCollisionTraverser*(name: string): CollisionTraverser {.importcpp: "CollisionTraverser(nimStringToStdString(#))", header: stringConversionCode.}

proc initCollisionTraverser*(): CollisionTraverser {.importcpp: "CollisionTraverser()".}

proc set_respect_prev_transform*(this: CollisionTraverser, flag: bool) {.importcpp: "#.set_respect_prev_transform(#)".} ## \
## Sets the flag that indicates whether the prev_transform stored on a node
## (as updated via set_fluid_pos(), etc.) is respected to calculate
## collisions.  If this is true, certain types of collision tests will be
## enhanced by the information about objects in motion.  If this is false,
## objects are always considered to be static.  The default is false.

proc get_respect_prev_transform*(this: CollisionTraverser): bool {.importcpp: "#.get_respect_prev_transform()".} ## \
## Returns the flag that indicates whether the prev_transform stored on a node
## is respected to calculate collisions.  See set_respect_prev_transform().

proc add_collider*(this: CollisionTraverser, collider: NodePath, handler: CollisionHandler) {.importcpp: "#.add_collider(#, #)".} ## \
## Adds a new CollisionNode, representing an object that will be tested for
## collisions into other objects, along with the handler that will serve each
## detected collision.  Each CollisionNode may be served by only one handler
## at a time, but a given handler may serve many CollisionNodes.
##
## The handler that serves a particular node may be changed from time to time
## by calling add_collider() again on the same node.

proc remove_collider*(this: CollisionTraverser, collider: NodePath): bool {.importcpp: "#.remove_collider(#)".} ## \
## Removes the collider (and its associated handler) from the set of
## CollisionNodes that will be tested each frame for collisions into other
## objects.  Returns true if the definition was found and removed, false if it
## wasn't present to begin with.

proc has_collider*(this: CollisionTraverser, collider: NodePath): bool {.importcpp: "#.has_collider(#)".} ## \
## Returns true if the indicated node is current in the set of nodes that will
## be tested each frame for collisions into other objects.

proc get_num_colliders*(this: CollisionTraverser): int {.importcpp: "#.get_num_colliders()".} ## \
## Returns the number of CollisionNodes that have been added to the traverser
## via add_collider().

proc get_collider*(this: CollisionTraverser, n: int): NodePath {.importcpp: "#.get_collider(#)".} ## \
## Returns the nth CollisionNode that has been added to the traverser via
## add_collider().

proc get_handler*(this: CollisionTraverser, collider: NodePath): CollisionHandler {.importcpp: "#.get_handler(#)".} ## \
## Returns the handler that is currently assigned to serve the indicated
## collision node, or NULL if the node is not on the traverser's set of active
## nodes.

proc clear_colliders*(this: CollisionTraverser) {.importcpp: "#.clear_colliders()".} ## \
## Completely empties the set of collision nodes and their associated
## handlers.

proc traverse*(this: CollisionTraverser, root: NodePath) {.importcpp: "#.traverse(#)".} ## \
## Perform the traversal. Begins at the indicated root and detects all
## collisions with any of its collider objects against nodes at or below the
## indicated root, calling the appropriate CollisionHandler for each detected
## collision.

proc set_recorder*(this: CollisionTraverser, recorder: CollisionRecorder) {.importcpp: "#.set_recorder(#)".} ## \
## Uses the indicated CollisionRecorder object to start recording the
## intersection tests made by each subsequent call to traverse() on this
## object.  A particular CollisionRecorder object can only record one
## traverser at a time; if this object has already been assigned to another
## traverser, that assignment is broken.
##
## This is intended to be used in a debugging mode to try to determine what
## work is being performed by the collision traversal.  Usually, attaching a
## recorder will impose significant runtime overhead.
##
## This does not transfer ownership of the CollisionRecorder pointer;
## maintenance of that remains the caller's responsibility.  If the
## CollisionRecorder is destructed, it will cleanly remove itself from the
## traverser.

proc has_recorder*(this: CollisionTraverser): bool {.importcpp: "#.has_recorder()".} ## \
## Returns true if the CollisionTraverser has a CollisionRecorder object
## currently assigned, false otherwise.

proc get_recorder*(this: CollisionTraverser): CollisionRecorder {.importcpp: "#.get_recorder()".} ## \
## Returns the CollisionRecorder currently assigned, or NULL if no recorder is
## assigned.

proc clear_recorder*(this: CollisionTraverser) {.importcpp: "#.clear_recorder()".} ## \
## Removes the CollisionRecorder from the traverser and restores normal low-
## overhead operation.

proc output*(this: CollisionRecorder, `out`: ostream) {.importcpp: "#.output(#)".}

proc get_class_type*(_: typedesc[CollisionRecorder]): TypeHandle {.importcpp: "CollisionRecorder::get_class_type()", header: "collisionRecorder.h".}

proc show_collisions*(this: CollisionTraverser, root: NodePath): CollisionVisualizer {.importcpp: "#.show_collisions(#)".} ## \
## This is a high-level function to create a CollisionVisualizer object to
## render the collision tests performed by this traverser.  The supplied root
## should be any node in the scene graph; typically, the top node (e.g.
## render).  The CollisionVisualizer will be attached to this node.

proc hide_collisions*(this: CollisionTraverser) {.importcpp: "#.hide_collisions()".} ## \
## Undoes the effect of a previous call to show_collisions().

proc output*(this: CollisionTraverser, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: CollisionTraverser, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc get_class_type*(_: typedesc[CollisionTraverser]): TypeHandle {.importcpp: "CollisionTraverser::get_class_type()", header: "collisionTraverser.h".}

proc get_from*(this: CollisionEntry): CollisionSolid {.importcpp: "#->get_from()".} ## \
## Returns the CollisionSolid pointer for the particular solid that triggered
## this collision.

proc has_into*(this: CollisionEntry): bool {.importcpp: "#->has_into()".} ## \
## Returns true if the "into" solid is, in fact, a CollisionSolid, and its
## pointer is known (in which case get_into() may be called to retrieve it).
## If this returns false, the collision was detected into a GeomNode, and
## there is no CollisionSolid pointer to be retrieved.

proc get_into*(this: CollisionEntry): CollisionSolid {.importcpp: "#->get_into()".} ## \
## Returns the CollisionSolid pointer for the particular solid was collided
## into.  This pointer might be NULL if the collision was into a piece of
## visible geometry, instead of a normal CollisionSolid collision; see
## has_into().

proc get_from_node*(this: CollisionEntry): CollisionNode {.importcpp: "#->get_from_node()".} ## \
## Returns the node that contains the CollisionSolid that triggered this
## collision.  This will be a node that has been added to a CollisionTraverser
## via add_collider().

proc get_into_node*(this: CollisionEntry): PandaNode {.importcpp: "#->get_into_node()".} ## \
## Returns the node that contains the CollisionSolid that was collided into.
## This returns a PandaNode pointer instead of something more specific,
## because it might be either a CollisionNode or a GeomNode.
##
## Also see get_into_node_path().

proc get_from_node_path*(this: CollisionEntry): NodePath {.importcpp: "#->get_from_node_path()".} ## \
## Returns the NodePath that represents the CollisionNode that contains the
## CollisionSolid that triggered this collision.  This will be a NodePath that
## has been added to a CollisionTraverser via add_collider().

proc get_into_node_path*(this: CollisionEntry): NodePath {.importcpp: "#->get_into_node_path()".} ## \
## Returns the NodePath that represents the specific CollisionNode or GeomNode
## instance that was collided into.  This is the same node returned by
## get_into_node(), represented as a NodePath; however, it may be more useful
## because the NodePath can resolve the particular instance of the node, if
## there is more than one.

proc set_t*(this: CollisionEntry, t: float32) {.importcpp: "#->set_t(#)".} ## \
## Sets a time value for this collision relative to other CollisionEntries

proc get_t*(this: CollisionEntry): float32 {.importcpp: "#->get_t()".} ## \
## returns time value for this collision relative to other CollisionEntries

proc collided*(this: CollisionEntry): bool {.importcpp: "#->collided()".} ## \
## returns true if this represents an actual collision as opposed to a
## potential collision, needed for iterative collision resolution where path
## of collider changes mid-frame

proc reset_collided*(this: CollisionEntry) {.importcpp: "#->reset_collided()".} ## \
## prepare for another collision test

proc get_respect_prev_transform*(this: CollisionEntry): bool {.importcpp: "#->get_respect_prev_transform()".} ## \
## Returns true if the collision was detected by a CollisionTraverser whose
## respect_prev_transform flag was set true, meaning we should consider motion
## significant in evaluating collisions.

proc set_surface_point*(this: CollisionEntry, point: LPoint3) {.importcpp: "#->set_surface_point(#)".} ## \
## Stores the point, on the surface of the "into" object, at which a collision
## is detected.
##
## This point is specified in the coordinate space of the "into" object.

proc set_surface_normal*(this: CollisionEntry, normal: LVector3) {.importcpp: "#->set_surface_normal(#)".} ## \
## Stores the surface normal of the "into" object at the point of the
## intersection.
##
## This normal is specified in the coordinate space of the "into" object.

proc set_interior_point*(this: CollisionEntry, point: LPoint3) {.importcpp: "#->set_interior_point(#)".} ## \
## Stores the point, within the interior of the "into" object, which
## represents the depth to which the "from" object has penetrated.  This can
## also be described as the intersection point on the surface of the "from"
## object (which is inside the "into" object).
##
## This point is specified in the coordinate space of the "into" object.

proc has_surface_point*(this: CollisionEntry): bool {.importcpp: "#->has_surface_point()".} ## \
## Returns true if the surface point has been specified, false otherwise.  See
## get_surface_point().  Some types of collisions may not compute the surface
## point.

proc has_surface_normal*(this: CollisionEntry): bool {.importcpp: "#->has_surface_normal()".} ## \
## Returns true if the surface normal has been specified, false otherwise.
## See get_surface_normal().  Some types of collisions may not compute the
## surface normal.

proc has_interior_point*(this: CollisionEntry): bool {.importcpp: "#->has_interior_point()".} ## \
## Returns true if the interior point has been specified, false otherwise.
## See get_interior_point().  Some types of collisions may not compute the
## interior point.

proc set_contact_pos*(this: CollisionEntry, pos: LPoint3) {.importcpp: "#->set_contact_pos(#)".} ## \
## Stores the position of the "from" object at the instant at which the
## collision is first detected.
##
## This position is specified in the coordinate space of the "into" object.

proc set_contact_normal*(this: CollisionEntry, normal: LVector3) {.importcpp: "#->set_contact_normal(#)".} ## \
## Stores the surface normal of the "into" object at the contact pos.
##
## This normal is specified in the coordinate space of the "into" object.

proc has_contact_pos*(this: CollisionEntry): bool {.importcpp: "#->has_contact_pos()".} ## \
## Returns true if the contact position has been specified, false otherwise.
## See get_contact_pos().  Some types of collisions may not compute the
## contact pos.

proc has_contact_normal*(this: CollisionEntry): bool {.importcpp: "#->has_contact_normal()".} ## \
## Returns true if the contact normal has been specified, false otherwise.
## See get_contact_normal().  Some types of collisions may not compute the
## contact normal.

proc get_surface_point*(this: CollisionEntry, space: NodePath): LPoint3 {.importcpp: "#->get_surface_point(#)".} ## \
## Returns the point, on the surface of the "into" object, at which a
## collision is detected.  This can be thought of as the first point of
## intersection.  However the contact point is the actual first point of
## intersection.
##
## The point will be converted into whichever coordinate space the caller
## specifies.

proc get_surface_normal*(this: CollisionEntry, space: NodePath): LVector3 {.importcpp: "#->get_surface_normal(#)".} ## \
## Returns the surface normal of the "into" object at the point at which a
## collision is detected.
##
## The normal will be converted into whichever coordinate space the caller
## specifies.

proc get_interior_point*(this: CollisionEntry, space: NodePath): LPoint3 {.importcpp: "#->get_interior_point(#)".} ## \
## Returns the point, within the interior of the "into" object, which
## represents the depth to which the "from" object has penetrated.  This can
## also be described as the intersection point on the surface of the "from"
## object (which is inside the "into" object).  It can be thought of as the
## deepest point of intersection.
##
## The point will be converted into whichever coordinate space the caller
## specifies.

proc get_all*(this: CollisionEntry, space: NodePath, surface_point: LPoint3, surface_normal: LVector3, interior_point: LPoint3): bool {.importcpp: "#->get_all(#, #, #, #)".} ## \
## Simultaneously transforms the surface point, surface normal, and interior
## point of the collision into the indicated coordinate space.
##
## Returns true if all three properties are available, or false if any one of
## them is not.

proc get_contact_pos*(this: CollisionEntry, space: NodePath): LPoint3 {.importcpp: "#->get_contact_pos(#)".} ## \
## Returns the position of the "from" object at the instant that a collision
## is first detected.
##
## The position will be converted into whichever coordinate space the caller
## specifies.

proc get_contact_normal*(this: CollisionEntry, space: NodePath): LVector3 {.importcpp: "#->get_contact_normal(#)".} ## \
## Returns the surface normal of the "into" object at the contact position.
##
## The normal will be converted into whichever coordinate space the caller
## specifies.

proc get_all_contact_info*(this: CollisionEntry, space: NodePath, contact_pos: LPoint3, contact_normal: LVector3): bool {.importcpp: "#->get_all_contact_info(#, #, #)".} ## \
## Simultaneously transforms the contact position and contact normal of the
## collision into the indicated coordinate space.
##
## Returns true if all three properties are available, or false if any one of
## them is not.

proc output*(this: CollisionEntry, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: CollisionEntry, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: CollisionEntry, `out`: ostream) {.importcpp: "#->write(#)".}

proc get_class_type*(_: typedesc[CollisionEntry]): TypeHandle {.importcpp: "CollisionEntry::get_class_type()", header: "collisionEntry.h".}

proc newCollisionPlane*(copy: CollisionPlane): CollisionPlane {.importcpp: "new CollisionPlane(#)".}

proc newCollisionPlane*(plane: LPlane): CollisionPlane {.importcpp: "new CollisionPlane(#)".}

proc get_normal*(this: CollisionPlane): LVector3 {.importcpp: "#->get_normal()".}

proc dist_to_plane*(this: CollisionPlane, point: LPoint3): float32 {.importcpp: "#->dist_to_plane(#)".}

proc set_plane*(this: CollisionPlane, plane: LPlane) {.importcpp: "#->set_plane(#)".}

proc get_plane*(this: CollisionPlane): LPlane {.importcpp: "#->get_plane()".}

proc flip*(this: CollisionPlane) {.importcpp: "#->flip()".} ## \
## Convenience method to flip the plane in-place.

proc get_class_type*(_: typedesc[CollisionPlane]): TypeHandle {.importcpp: "CollisionPlane::get_class_type()", header: "collisionPlane.h".}

proc newCollisionFloorMesh*(): CollisionFloorMesh {.importcpp: "new CollisionFloorMesh()".} ## \
## This is only for the convenience of CollisionPolygon.  Normally, you should
## not attempt to create an uninitialized CollisionPlane.

proc add_vertex*(this: CollisionFloorMesh, vert: LPoint3) {.importcpp: "#->add_vertex(#)".} ## \
## store away a vertex to index against

proc add_triangle*(this: CollisionFloorMesh, pointA: int, pointB: int, pointC: int) {.importcpp: "#->add_triangle(#, #, #)".} ## \
## store a triangle for processing

proc get_num_vertices*(this: CollisionFloorMesh): int {.importcpp: "#->get_num_vertices()".}

proc get_vertex*(this: CollisionFloorMesh, index: int): LPoint3 {.importcpp: "#->get_vertex(#)".}

proc get_num_triangles*(this: CollisionFloorMesh): int {.importcpp: "#->get_num_triangles()".}

proc get_triangle*(this: CollisionFloorMesh, index: int): LPoint3i {.importcpp: "#->get_triangle(#)".}

proc get_class_type*(_: typedesc[CollisionFloorMesh]): TypeHandle {.importcpp: "CollisionFloorMesh::get_class_type()", header: "collisionFloorMesh.h".}

proc newCollisionPolygon*(a: LVecBase3, b: LVecBase3, c: LVecBase3): CollisionPolygon {.importcpp: "new CollisionPolygon(#, #, #)".}

proc newCollisionPolygon*(a: LVecBase3, b: LVecBase3, c: LVecBase3, d: LVecBase3): CollisionPolygon {.importcpp: "new CollisionPolygon(#, #, #, #)".}

proc get_num_points*(this: CollisionPolygon): clonglong {.importcpp: "#->get_num_points()".} ## \
## Returns the number of vertices of the CollisionPolygon.

proc get_point*(this: CollisionPolygon, n: clonglong): LPoint3 {.importcpp: "#->get_point(#)".} ## \
## Returns the nth vertex of the CollisionPolygon, expressed in 3-D space.

proc verify_points*(_: typedesc[CollisionPolygon], a: LPoint3, b: LPoint3, c: LPoint3): bool {.importcpp: "CollisionPolygon::verify_points(#, #, #)", header: "collisionPolygon.h".} ## \
## Verifies that the indicated set of points will define a valid
## CollisionPolygon: that is, at least three non-collinear points, with no
## points repeated.

proc verify_points*(_: typedesc[CollisionPolygon], a: LPoint3, b: LPoint3, c: LPoint3, d: LPoint3): bool {.importcpp: "CollisionPolygon::verify_points(#, #, #, #)", header: "collisionPolygon.h".} ## \
## Verifies that the indicated set of points will define a valid
## CollisionPolygon: that is, at least three non-collinear points, with no
## points repeated.

proc is_valid*(this: CollisionPolygon): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the CollisionPolygon is valid (that is, it has at least
## three vertices), or false otherwise.

proc is_concave*(this: CollisionPolygon): bool {.importcpp: "#->is_concave()".} ## \
## Returns true if the CollisionPolygon appears to be concave, or false if it
## is safely convex.

proc get_class_type*(_: typedesc[CollisionPolygon]): TypeHandle {.importcpp: "CollisionPolygon::get_class_type()", header: "collisionPolygon.h".}

proc newCollisionHandlerEvent*(): CollisionHandlerEvent {.importcpp: "new CollisionHandlerEvent()".} ## \
## The default CollisionHandlerEvent will throw no events.  Its pattern
## strings must first be set via a call to add_in_pattern() and/or
## add_out_pattern().

proc newCollisionHandlerEvent*(param0: CollisionHandlerEvent): CollisionHandlerEvent {.importcpp: "new CollisionHandlerEvent(#)".}

proc clear_in_patterns*(this: CollisionHandlerEvent) {.importcpp: "#->clear_in_patterns()".} ## \
## Removes all of the previously-added in patterns.  See add_in_pattern.

proc add_in_pattern*(this: CollisionHandlerEvent, in_pattern: string) {.importcpp: "#->add_in_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a pattern string to the list of events that will be generated in
## response to a collision.  The pattern string describes how the event name
## will be composed.  It is a string that may contain any of the following:
##
## %fn  - the name of the "from" object's node %in  - the name of the "into"
## object's node %fs  - 't' if "from" is tangible, 'i' if intangible %is  -
## 't' if "into" is tangible, 'i' if intangible %ig  - 'c' if the collision is
## into a CollisionNode, 'g' if it is a geom.
##
## %(tag)fh - generate event only if "from" node has the indicated net tag.
## %(tag)fx - generate event only if "from" node does not have the indicated
## net tag.  %(tag)ih - generate event only if "into" node has the indicated
## net tag.  %(tag)ix - generate event only if "into" node does not have the
## indicated net tag.  %(tag)ft - the indicated net tag value of the "from"
## node.  %(tag)it - the indicated net tag value of the "into" node.
##
## Parentheses in the above are literal and should be included in the actual
## pattern.
##
## The event name will be based on the in_pattern string specified here, with
## all occurrences of the above strings replaced with the corresponding
## values.
##
## In general, the in_pattern event is thrown on the first detection of a
## collision between two particular nodes.  In subsequent passes, as long as a
## collision between those two nodes continues to be detected each frame, the
## again_pattern is thrown.  The first frame in which the collision is no
## longer detected, the out_pattern event is thrown.

proc set_in_pattern*(this: CollisionHandlerEvent, in_pattern: string) {.importcpp: "#->set_in_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## This method is deprecated; it completely replaces all the in patterns that
## have previously been set with the indicated pattern.
##
## @deprecated Use add_in_pattern() instead.

proc get_num_in_patterns*(this: CollisionHandlerEvent): int {.importcpp: "#->get_num_in_patterns()".} ## \
## Returns the number of in pattern strings that have been added.

proc get_in_pattern*(this: CollisionHandlerEvent, n: int): string {.importcpp: "nimStringFromStdString(#->get_in_pattern(#))", header: stringConversionCode.} ## \
## Returns the nth pattern string that indicates how the event names are
## generated for each collision detected.  See add_in_pattern().

proc clear_again_patterns*(this: CollisionHandlerEvent) {.importcpp: "#->clear_again_patterns()".} ## \
## Removes all of the previously-added in patterns.  See add_again_pattern.

proc add_again_pattern*(this: CollisionHandlerEvent, again_pattern: string) {.importcpp: "#->add_again_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds the pattern string that indicates how the event names are generated
## when a collision between two particular nodes is *still* detected.  This
## event is thrown each consecutive time a collision between two particular
## nodes is detected, starting with the second time.
##
## In general, the in_pattern event is thrown on the first detection of a
## collision between two particular nodes.  In subsequent passes, as long as a
## collision between those two nodes continues to be detected each frame, the
## again_pattern is thrown.  The first frame in which the collision is no
## longer detected, the out_pattern event is thrown.

proc set_again_pattern*(this: CollisionHandlerEvent, again_pattern: string) {.importcpp: "#->set_again_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## This method is deprecated; it completely replaces all the in patterns that
## have previously been set with the indicated pattern.
##
## @deprecated Use add_again_pattern() instead.

proc get_num_again_patterns*(this: CollisionHandlerEvent): int {.importcpp: "#->get_num_again_patterns()".} ## \
## Returns the number of in pattern strings that have been added.

proc get_again_pattern*(this: CollisionHandlerEvent, n: int): string {.importcpp: "nimStringFromStdString(#->get_again_pattern(#))", header: stringConversionCode.} ## \
## Returns the nth pattern string that indicates how the event names are
## generated for each collision detected.  See add_again_pattern().

proc clear_out_patterns*(this: CollisionHandlerEvent) {.importcpp: "#->clear_out_patterns()".} ## \
## Removes all of the previously-added in patterns.  See add_out_pattern.

proc add_out_pattern*(this: CollisionHandlerEvent, out_pattern: string) {.importcpp: "#->add_out_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds the pattern string that indicates how the event names are generated
## when a collision between two particular nodes is *no longer* detected.
##
## In general, the in_pattern event is thrown on the first detection of a
## collision between two particular nodes.  In subsequent passes, as long as a
## collision between those two nodes continues to be detected each frame, the
## again_pattern is thrown.  The first frame in which the collision is no
## longer detected, the out_pattern event is thrown.

proc set_out_pattern*(this: CollisionHandlerEvent, out_pattern: string) {.importcpp: "#->set_out_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## This method is deprecated; it completely replaces all the in patterns that
## have previously been set with the indicated pattern.
##
## @deprecated Use add_out_pattern() instead.

proc get_num_out_patterns*(this: CollisionHandlerEvent): int {.importcpp: "#->get_num_out_patterns()".} ## \
## Returns the number of in pattern strings that have been added.

proc get_out_pattern*(this: CollisionHandlerEvent, n: int): string {.importcpp: "nimStringFromStdString(#->get_out_pattern(#))", header: stringConversionCode.} ## \
## Returns the nth pattern string that indicates how the event names are
## generated for each collision detected.  See add_out_pattern().

proc clear*(this: CollisionHandlerEvent) {.importcpp: "#->clear()".} ## \
## Empties the list of elements that all colliders are known to be colliding
## with.  No "out" events will be thrown; if the same collision is detected
## next frame, a new "in" event will be thrown for each collision.
##
## This can be called each frame to defeat the persistent "in" event
## mechanism, which prevents the same "in" event from being thrown repeatedly.
## However, also see add_again_pattern(), which can be used to set the event
## that is thrown when a collision is detected for two or more consecutive
## frames.

proc flush*(this: CollisionHandlerEvent) {.importcpp: "#->flush()".} ## \
## Same as clear() except "out" events are thrown.

proc write_datagram*(this: CollisionHandlerEvent, destination: Datagram) {.importcpp: "#->write_datagram(#)".} ## \
## Serializes this object, to implement pickle support.

proc read_datagram*(this: CollisionHandlerEvent, source: DatagramIterator) {.importcpp: "#->read_datagram(#)".} ## \
## Restores the object state from the given datagram, previously obtained using
## __getstate__.

proc get_class_type*(_: typedesc[CollisionHandlerEvent]): TypeHandle {.importcpp: "CollisionHandlerEvent::get_class_type()", header: "collisionHandlerEvent.h".}

proc add_collider*(this: CollisionHandlerPhysical, collider: NodePath, target: NodePath) {.importcpp: "#->add_collider(#, #)".} ## \
## Adds a new collider to the list with a NodePath that will be updated with
## the collider's new position, or updates the existing collider with a new
## NodePath object.

proc add_collider*(this: CollisionHandlerPhysical, collider: NodePath, target: NodePath, drive_interface: DriveInterface) {.importcpp: "#->add_collider(#, #, #)".} ## \
## Adds a new collider to the list with a NodePath that will be updated with
## the collider's new position, or updates the existing collider with a new
## NodePath object.
##
## The indicated DriveInterface will also be updated with the target's new
## transform each frame.  This method should be used when the target is
## directly controlled by a DriveInterface.

proc remove_collider*(this: CollisionHandlerPhysical, collider: NodePath): bool {.importcpp: "#->remove_collider(#)".} ## \
## Removes the collider from the list of colliders that this handler knows
## about.

proc has_collider*(this: CollisionHandlerPhysical, collider: NodePath): bool {.importcpp: "#->has_collider(#)".} ## \
## Returns true if the handler knows about the indicated collider, false
## otherwise.

proc clear_colliders*(this: CollisionHandlerPhysical) {.importcpp: "#->clear_colliders()".} ## \
## Completely empties the list of colliders this handler knows about.

proc set_center*(this: CollisionHandlerPhysical, center: NodePath) {.importcpp: "#->set_center(#)".} ## \
## Specifies an arbitrary NodePath that the handler is always considered to be
## facing.  It does not detect collisions with surfaces that appear to be
## facing away from this NodePath.  This works best when the collision
## surfaces in question are polygons.

proc clear_center*(this: CollisionHandlerPhysical) {.importcpp: "#->clear_center()".} ## \
## Clears the center NodePath specified with set_center.

proc get_center*(this: CollisionHandlerPhysical): NodePath {.importcpp: "#->get_center()".} ## \
## Returns the NodePath specified with set_center, or the empty NodePath if
## nothing has been specified.

proc has_center*(this: CollisionHandlerPhysical): bool {.importcpp: "#->has_center()".} ## \
## Returns true if a NodePath has been specified with set_center(), false
## otherwise.

proc has_contact*(this: CollisionHandlerPhysical): bool {.importcpp: "#->has_contact()".} ## \
## Did the handler make any contacts with anything on the last collision pass?
## Depending on how your world is setup, this can be used to tell if the
## handler is out of the world (i.e.  out of bounds). That is the original use
## of this call.

proc get_class_type*(_: typedesc[CollisionHandlerPhysical]): TypeHandle {.importcpp: "CollisionHandlerPhysical::get_class_type()", header: "collisionHandlerPhysical.h".}

proc newCollisionHandlerFloor*(): CollisionHandlerFloor {.importcpp: "new CollisionHandlerFloor()".}

proc set_offset*(this: CollisionHandlerFloor, offset: float32) {.importcpp: "#->set_offset(#)".} ## \
## Sets the linear offset to add to (or subtract from) the highest detected
## collision point to determine the actual height at which to set the
## collider.

proc get_offset*(this: CollisionHandlerFloor): float32 {.importcpp: "#->get_offset()".} ## \
## Returns the linear offset to add to (or subtract from) the highest detected
## collision point to determine the actual height at which to set the
## collider.

proc set_reach*(this: CollisionHandlerFloor, reach: float32) {.importcpp: "#->set_reach(#)".} ## \
## Sets the reach to add to (or subtract from) the highest collision point

proc get_reach*(this: CollisionHandlerFloor): float32 {.importcpp: "#->get_reach()".} ## \
## Returns the reach to add to (or subtract from) the highest collision point

proc set_max_velocity*(this: CollisionHandlerFloor, max_vel: float32) {.importcpp: "#->set_max_velocity(#)".} ## \
## Sets the maximum speed at which the object will be allowed to descend
## towards a floor below it, in units per second.  Set this to zero to allow
## it to instantly teleport any distance.

proc get_max_velocity*(this: CollisionHandlerFloor): float32 {.importcpp: "#->get_max_velocity()".} ## \
## Retrieves the maximum speed at which the object will be allowed to descend
## towards a floor below it, in units per second.  See set_max_velocity().

proc write_datagram*(this: CollisionHandlerFloor, destination: Datagram) {.importcpp: "#->write_datagram(#)".} ## \
## Serializes this object, to implement pickle support.

proc read_datagram*(this: CollisionHandlerFloor, source: DatagramIterator) {.importcpp: "#->read_datagram(#)".} ## \
## Restores the object state from the given datagram, previously obtained using
## __getstate__.

proc get_class_type*(_: typedesc[CollisionHandlerFloor]): TypeHandle {.importcpp: "CollisionHandlerFloor::get_class_type()", header: "collisionHandlerFloor.h".}

proc newCollisionHandlerPusher*(): CollisionHandlerPusher {.importcpp: "new CollisionHandlerPusher()".}

proc set_horizontal*(this: CollisionHandlerPusher, flag: bool) {.importcpp: "#->set_horizontal(#)".}

proc get_horizontal*(this: CollisionHandlerPusher): bool {.importcpp: "#->get_horizontal()".}

proc write_datagram*(this: CollisionHandlerPusher, destination: Datagram) {.importcpp: "#->write_datagram(#)".} ## \
## Serializes this object, to implement pickle support.

proc read_datagram*(this: CollisionHandlerPusher, source: DatagramIterator) {.importcpp: "#->read_datagram(#)".} ## \
## Restores the object state from the given datagram, previously obtained using
## __getstate__.

proc get_class_type*(_: typedesc[CollisionHandlerPusher]): TypeHandle {.importcpp: "CollisionHandlerPusher::get_class_type()", header: "collisionHandlerPusher.h".}

proc newCollisionHandlerFluidPusher*(): CollisionHandlerFluidPusher {.importcpp: "new CollisionHandlerFluidPusher()".}

proc get_class_type*(_: typedesc[CollisionHandlerFluidPusher]): TypeHandle {.importcpp: "CollisionHandlerFluidPusher::get_class_type()", header: "collisionHandlerFluidPusher.h".}

proc newCollisionHandlerGravity*(): CollisionHandlerGravity {.importcpp: "new CollisionHandlerGravity()".}

proc set_offset*(this: CollisionHandlerGravity, offset: float32) {.importcpp: "#->set_offset(#)".} ## \
## Sets the linear offset to add to (or subtract from) the highest detected
## collision point to determine the actual height at which to set the
## collider.

proc get_offset*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_offset()".} ## \
## Returns the linear offset to add to (or subtract from) the highest detected
## collision point to determine the actual height at which to set the
## collider.

proc set_reach*(this: CollisionHandlerGravity, reach: float32) {.importcpp: "#->set_reach(#)".} ## \
## Sets the reach to add to (or subtract from) the highest collision point

proc get_reach*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_reach()".} ## \
## Returns the reach to add to (or subtract from) the highest collision point

proc get_airborne_height*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_airborne_height()".} ## \
## Return the height of the object from the ground.
##
## The object might not necessarily be at rest.  Use is_on_ground() if you
## want to know whether the object is on the ground and at rest.

proc is_on_ground*(this: CollisionHandlerGravity): bool {.importcpp: "#->is_on_ground()".} ## \
## Is the object at rest?

proc get_impact_velocity*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_impact_velocity()".} ## \
## How hard did the object hit the ground.  This value is set on impact with
## the ground.  You may want to watch (poll) on is_on_ground() and when that is
## true, call get_impact_velocity(). Normally I avoid polling, but we are
## calling is_on_ground() frequently anyway.

proc get_contact_normal*(this: CollisionHandlerGravity): LVector3 {.importcpp: "#->get_contact_normal()".}

proc add_velocity*(this: CollisionHandlerGravity, velocity: float32) {.importcpp: "#->add_velocity(#)".} ## \
## Adds the sepcified amount to the current velocity.  This is mostly here
## allow this common operation to be faster for scripting, but it's also more
## concise even in cpp.

proc set_velocity*(this: CollisionHandlerGravity, velocity: float32) {.importcpp: "#->set_velocity(#)".} ## \
## Sets the current vertical velocity.

proc get_velocity*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_velocity()".} ## \
## Gets the current vertical velocity.
##
## Generally, negative values mean the object is in free fall; while postive
## values mean the object has vertical thrust.
##
## A zero value does not necessarily mean the object on the ground, it may
## also be weightless and/or at the apex of its jump.
##
## See Also: is_on_ground() and get_gravity()

proc set_gravity*(this: CollisionHandlerGravity, gravity: float32) {.importcpp: "#->set_gravity(#)".} ## \
## Sets the linear gravity force (always plumb).

proc get_gravity*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_gravity()".} ## \
## Gets the linear gravity force (always plumb).

proc set_max_velocity*(this: CollisionHandlerGravity, max_vel: float32) {.importcpp: "#->set_max_velocity(#)".} ## \
## Sets the maximum speed at which the object will be allowed to descend
## towards a floor below it, in units per second.  Set this to zero to allow
## it to instantly teleport any distance.

proc get_max_velocity*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_max_velocity()".} ## \
## Retrieves the maximum speed at which the object will be allowed to descend
## towards a floor below it, in units per second.  See set_max_velocity().

proc set_legacy_mode*(this: CollisionHandlerGravity, legacy_mode: bool) {.importcpp: "#->set_legacy_mode(#)".} ## \
## Enables old behavior required by Toontown (Sellbot Factory lava room is
## good test case, lava and conveyor belt specifically). Behavior is to throw
## enter/exit events only for floor that the toon is in contact with

proc get_legacy_mode*(this: CollisionHandlerGravity): bool {.importcpp: "#->get_legacy_mode()".} ## \
## returns true if legacy mode is enabled

proc write_datagram*(this: CollisionHandlerGravity, destination: Datagram) {.importcpp: "#->write_datagram(#)".} ## \
## Serializes this object, to implement pickle support.

proc read_datagram*(this: CollisionHandlerGravity, source: DatagramIterator) {.importcpp: "#->read_datagram(#)".} ## \
## Restores the object state from the given datagram, previously obtained using
## __getstate__.

proc get_class_type*(_: typedesc[CollisionHandlerGravity]): TypeHandle {.importcpp: "CollisionHandlerGravity::get_class_type()", header: "collisionHandlerGravity.h".}

proc newCollisionHandlerHighestEvent*(): CollisionHandlerHighestEvent {.importcpp: "new CollisionHandlerHighestEvent()".} ## \
## The default CollisionHandlerEvent will throw no events.  Its pattern
## strings must first be set via a call to add_in_pattern() and/or
## add_out_pattern().

proc newCollisionHandlerHighestEvent*(param0: CollisionHandlerHighestEvent): CollisionHandlerHighestEvent {.importcpp: "new CollisionHandlerHighestEvent(#)".}

proc get_class_type*(_: typedesc[CollisionHandlerHighestEvent]): TypeHandle {.importcpp: "CollisionHandlerHighestEvent::get_class_type()", header: "collisionHandlerHighestEvent.h".}

proc newCollisionHandlerQueue*(): CollisionHandlerQueue {.importcpp: "new CollisionHandlerQueue()".}

proc newCollisionHandlerQueue*(param0: CollisionHandlerQueue): CollisionHandlerQueue {.importcpp: "new CollisionHandlerQueue(#)".}

proc sort_entries*(this: CollisionHandlerQueue) {.importcpp: "#->sort_entries()".} ## \
## Sorts all the detected collisions front-to-back by
## from_intersection_point() so that those intersection points closest to the
## collider's origin (e.g., the center of the CollisionSphere, or the point_a
## of a CollisionSegment) appear first.

proc clear_entries*(this: CollisionHandlerQueue) {.importcpp: "#->clear_entries()".} ## \
## Removes all the entries from the queue.

proc get_num_entries*(this: CollisionHandlerQueue): int {.importcpp: "#->get_num_entries()".} ## \
## Returns the number of CollisionEntries detected last pass.

proc get_entry*(this: CollisionHandlerQueue, n: int): CollisionEntry {.importcpp: "#->get_entry(#)".} ## \
## Returns the nth CollisionEntry detected last pass.

proc output*(this: CollisionHandlerQueue, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: CollisionHandlerQueue, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: CollisionHandlerQueue, `out`: ostream) {.importcpp: "#->write(#)".}

proc get_class_type*(_: typedesc[CollisionHandlerQueue]): TypeHandle {.importcpp: "CollisionHandlerQueue::get_class_type()", header: "collisionHandlerQueue.h".}

proc newCollisionSphere*(center: LPoint3, radius: float32): CollisionSphere {.importcpp: "new CollisionSphere(#, #)".}

proc newCollisionSphere*(cx: float32, cy: float32, cz: float32, radius: float32): CollisionSphere {.importcpp: "new CollisionSphere(#, #, #, #)".}

proc set_center*(this: CollisionSphere, center: LPoint3) {.importcpp: "#->set_center(#)".}

proc set_center*(this: CollisionSphere, x: float32, y: float32, z: float32) {.importcpp: "#->set_center(#, #, #)".}

proc get_center*(this: CollisionSphere): LPoint3 {.importcpp: "#->get_center()".}

proc set_radius*(this: CollisionSphere, radius: float32) {.importcpp: "#->set_radius(#)".}

proc get_radius*(this: CollisionSphere): float32 {.importcpp: "#->get_radius()".}

proc get_class_type*(_: typedesc[CollisionSphere]): TypeHandle {.importcpp: "CollisionSphere::get_class_type()", header: "collisionSphere.h".}

proc newCollisionInvSphere*(center: LPoint3, radius: float32): CollisionInvSphere {.importcpp: "new CollisionInvSphere(#, #)".}

proc newCollisionInvSphere*(cx: float32, cy: float32, cz: float32, radius: float32): CollisionInvSphere {.importcpp: "new CollisionInvSphere(#, #, #, #)".}

proc get_class_type*(_: typedesc[CollisionInvSphere]): TypeHandle {.importcpp: "CollisionInvSphere::get_class_type()", header: "collisionInvSphere.h".}

proc newCollisionRay*(): CollisionRay {.importcpp: "new CollisionRay()".} ## \
## Creates an invalid ray.  This isn't terribly useful; it's expected that the
## user will subsequently adjust the ray via set_origin()/set_direction() or
## set_from_lens().

proc newCollisionRay*(origin: LPoint3, direction: LVector3): CollisionRay {.importcpp: "new CollisionRay(#, #)".}

proc newCollisionRay*(ox: float32, oy: float32, oz: float32, dx: float32, dy: float32, dz: float32): CollisionRay {.importcpp: "new CollisionRay(#, #, #, #, #, #)".}

proc set_origin*(this: CollisionRay, origin: LPoint3) {.importcpp: "#->set_origin(#)".}

proc set_origin*(this: CollisionRay, x: float32, y: float32, z: float32) {.importcpp: "#->set_origin(#, #, #)".}

proc get_origin*(this: CollisionRay): LPoint3 {.importcpp: "#->get_origin()".}

proc set_direction*(this: CollisionRay, direction: LVector3) {.importcpp: "#->set_direction(#)".}

proc set_direction*(this: CollisionRay, x: float32, y: float32, z: float32) {.importcpp: "#->set_direction(#, #, #)".}

proc get_direction*(this: CollisionRay): LVector3 {.importcpp: "#->get_direction()".}

proc set_from_lens*(this: CollisionRay, camera: LensNode, point: LPoint2): bool {.importcpp: "#->set_from_lens(#, #)".} ## \
## Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
## CollisionRay so that it begins at the LensNode's near plane and extends to
## infinity, making it suitable for picking objects from the screen given a
## camera and a mouse location.
##
## Returns true if the point was acceptable, false otherwise.

proc set_from_lens*(this: CollisionRay, camera: LensNode, px: float32, py: float32): bool {.importcpp: "#->set_from_lens(#, #, #)".} ## \
## Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
## CollisionRay so that it begins at the LensNode's near plane and extends to
## infinity, making it suitable for picking objects from the screen given a
## camera and a mouse location.

proc get_class_type*(_: typedesc[CollisionRay]): TypeHandle {.importcpp: "CollisionRay::get_class_type()", header: "collisionRay.h".}

proc newCollisionLine*(): CollisionLine {.importcpp: "new CollisionLine()".} ## \
## Creates an invalid line.  This isn't terribly useful; it's expected that
## the user will subsequently adjust the line via set_origin()/set_direction()
## or set_from_lens().

proc newCollisionLine*(origin: LPoint3, direction: LVector3): CollisionLine {.importcpp: "new CollisionLine(#, #)".}

proc newCollisionLine*(ox: float32, oy: float32, oz: float32, dx: float32, dy: float32, dz: float32): CollisionLine {.importcpp: "new CollisionLine(#, #, #, #, #, #)".}

proc get_class_type*(_: typedesc[CollisionLine]): TypeHandle {.importcpp: "CollisionLine::get_class_type()", header: "collisionLine.h".}

proc newCollisionParabola*(): CollisionParabola {.importcpp: "new CollisionParabola()".} ## \
## Creates an invalid parabola.

proc newCollisionParabola*(parabola: LParabola, t1: float32, t2: float32): CollisionParabola {.importcpp: "new CollisionParabola(#, #, #)".} ## \
## Creates a parabola with the endpoints between t1 and t2 in the parametric
## space of the parabola.

proc set_parabola*(this: CollisionParabola, parabola: LParabola) {.importcpp: "#->set_parabola(#)".} ## \
## Replaces the parabola specified by this solid.

proc get_parabola*(this: CollisionParabola): LParabola {.importcpp: "#->get_parabola()".} ## \
## Returns the parabola specified by this solid.

proc set_t1*(this: CollisionParabola, t1: float32) {.importcpp: "#->set_t1(#)".} ## \
## Changes the starting point on the parabola.

proc get_t1*(this: CollisionParabola): float32 {.importcpp: "#->get_t1()".} ## \
## Returns the starting point on the parabola.

proc set_t2*(this: CollisionParabola, t2: float32) {.importcpp: "#->set_t2(#)".} ## \
## Changes the ending point on the parabola.

proc get_t2*(this: CollisionParabola): float32 {.importcpp: "#->get_t2()".} ## \
## Returns the ending point on the parabola.

proc get_class_type*(_: typedesc[CollisionParabola]): TypeHandle {.importcpp: "CollisionParabola::get_class_type()", header: "collisionParabola.h".}

proc newCollisionSegment*(): CollisionSegment {.importcpp: "new CollisionSegment()".} ## \
## Creates an invalid segment.  This isn't terribly useful; it's expected that
## the user will subsequently adjust the segment via
## set_origin()/set_direction() or set_from_lens().

proc newCollisionSegment*(a: LPoint3, db: LPoint3): CollisionSegment {.importcpp: "new CollisionSegment(#, #)".}

proc newCollisionSegment*(ax: float32, ay: float32, az: float32, bx: float32, by: float32, bz: float32): CollisionSegment {.importcpp: "new CollisionSegment(#, #, #, #, #, #)".}

proc set_point_a*(this: CollisionSegment, a: LPoint3) {.importcpp: "#->set_point_a(#)".}

proc set_point_a*(this: CollisionSegment, x: float32, y: float32, z: float32) {.importcpp: "#->set_point_a(#, #, #)".}

proc get_point_a*(this: CollisionSegment): LPoint3 {.importcpp: "#->get_point_a()".}

proc set_point_b*(this: CollisionSegment, b: LPoint3) {.importcpp: "#->set_point_b(#)".}

proc set_point_b*(this: CollisionSegment, x: float32, y: float32, z: float32) {.importcpp: "#->set_point_b(#, #, #)".}

proc get_point_b*(this: CollisionSegment): LPoint3 {.importcpp: "#->get_point_b()".}

proc set_from_lens*(this: CollisionSegment, camera: LensNode, point: LPoint2): bool {.importcpp: "#->set_from_lens(#, #)".} ## \
## Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
## CollisionSegment so that it begins at the LensNode's near plane and extends
## to the far plane, making it suitable for picking objects from the screen
## given a camera and a mouse location.
##
## Returns true if the point was acceptable, false otherwise.

proc set_from_lens*(this: CollisionSegment, camera: LensNode, px: float32, py: float32): bool {.importcpp: "#->set_from_lens(#, #, #)".} ## \
## Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
## CollisionSegment so that it begins at the LensNode's near plane and extends
## to the far plane, making it suitable for picking objects from the screen
## given a camera and a mouse location.

proc get_class_type*(_: typedesc[CollisionSegment]): TypeHandle {.importcpp: "CollisionSegment::get_class_type()", header: "collisionSegment.h".}

converter upcast_to_PandaNode*(this: CollisionVisualizer): PandaNode {.importcpp: "(PT(PandaNode)(#))".}

converter upcast_to_CollisionRecorder*(this: CollisionVisualizer): CollisionRecorder {.importcpp: "((CollisionRecorder *)(#.p()))".}

proc newCollisionVisualizer*(copy: CollisionVisualizer): CollisionVisualizer {.importcpp: "new CollisionVisualizer(#)".} ## \
## Copy constructor.

proc newCollisionVisualizer*(name: string): CollisionVisualizer {.importcpp: "new CollisionVisualizer(nimStringToStdString(#))", header: stringConversionCode.}

proc set_point_scale*(this: CollisionVisualizer, point_scale: float32) {.importcpp: "#->set_point_scale(#)".} ## \
## Scales the points that are drawn to represent the surface and interior
## intersection points of the collisions.  By default, these objects are drawn
## at an arbitrary scale which is appropriate if the window units are the
## default range -1 .. 1.  Change this scale accordinatly if the window units
## are measured on some other scale or if you need to observe these objects in
## a smaller window.

proc get_point_scale*(this: CollisionVisualizer): float32 {.importcpp: "#->get_point_scale()".} ## \
## Returns the value last set by set_point_scale().

proc set_normal_scale*(this: CollisionVisualizer, normal_scale: float32) {.importcpp: "#->set_normal_scale(#)".} ## \
## Scales the line segments that are drawn to represent the normals of the
## collisions.  By default, these objects are drawn at an arbitrary scale
## which is appropriate if the scene units are measured in feet.  Change this
## scale accordinatly if the scene units are measured on some other scale or
## if you need to observe these normals from farther away.

proc get_normal_scale*(this: CollisionVisualizer): float32 {.importcpp: "#->get_normal_scale()".} ## \
## Returns the value last set by set_normal_scale().

proc clear*(this: CollisionVisualizer) {.importcpp: "#->clear()".} ## \
## Removes all the visualization data from a previous traversal and resets the
## visualizer to empty.

proc get_class_type*(_: typedesc[CollisionVisualizer]): TypeHandle {.importcpp: "CollisionVisualizer::get_class_type()", header: "collisionVisualizer.h".}

proc has_tracker*(this: InputDevice): bool {.importcpp: "#->has_tracker()".} ## \
## Returns true if the device features a tracker that can track position and/or
## orientation in 3D space.

proc has_battery*(this: InputDevice): bool {.importcpp: "#->has_battery()".} ## \
## Returns true if the device may be able to provide information about its
## battery life.

proc get_num_buttons*(this: InputDevice): clonglong {.importcpp: "#->get_num_buttons()".} ## \
## Returns the number of buttons known to the device.  This includes those
## buttons whose state has been seen, as well as buttons that have been
## associated with a ButtonHandle even if their state is unknown.  This number
## may change as more buttons are discovered.

proc get_num_axes*(this: InputDevice): clonglong {.importcpp: "#->get_num_axes()".} ## \
## Returns the number of analog axes known to the InputDevice.  This number
## may change as more axes are discovered.

proc map_button*(this: InputDevice, index: clonglong, handle: ButtonHandle) {.importcpp: "#->map_button(#, #)".} ## \
## Associates the indicated ButtonHandle with the button of the indicated index
## number.  When the given button index changes state, a corresponding
## ButtonEvent will be generated with the given ButtonHandle.  Pass
## ButtonHandle::none() to turn off any association.
##
## It is not necessary to call this if you simply want to query the state of
## the various buttons by index number; this is only necessary in order to
## generate ButtonEvents when the buttons change state.

proc set_vibration*(this: InputDevice, strong: float64, weak: float64) {.importcpp: "#->set_vibration(#, #)".} ## \
## Sets the strength of the vibration effect, if supported.  The values are
## clamped to 0-1 range. The first value axes the low-frequency rumble
## motor, whereas the second axes the high-frequency motor, if present.

proc enable_pointer_events*(this: InputDevice) {.importcpp: "#->enable_pointer_events()".} ## \
## Enables the generation of mouse-movement events.

proc disable_pointer_events*(this: InputDevice) {.importcpp: "#->disable_pointer_events()".} ## \
## Disables the generation of mouse-movement events.

proc poll*(this: InputDevice) {.importcpp: "#->poll()".} ## \
## Polls the input device for new activity, to ensure it contains the latest
## events.  This will only have any effect for some types of input devices;
## others may be updated automatically, and this method will be a no-op.

proc has_button_event*(this: InputDevice): bool {.importcpp: "#->has_button_event()".} ## \
## Returns true if this device has a pending button event (a mouse button or
## keyboard button down/up), false otherwise.  If this returns true, the
## particular event may be extracted via get_button_event().

proc get_button_events*(this: InputDevice): ButtonEventList {.importcpp: "#->get_button_events()".} ## \
## Returns the list of recently-generated ButtonEvents.
## The list is also cleared.

proc has_pointer_event*(this: InputDevice): bool {.importcpp: "#->has_pointer_event()".} ## \
## Returns true if this device has a pending pointer event (a mouse movement),
## or false otherwise.  If this returns true, the particular event may be
## extracted via get_pointer_event().

proc get_pointer_events*(this: InputDevice): PointerEventList {.importcpp: "#->get_pointer_events()".} ## \
## Returns a PointerEventList containing all the recent pointer events.
## Clears the list.

proc output*(this: InputDevice, `out`: ostream) {.importcpp: "#->output(#)".} ## \
## Writes a one-line string describing the device.

proc get_class_type*(_: typedesc[InputDevice]): TypeHandle {.importcpp: "InputDevice::get_class_type()", header: "inputDevice.h".}

proc fork_asynchronous_thread*(this: ClientBase, poll_time: float64): bool {.importcpp: "#->fork_asynchronous_thread(#)".} ## \
## Forks a separate thread to do all the polling of connected devices.  The
## forked thread will poll after every poll_time seconds has elapsed.  Returns
## true if the fork was successful, or false otherwise (for instance, because
## we were already forked, or because asynchronous threads are disabled).

proc is_forked*(this: ClientBase): bool {.importcpp: "#->is_forked()".} ## \
## Returns true if the ClientBase has been forked (and, therefore, poll() does
## not need to be called), false otherwise.

proc poll*(this: ClientBase): bool {.importcpp: "#->poll()".} ## \
## Initiates a poll of the client devices, if we are not forked and if we have
## not already polled this frame.  Returns true if the poll occurred, or false
## if it did not.

proc get_last_poll_time*(this: ClientBase): float64 {.importcpp: "#->get_last_poll_time()".} ## \
## Returns the time (according to the global ClockObject's get_real_time()
## method) of the last device poll.

proc set_coordinate_system*(this: ClientBase, cs: CoordinateSystem) {.importcpp: "#->set_coordinate_system(#)".} ## \
## Specifies the coordinate system that all devices associated with this
## client will operate in.  Normally, this is CS_default.

proc get_coordinate_system*(this: ClientBase): CoordinateSystem {.importcpp: "#->get_coordinate_system()".} ## \
## Returns the coordinate system that all devices associated with this client
## will operate in.  Normally, this is CS_default.

proc get_class_type*(_: typedesc[ClientBase]): TypeHandle {.importcpp: "ClientBase::get_class_type()", header: "clientBase.h".}

proc newAnalogNode*(param0: AnalogNode): AnalogNode {.importcpp: "new AnalogNode(#)".}

proc newAnalogNode*(client: ClientBase, device_name: string): AnalogNode {.importcpp: "new AnalogNode(#, nimStringToStdString(#))", header: stringConversionCode.}

proc newAnalogNode*(device: InputDevice): AnalogNode {.importcpp: "new AnalogNode(#)".}

proc is_valid*(this: AnalogNode): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the AnalogNode is valid and connected to a server, false
## otherwise.

proc get_num_controls*(this: AnalogNode): int {.importcpp: "#->get_num_controls()".} ## \
## Returns the number of analog controls known to the AnalogNode.  This number
## may change as more controls are discovered.

proc get_control_state*(this: AnalogNode, index: int): float64 {.importcpp: "#->get_control_state(#)".} ## \
## Returns the current position of indicated analog control identified by its
## index number, or 0.0 if the control is unknown.  The normal range of a
## single control is -1.0 to 1.0.

proc is_control_known*(this: AnalogNode, index: int): bool {.importcpp: "#->is_control_known(#)".} ## \
## Returns true if the state of the indicated analog control is known, or
## false if we have never heard anything about this particular control.

proc set_output*(this: AnalogNode, channel: int, index: int, flip: bool) {.importcpp: "#->set_output(#, #, #)".} ## \
## Causes a particular analog control to be placed in the data graph for the
## indicated channel.  Normally, a mouse uses channels 0 and 1 for the X and Y
## information, respectively; channels 0, 1, and 2 are available.  If flip is
## true, the analog control value will be reversed before outputting it.

proc clear_output*(this: AnalogNode, channel: int) {.importcpp: "#->clear_output(#)".} ## \
## Removes the output to the data graph associated with the indicated channel.
## See set_output().

proc get_output*(this: AnalogNode, channel: int): int {.importcpp: "#->get_output(#)".} ## \
## Returns the analog control index that is output to the data graph on the
## indicated channel, or -1 if no control is output on that channel.  See
## set_output().

proc is_output_flipped*(this: AnalogNode, channel: int): bool {.importcpp: "#->is_output_flipped(#)".} ## \
## Returns true if the analog control index that is output to the data graph
## on the indicated channel is flipped.  See set_output().

proc get_class_type*(_: typedesc[AnalogNode]): TypeHandle {.importcpp: "AnalogNode::get_class_type()", header: "analogNode.h".}

proc newButtonNode*(param0: ButtonNode): ButtonNode {.importcpp: "new ButtonNode(#)".}

proc newButtonNode*(client: ClientBase, device_name: string): ButtonNode {.importcpp: "new ButtonNode(#, nimStringToStdString(#))", header: stringConversionCode.}

proc newButtonNode*(device: InputDevice): ButtonNode {.importcpp: "new ButtonNode(#)".}

proc is_valid*(this: ButtonNode): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the ButtonNode is valid and connected to a server, false
## otherwise.

proc get_num_buttons*(this: ButtonNode): int {.importcpp: "#->get_num_buttons()".} ## \
## Returns the number of buttons known to the ButtonNode.  This includes those
## buttons whose state has been seen, as well as buttons that have been
## associated with a ButtonHandle even if their state is unknown.  This number
## may change as more buttons are discovered.

proc set_button_map*(this: ButtonNode, index: int, button: ButtonHandle) {.importcpp: "#->set_button_map(#, #)".} ## \
## Associates the indicated ButtonHandle with the button of the indicated
## index number.  When the given button index changes state, a corresponding
## ButtonEvent will be generated with the given ButtonHandle.  Pass
## ButtonHandle::none() to turn off any association.
##
## It is not necessary to call this if you simply want to query the state of
## the various buttons by index number; this is only necessary in order to
## generate ButtonEvents when the buttons change state.

proc get_button_map*(this: ButtonNode, index: int): ButtonHandle {.importcpp: "#->get_button_map(#)".} ## \
## Returns the ButtonHandle that was previously associated with the given
## index number by a call to set_button_map(), or ButtonHandle::none() if no
## button was associated.

proc get_button_state*(this: ButtonNode, index: int): bool {.importcpp: "#->get_button_state(#)".} ## \
## Returns true if the indicated button (identified by its index number) is
## currently known to be down, or false if it is up or unknown.

proc is_button_known*(this: ButtonNode, index: int): bool {.importcpp: "#->is_button_known(#)".} ## \
## Returns true if the state of the indicated button is known, or false if we
## have never heard anything about this particular button.

proc get_class_type*(_: typedesc[ButtonNode]): TypeHandle {.importcpp: "ButtonNode::get_class_type()", header: "buttonNode.h".}

proc newDialNode*(client: ClientBase, device_name: string): DialNode {.importcpp: "new DialNode(#, nimStringToStdString(#))", header: stringConversionCode.}

proc newDialNode*(param0: DialNode): DialNode {.importcpp: "new DialNode(#)".}

proc is_valid*(this: DialNode): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the DialNode is valid and connected to a server, false
## otherwise.

proc get_num_dials*(this: DialNode): int {.importcpp: "#->get_num_dials()".} ## \
## Returns the number of dial dials known to the DialNode.  This number may
## change as more dials are discovered.

proc read_dial*(this: DialNode, index: int): float64 {.importcpp: "#->read_dial(#)".} ## \
## Returns the number of complete revolutions of the dial since the last time
## read_dial() was called.  This is a destructive operation; it is not
## possible to read the dial without resetting the counter.

proc is_dial_known*(this: DialNode, index: int): bool {.importcpp: "#->is_dial_known(#)".} ## \
## Returns true if the state of the indicated dial dial is known, or false if
## we have never heard anything about this particular dial.

proc get_class_type*(_: typedesc[DialNode]): TypeHandle {.importcpp: "DialNode::get_class_type()", header: "dialNode.h".}

proc initInputDeviceSet*(): InputDeviceSet {.importcpp: "InputDeviceSet()".}

proc initInputDeviceSet*(copy: InputDeviceSet): InputDeviceSet {.importcpp: "InputDeviceSet(#)".}

proc clear*(this: InputDeviceSet) {.importcpp: "#.clear()".} ## \
## Removes all InputDevices from the collection.

proc reserve*(this: InputDeviceSet, num: clonglong) {.importcpp: "#.reserve(#)".} ## \
## This is a hint to Panda to allocate enough memory to hold the given number
## of InputDevices, if you know ahead of time how many you will be adding.

proc `[]`*(this: InputDeviceSet, index: clonglong): InputDevice {.importcpp: "#.operator [](#)".} ## \
## Returns the nth InputDevice in the collection.

proc size*(this: InputDeviceSet): clonglong {.importcpp: "#.size()".} ## \
## Returns the number of devices in the collection.

proc output*(this: InputDeviceSet, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes a brief one-line description of the InputDeviceSet to the indicated
## output stream.

proc write*(this: InputDeviceSet, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes a complete multi-line description of the InputDeviceSet to the
## indicated output stream.

proc write*(this: InputDeviceSet, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a complete multi-line description of the InputDeviceSet to the
## indicated output stream.

proc get_devices*(this: InputDeviceManager): InputDeviceSet {.importcpp: "#.get_devices()".} ## \
## Description: Returns all currently connected devices.

proc add_device*(this: InputDeviceManager, device: InputDevice) {.importcpp: "#.add_device(#)".} ## \
## Called when a new device has been discovered.  This may also be used to
## register virtual devices.
##
## This causes a connect-device event to be thrown.

proc remove_device*(this: InputDeviceManager, device: InputDevice) {.importcpp: "#.remove_device(#)".} ## \
## Called when a device has been removed, or when a device should otherwise no
## longer be tracked.
##
## This causes a disconnect-device event to be thrown.

proc update*(this: InputDeviceManager) {.importcpp: "#.update()".} ## \
## Polls the system to see if there are any new devices.  In some
## implementations this is a no-op.

proc get_global_ptr*(_: typedesc[InputDeviceManager]): InputDeviceManager {.importcpp: "InputDeviceManager::get_global_ptr()", header: "inputDeviceManager.h".} ## \
## Returns the singleton InputDeviceManager instance.

proc newInputDeviceNode*(device: InputDevice, name: string): InputDeviceNode {.importcpp: "new InputDeviceNode(#, nimStringToStdString(#))", header: stringConversionCode.}

proc newInputDeviceNode*(param0: InputDeviceNode): InputDeviceNode {.importcpp: "new InputDeviceNode(#)".}

proc get_class_type*(_: typedesc[InputDeviceNode]): TypeHandle {.importcpp: "InputDeviceNode::get_class_type()", header: "inputDeviceNode.h".}

proc newTrackerNode*(client: ClientBase, device_name: string): TrackerNode {.importcpp: "new TrackerNode(#, nimStringToStdString(#))", header: stringConversionCode.}

proc newTrackerNode*(device: InputDevice): TrackerNode {.importcpp: "new TrackerNode(#)".}

proc newTrackerNode*(param0: TrackerNode): TrackerNode {.importcpp: "new TrackerNode(#)".}

proc is_valid*(this: TrackerNode): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the TrackerNode is valid and connected to a server, false
## otherwise.

proc get_pos*(this: TrackerNode): LPoint3 {.importcpp: "#->get_pos()".} ## \
## Returns the current position of the tracker, if it is available.

proc get_orient*(this: TrackerNode): LOrientation {.importcpp: "#->get_orient()".} ## \
## Returns the current orientation of the tracker, if it is available.

proc get_transform*(this: TrackerNode): LMatrix4 {.importcpp: "#->get_transform()".} ## \
## Returns the current position and orientation of the tracker, as a combined
## matrix.

proc get_time*(this: TrackerNode): float64 {.importcpp: "#->get_time()".} ## \
## Returns the time of the tracker's last update.

proc has_time*(this: TrackerNode): bool {.importcpp: "#->has_time()".} ## \
## True if this data comes with timestamps.

proc set_tracker_coordinate_system*(this: TrackerNode, cs: CoordinateSystem) {.importcpp: "#->set_tracker_coordinate_system(#)".} ## \
## Specifies the coordinate system that the tracker associated with this node
## will operate in.  Normally, this is set from the ClientBase that's used to
## create the TrackerNode, so it should not need to be set on an individual
## tracker basis.

proc get_tracker_coordinate_system*(this: TrackerNode): CoordinateSystem {.importcpp: "#->get_tracker_coordinate_system()".} ## \
## Returns the coordinate system that the tracker associated with this node
## will operate in.

proc set_graph_coordinate_system*(this: TrackerNode, cs: CoordinateSystem) {.importcpp: "#->set_graph_coordinate_system(#)".} ## \
## Specifies the coordinate system that the TrackerNode will convert its
## transform into for passing down the data graph.  Normally, this is
## CS_default.

proc get_graph_coordinate_system*(this: TrackerNode): CoordinateSystem {.importcpp: "#->get_graph_coordinate_system()".} ## \
## Returns the coordinate system that the TrackerNode will convert its
## transform into for passing down the data graph.  Normally, this is
## CS_default.

proc get_class_type*(_: typedesc[TrackerNode]): TypeHandle {.importcpp: "TrackerNode::get_class_type()", header: "trackerNode.h".}

proc newVirtualMouse*(param0: VirtualMouse): VirtualMouse {.importcpp: "new VirtualMouse(#)".}

proc newVirtualMouse*(name: string): VirtualMouse {.importcpp: "new VirtualMouse(nimStringToStdString(#))", header: stringConversionCode.}

proc set_mouse_pos*(this: VirtualMouse, x: int, y: int) {.importcpp: "#->set_mouse_pos(#, #)".} ## \
## Sets the current mouse pixel location, where (0,0) is the upper left, and
## (width-1, height-1) is the lower right pixel of the virtual window.

proc set_window_size*(this: VirtualMouse, width: int, height: int) {.importcpp: "#->set_window_size(#, #)".} ## \
## Sets the size of the "window" in which the mouse rolls.  This changes the
## meaning of the values passed to set_mouse_pos().

proc set_mouse_on*(this: VirtualMouse, flag: bool) {.importcpp: "#->set_mouse_on(#)".} ## \
## Sets whether the mouse should appear to be within the window or not.  If
## this is true, the mouse is within the window; if false, the mouse is not
## within the window (and set_mouse_pos() means nothing).

proc press_button*(this: VirtualMouse, button: ButtonHandle) {.importcpp: "#->press_button(#)".} ## \
## Simulates a mouse or keyboard button being depressed.  This should be
## followed up by a call to release_button() sometime later (possibly
## immediately).

proc release_button*(this: VirtualMouse, button: ButtonHandle) {.importcpp: "#->release_button(#)".} ## \
## Simulates the button being released.  This should follow a previous call to
## press_button().

proc get_class_type*(_: typedesc[VirtualMouse]): TypeHandle {.importcpp: "VirtualMouse::get_class_type()", header: "virtualMouse.h".}

proc initDataGraphTraverser*(param0: DataGraphTraverser): DataGraphTraverser {.importcpp: "DataGraphTraverser(#)".}

proc initDataGraphTraverser*(current_thread: Thread): DataGraphTraverser {.importcpp: "DataGraphTraverser(#)".}

proc initDataGraphTraverser*(): DataGraphTraverser {.importcpp: "DataGraphTraverser()".}

proc get_current_thread*(this: DataGraphTraverser): Thread {.importcpp: "#.get_current_thread()".} ## \
## Returns the currently-executing thread object, as passed to the
## DataGraphTraverser constructor.

proc traverse*(this: DataGraphTraverser, node: PandaNode) {.importcpp: "#.traverse(#)".} ## \
## Starts the traversal of the data graph at the indicated root node.

proc collect_leftovers*(this: DataGraphTraverser) {.importcpp: "#.collect_leftovers()".} ## \
## Pick up any nodes that didn't get completely traversed.  These must be
## nodes that have multiple parents, with at least one parent completely
## outside of the data graph.

proc newDataNode*(name: string): DataNode {.importcpp: "new DataNode(nimStringToStdString(#))", header: stringConversionCode.}

proc write_inputs*(this: DataNode, `out`: ostream) {.importcpp: "#->write_inputs(#)".} ## \
## Writes to the indicated ostream a list of all the inputs this DataNode
## might expect to receive.

proc write_outputs*(this: DataNode, `out`: ostream) {.importcpp: "#->write_outputs(#)".} ## \
## Writes to the indicated ostream a list of all the outputs this DataNode
## might generate.

proc write_connections*(this: DataNode, `out`: ostream) {.importcpp: "#->write_connections(#)".} ## \
## Writes to the indicated ostream a list of all the connections currently
## showing between this DataNode and its parent(s).

proc get_class_type*(_: typedesc[DataNode]): TypeHandle {.importcpp: "DataNode::get_class_type()", header: "dataNode.h".}

proc get_pipe*(this: GraphicsDevice): GraphicsPipe {.importcpp: "#->get_pipe()".} ## \
## Returns the GraphicsPipe that this device is associated with.

proc get_class_type*(_: typedesc[GraphicsDevice]): TypeHandle {.importcpp: "GraphicsDevice::get_class_type()", header: "graphicsDevice.h".}

proc is_valid*(this: GraphicsPipe): bool {.importcpp: "#->is_valid()".} ## \
## Returns false if this pipe is known to be invalid, meaning that an attempt
## to create a GraphicsWindow with the pipe will certainly fail.  Returns true
## if the pipe is probably valid (is this case, an attempt to create a
## GraphicsWindow should succeed, but might still fail).
##
## Use the GraphicsEngine class to create a GraphicsWindow on a particular
## pipe.

proc get_supported_types*(this: GraphicsPipe): int {.importcpp: "#->get_supported_types()".} ## \
## Returns the mask of bits that represents the kinds of GraphicsOutput
## objects this pipe might be able to successfully create.  The return value
## is the union of bits in GraphicsPipe::OutputTypes that represents the set
## of GraphicsOutput types.
##
## A 1 bit in a particular position is not a guarantee of success, but a 0 bit
## is a guarantee of failure.

proc supports_type*(this: GraphicsPipe, flags: int): bool {.importcpp: "#->supports_type(#)".} ## \
## A convenience function to ask if a particular type or types of
## GraphicsObjects are supported.  The parameter is a union of one or more
## bits defined in GrpahicsPipe::OutputTypes.
##
## Returns true if all of the requested types are listed in the
## supported_types mask, false if any one of them is not.  This is not a
## guarantee that the indicated output type will successfully be created when
## it is attempted.

proc get_display_width*(this: GraphicsPipe): int {.importcpp: "#->get_display_width()".} ## \
## Returns the width of the entire display, if it is known.  This may return
## 0.  This is not a guarantee that windows (particularly fullscreen windows)
## may not be created larger than this width, but it is intended to provide a
## hint to the application.

proc get_display_height*(this: GraphicsPipe): int {.importcpp: "#->get_display_height()".} ## \
## Returns the height of the entire display, if it is known.  This may return
## 0.  See the caveats for get_display_width().

proc get_display_zoom*(this: GraphicsPipe): float32 {.importcpp: "#->get_display_zoom()".} ## \
## Returns the display zoom factor configured in the operating system.  If the
## operating system automatically scales windows to match the DPI (such as when
## dpi-aware is set to false), this will be 1.0.  Otherwise, this will be set to
## a value approximating the density of the monitor divided by the standard
## density of the operating system (usually 96), yielding a value like 1.5 or
## 2.0.
##
## @since 1.10.8

proc get_display_information*(this: GraphicsPipe): DisplayInformation {.importcpp: "#->get_display_information()".} ## \
## Gets the pipe's DisplayInformation.

proc initDisplayInformation*(): DisplayInformation {.importcpp: "DisplayInformation()".}

proc initDisplayInformation*(param0: DisplayInformation): DisplayInformation {.importcpp: "DisplayInformation(#)".}

proc get_display_state*(this: DisplayInformation): int {.importcpp: "#.get_display_state()".}

proc get_maximum_window_width*(this: DisplayInformation): int {.importcpp: "#.get_maximum_window_width()".}

proc get_maximum_window_height*(this: DisplayInformation): int {.importcpp: "#.get_maximum_window_height()".}

proc get_window_bits_per_pixel*(this: DisplayInformation): int {.importcpp: "#.get_window_bits_per_pixel()".}

proc get_total_display_modes*(this: DisplayInformation): int {.importcpp: "#.get_total_display_modes()".}

proc get_display_mode*(this: DisplayInformation, display_index: int): DisplayMode {.importcpp: "#.get_display_mode(#)".}

proc get_display_mode_width*(this: DisplayInformation, display_index: int): int {.importcpp: "#.get_display_mode_width(#)".} ## \
## Older interface for display modes.

proc get_display_mode_height*(this: DisplayInformation, display_index: int): int {.importcpp: "#.get_display_mode_height(#)".}

proc get_display_mode_bits_per_pixel*(this: DisplayInformation, display_index: int): int {.importcpp: "#.get_display_mode_bits_per_pixel(#)".}

proc get_display_mode_refresh_rate*(this: DisplayInformation, display_index: int): int {.importcpp: "#.get_display_mode_refresh_rate(#)".}

proc get_display_mode_fullscreen_only*(this: DisplayInformation, display_index: int): int {.importcpp: "#.get_display_mode_fullscreen_only(#)".}

proc get_video_memory*(this: DisplayInformation): int {.importcpp: "#.get_video_memory()".}

proc get_texture_memory*(this: DisplayInformation): int {.importcpp: "#.get_texture_memory()".}

proc update_memory_information*(this: DisplayInformation) {.importcpp: "#.update_memory_information()".}

proc get_physical_memory*(this: DisplayInformation): clonglong {.importcpp: "#.get_physical_memory()".}

proc get_available_physical_memory*(this: DisplayInformation): clonglong {.importcpp: "#.get_available_physical_memory()".}

proc get_page_file_size*(this: DisplayInformation): clonglong {.importcpp: "#.get_page_file_size()".}

proc get_available_page_file_size*(this: DisplayInformation): clonglong {.importcpp: "#.get_available_page_file_size()".}

proc get_process_virtual_memory*(this: DisplayInformation): clonglong {.importcpp: "#.get_process_virtual_memory()".}

proc get_available_process_virtual_memory*(this: DisplayInformation): clonglong {.importcpp: "#.get_available_process_virtual_memory()".}

proc get_memory_load*(this: DisplayInformation): int {.importcpp: "#.get_memory_load()".}

proc get_page_fault_count*(this: DisplayInformation): clonglong {.importcpp: "#.get_page_fault_count()".}

proc get_process_memory*(this: DisplayInformation): clonglong {.importcpp: "#.get_process_memory()".}

proc get_peak_process_memory*(this: DisplayInformation): clonglong {.importcpp: "#.get_peak_process_memory()".}

proc get_page_file_usage*(this: DisplayInformation): clonglong {.importcpp: "#.get_page_file_usage()".}

proc get_peak_page_file_usage*(this: DisplayInformation): clonglong {.importcpp: "#.get_peak_page_file_usage()".}

proc get_vendor_id*(this: DisplayInformation): int {.importcpp: "#.get_vendor_id()".}

proc get_device_id*(this: DisplayInformation): int {.importcpp: "#.get_device_id()".}

proc get_driver_product*(this: DisplayInformation): int {.importcpp: "#.get_driver_product()".}

proc get_driver_version*(this: DisplayInformation): int {.importcpp: "#.get_driver_version()".}

proc get_driver_sub_version*(this: DisplayInformation): int {.importcpp: "#.get_driver_sub_version()".}

proc get_driver_build*(this: DisplayInformation): int {.importcpp: "#.get_driver_build()".}

proc get_driver_date_month*(this: DisplayInformation): int {.importcpp: "#.get_driver_date_month()".}

proc get_driver_date_day*(this: DisplayInformation): int {.importcpp: "#.get_driver_date_day()".}

proc get_driver_date_year*(this: DisplayInformation): int {.importcpp: "#.get_driver_date_year()".}

proc get_cpu_vendor_string*(this: DisplayInformation): string {.importcpp: "nimStringFromStdString(#.get_cpu_vendor_string())", header: stringConversionCode.}

proc get_cpu_brand_string*(this: DisplayInformation): string {.importcpp: "nimStringFromStdString(#.get_cpu_brand_string())", header: stringConversionCode.}

proc get_cpu_version_information*(this: DisplayInformation): int {.importcpp: "#.get_cpu_version_information()".}

proc get_cpu_brand_index*(this: DisplayInformation): int {.importcpp: "#.get_cpu_brand_index()".}

proc get_cpu_frequency*(this: DisplayInformation): clonglong {.importcpp: "#.get_cpu_frequency()".}

proc get_cpu_time*(_: typedesc[DisplayInformation]): clonglong {.importcpp: "DisplayInformation::get_cpu_time()", header: "displayInformation.h".} ## \
## Equivalent to the rdtsc processor instruction.

proc get_maximum_cpu_frequency*(this: DisplayInformation): clonglong {.importcpp: "#.get_maximum_cpu_frequency()".}

proc get_current_cpu_frequency*(this: DisplayInformation): clonglong {.importcpp: "#.get_current_cpu_frequency()".}

proc update_cpu_frequency*(this: DisplayInformation, processor_number: int) {.importcpp: "#.update_cpu_frequency(#)".}

proc get_num_cpu_cores*(this: DisplayInformation): int {.importcpp: "#.get_num_cpu_cores()".} ## \
## Returns the number of individual CPU cores in the system, or 0 if this
## number is not available.  A hyperthreaded CPU counts once here.

proc get_num_logical_cpus*(this: DisplayInformation): int {.importcpp: "#.get_num_logical_cpus()".} ## \
## Returns the number of logical CPU's in the system, or 0 if this number is
## not available.  A hyperthreaded CPU counts as two or more here.

proc get_os_version_major*(this: DisplayInformation): int {.importcpp: "#.get_os_version_major()".} ## \
## Returns -1 if not set.

proc get_os_version_minor*(this: DisplayInformation): int {.importcpp: "#.get_os_version_minor()".} ## \
## Returns -1 if not set.

proc get_os_version_build*(this: DisplayInformation): int {.importcpp: "#.get_os_version_build()".} ## \
## Returns -1 if not set.

proc get_os_platform_id*(this: DisplayInformation): int {.importcpp: "#.get_os_platform_id()".} ## \
## Returns -1 if not set.

proc lookup_cpu_data*(this: GraphicsPipe) {.importcpp: "#->lookup_cpu_data()".} ## \
## Looks up the detailed CPU information and stores it in
## _display_information, if supported by the OS. This may take a second or
## two.

proc get_interface_name*(this: GraphicsPipe): string {.importcpp: "nimStringFromStdString(#->get_interface_name())", header: stringConversionCode.}

proc get_class_type*(_: typedesc[GraphicsPipe]): TypeHandle {.importcpp: "GraphicsPipe::get_class_type()", header: "graphicsPipe.h".}

proc set_clear_color_active*(this: DrawableRegion, clear_color_active: bool) {.importcpp: "#.set_clear_color_active(#)".} ## \
## Toggles the flag that indicates whether the color buffer should be cleared
## every frame.  If this is true, the color buffer will be cleared to the
## color indicated by set_clear_color(); otherwise, it will be left alone.

proc get_clear_color_active*(this: DrawableRegion): bool {.importcpp: "#.get_clear_color_active()".} ## \
## Returns the current setting of the flag that indicates whether the color
## buffer should be cleared every frame.  See set_clear_color_active().

proc set_clear_depth_active*(this: DrawableRegion, clear_depth_active: bool) {.importcpp: "#.set_clear_depth_active(#)".} ## \
## Toggles the flag that indicates whether the depth buffer should be cleared
## every frame.  If this is true, the depth buffer will be cleared to the
## depth value indicated by set_clear_depth(); otherwise, it will be left
## alone.

proc get_clear_depth_active*(this: DrawableRegion): bool {.importcpp: "#.get_clear_depth_active()".} ## \
## Returns the current setting of the flag that indicates whether the depth
## buffer should be cleared every frame.  See set_clear_depth_active().

proc set_clear_stencil_active*(this: DrawableRegion, clear_stencil_active: bool) {.importcpp: "#.set_clear_stencil_active(#)".} ## \
## Toggles the flag that indicates whether the stencil buffer should be
## cleared every frame.  If this is true, the stencil buffer will be cleared
## to the value indicated by set_clear_stencil(); otherwise, it will be left
## alone.

proc get_clear_stencil_active*(this: DrawableRegion): bool {.importcpp: "#.get_clear_stencil_active()".} ## \
## Returns the current setting of the flag that indicates whether the color
## buffer should be cleared every frame.  See set_clear_stencil_active().

proc set_clear_color*(this: DrawableRegion, color: LColor) {.importcpp: "#.set_clear_color(#)".} ## \
## Sets the clear color to the indicated value.  This is the value that will
## be used to clear the color buffer every frame, but only if
## get_clear_color_active() returns true.  If get_clear_color_active() returns
## false, this is meaningless.

proc get_clear_color*(this: DrawableRegion): LColor {.importcpp: "#.get_clear_color()".} ## \
## Returns the current clear color value.  This is the value that will be used
## to clear the color buffer every frame, but only if get_clear_color_active()
## returns true.  If get_clear_color_active() returns false, this is
## meaningless.

proc set_clear_depth*(this: DrawableRegion, depth: float32) {.importcpp: "#.set_clear_depth(#)".} ## \
## Sets the clear depth to the indicated value.  This is the value that will
## be used to clear the depth buffer every frame, but only if
## get_clear_depth_active() returns true.  If get_clear_depth_active() returns
## false, this is meaningless.

proc get_clear_depth*(this: DrawableRegion): float32 {.importcpp: "#.get_clear_depth()".} ## \
## Returns the current clear depth value.  This is the value that will be used
## to clear the depth buffer every frame, but only if get_clear_depth_active()
## returns true.  If get_clear_depth_active() returns false, this is
## meaningless.

proc set_clear_stencil*(this: DrawableRegion, stencil: int) {.importcpp: "#.set_clear_stencil(#)".}

proc get_clear_stencil*(this: DrawableRegion): int {.importcpp: "#.get_clear_stencil()".} ## \
## Returns the current clear stencil value.  This is the value that will be
## used to clear the stencil buffer every frame, but only if
## get_clear_stencil_active() returns true.  If get_clear_stencil_active()
## returns false, this is meaningless.

proc set_clear_active*(this: DrawableRegion, n: int, clear_aux_active: bool) {.importcpp: "#.set_clear_active(#, #)".} ## \
## Sets the clear-active flag for any bitplane.

proc get_clear_active*(this: DrawableRegion, n: int): bool {.importcpp: "#.get_clear_active(#)".} ## \
## Gets the clear-active flag for any bitplane.

proc set_clear_value*(this: DrawableRegion, n: int, clear_value: LColor) {.importcpp: "#.set_clear_value(#, #)".} ## \
## Sets the clear value for any bitplane.

proc get_clear_value*(this: DrawableRegion, n: int): LColor {.importcpp: "#.get_clear_value(#)".} ## \
## Returns the clear value for any bitplane.

proc disable_clears*(this: DrawableRegion) {.importcpp: "#.disable_clears()".} ## \
## Disables both the color and depth clear.  See set_clear_color_active and
## set_clear_depth_active.

proc is_any_clear_active*(this: DrawableRegion): bool {.importcpp: "#.is_any_clear_active()".} ## \
## Returns true if any of the clear types (so far there are just color or
## depth) have been set active, or false if none of them are active and there
## is no need to clear.

proc set_pixel_zoom*(this: DrawableRegion, pixel_zoom: float32) {.importcpp: "#.set_pixel_zoom(#)".} ## \
## Sets the amount by which the pixels of the region are scaled internally
## when filling the image interally.  Setting this number larger makes the
## pixels blockier, but may make the rendering faster, particularly for
## software renderers.  Setting this number to 2.0 reduces the number of
## pixels that have to be filled by the renderer by a factor of 2.0.  It
## doesn't make sense to set this lower than 1.0.
##
## It is possible to set this on either individual DisplayRegions or on
## overall GraphicsWindows, but you will get better performance for setting it
## on the window rather than its individual DisplayRegions.  Also, you may not
## set it on a DisplayRegion that doesn't have both clear_color() and
## clear_depth() enabled.
##
## This property is only supported on renderers for which it is particularly
## useful--currently, this is the tinydisplay software renderer.  Other kinds
## of renderers allow you to set this property, but ignore it.

proc get_pixel_zoom*(this: DrawableRegion): float32 {.importcpp: "#.get_pixel_zoom()".} ## \
## Returns the value set by set_pixel_zoom(), regardless of whether it is
## being respected or not.  Also see get_pixel_factor().

proc get_pixel_factor*(this: DrawableRegion): float32 {.importcpp: "#.get_pixel_factor()".} ## \
## Returns the amount by which the height and width of the region will be
## scaled internally, based on the zoom factor set by set_pixel_zoom().  This
## will return 1.0 if the pixel_zoom was not set or if it is not being
## respected (for instance, because the underlying renderer doesn't support it
## --see supports_pixel_zoom).

proc supports_pixel_zoom*(this: DrawableRegion): bool {.importcpp: "#.supports_pixel_zoom()".} ## \
## Returns true if a call to set_pixel_zoom() will be respected, false if it
## will be ignored.  If this returns false, then get_pixel_factor() will
## always return 1.0, regardless of what value you specify for
## set_pixel_zoom().
##
## This may return false if the underlying renderer doesn't support pixel
## zooming, or if you have called this on a DisplayRegion that doesn't have
## both set_clear_color() and set_clear_depth() enabled.

proc get_renderbuffer_type*(_: typedesc[DrawableRegion], plane: int): int {.importcpp: "DrawableRegion::get_renderbuffer_type(#)", header: "drawableRegion.h".} ## \
## Returns the RenderBuffer::Type that corresponds to a RenderTexturePlane.

proc newWindowHandle*(copy: WindowHandle): WindowHandle {.importcpp: "new WindowHandle(#)".}

proc send_windows_message*(this: WindowHandle, msg: int, wparam: int, lparam: int) {.importcpp: "#->send_windows_message(#, #, #)".} ## \
## Call this method on a parent WindowHandle to deliver a Windows message to
## the current child window, if any.  This is used in the web plugin system to
## deliver button events detected directly by the browser system into Panda,
## which is particularly necessary on Vista.

proc get_int_handle*(this: WindowHandle): clonglong {.importcpp: "#->get_int_handle()".} ## \
## Returns the OS-specific handle converted to an integer, if this is possible
## for the particular representation.  Returns 0 if it is not.

proc output*(this: WindowHandle, `out`: ostream) {.importcpp: "#->output(#)".}

proc get_class_type*(_: typedesc[WindowHandle]): TypeHandle {.importcpp: "WindowHandle::get_class_type()", header: "windowHandle.h".}

proc get_config_properties*(_: typedesc[WindowProperties]): WindowProperties {.importcpp: "WindowProperties::get_config_properties()", header: "windowProperties.h".} ## \
## Returns a WindowProperties structure with all of the default values filled
## in according to the user's config file.

proc get_default*(_: typedesc[WindowProperties]): WindowProperties {.importcpp: "WindowProperties::get_default()", header: "windowProperties.h".} ## \
## Returns the "default" WindowProperties.  If set_default() has been called,
## this returns that WindowProperties structure; otherwise, this returns
## get_config_properties().

proc set_default*(_: typedesc[WindowProperties], default_properties: WindowProperties) {.importcpp: "WindowProperties::set_default(#)", header: "windowProperties.h".} ## \
## Replaces the "default" WindowProperties with the specified structure.  The
## specified WindowProperties will be returned by future calls to
## get_default(), until clear_default() is called.
##
## Note that this completely replaces the default properties; it is not
## additive.

proc clear_default*(_: typedesc[WindowProperties]) {.importcpp: "WindowProperties::clear_default()", header: "windowProperties.h".} ## \
## Returns the "default" WindowProperties to whatever is specified in the
## user's config file.

proc size*(_: typedesc[WindowProperties], size: LVecBase2i): WindowProperties {.importcpp: "WindowProperties::size(#)", header: "windowProperties.h".} ## \
## Returns a WindowProperties structure with only the size specified.  The
## size is the only property that matters to buffers.
##
## @deprecated in the Python API, use WindowProperties(size=(x, y)) instead.

proc size*(_: typedesc[WindowProperties], x_size: int, y_size: int): WindowProperties {.importcpp: "WindowProperties::size(#, #)", header: "windowProperties.h".}

proc `==`*(this: WindowProperties, other: WindowProperties): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: WindowProperties, other: WindowProperties): bool {.importcpp: "#.operator !=(#)".}

proc clear*(this: WindowProperties) {.importcpp: "#.clear()".} ## \
## Unsets all properties that have been specified so far, and resets the
## WindowProperties structure to its initial empty state.

proc is_any_specified*(this: WindowProperties): bool {.importcpp: "#.is_any_specified()".} ## \
## Returns true if any properties have been specified, false otherwise.

proc set_origin*(this: WindowProperties, origin: LPoint2i) {.importcpp: "#.set_origin(#)".} ## \
## Specifies the origin on the screen (in pixels, relative to the top-left
## corner) at which the window should appear.  This is the origin of the top-
## left corner of the useful part of the window, not including decorations.

proc set_origin*(this: WindowProperties, x_origin: int, y_origin: int) {.importcpp: "#.set_origin(#, #)".} ## \
## Specifies the origin on the screen (in pixels, relative to the top-left
## corner) at which the window should appear.  This is the origin of the top-
## left corner of the useful part of the window, not including decorations.

proc get_origin*(this: WindowProperties): LPoint2i {.importcpp: "#.get_origin()".} ## \
## Returns the coordinates of the window's top-left corner, not including
## decorations.

proc get_x_origin*(this: WindowProperties): int {.importcpp: "#.get_x_origin()".} ## \
## Returns the x coordinate of the window's top-left corner, not including
## decorations.

proc get_y_origin*(this: WindowProperties): int {.importcpp: "#.get_y_origin()".} ## \
## Returns the y coordinate of the window's top-left corner, not including
## decorations.

proc has_origin*(this: WindowProperties): bool {.importcpp: "#.has_origin()".} ## \
## Returns true if the window origin has been specified, false otherwise.

proc clear_origin*(this: WindowProperties) {.importcpp: "#.clear_origin()".} ## \
## Removes the origin specification from the properties.

proc set_size*(this: WindowProperties, size: LVector2i) {.importcpp: "#.set_size(#)".} ## \
## Specifies the requested size of the window, in pixels.  This is the size of
## the useful part of the window, not including decorations.

proc set_size*(this: WindowProperties, x_size: int, y_size: int) {.importcpp: "#.set_size(#, #)".} ## \
## Specifies the requested size of the window, in pixels.  This is the size of
## the useful part of the window, not including decorations.

proc get_size*(this: WindowProperties): LVector2i {.importcpp: "#.get_size()".} ## \
## Returns size in pixels of the useful part of the window, not including
## decorations.

proc get_x_size*(this: WindowProperties): int {.importcpp: "#.get_x_size()".} ## \
## Returns size in pixels in the x dimension of the useful part of the window,
## not including decorations.  That is, this is the window's width.

proc get_y_size*(this: WindowProperties): int {.importcpp: "#.get_y_size()".} ## \
## Returns size in pixels in the y dimension of the useful part of the window,
## not including decorations.  That is, this is the window's height.

proc has_size*(this: WindowProperties): bool {.importcpp: "#.has_size()".} ## \
## Returns true if the window size has been specified, false otherwise.

proc clear_size*(this: WindowProperties) {.importcpp: "#.clear_size()".} ## \
## Removes the size specification from the properties.

proc has_mouse_mode*(this: WindowProperties): bool {.importcpp: "#.has_mouse_mode()".}

proc clear_mouse_mode*(this: WindowProperties) {.importcpp: "#.clear_mouse_mode()".} ## \
## Removes the mouse_mode specification from the properties.

proc set_title*(this: WindowProperties, title: string) {.importcpp: "#.set_title(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the title that should be assigned to the window.

proc get_title*(this: WindowProperties): string {.importcpp: "nimStringFromStdString(#.get_title())", header: stringConversionCode.} ## \
## Returns the window's title.

proc has_title*(this: WindowProperties): bool {.importcpp: "#.has_title()".} ## \
## Returns true if the window title has been specified, false otherwise.

proc clear_title*(this: WindowProperties) {.importcpp: "#.clear_title()".} ## \
## Removes the title specification from the properties.

proc set_undecorated*(this: WindowProperties, undecorated: bool) {.importcpp: "#.set_undecorated(#)".} ## \
## Specifies whether the window should be created with a visible title and
## border (false, the default) or not (true).

proc get_undecorated*(this: WindowProperties): bool {.importcpp: "#.get_undecorated()".} ## \
## Returns true if the window has no border.

proc has_undecorated*(this: WindowProperties): bool {.importcpp: "#.has_undecorated()".} ## \
## Returns true if set_undecorated() has been specified.

proc clear_undecorated*(this: WindowProperties) {.importcpp: "#.clear_undecorated()".} ## \
## Removes the undecorated specification from the properties.

proc set_fixed_size*(this: WindowProperties, fixed_size: bool) {.importcpp: "#.set_fixed_size(#)".} ## \
## Specifies whether the window should be resizable by the user.

proc get_fixed_size*(this: WindowProperties): bool {.importcpp: "#.get_fixed_size()".} ## \
## Returns true if the window cannot be resized by the user, false otherwise.

proc has_fixed_size*(this: WindowProperties): bool {.importcpp: "#.has_fixed_size()".} ## \
## Returns true if set_fixed_size() has been specified.

proc clear_fixed_size*(this: WindowProperties) {.importcpp: "#.clear_fixed_size()".} ## \
## Removes the fixed_size specification from the properties.

proc set_fullscreen*(this: WindowProperties, fullscreen: bool) {.importcpp: "#.set_fullscreen(#)".} ## \
## Specifies whether the window should be opened in fullscreen mode (true) or
## normal windowed mode (false, the default).

proc get_fullscreen*(this: WindowProperties): bool {.importcpp: "#.get_fullscreen()".} ## \
## Returns true if the window is in fullscreen mode.

proc has_fullscreen*(this: WindowProperties): bool {.importcpp: "#.has_fullscreen()".} ## \
## Returns true if set_fullscreen() has been specified.

proc clear_fullscreen*(this: WindowProperties) {.importcpp: "#.clear_fullscreen()".} ## \
## Removes the fullscreen specification from the properties.

proc set_foreground*(this: WindowProperties, foreground: bool) {.importcpp: "#.set_foreground(#)".} ## \
## Specifies whether the window should be opened in the foreground (true), or
## left in the background (false).

proc get_foreground*(this: WindowProperties): bool {.importcpp: "#.get_foreground()".} ## \
## Returns true if the window is in the foreground.

proc has_foreground*(this: WindowProperties): bool {.importcpp: "#.has_foreground()".} ## \
## Returns true if set_foreground() has been specified.

proc clear_foreground*(this: WindowProperties) {.importcpp: "#.clear_foreground()".} ## \
## Removes the foreground specification from the properties.

proc set_minimized*(this: WindowProperties, minimized: bool) {.importcpp: "#.set_minimized(#)".} ## \
## Specifies whether the window should be created minimized (true), or normal
## (false).

proc get_minimized*(this: WindowProperties): bool {.importcpp: "#.get_minimized()".} ## \
## Returns true if the window is minimized.

proc has_minimized*(this: WindowProperties): bool {.importcpp: "#.has_minimized()".} ## \
## Returns true if set_minimized() has been specified.

proc clear_minimized*(this: WindowProperties) {.importcpp: "#.clear_minimized()".} ## \
## Removes the minimized specification from the properties.

proc set_raw_mice*(this: WindowProperties, raw_mice: bool) {.importcpp: "#.set_raw_mice(#)".} ## \
## Specifies whether the window should read the raw mouse devices.

proc get_raw_mice*(this: WindowProperties): bool {.importcpp: "#.get_raw_mice()".} ## \
## Returns true if the window reads the raw mice.

proc has_raw_mice*(this: WindowProperties): bool {.importcpp: "#.has_raw_mice()".} ## \
## Returns true if set_raw_mice() has been specified.

proc clear_raw_mice*(this: WindowProperties) {.importcpp: "#.clear_raw_mice()".} ## \
## Removes the raw_mice specification from the properties.

proc set_open*(this: WindowProperties, open: bool) {.importcpp: "#.set_open(#)".} ## \
## Specifies whether the window should be open.  It is legal to create a
## GraphicsWindow in the closed state, and later request it to open by
## changing this flag.

proc get_open*(this: WindowProperties): bool {.importcpp: "#.get_open()".} ## \
## Returns true if the window is open.

proc has_open*(this: WindowProperties): bool {.importcpp: "#.has_open()".} ## \
## Returns true if set_open() has been specified.

proc clear_open*(this: WindowProperties) {.importcpp: "#.clear_open()".} ## \
## Removes the open specification from the properties.

proc set_cursor_hidden*(this: WindowProperties, cursor_hidden: bool) {.importcpp: "#.set_cursor_hidden(#)".} ## \
## Specifies whether the mouse cursor should be visible.

proc get_cursor_hidden*(this: WindowProperties): bool {.importcpp: "#.get_cursor_hidden()".} ## \
## Returns true if the mouse cursor is invisible.

proc has_cursor_hidden*(this: WindowProperties): bool {.importcpp: "#.has_cursor_hidden()".} ## \
## Returns true if set_cursor_hidden() has been specified.

proc clear_cursor_hidden*(this: WindowProperties) {.importcpp: "#.clear_cursor_hidden()".} ## \
## Removes the cursor_hidden specification from the properties.

proc set_icon_filename*(this: WindowProperties, icon_filename: Filename) {.importcpp: "#.set_icon_filename(#)".} ## \
## Specifies the file that contains the icon to associate with the window when
## it is minimized.

proc get_icon_filename*(this: WindowProperties): Filename {.importcpp: "#.get_icon_filename()".} ## \
## Returns the icon filename associated with the window.

proc has_icon_filename*(this: WindowProperties): bool {.importcpp: "#.has_icon_filename()".} ## \
## Returns true if set_icon_filename() has been specified.

proc clear_icon_filename*(this: WindowProperties) {.importcpp: "#.clear_icon_filename()".} ## \
## Removes the icon_filename specification from the properties.

proc set_cursor_filename*(this: WindowProperties, cursor_filename: Filename) {.importcpp: "#.set_cursor_filename(#)".} ## \
## Specifies the file that contains the icon to associate with the mouse
## cursor when it is within the window (and visible).

proc get_cursor_filename*(this: WindowProperties): Filename {.importcpp: "#.get_cursor_filename()".} ## \
## Returns the icon filename associated with the mouse cursor.

proc has_cursor_filename*(this: WindowProperties): bool {.importcpp: "#.has_cursor_filename()".} ## \
## Returns true if set_cursor_filename() has been specified.

proc clear_cursor_filename*(this: WindowProperties) {.importcpp: "#.clear_cursor_filename()".} ## \
## Removes the cursor_filename specification from the properties.

proc has_z_order*(this: WindowProperties): bool {.importcpp: "#.has_z_order()".} ## \
## Returns true if the window z_order has been specified, false otherwise.

proc clear_z_order*(this: WindowProperties) {.importcpp: "#.clear_z_order()".} ## \
## Removes the z_order specification from the properties.

proc set_parent_window*(this: WindowProperties, parent_window: WindowHandle) {.importcpp: "#.set_parent_window(#)".} ## \
## Specifies the window that this window should be attached to.  If this is
## NULL or unspecified, the window will be created as a toplevel window on the
## desktop; if this is non-NULL, the window will be bound as a child window to
## the indicated parent window.
##
## You should use GraphicsPipe::make_window_handle() to create an instance of
## a WindowHandle object given an appropriate OS-specific window handle
## representation.  Each OS-specific GraphicsPipe class defines a
## make_window_handle() method that returns an appropriate WindowHandle object
## to wrap the particular OS-specific representation.

proc set_parent_window*(this: WindowProperties) {.importcpp: "#.set_parent_window()".} ## \
## Specifies the window that this window should be attached to.  If this is
## NULL or unspecified, the window will be created as a toplevel window on the
## desktop; if this is non-NULL, the window will be bound as a child window to
## the indicated parent window.
##
## You should use GraphicsPipe::make_window_handle() to create an instance of
## a WindowHandle object given an appropriate OS-specific window handle
## representation.  Each OS-specific GraphicsPipe class defines a
## make_window_handle() method that returns an appropriate WindowHandle object
## to wrap the particular OS-specific representation.

proc set_parent_window*(this: WindowProperties, parent: clonglong) {.importcpp: "#.set_parent_window(#)".} ## \
## Specifies the window that this window should be attached to.
##
## This is a deprecated variant on this method, and exists only for backward
## compatibility.  Future code should use the version of set_parent_window()
## below that receives a WindowHandle object; that interface is much more
## robust.
##
## In this deprecated variant, the actual value for "parent" is platform-
## specific.  On Windows, it is the HWND of the parent window, cast to an
## unsigned integer.  On X11, it is the Window pointer of the parent window,
## similarly cast.  On OSX, this is the NSWindow pointer, which doesn't appear
## to work at all.

proc get_parent_window*(this: WindowProperties): WindowHandle {.importcpp: "#.get_parent_window()".} ## \
## Returns the parent window specification, or NULL if there is no parent
## window specified.

proc has_parent_window*(this: WindowProperties): bool {.importcpp: "#.has_parent_window()".} ## \
## Checks the S_parent_window specification from the properties.

proc clear_parent_window*(this: WindowProperties) {.importcpp: "#.clear_parent_window()".} ## \
## Removes the S_parent_window specification from the properties.

proc add_properties*(this: WindowProperties, other: WindowProperties) {.importcpp: "#.add_properties(#)".} ## \
## Sets any properties that are explicitly specified in other on this object.
## Leaves other properties unchanged.

proc output*(this: WindowProperties, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Sets any properties that are explicitly specified in other on this object.
## Leaves other properties unchanged.

converter upcast_to_TypedReferenceCount*(this: DisplayRegion): TypedReferenceCount {.importcpp: "(PT(TypedReferenceCount)(#))".}

converter upcast_to_DrawableRegion*(this: DisplayRegion): DrawableRegion {.importcpp: "((DrawableRegion *)(#.p()))".}

proc get_num_regions*(this: DisplayRegion): int {.importcpp: "#->get_num_regions()".} ## \
## Returns the number of regions, see set_num_regions.

proc set_num_regions*(this: DisplayRegion, i: int) {.importcpp: "#->set_num_regions(#)".} ## \
## Sets the number of regions that this DisplayRegion indicates.  Usually,
## this number is 1 (and it is always at least 1), and only the first is used
## for rendering.  However, if more than one is provided, you may select which
## one to render into using a geometry shader (gl_ViewportIndex in GLSL).

proc get_dimensions*(this: DisplayRegion, i: int): LVecBase4 {.importcpp: "#->get_dimensions(#)".} ## \
## Retrieves the coordinates of the DisplayRegion's rectangle within its
## GraphicsOutput.  These numbers will be in the range [0..1].

proc get_dimensions*(this: DisplayRegion): LVecBase4 {.importcpp: "#->get_dimensions()".} ## \
## Retrieves the coordinates of the DisplayRegion's rectangle within its
## GraphicsOutput.  These numbers will be in the range [0..1].

proc get_left*(this: DisplayRegion, i: int): float32 {.importcpp: "#->get_left(#)".} ## \
## Retrieves the x coordinate of the left edge of the rectangle within its
## GraphicsOutput.  This number will be in the range [0..1].

proc get_left*(this: DisplayRegion): float32 {.importcpp: "#->get_left()".} ## \
## Retrieves the x coordinate of the left edge of the rectangle within its
## GraphicsOutput.  This number will be in the range [0..1].

proc get_right*(this: DisplayRegion, i: int): float32 {.importcpp: "#->get_right(#)".} ## \
## Retrieves the x coordinate of the right edge of the rectangle within its
## GraphicsOutput.  This number will be in the range [0..1].

proc get_right*(this: DisplayRegion): float32 {.importcpp: "#->get_right()".} ## \
## Retrieves the x coordinate of the right edge of the rectangle within its
## GraphicsOutput.  This number will be in the range [0..1].

proc get_bottom*(this: DisplayRegion, i: int): float32 {.importcpp: "#->get_bottom(#)".} ## \
## Retrieves the y coordinate of the bottom edge of the rectangle within its
## GraphicsOutput.  This number will be in the range [0..1].

proc get_bottom*(this: DisplayRegion): float32 {.importcpp: "#->get_bottom()".} ## \
## Retrieves the y coordinate of the bottom edge of the rectangle within its
## GraphicsOutput.  This number will be in the range [0..1].

proc get_top*(this: DisplayRegion, i: int): float32 {.importcpp: "#->get_top(#)".} ## \
## Retrieves the y coordinate of the top edge of the rectangle within its
## GraphicsOutput.  This number will be in the range [0..1].

proc get_top*(this: DisplayRegion): float32 {.importcpp: "#->get_top()".} ## \
## Retrieves the y coordinate of the top edge of the rectangle within its
## GraphicsOutput.  This number will be in the range [0..1].

proc set_dimensions*(this: DisplayRegion, dimensions: LVecBase4) {.importcpp: "#->set_dimensions(#)".} ## \
## Changes the portion of the framebuffer this DisplayRegion corresponds to.
## The parameters range from 0 to 1, where 0,0 is the lower left corner and
## 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.

proc set_dimensions*(this: DisplayRegion, l: float32, r: float32, b: float32, t: float32) {.importcpp: "#->set_dimensions(#, #, #, #)".} ## \
## Changes the portion of the framebuffer this DisplayRegion corresponds to.
## The parameters range from 0 to 1, where 0,0 is the lower left corner and
## 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.

proc set_dimensions*(this: DisplayRegion, i: int, dimensions: LVecBase4) {.importcpp: "#->set_dimensions(#, #)".} ## \
## Changes the portion of the framebuffer this DisplayRegion corresponds to.
## The parameters range from 0 to 1, where 0,0 is the lower left corner and
## 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc set_dimensions*(this: DisplayRegion, i: int, l: float32, r: float32, b: float32, t: float32) {.importcpp: "#->set_dimensions(#, #, #, #, #)".} ## \
## Changes the portion of the framebuffer this DisplayRegion corresponds to.
## The parameters range from 0 to 1, where 0,0 is the lower left corner and
## 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.

proc get_window*(this: DisplayRegion): GraphicsOutput {.importcpp: "#->get_window()".} ## \
## Returns the GraphicsOutput that this DisplayRegion is ultimately associated
## with, or NULL if no window is associated.

proc get_pipe*(this: DisplayRegion): GraphicsPipe {.importcpp: "#->get_pipe()".} ## \
## Returns the GraphicsPipe that this DisplayRegion is ultimately associated
## with, or NULL if no pipe is associated.

proc is_stereo*(this: DisplayRegion): bool {.importcpp: "#->is_stereo()".} ## \
## Returns true if this is a StereoDisplayRegion, false otherwise.

converter upcast_to_GraphicsOutputBase*(this: GraphicsOutput): GraphicsOutputBase {.importcpp: "(PT(GraphicsOutputBase)(#))".}

converter upcast_to_DrawableRegion*(this: GraphicsOutput): DrawableRegion {.importcpp: "((DrawableRegion *)(#.p()))".}

proc get_gsg*(this: GraphicsOutput): GraphicsStateGuardian {.importcpp: "#->get_gsg()".} ## \
## Returns the GSG that is associated with this window.  There is a one-to-one
## association between windows and GSG's.
##
## This may return NULL if the graphics context has not yet been created for
## the window, e.g.  before the first frame has rendered; or after the window
## has been closed.

proc get_pipe*(this: GraphicsOutput): GraphicsPipe {.importcpp: "#->get_pipe()".} ## \
## Returns the GraphicsPipe that this window is associated with.  It is
## possible that the GraphicsPipe might have been deleted while an outstanding
## PT(GraphicsOutput) prevented all of its children windows from also being
## deleted; in this unlikely case, get_pipe() may return NULL.

proc get_engine*(this: GraphicsOutput): GraphicsEngine {.importcpp: "#->get_engine()".} ## \
## Returns the graphics engine that created this output.  Since there is
## normally only one GraphicsEngine object in an application, this is usually
## the same as the global GraphicsEngine.

proc get_name*(this: GraphicsOutput): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the name that was passed to the GraphicsOutput constructor.

proc release_all*(this: GraphicsStateGuardian) {.importcpp: "#->release_all()".} ## \
## Releases all prepared objects.

proc release_all_textures*(this: GraphicsStateGuardian): int {.importcpp: "#->release_all_textures()".} ## \
## Frees the resources for all textures associated with this GSG.

proc release_all_samplers*(this: GraphicsStateGuardian): int {.importcpp: "#->release_all_samplers()".} ## \
## Frees the resources for all samplers associated with this GSG.

proc release_all_geoms*(this: GraphicsStateGuardian): int {.importcpp: "#->release_all_geoms()".} ## \
## Frees the resources for all geoms associated with this GSG.

proc release_all_vertex_buffers*(this: GraphicsStateGuardian): int {.importcpp: "#->release_all_vertex_buffers()".} ## \
## Frees the resources for all vertex buffers associated with this GSG.

proc release_all_index_buffers*(this: GraphicsStateGuardian): int {.importcpp: "#->release_all_index_buffers()".} ## \
## Frees the resources for all index buffers associated with this GSG.

proc release_all_shader_buffers*(this: GraphicsStateGuardian): int {.importcpp: "#->release_all_shader_buffers()".} ## \
## Frees the resources for all index buffers associated with this GSG.

proc set_active*(this: GraphicsStateGuardian, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets the active flag associated with the GraphicsStateGuardian.  If the
## GraphicsStateGuardian is marked inactive, nothing is rendered.  This is not
## normally turned off unless there is a problem with the rendering detected
## at a low level.

proc is_active*(this: GraphicsStateGuardian): bool {.importcpp: "#->is_active()".} ## \
## Returns the active flag associated with the GraphicsStateGuardian.

proc is_valid*(this: GraphicsStateGuardian): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the GSG has been correctly initialized within a graphics
## context, false if there has been some problem or it hasn't been initialized
## yet.

proc needs_reset*(this: GraphicsStateGuardian): bool {.importcpp: "#->needs_reset()".} ## \
## Returns true if the gsg is marked as needing a reset.

proc set_incomplete_render*(this: GraphicsStateGuardian, incomplete_render: bool) {.importcpp: "#->set_incomplete_render(#)".} ## \
## Sets the incomplete_render flag.  When this is true, the frame will be
## rendered even if some of the geometry or textures in the scene are not
## available (e.g.  they have been temporarily paged out).  When this is
## false, the frame will be held up while this data is reloaded.
##
## Setting this true allows for a smoother frame rate, but occasionally parts
## of the frame will be invisible or missing (they will generally come in
## within a second or two).  Setting this false guarantees that every frame
## will be complete, but may cause more chugs as things are loaded up at
## runtime.
##
## You may want to set this false during loading screens, to guarantee that
## all of your assets are available by the time you take the loading screen
## down.
##
## This flag may also be set individually on each DisplayRegion.  It will be
## considered true for a given DisplayRegion only if it is true on both the
## GSG and on the DisplayRegion.

proc set_loader*(this: GraphicsStateGuardian, loader: Loader) {.importcpp: "#->set_loader(#)".} ## \
## Sets the Loader object that will be used by this GSG to load textures when
## necessary, if get_incomplete_render() is true.

proc get_loader*(this: GraphicsStateGuardian): Loader {.importcpp: "#->get_loader()".} ## \
## Returns the Loader object that will be used by this GSG to load textures
## when necessary, if get_incomplete_render() is true.

proc set_shader_generator*(this: GraphicsStateGuardian, shader_generator: ShaderGenerator) {.importcpp: "#->set_shader_generator(#)".} ## \
## Sets the ShaderGenerator object that will be used by this GSG to generate
## shaders when necessary.

proc get_shader_generator*(this: GraphicsStateGuardian): ShaderGenerator {.importcpp: "#->get_shader_generator()".} ## \
## Returns the ShaderGenerator object that will be used by this GSG to
## generate shaders when necessary.

proc get_pipe*(this: GraphicsStateGuardian): GraphicsPipe {.importcpp: "#->get_pipe()".} ## \
## Returns the graphics pipe on which this GSG was created.

proc get_engine*(this: GraphicsStateGuardian): GraphicsEngine {.importcpp: "#->get_engine()".}

proc get_threading_model*(this: GraphicsStateGuardian): GraphicsThreadingModel {.importcpp: "#->get_threading_model()".} ## \
## Returns the threading model that was used to create this GSG.

proc is_hardware*(this: GraphicsStateGuardian): bool {.importcpp: "#->is_hardware()".} ## \
## Returns true if this GSG appears to be hardware-accelerated, or false if it
## is known to be software only.

proc get_max_texture_stages*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_texture_stages()".} ## \
## Returns the maximum number of simultaneous textures that may be applied to
## geometry with multitexturing, as supported by this particular GSG.  If you
## exceed this number, the lowest-priority texture stages will not be applied.
## Use TextureStage::set_priority() to adjust the relative importance of the
## different texture stages.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc get_max_3d_texture_dimension*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_3d_texture_dimension()".} ## \
## Returns the largest possible texture size in any one dimension for a 3-d
## texture, or -1 if there is no particular limit.  Returns 0 if 3-d textures
## are not supported.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc get_max_2d_texture_array_layers*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_2d_texture_array_layers()".} ## \
## Returns the largest possible number of pages, or -1 if there is no
## particular limit.  Returns 0 if 2-d texture arrays not supported.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc get_max_cube_map_dimension*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_cube_map_dimension()".} ## \
## Returns the largest possible texture size in any one dimension for a cube
## map texture, or -1 if there is no particular limit.  Returns 0 if cube map
## textures are not supported.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc get_max_buffer_texture_size*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_buffer_texture_size()".} ## \
## Returns the largest possible buffer texture size, or -1 if there is no
## particular limit.  Returns 0 if cube map textures are not supported.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc get_supports_texture_combine*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_texture_combine()".} ## \
## Returns true if this particular GSG can use the TextureStage::M_combine
## mode, which includes all of the texture blend modes specified by
## set_combine_rgb() and/or set_combine_alpha().  If this is false, you must
## limit yourself to using the simpler blend modes.

proc get_supports_texture_saved_result*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_texture_saved_result()".} ## \
## Returns true if this GSG can use the TextureStage::CS_last_saved_result
## source, which allows you to save the result of a TextureStage and re-use it
## for multiple inputs.

proc get_supports_texture_dot3*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_texture_dot3()".} ## \
## Returns true if this GSG can use the TextureStage::CM_dot3_rgb or
## CM_dot3_rgba combine modes.

proc get_supports_3d_texture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_3d_texture()".} ## \
## Returns true if this GSG can render 3-d (volumetric) textures.

proc get_supports_2d_texture_array*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_2d_texture_array()".} ## \
## Returns true if this GSG can render 2-d textures array.

proc get_supports_cube_map*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_cube_map()".} ## \
## Returns true if this GSG can render cube map textures.

proc get_supports_buffer_texture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_buffer_texture()".} ## \
## Returns true if this GSG can render buffer textures.

proc get_supports_cube_map_array*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_cube_map_array()".} ## \
## Returns true if this GSG can render cube map arrays.

proc get_supports_tex_non_pow2*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_tex_non_pow2()".} ## \
## Returns true if this GSG can handle non power of two sized textures.

proc get_supports_compressed_texture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_compressed_texture()".} ## \
## Returns true if this GSG can compress textures as it loads them into
## texture memory, and/or accept pre-compressed textures for storing.

proc get_max_lights*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_lights()".} ## \
## Returns the maximum number of simultaneous lights that may be rendered on
## geometry, or -1 if there is no particular limit.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc get_max_clip_planes*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_clip_planes()".} ## \
## Returns the maximum number of simultaneous clip planes that may be applied
## to geometry, or -1 if there is no particular limit.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc get_max_vertex_transforms*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_vertex_transforms()".} ## \
## Returns the maximum number of transform matrices that may be simultaneously
## used to transform any one vertex by the graphics hardware.  If this number
## is 0, then the hardware (or the graphics backend) doesn't support soft-
## skinned vertices (in which case Panda will animate the vertices in
## software).
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc get_max_vertex_transform_indices*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_vertex_transform_indices()".} ## \
## Returns the maximum number of transforms there may be in a single
## TransformTable for this graphics hardware.  If this number is 0 (but
## get_max_transforms() is nonzero), then the graphics hardware (or API)
## doesn't support indexed transforms, but can support direct transform
## references.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc get_copy_texture_inverted*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_copy_texture_inverted()".} ## \
## Returns true if this particular GSG has the property that any framebuffer-
## to-texture copy results in a texture that is upside-down and backwards from
## Panda's usual convention; that is, it copies into a texture from the bottom
## up instead of from the top down.
##
## If this is true, then on offscreen GraphicsBuffer created for the purposes
## of rendering into a texture should be created with the invert flag set
## true, to compensate.  Panda will do this automatically if you create an
## offscreen buffer using GraphicsOutput::make_texture_buffer().

proc get_supports_generate_mipmap*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_generate_mipmap()".} ## \
## Returns true if this particular GSG can generate mipmaps for a texture
## automatically, or if they must be generated in software.  If this is true,
## then mipmaps can safely be enabled for rendered textures (e.g.  using the
## MultitexReducer).

proc get_supports_depth_texture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_depth_texture()".} ## \
## Returns true if this particular GSG supports textures whose format is
## F_depth_stencil.  This returns true if the GSG supports GL_DEPTH_COMPONENT
## textures, which are considered a limited but still valid case of
## F_depth_stencil.

proc get_supports_depth_stencil*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_depth_stencil()".} ## \
## Returns true if this particular GSG supports textures whose format is
## F_depth_stencil.  This only returns true if the GSG supports the full
## packed depth-stencil functionality.

proc get_supports_luminance_texture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_luminance_texture()".} ## \
## Returns true if this particular GSG supports luminance textures.

proc get_supports_sampler_objects*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_sampler_objects()".} ## \
## Returns true if this particular GSG supports the use of sampler objects to
## record texture sampling parameters separately from the texture objects.
## This doesn't really affect functionality, but if this is false, it may mean
## that using the same texture with different SamplerState objects will result
## in reduced performance.

proc get_supports_basic_shaders*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_basic_shaders()".} ## \
## Returns true if this particular GSG supports arbfp1+arbvp1 or above.

proc get_supports_geometry_shaders*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_geometry_shaders()".} ## \
## Returns true if this particular GSG supports geometry shaders.

proc get_supports_tessellation_shaders*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_tessellation_shaders()".} ## \
## Returns true if this particular GSG supports tesselation shaders.

proc get_supports_compute_shaders*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_compute_shaders()".} ## \
## Returns true if this particular GSG supports compute shaders.

proc get_supports_glsl*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_glsl()".} ## \
## Returns true if this particular GSG supports GLSL shaders.

proc get_supports_stencil*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_stencil()".} ## \
## Returns true if this particular GSG supports stencil buffers at all.

proc get_supports_two_sided_stencil*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_two_sided_stencil()".} ## \
## Returns true if this particular GSG supports two sided stencil: different
## stencil settings for the front and back side of the same polygon.

proc get_supports_geometry_instancing*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_geometry_instancing()".} ## \
## Returns true if this particular GSG supports hardware geometry instancing:
## the ability to render multiple copies of a model.  In OpenGL, this is done
## using the EXT_draw_instanced extension.

proc get_supports_indirect_draw*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_indirect_draw()".} ## \
## Returns true if this particular GSG supports draw calls for which the
## information comes from a buffer.

proc get_supports_occlusion_query*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_occlusion_query()".} ## \
## Returns true if this GSG supports an occlusion query.  If this is true,
## then begin_occlusion_query() and end_occlusion_query() may be called to
## bracket a sequence of draw_triangles() (or whatever) calls to measure
## pixels that pass the depth test.

proc get_supports_timer_query*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_timer_query()".} ## \
## Returns true if this GSG supports a timer query.

proc get_timer_queries_active*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_timer_queries_active()".} ## \
## Returns true if timer queries are currently enabled on this GSG.

proc get_max_color_targets*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_color_targets()".} ## \
## Returns the maximum number of simultaneous color textures that may be
## attached for render-to-texture, as supported by this particular GSG.  If
## you exceed this number, the lowest-priority render targets will not be
## applied.  Use RenderTarget::set_priority() to adjust the relative
## importance of the different render targets.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc get_maximum_simultaneous_render_targets*(this: GraphicsStateGuardian): int {.importcpp: "#->get_maximum_simultaneous_render_targets()".} ## \
## Deprecated.  Use get_max_color_targets() instead, which returns the exact
## same value.

proc get_supports_dual_source_blending*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_dual_source_blending()".} ## \
## Returns true if dual source (incoming1_color and incoming1_alpha) blend
## operands are supported by this GSG.

proc get_supports_cg_profile*(this: GraphicsStateGuardian, name: string): bool {.importcpp: "#->get_supports_cg_profile(nimStringToStdString(#))", header: stringConversionCode.}

proc get_color_scale_via_lighting*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_color_scale_via_lighting()".} ## \
## Returns true if this particular GSG can implement (or would prefer to
## implement) set color and/or color scale using materials and/or ambient
## lights, or false if we need to actually munge the color.

proc get_alpha_scale_via_texture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_alpha_scale_via_texture()".} ## \
## Returns true if this particular GSG can implement (or would prefer to
## implement) an alpha scale via an additional Texture layer, or false if we
## need to actually munge the alpha.

proc get_alpha_scale_via_texture*(this: GraphicsStateGuardian, tex_attrib: TextureAttrib): bool {.importcpp: "#->get_alpha_scale_via_texture(#)".} ## \
## This variant of get_alpha_scale_via_texture() answers the question of
## whether the GSG can implement an alpha scale via an additional Texture
## layer, considering the current TextureAttrib that will be in effect.  This
## considers whether there is at least one additional texture slot available
## on the GSG.

proc get_runtime_color_scale*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_runtime_color_scale()".} ## \
## Returns true if this particular GSG can implement (or would prefer to
## implement) set color and/or color scale directly, without requiring any
## munging of vertices or tricks with lighting.

proc get_alpha_scale_texture_stage*(_: typedesc[GraphicsStateGuardian]): TextureStage {.importcpp: "GraphicsStateGuardian::get_alpha_scale_texture_stage()", header: "graphicsStateGuardian.h".} ## \
## Returns the TextureStage that will be used to apply an alpha scale, if
## get_alpha_scale_via_texture() returns true.

proc set_coordinate_system*(this: GraphicsStateGuardian, cs: CoordinateSystem) {.importcpp: "#->set_coordinate_system(#)".}

proc get_coordinate_system*(this: GraphicsStateGuardian): CoordinateSystem {.importcpp: "#->get_coordinate_system()".} ## \
## Returns the coordinate system in effect on this particular gsg.  Normally,
## this will be the default coordinate system, but it might be set differently
## at runtime.

proc get_internal_coordinate_system*(this: GraphicsStateGuardian): CoordinateSystem {.importcpp: "#->get_internal_coordinate_system()".}

proc get_prepared_objects*(this: GraphicsStateGuardian): PreparedGraphicsObjects {.importcpp: "#->get_prepared_objects()".}

proc set_gamma*(this: GraphicsStateGuardian, gamma: float32): bool {.importcpp: "#->set_gamma(#)".}

proc get_gamma*(this: GraphicsStateGuardian): float32 {.importcpp: "#->get_gamma()".}

proc restore_gamma*(this: GraphicsStateGuardian) {.importcpp: "#->restore_gamma()".}

proc set_flash_texture*(this: GraphicsStateGuardian, tex: Texture) {.importcpp: "#->set_flash_texture(#)".}

proc clear_flash_texture*(this: GraphicsStateGuardian) {.importcpp: "#->clear_flash_texture()".}

proc get_flash_texture*(this: GraphicsStateGuardian): Texture {.importcpp: "#->get_flash_texture()".}

proc has_extension*(this: GraphicsStateGuardian, extension: string): bool {.importcpp: "#->has_extension(nimStringToStdString(#))", header: stringConversionCode.}

proc get_driver_vendor*(this: GraphicsStateGuardian): string {.importcpp: "nimStringFromStdString(#->get_driver_vendor())", header: stringConversionCode.}

proc get_driver_renderer*(this: GraphicsStateGuardian): string {.importcpp: "nimStringFromStdString(#->get_driver_renderer())", header: stringConversionCode.}

proc get_driver_version*(this: GraphicsStateGuardian): string {.importcpp: "nimStringFromStdString(#->get_driver_version())", header: stringConversionCode.}

proc get_driver_version_major*(this: GraphicsStateGuardian): int {.importcpp: "#->get_driver_version_major()".}

proc get_driver_version_minor*(this: GraphicsStateGuardian): int {.importcpp: "#->get_driver_version_minor()".}

proc get_driver_shader_version_major*(this: GraphicsStateGuardian): int {.importcpp: "#->get_driver_shader_version_major()".}

proc get_driver_shader_version_minor*(this: GraphicsStateGuardian): int {.importcpp: "#->get_driver_shader_version_minor()".}

proc set_scene*(this: GraphicsStateGuardian, scene_setup: SceneSetup): bool {.importcpp: "#->set_scene(#)".}

proc get_scene*(this: GraphicsStateGuardian): SceneSetup {.importcpp: "#->get_scene()".}

proc begin_scene*(this: GraphicsStateGuardian): bool {.importcpp: "#->begin_scene()".}

proc end_scene*(this: GraphicsStateGuardian) {.importcpp: "#->end_scene()".}

proc get_class_type*(_: typedesc[GraphicsStateGuardian]): TypeHandle {.importcpp: "GraphicsStateGuardian::get_class_type()", header: "graphicsStateGuardian.h".}

proc newGraphicsEngine*(): GraphicsEngine {.importcpp: "new GraphicsEngine()".} ## \
## Creates a new GraphicsEngine object.  The Pipeline is normally left to
## default to NULL, which indicates the global render pipeline, but it may be
## any Pipeline you choose.

proc set_threading_model*(this: GraphicsEngine, threading_model: GraphicsThreadingModel) {.importcpp: "#->set_threading_model(#)".} ## \
## Specifies how future objects created via make_gsg(), make_buffer(), and
## make_output() will be threaded.  This does not affect any already-created
## objects.

proc get_threading_model*(this: GraphicsEngine): GraphicsThreadingModel {.importcpp: "#->get_threading_model()".} ## \
## Returns the threading model that will be applied to future objects.  See
## set_threading_model().

proc initGraphicsThreadingModel*(copy: GraphicsThreadingModel): GraphicsThreadingModel {.importcpp: "GraphicsThreadingModel(#)".}

proc initGraphicsThreadingModel*(model: string): GraphicsThreadingModel {.importcpp: "GraphicsThreadingModel(nimStringToStdString(#))", header: stringConversionCode.} ## \
## The threading model accepts a string representing the names of the two
## threads that will process cull and draw for the given window, separated by
## a slash.  The names are completely arbitrary and are used only to
## differentiate threads.  The two names may be the same, meaning the same
## thread, or each may be the empty string, which represents the previous
## thread.
##
## Thus, for example, "cull/draw" indicates that the window will be culled in
## a thread called "cull", and drawn in a separate thread called "draw".
## "draw/draw" or simply "draw" indicates the window will be culled and drawn
## in the same thread, "draw". On the other hand, "/draw" indicates the thread
## will be culled in the main, or app thread, and drawn in a separate thread
## named "draw".  The empty string, "" or "/", indicates the thread will be
## culled and drawn in the main thread; that is to say, a single-process
## model.
##
## Finally, if the threading model begins with a "-" character, then cull and
## draw are run simultaneously, in the same thread, with no binning or state
## sorting.  It simplifies the cull process but it forces the scene to render
## in scene graph order; state sorting and alpha sorting is lost.

proc initGraphicsThreadingModel*(): GraphicsThreadingModel {.importcpp: "GraphicsThreadingModel()".} ## \
## The threading model accepts a string representing the names of the two
## threads that will process cull and draw for the given window, separated by
## a slash.  The names are completely arbitrary and are used only to
## differentiate threads.  The two names may be the same, meaning the same
## thread, or each may be the empty string, which represents the previous
## thread.
##
## Thus, for example, "cull/draw" indicates that the window will be culled in
## a thread called "cull", and drawn in a separate thread called "draw".
## "draw/draw" or simply "draw" indicates the window will be culled and drawn
## in the same thread, "draw". On the other hand, "/draw" indicates the thread
## will be culled in the main, or app thread, and drawn in a separate thread
## named "draw".  The empty string, "" or "/", indicates the thread will be
## culled and drawn in the main thread; that is to say, a single-process
## model.
##
## Finally, if the threading model begins with a "-" character, then cull and
## draw are run simultaneously, in the same thread, with no binning or state
## sorting.  It simplifies the cull process but it forces the scene to render
## in scene graph order; state sorting and alpha sorting is lost.

proc get_model*(this: GraphicsThreadingModel): string {.importcpp: "nimStringFromStdString(#.get_model())", header: stringConversionCode.} ## \
## Returns the string that describes the threading model.  See the
## constructor.

proc get_cull_name*(this: GraphicsThreadingModel): string {.importcpp: "nimStringFromStdString(#.get_cull_name())", header: stringConversionCode.} ## \
## Returns the name of the thread that will handle culling in this model.

proc set_cull_name*(this: GraphicsThreadingModel, cull_name: string) {.importcpp: "#.set_cull_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of the thread that will handle culling in this model.
## This won't change any windows that were already created with this model;
## this only has an effect on newly-opened windows.

proc get_cull_stage*(this: GraphicsThreadingModel): int {.importcpp: "#.get_cull_stage()".} ## \
## Returns the pipeline stage from which the cull thread should access data.
## This will be 0 if the cull is run in the same thread as app, or 1 if it is
## its own thread.

proc get_draw_name*(this: GraphicsThreadingModel): string {.importcpp: "nimStringFromStdString(#.get_draw_name())", header: stringConversionCode.} ## \
## Returns the name of the thread that will handle sending the actual graphics
## primitives to the graphics API in this model.

proc set_draw_name*(this: GraphicsThreadingModel, cull_name: string) {.importcpp: "#.set_draw_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of the thread that will handle drawing in this model.
## This won't change any windows that were already created with this model;
## this only has an effect on newly-opened windows.

proc get_draw_stage*(this: GraphicsThreadingModel): int {.importcpp: "#.get_draw_stage()".} ## \
## Returns the pipeline stage from which the draw thread should access data.
## This will be the same value as get_cull_stage() if cull and draw are run in
## the same thread, or one more than that value if draw should be in its own
## thread.

proc get_cull_sorting*(this: GraphicsThreadingModel): bool {.importcpp: "#.get_cull_sorting()".} ## \
## Returns true if the model involves a separate cull pass, or false if
## culling happens implicitly, at the same time as draw.

proc set_cull_sorting*(this: GraphicsThreadingModel, cull_sorting: bool) {.importcpp: "#.set_cull_sorting(#)".} ## \
## Changes the flag that indicates whether the threading model involves a
## separate cull pass.  This won't change any windows that were already
## created with this model; this only has an effect on newly-opened windows.

proc is_single_threaded*(this: GraphicsThreadingModel): bool {.importcpp: "#.is_single_threaded()".} ## \
## Returns true if the threading model is a single-threaded model, or false if
## it involves threads.

proc is_default*(this: GraphicsThreadingModel): bool {.importcpp: "#.is_default()".} ## \
## Returns true if the threading model is the default, cull-then-draw single-
## threaded model, or false otherwise.

proc output*(this: GraphicsThreadingModel, `out`: ostream) {.importcpp: "#.output(#)".}

proc get_render_lock*(this: GraphicsEngine): ReMutex {.importcpp: "#->get_render_lock()".} ## \
## Returns a ReMutex object that is held by the GraphicsEngine during the
## entire call to render_frame().  While you hold this lock you can be
## confident that no part of the frame will be rendered (at least by the app
## thread).

proc set_auto_flip*(this: GraphicsEngine, auto_flip: bool) {.importcpp: "#->set_auto_flip(#)".} ## \
## Set this flag true to indicate the GraphicsEngine should automatically
## cause windows to sync and flip as soon as they have finished drawing,
## rather than waiting for all of the windows to finish drawing first so they
## can flip together.
##
## This only affects the timing of when the flip occurs.  If this is true (the
## default), the flip occurs before render_frame() returns.  If this is false,
## the flip occurs whenever flip_frame() is called, or at the beginning of the
## next call to render_frame(), if flip_frame() is never called.

proc get_auto_flip*(this: GraphicsEngine): bool {.importcpp: "#->get_auto_flip()".} ## \
## Returns the current setting for the auto-flip flag.  See set_auto_flip.

proc set_portal_cull*(this: GraphicsEngine, value: bool) {.importcpp: "#->set_portal_cull(#)".} ## \
## Set this flag true to indicate the GraphicsEngine should start portal
## culling

proc get_portal_cull*(this: GraphicsEngine): bool {.importcpp: "#->get_portal_cull()".} ## \
## Returns the current setting for the portal culling flag.

proc set_default_loader*(this: GraphicsEngine, loader: Loader) {.importcpp: "#->set_default_loader(#)".} ## \
## Sets the Loader object that will be assigned to every GSG created with this
## GraphicsEngine.  See GraphicsStateGuardian::set_loader().

proc get_default_loader*(this: GraphicsEngine): Loader {.importcpp: "#->get_default_loader()".} ## \
## Returns the Loader object that will be assigned to every GSG created with
## this GraphicsEngine.  See GraphicsStateGuardian::set_loader().

proc make_output*(this: GraphicsEngine, pipe: GraphicsPipe, name: string, sort: int, fb_prop: FrameBufferProperties, win_prop: WindowProperties, flags: int, gsg: GraphicsStateGuardian, host: GraphicsOutput): GraphicsOutput {.importcpp: "#->make_output(#, nimStringToStdString(#), #, #, #, #, #, #)", header: stringConversionCode.}

proc make_output*(this: GraphicsEngine, pipe: GraphicsPipe, name: string, sort: int, fb_prop: FrameBufferProperties, win_prop: WindowProperties, flags: int, gsg: GraphicsStateGuardian): GraphicsOutput {.importcpp: "#->make_output(#, nimStringToStdString(#), #, #, #, #, #)", header: stringConversionCode.}

proc make_output*(this: GraphicsEngine, pipe: GraphicsPipe, name: string, sort: int, fb_prop: FrameBufferProperties, win_prop: WindowProperties, flags: int): GraphicsOutput {.importcpp: "#->make_output(#, nimStringToStdString(#), #, #, #, #)", header: stringConversionCode.}

proc make_buffer*(this: GraphicsEngine, host: GraphicsOutput, name: string, sort: int, x_size: int, y_size: int): GraphicsOutput {.importcpp: "#->make_buffer(#, nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Syntactic shorthand for make_output.  This is the preferred way to create
## an offscreen buffer, when you already have an onscreen window or another
## buffer to start with.  For the first parameter, pass an existing
## GraphicsOutput object, e.g.  the main window; this allows the buffer to
## adapt itself to that window's framebuffer properties, and allows maximum
## sharing of resources.

proc make_buffer*(this: GraphicsEngine, gsg: GraphicsStateGuardian, name: string, sort: int, x_size: int, y_size: int): GraphicsOutput {.importcpp: "#->make_buffer(#, nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Syntactic shorthand for make_output.  This flavor accepts a GSG rather than
## a GraphicsOutput as the first parameter, which is too limiting and
## disallows the possibility of creating a ParasiteBuffer if the user's
## graphics hardware prefers that.  It also attempts to request specific
## framebuffer properties and may therefore do a poorer job of sharing the GSG
## between the old buffer and the new.
##
## For these reasons, this variant is a poor choice unless you are creating an
## offscreen buffer for the first time, without an onscreen window already in
## existence.  If you already have an onscreen window, you should use the
## other flavor of make_buffer() instead, which accepts a GraphicsOutput as
## the first parameter.

proc make_parasite*(this: GraphicsEngine, host: GraphicsOutput, name: string, sort: int, x_size: int, y_size: int): GraphicsOutput {.importcpp: "#->make_parasite(#, nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Syntactic shorthand for make_buffer.

proc add_window*(this: GraphicsEngine, window: GraphicsOutput, sort: int): bool {.importcpp: "#->add_window(#, #)".} ## \
## This can be used to add a newly-created GraphicsOutput object (and its GSG)
## to the engine's list of windows, and requests that it be opened.  This
## shouldn't be called by user code as make_output normally does this under
## the hood; it may be useful in esoteric cases in which a custom window
## object is used.
##
## This can be called during the rendering loop, unlike make_output(); the
## window will be opened before the next frame begins rendering.  Because it
## doesn't call open_windows(), however, it's not guaranteed that the window
## will succeed opening even if it returns true.

proc remove_window*(this: GraphicsEngine, window: GraphicsOutput): bool {.importcpp: "#->remove_window(#)".} ## \
## Removes the indicated window or offscreen buffer from the set of windows
## that will be processed when render_frame() is called.  This also closes the
## window if it is open, and removes the window from its GraphicsPipe,
## allowing the window to be destructed if there are no other references to
## it.  (However, the window may not be actually closed until next frame, if
## it is controlled by a sub-thread.)
##
## The return value is true if the window was removed, false if it was not
## found.
##
## Unlike remove_all_windows(), this function does not terminate any of the
## threads that may have been started to service this window; they are left
## running (since you might open a new window later on these threads).  If
## your intention is to clean up before shutting down, it is better to call
## remove_all_windows() then to call remove_window() one at a time.

proc remove_all_windows*(this: GraphicsEngine) {.importcpp: "#->remove_all_windows()".} ## \
## Removes and closes all windows from the engine.  This also cleans up and
## terminates any threads that have been started to service those windows.

proc reset_all_windows*(this: GraphicsEngine, swapchain: bool) {.importcpp: "#->reset_all_windows(#)".} ## \
## Resets the framebuffer of the current window.  This is currently used by
## DirectX 8 only.  It calls a reset_window function on each active window to
## release/create old/new framebuffer

proc is_empty*(this: GraphicsEngine): bool {.importcpp: "#->is_empty()".} ## \
## Returns true if there are no windows or buffers managed by the engine,
## false if there is at least one.

proc get_num_windows*(this: GraphicsEngine): int {.importcpp: "#->get_num_windows()".} ## \
## Returns the number of windows (or buffers) managed by the engine.

proc get_window*(this: GraphicsEngine, n: int): GraphicsOutput {.importcpp: "#->get_window(#)".} ## \
## Returns the nth window or buffers managed by the engine, in sorted order.

proc render_frame*(this: GraphicsEngine) {.importcpp: "#->render_frame()".} ## \
## Renders the next frame in all the registered windows, and flips all of the
## frame buffers.

proc open_windows*(this: GraphicsEngine) {.importcpp: "#->open_windows()".} ## \
## Fully opens (or closes) any windows that have recently been requested open
## or closed, without rendering any frames.  It is not necessary to call this
## explicitly, since windows will be automatically opened or closed when the
## next frame is rendered, but you may call this if you want your windows now
## without seeing a frame go by.

proc sync_frame*(this: GraphicsEngine) {.importcpp: "#->sync_frame()".} ## \
## Waits for all the threads that started drawing their last frame to finish
## drawing.  The windows are not yet flipped when this returns; see also
## flip_frame(). It is not usually necessary to call this explicitly, unless
## you need to see the previous frame right away.

proc ready_flip*(this: GraphicsEngine) {.importcpp: "#->ready_flip()".} ## \
## Waits for all the threads that started drawing their last frame to finish
## drawing.  Returns when all threads have actually finished drawing, as
## opposed to 'sync_frame' we seems to return once all draw calls have been
## submitted.  Calling 'flip_frame' after this function should immediately
## cause a buffer flip.  This function will only work in opengl right now, for
## all other graphics pipelines it will simply return immediately.  In opengl
## it's a bit of a hack: it will attempt to read a single pixel from the frame
## buffer to force the graphics card to finish drawing before it returns

proc flip_frame*(this: GraphicsEngine) {.importcpp: "#->flip_frame()".} ## \
## Waits for all the threads that started drawing their last frame to finish
## drawing, and then flips all the windows.  It is not usually necessary to
## call this explicitly, unless you need to see the previous frame right away.

proc extract_texture_data*(this: GraphicsEngine, tex: Texture, gsg: GraphicsStateGuardian): bool {.importcpp: "#->extract_texture_data(#, #)".} ## \
## Asks the indicated GraphicsStateGuardian to retrieve the texture memory
## image of the indicated texture and store it in the texture's ram_image
## field.  The image can then be written to disk via Texture::write(), or
## otherwise manipulated on the CPU.
##
## This is useful for retrieving the contents of a texture that has been
## somehow generated on the graphics card, instead of having been loaded the
## normal way via Texture::read() or Texture::load(). It is particularly
## useful for getting the data associated with a compressed texture image.
##
## Since this requires a round-trip to the draw thread, it may require waiting
## for the current thread to finish rendering if it is called in a
## multithreaded environment.  However, you can call this several consecutive
## times on different textures for little additional cost.
##
## If the texture has not yet been loaded to the GSG in question, it will be
## loaded immediately.
##
## The return value is true if the operation is successful, false otherwise.

proc dispatch_compute*(this: GraphicsEngine, work_groups: LVecBase3i, sattr: ShaderAttrib, gsg: GraphicsStateGuardian) {.importcpp: "#->dispatch_compute(#, #, #)".} ## \
## Asks the indicated GraphicsStateGuardian to dispatch the compute shader in
## the given ShaderAttrib using the given work group counts.  This can act as
## an interface for running a one-off compute shader, without having to store
## it in the scene graph using a ComputeNode.
##
## Since this requires a round-trip to the draw thread, it may require waiting
## for the current thread to finish rendering if it is called in a
## multithreaded environment.  However, you can call this several consecutive
## times on different textures for little additional cost.
##
## The return value is true if the operation is successful, false otherwise.

proc get_global_ptr*(_: typedesc[GraphicsEngine]): GraphicsEngine {.importcpp: "GraphicsEngine::get_global_ptr()", header: "graphicsEngine.h".}

proc count_textures*(this: GraphicsOutput): int {.importcpp: "#->count_textures()".} ## \
## If the GraphicsOutput is set to render into a texture, returns the number
## of textures that are being rendered into.  Normally, the textures would be
## associated with different buffers - a color texture, a depth texture, and a
## stencil texture.

proc has_texture*(this: GraphicsOutput): bool {.importcpp: "#->has_texture()".} ## \
## Returns true if the GraphicsOutput is rendering into any textures at all.

proc get_texture*(this: GraphicsOutput, i: int): Texture {.importcpp: "#->get_texture(#)".} ## \
## Returns the nth texture into which the GraphicsOutput renders.  Returns
## NULL if there is no such texture.
##
## If the texture is non-NULL, it may be applied to geometry to be rendered
## for any other windows or outputs that share the same GSG as this
## GraphicsOutput.  The effect is undefined for windows that share a different
## GSG; usually in these cases the texture will be invalid.

proc get_texture*(this: GraphicsOutput): Texture {.importcpp: "#->get_texture()".} ## \
## Returns the nth texture into which the GraphicsOutput renders.  Returns
## NULL if there is no such texture.
##
## If the texture is non-NULL, it may be applied to geometry to be rendered
## for any other windows or outputs that share the same GSG as this
## GraphicsOutput.  The effect is undefined for windows that share a different
## GSG; usually in these cases the texture will be invalid.

proc clear_render_textures*(this: GraphicsOutput) {.importcpp: "#->clear_render_textures()".} ## \
## If the GraphicsOutput is currently rendering to a texture, then all
## textures are dissociated from the GraphicsOuput.

proc setup_render_texture*(this: GraphicsOutput, tex: Texture, allow_bind: bool, to_ram: bool) {.importcpp: "#->setup_render_texture(#, #, #)".} ## \
## This is a deprecated interface that made sense back when GraphicsOutputs
## could only render into one texture at a time.  From now on, use
## clear_render_textures and add_render_texture instead.
##
## @deprecated Use add_render_texture() instead.

proc get_size*(this: GraphicsOutput): LVecBase2i {.importcpp: "#->get_size()".} ## \
## Returns the visible size of the window or buffer, if it is known.  In
## certain cases (e.g.  fullscreen windows), the size may not be known until
## after the object has been fully created.  Check has_size() first.
##
## Certain objects (like windows) may change size spontaneously; this method
## is not thread-safe.  To get the size of a window in a thread-safe manner,
## query get_properties().

proc get_x_size*(this: GraphicsOutput): int {.importcpp: "#->get_x_size()".} ## \
## Returns the visible width of the window or buffer, if it is known.  In
## certain cases (e.g.  fullscreen windows), the size may not be known until
## after the object has been fully created.  Check has_size() first.
##
## Certain objects (like windows) may change size spontaneously; this method
## is not thread-safe.  To get the size of a window in a thread-safe manner,
## query get_properties().

proc get_y_size*(this: GraphicsOutput): int {.importcpp: "#->get_y_size()".} ## \
## Returns the visible height of the window or buffer, if it is known.  In
## certain cases (e.g.  fullscreen windows), the size may not be known until
## after the object has been fully created.  Check has_size() first.
##
## Certain objects (like windows) may change size spontaneously; this method
## is not thread-safe.  To get the size of a window in a thread-safe manner,
## query get_properties().

proc get_fb_size*(this: GraphicsOutput): LVecBase2i {.importcpp: "#->get_fb_size()".} ## \
## Returns the internal size of the window or buffer.  This is almost always
## the same as get_size(), except when a pixel_zoom is in effect--see
## set_pixel_zoom().

proc get_fb_x_size*(this: GraphicsOutput): int {.importcpp: "#->get_fb_x_size()".} ## \
## Returns the internal width of the window or buffer.  This is almost always
## the same as get_x_size(), except when a pixel_zoom is in effect--see
## set_pixel_zoom().

proc get_fb_y_size*(this: GraphicsOutput): int {.importcpp: "#->get_fb_y_size()".} ## \
## Returns the internal height of the window or buffer.  This is almost always
## the same as get_y_size(), except when a pixel_zoom is in effect--see
## set_pixel_zoom().

proc get_sbs_left_size*(this: GraphicsOutput): LVecBase2i {.importcpp: "#->get_sbs_left_size()".} ## \
## If side-by-side stereo is enabled, this returns the pixel size of the left
## eye, based on scaling get_size() by get_sbs_left_dimensions().  If side-by-
## side stereo is not enabled, this returns the same as get_size().

proc get_sbs_left_x_size*(this: GraphicsOutput): int {.importcpp: "#->get_sbs_left_x_size()".} ## \
## If side-by-side stereo is enabled, this returns the pixel width of the left
## eye, based on scaling get_x_size() by get_sbs_left_dimensions().  If side-
## by-side stereo is not enabled, this returns the same as get_x_size().

proc get_sbs_left_y_size*(this: GraphicsOutput): int {.importcpp: "#->get_sbs_left_y_size()".} ## \
## If side-by-side stereo is enabled, this returns the pixel height of the
## left eye, based on scaling get_y_size() by get_sbs_left_dimensions().  If
## side-by-side stereo is not enabled, this returns the same as get_y_size().

proc get_sbs_right_size*(this: GraphicsOutput): LVecBase2i {.importcpp: "#->get_sbs_right_size()".} ## \
## If side-by-side stereo is enabled, this returns the pixel size of the right
## eye, based on scaling get_size() by get_sbs_right_dimensions().  If side-
## by-side stereo is not enabled, this returns the same as get_size().

proc get_sbs_right_x_size*(this: GraphicsOutput): int {.importcpp: "#->get_sbs_right_x_size()".} ## \
## If side-by-side stereo is enabled, this returns the pixel width of the
## right eye, based on scaling get_x_size() by get_sbs_right_dimensions().  If
## side-by-side stereo is not enabled, this returns the same as get_x_size().

proc get_sbs_right_y_size*(this: GraphicsOutput): int {.importcpp: "#->get_sbs_right_y_size()".} ## \
## If side-by-side stereo is enabled, this returns the pixel height of the
## right eye, based on scaling get_y_size() by get_sbs_right_dimensions().  If
## side-by-side stereo is not enabled, this returns the same as get_y_size().

proc has_size*(this: GraphicsOutput): bool {.importcpp: "#->has_size()".} ## \
## Returns true if the size of the window/frame buffer is known, false
## otherwise.  In certain cases the size may not be known until after the
## object has been fully created.  Also, certain objects (like windows) may
## change size spontaneously.

proc is_valid*(this: GraphicsOutput): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the output is fully created and ready for rendering, false
## otherwise.

proc is_nonzero_size*(this: GraphicsOutput): bool {.importcpp: "#->is_nonzero_size()".} ## \
## Returns true if the output has a nonzero size in both X and Y, or false if
## it is zero (and therefore invalid).

proc set_active*(this: GraphicsOutput, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets the active flag associated with the GraphicsOutput.  If the
## GraphicsOutput is marked inactive, nothing is rendered.

proc is_active*(this: GraphicsOutput): bool {.importcpp: "#->is_active()".} ## \
## Returns true if the window is ready to be rendered into, false otherwise.

proc set_one_shot*(this: GraphicsOutput, one_shot: bool) {.importcpp: "#->set_one_shot(#)".} ## \
## Changes the current setting of the one-shot flag.  When this is true, the
## GraphicsOutput will render the current frame and then automatically set
## itself inactive.  This is particularly useful for buffers that are created
## for the purposes of render-to-texture, for static textures that don't need
## to be continually re-rendered once they have been rendered the first time.
##
## Setting the buffer inactive is not the same thing as destroying it.  You
## are still responsible for passing this buffer to
## GraphicsEngine::remove_window() when you no longer need the texture, in
## order to clean up fully.  (However, you should not call remove_window() on
## this buffer while the texture is still needed, because depending on the
## render-to-texture mechanism in use, this may invalidate the texture
## contents.)

proc get_one_shot*(this: GraphicsOutput): bool {.importcpp: "#->get_one_shot()".} ## \
## Returns the current setting of the one-shot flag.  When this is true, the
## GraphicsOutput will automatically set itself inactive after the next frame.

proc set_inverted*(this: GraphicsOutput, inverted: bool) {.importcpp: "#->set_inverted(#)".} ## \
## Changes the current setting of the inverted flag.  When this is true, the
## scene is rendered into the window upside-down and backwards, that is,
## inverted as if viewed through a mirror placed on the floor.
##
## This is primarily intended to support DirectX (and a few buggy OpenGL
## graphics drivers) that perform a framebuffer-to-texture copy upside-down
## from the usual OpenGL (and Panda) convention.  Panda will automatically set
## this flag for offscreen buffers on hardware that is known to do this, to
## compensate when rendering offscreen into a texture.

proc get_inverted*(this: GraphicsOutput): bool {.importcpp: "#->get_inverted()".} ## \
## Returns the current setting of the inverted flag.  When this is true, the
## scene is rendered into the window upside-down, flipped like a mirror along
## the X axis.  See set_inverted().

proc set_swap_eyes*(this: GraphicsOutput, swap_eyes: bool) {.importcpp: "#->set_swap_eyes(#)".} ## \
## Changes the "swap eyes" flag.  This flag is normally false.  When it is
## true, the left and right channels of a stereo DisplayRegion are sent to the
## opposite channels in the rendering backend.  This is meant to work around
## hardware that inadvertently swaps the output channels, or hardware for
## which it cannot be determined which channel is which until runtime.

proc get_swap_eyes*(this: GraphicsOutput): bool {.importcpp: "#->get_swap_eyes()".} ## \
## Returns the current setting of the "swap eyes" flag.  See set_swap_eyes().

proc set_red_blue_stereo*(this: GraphicsOutput, red_blue_stereo: bool, left_eye_color_mask: int, right_eye_color_mask: int) {.importcpp: "#->set_red_blue_stereo(#, #, #)".} ## \
## Enables red-blue stereo mode on this particular window.  When red-blue
## stereo mode is in effect, DisplayRegions that have the "left" channel set
## will render in the red (or specified) channel only, while DisplayRegions
## that have the "right" channel set will render in the blue (or specified)
## channel only.
##
## The remaining two parameters specify the particular color channel(s) to
## associate with each eye.  Use the bits defined in
## ColorWriteAttrib::Channels.
##
## This can be used to achieve a cheesy stereo mode in the absence of
## hardware-supported stereo.

proc get_red_blue_stereo*(this: GraphicsOutput): bool {.importcpp: "#->get_red_blue_stereo()".} ## \
## Returns whether red-blue stereo mode is in effect for this particular
## window.  See set_red_blue_stereo().

proc get_left_eye_color_mask*(this: GraphicsOutput): int {.importcpp: "#->get_left_eye_color_mask()".} ## \
## Returns the color mask in effect when rendering a left-eye view in red_blue
## stereo mode.  This is one or more bits defined in
## ColorWriteAttrib::Channels.  See set_red_blue_stereo().

proc get_right_eye_color_mask*(this: GraphicsOutput): int {.importcpp: "#->get_right_eye_color_mask()".} ## \
## Returns the color mask in effect when rendering a right-eye view in
## red_blue stereo mode.  This is one or more bits defined in
## ColorWriteAttrib::Channels.  See set_red_blue_stereo().

proc set_side_by_side_stereo*(this: GraphicsOutput, side_by_side_stereo: bool) {.importcpp: "#->set_side_by_side_stereo(#)".} ## \
## Enables side-by-side stereo mode on this particular window.  When side-by-
## side stereo mode is in effect, DisplayRegions that have the "left" channel
## set will render on the part of the window specified by sbs_left_dimensions
## (typically the left half: (0, 0.5, 0, 1)), while DisplayRegions that have
## the "right" channel set will render on the part of the window specified by
## sbs_right_dimensions (typically the right half: (0.5, 1, 0, 1)).
##
## This is commonly used in a dual-monitor mode, where a window is opened that
## spans two monitors, and each monitor represents a different eye.

proc set_side_by_side_stereo*(this: GraphicsOutput, side_by_side_stereo: bool, sbs_left_dimensions: LVecBase4, sbs_right_dimensions: LVecBase4) {.importcpp: "#->set_side_by_side_stereo(#, #, #)".} ## \
## Enables side-by-side stereo mode on this particular window.  When side-by-
## side stereo mode is in effect, DisplayRegions that have the "left" channel
## set will render on the part of the window specified by sbs_left_dimensions
## (typically the left half: (0, 0.5, 0, 1)), while DisplayRegions that have
## the "right" channel set will render on the part of the window specified by
## sbs_right_dimensions (typically the right half: (0.5, 1, 0, 1)).
##
## This is commonly used in a dual-monitor mode, where a window is opened that
## spans two monitors, and each monitor represents a different eye.

proc get_side_by_side_stereo*(this: GraphicsOutput): bool {.importcpp: "#->get_side_by_side_stereo()".} ## \
## Returns whether side-by-side stereo mode is in effect for this particular
## window.  See set_side_by_side_stereo().

proc get_sbs_left_dimensions*(this: GraphicsOutput): LVecBase4 {.importcpp: "#->get_sbs_left_dimensions()".} ## \
## Returns the effective sub-region of the window for displaying the left
## channel, if side-by-side stereo mode is in effect for the window.  See
## set_side_by_side_stereo().

proc get_sbs_right_dimensions*(this: GraphicsOutput): LVecBase4 {.importcpp: "#->get_sbs_right_dimensions()".} ## \
## Returns the effective sub-region of the window for displaying the right
## channel, if side-by-side stereo mode is in effect for the window.  See
## set_side_by_side_stereo().

proc get_fb_properties*(this: GraphicsOutput): FrameBufferProperties {.importcpp: "#->get_fb_properties()".} ## \
## Returns the framebuffer properties of the window.

proc is_stereo*(this: GraphicsOutput): bool {.importcpp: "#->is_stereo()".} ## \
## Returns Returns true if this window can render stereo DisplayRegions,
## either through red-blue stereo (see set_red_blue_stereo()) or through true
## hardware stereo rendering.

proc clear_delete_flag*(this: GraphicsOutput) {.importcpp: "#->clear_delete_flag()".} ## \
## Resets the delete flag, so the GraphicsOutput will not be automatically
## deleted before the beginning of the next frame.

proc get_delete_flag*(this: GraphicsOutput): bool {.importcpp: "#->get_delete_flag()".} ## \
## Returns the current setting of the delete flag.  When this is true, the
## GraphicsOutput will automatically be removed before the beginning of the
## next frame by the GraphicsEngine.

proc set_sort*(this: GraphicsOutput, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Adjusts the sorting order of this particular GraphicsOutput, relative to
## other GraphicsOutputs.

proc get_sort*(this: GraphicsOutput): int {.importcpp: "#->get_sort()".} ## \
## Returns the sorting order of this particular GraphicsOutput.  The various
## GraphicsOutputs within a particular thread will be rendered in the
## indicated order.

proc set_child_sort*(this: GraphicsOutput, child_sort: int) {.importcpp: "#->set_child_sort(#)".} ## \
## Specifies the sort value of future offscreen buffers created by
## make_texture_sort().
##
## The purpose of this method is to allow the user to limit the sort value
## chosen for a buffer created via make_texture_buffer().  Normally, this
## buffer will be assigned a value of get_sort() - 1, so that it will be
## rendered before this window is rendered; but sometimes this isn't
## sufficiently early, especially if other buffers also have a view into the
## same scene.
##
## If you specify a value here, then new buffers created via
## make_texture_buffer() will be given that sort value instead of get_sort() -
## 1.

proc clear_child_sort*(this: GraphicsOutput) {.importcpp: "#->clear_child_sort()".} ## \
## Resets the sort value of future offscreen buffers created by
## make_texture_sort() to the default value.  See set_child_sort().

proc get_child_sort*(this: GraphicsOutput): int {.importcpp: "#->get_child_sort()".} ## \
## Returns the sort value of future offscreen buffers created by
## make_texture_sort(). See set_child_sort().

proc trigger_copy*(this: GraphicsOutput): AsyncFuture {.importcpp: "#->trigger_copy()".} ## \
## When the GraphicsOutput is in triggered copy mode, this function triggers
## the copy (at the end of the next frame).
## @returns a future that can be awaited.

proc make_display_region*(this: GraphicsOutput): DisplayRegion {.importcpp: "#->make_display_region()".} ## \
## Creates a new DisplayRegion that covers the entire window.
##
## If is_stereo() is true for this window, and default-stereo-camera is
## configured true, this actually makes a StereoDisplayRegion.  Call
## make_mono_display_region() or make_stereo_display_region() if you want to
## insist on one or the other.

proc make_display_region*(this: GraphicsOutput, dimensions: LVecBase4): DisplayRegion {.importcpp: "#->make_display_region(#)".} ## \
## Creates a new DisplayRegion that covers the indicated sub-rectangle within
## the window.  The range on all parameters is 0..1.
##
## If is_stereo() is true for this window, and default-stereo-camera is
## configured true, this actually makes a StereoDisplayRegion.  Call
## make_mono_display_region() or make_stereo_display_region() if you want to
## insist on one or the other.

proc make_display_region*(this: GraphicsOutput, l: float32, r: float32, b: float32, t: float32): DisplayRegion {.importcpp: "#->make_display_region(#, #, #, #)".} ## \
## Creates a new DisplayRegion that covers the indicated sub-rectangle within
## the window.  The range on all parameters is 0..1.
##
## If is_stereo() is true for this window, and default-stereo-camera is
## configured true, this actually makes a StereoDisplayRegion.  Call
## make_mono_display_region() or make_stereo_display_region() if you want to
## insist on one or the other.

proc make_mono_display_region*(this: GraphicsOutput): DisplayRegion {.importcpp: "#->make_mono_display_region()".} ## \
## Creates a new DisplayRegion that covers the entire window.
##
## This generally returns a mono DisplayRegion, even if is_stereo() is true.
## However, if side-by-side stereo is enabled, this will return a
## StereoDisplayRegion whose two eyes are both set to SC_mono.  (This is
## necessary because in side-by-side stereo mode, it is necessary to draw even
## mono DisplayRegions twice).

proc make_mono_display_region*(this: GraphicsOutput, dimensions: LVecBase4): DisplayRegion {.importcpp: "#->make_mono_display_region(#)".} ## \
## Creates a new DisplayRegion that covers the indicated sub-rectangle within
## the window.  The range on all parameters is 0..1.
##
## This generally returns a mono DisplayRegion, even if is_stereo() is true.
## However, if side-by-side stereo is enabled, this will return a
## StereoDisplayRegion whose two eyes are both set to SC_mono.  (This is
## necessary because in side-by-side stereo mode, it is necessary to draw even
## mono DisplayRegions twice).

proc make_mono_display_region*(this: GraphicsOutput, l: float32, r: float32, b: float32, t: float32): DisplayRegion {.importcpp: "#->make_mono_display_region(#, #, #, #)".} ## \
## Creates a new DisplayRegion that covers the entire window.
##
## This generally returns a mono DisplayRegion, even if is_stereo() is true.
## However, if side-by-side stereo is enabled, this will return a
## StereoDisplayRegion whose two eyes are both set to SC_mono.  (This is
## necessary because in side-by-side stereo mode, it is necessary to draw even
## mono DisplayRegions twice).

proc make_stereo_display_region*(this: GraphicsOutput): StereoDisplayRegion {.importcpp: "#->make_stereo_display_region()".} ## \
## Creates a new DisplayRegion that covers the entire window.
##
## This always returns a stereo DisplayRegion, even if is_stereo() is false.

proc make_stereo_display_region*(this: GraphicsOutput, dimensions: LVecBase4): StereoDisplayRegion {.importcpp: "#->make_stereo_display_region(#)".} ## \
## Creates a new DisplayRegion that covers the indicated sub-rectangle within
## the window.  The range on all parameters is 0..1.
##
## This always returns a stereo DisplayRegion, even if is_stereo() is false.

proc make_stereo_display_region*(this: GraphicsOutput, l: float32, r: float32, b: float32, t: float32): StereoDisplayRegion {.importcpp: "#->make_stereo_display_region(#, #, #, #)".} ## \
## Creates a new DisplayRegion that covers the entire window.
##
## This always returns a stereo DisplayRegion, even if is_stereo() is false.

proc remove_display_region*(this: GraphicsOutput, display_region: DisplayRegion): bool {.importcpp: "#->remove_display_region(#)".} ## \
## Removes the indicated DisplayRegion from the window, and destructs it if
## there are no other references.
##
## Returns true if the DisplayRegion is found and removed, false if it was not
## a part of the window.

proc remove_all_display_regions*(this: GraphicsOutput) {.importcpp: "#->remove_all_display_regions()".} ## \
## Removes all display regions from the window, except the default one that is
## created with the window.

proc get_overlay_display_region*(this: GraphicsOutput): DisplayRegion {.importcpp: "#->get_overlay_display_region()".} ## \
## Returns the special "overlay" DisplayRegion that is created for each window
## or buffer.  This DisplayRegion covers the entire window, but cannot be used
## for rendering.  It is a placeholder only, to indicate the dimensions of the
## window, and is usually used internally for purposes such as clearing the
## window, or grabbing a screenshot of the window.
##
## There are very few applications that require access to this DisplayRegion.
## Normally, you should create your own DisplayRegion that covers the window,
## if you want to render to the window.

proc set_overlay_display_region*(this: GraphicsOutput, display_region: DisplayRegion) {.importcpp: "#->set_overlay_display_region(#)".} ## \
## Replaces the special "overlay" DisplayRegion that is created for each
## window or buffer.  See get_overlay_display_region().  This must be a new
## DisplayRegion that has already been created for this window, for instance
## via a call to make_mono_display_region().  You are responsible for ensuring
## that the new DisplayRegion covers the entire window.  The previous overlay
## display region is not automatically removed; you must explicitly call
## remove_display_region() on it after replacing it with this method, if you
## wish it to be removed.
##
## Normally, there is no reason to change the overlay DisplayRegion, so this
## method should be used only in very unusual circumstances.

proc get_num_display_regions*(this: GraphicsOutput): int {.importcpp: "#->get_num_display_regions()".} ## \
## Returns the number of DisplayRegions that have been created within the
## window, active or otherwise.

proc get_display_region*(this: GraphicsOutput, n: int): DisplayRegion {.importcpp: "#->get_display_region(#)".} ## \
## Returns the nth DisplayRegion of those that have been created within the
## window.  This may return NULL if n is out of bounds; particularly likely if
## the number of display regions has changed since the last call to
## get_num_display_regions().

proc get_num_active_display_regions*(this: GraphicsOutput): int {.importcpp: "#->get_num_active_display_regions()".} ## \
## Returns the number of active DisplayRegions that have been created within
## the window.

proc get_active_display_region*(this: GraphicsOutput, n: int): DisplayRegion {.importcpp: "#->get_active_display_region(#)".} ## \
## Returns the nth active DisplayRegion of those that have been created within
## the window.  This may return NULL if n is out of bounds; particularly
## likely if the number of display regions has changed since the last call to
## get_num_active_display_regions().

proc make_texture_buffer*(this: GraphicsOutput, name: string, x_size: int, y_size: int, tex: Texture, to_ram: bool, fbp: FrameBufferProperties): GraphicsOutput {.importcpp: "#->make_texture_buffer(nimStringToStdString(#), #, #, #, #, #)", header: stringConversionCode.} ## \
## Creates and returns an offscreen buffer for rendering into, the result of
## which will be a texture suitable for applying to geometry within the scene
## rendered into this window.
##
## If you pass zero as the buffer size, the buffer will have the same size as
## the host window, and will automatically be resized when the host window is.
##
## If tex is not NULL, it is the texture that will be set up for rendering
## into; otherwise, a new Texture object will be created.  In either case, the
## target texture can be retrieved from the return value with
## buffer->get_texture() (assuming the return value is not NULL).
##
## If to_ram is true, the buffer will be set up to download its contents to
## the system RAM memory associated with the Texture object, instead of
## keeping it strictly within texture memory; this is much slower, but it
## allows using the texture with any GSG.
##
## This will attempt to be smart about maximizing render performance while
## minimizing framebuffer waste.  It might return a GraphicsBuffer set to
## render directly into a texture, if possible; or it might return a
## ParasiteBuffer that renders into this window.  The return value is NULL if
## the buffer could not be created for some reason.
##
## When you are done using the buffer, you should remove it with a call to
## GraphicsEngine::remove_window().

proc make_texture_buffer*(this: GraphicsOutput, name: string, x_size: int, y_size: int, tex: Texture, to_ram: bool): GraphicsOutput {.importcpp: "#->make_texture_buffer(nimStringToStdString(#), #, #, #, #)", header: stringConversionCode.} ## \
## Creates and returns an offscreen buffer for rendering into, the result of
## which will be a texture suitable for applying to geometry within the scene
## rendered into this window.
##
## If you pass zero as the buffer size, the buffer will have the same size as
## the host window, and will automatically be resized when the host window is.
##
## If tex is not NULL, it is the texture that will be set up for rendering
## into; otherwise, a new Texture object will be created.  In either case, the
## target texture can be retrieved from the return value with
## buffer->get_texture() (assuming the return value is not NULL).
##
## If to_ram is true, the buffer will be set up to download its contents to
## the system RAM memory associated with the Texture object, instead of
## keeping it strictly within texture memory; this is much slower, but it
## allows using the texture with any GSG.
##
## This will attempt to be smart about maximizing render performance while
## minimizing framebuffer waste.  It might return a GraphicsBuffer set to
## render directly into a texture, if possible; or it might return a
## ParasiteBuffer that renders into this window.  The return value is NULL if
## the buffer could not be created for some reason.
##
## When you are done using the buffer, you should remove it with a call to
## GraphicsEngine::remove_window().

proc make_texture_buffer*(this: GraphicsOutput, name: string, x_size: int, y_size: int, tex: Texture): GraphicsOutput {.importcpp: "#->make_texture_buffer(nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Creates and returns an offscreen buffer for rendering into, the result of
## which will be a texture suitable for applying to geometry within the scene
## rendered into this window.
##
## If you pass zero as the buffer size, the buffer will have the same size as
## the host window, and will automatically be resized when the host window is.
##
## If tex is not NULL, it is the texture that will be set up for rendering
## into; otherwise, a new Texture object will be created.  In either case, the
## target texture can be retrieved from the return value with
## buffer->get_texture() (assuming the return value is not NULL).
##
## If to_ram is true, the buffer will be set up to download its contents to
## the system RAM memory associated with the Texture object, instead of
## keeping it strictly within texture memory; this is much slower, but it
## allows using the texture with any GSG.
##
## This will attempt to be smart about maximizing render performance while
## minimizing framebuffer waste.  It might return a GraphicsBuffer set to
## render directly into a texture, if possible; or it might return a
## ParasiteBuffer that renders into this window.  The return value is NULL if
## the buffer could not be created for some reason.
##
## When you are done using the buffer, you should remove it with a call to
## GraphicsEngine::remove_window().

proc make_texture_buffer*(this: GraphicsOutput, name: string, x_size: int, y_size: int): GraphicsOutput {.importcpp: "#->make_texture_buffer(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Creates and returns an offscreen buffer for rendering into, the result of
## which will be a texture suitable for applying to geometry within the scene
## rendered into this window.
##
## If you pass zero as the buffer size, the buffer will have the same size as
## the host window, and will automatically be resized when the host window is.
##
## If tex is not NULL, it is the texture that will be set up for rendering
## into; otherwise, a new Texture object will be created.  In either case, the
## target texture can be retrieved from the return value with
## buffer->get_texture() (assuming the return value is not NULL).
##
## If to_ram is true, the buffer will be set up to download its contents to
## the system RAM memory associated with the Texture object, instead of
## keeping it strictly within texture memory; this is much slower, but it
## allows using the texture with any GSG.
##
## This will attempt to be smart about maximizing render performance while
## minimizing framebuffer waste.  It might return a GraphicsBuffer set to
## render directly into a texture, if possible; or it might return a
## ParasiteBuffer that renders into this window.  The return value is NULL if
## the buffer could not be created for some reason.
##
## When you are done using the buffer, you should remove it with a call to
## GraphicsEngine::remove_window().

proc make_cube_map*(this: GraphicsOutput, name: string, size: int, camera_rig: NodePath): GraphicsOutput {.importcpp: "#->make_cube_map(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## This is similar to make_texture_buffer() in that it allocates a separate
## buffer suitable for rendering to a texture that can be assigned to geometry
## in this window, but in this case, the buffer is set up to render the six
## faces of a cube map.
##
## The buffer is automatically set up with six display regions and six
## cameras, each of which are assigned the indicated draw_mask and parented to
## the given camera_rig node (which you should then put in your scene to
## render the cube map from the appropriate point of view).
##
## You may take the texture associated with the buffer and apply it to
## geometry, particularly with TexGenAttrib::M_world_cube_map also in effect,
## to apply a reflection of everything seen by the camera rig.

proc make_screenshot_filename*(_: typedesc[GraphicsOutput], prefix: string): Filename {.importcpp: "GraphicsOutput::make_screenshot_filename(nimStringToStdString(#))", header: "graphicsOutput.h".} ## \
## Saves a screenshot of the region to a default filename, and returns the
## filename, or empty string if the screenshot failed.  The default filename
## is generated from the supplied prefix and from the Config variable
## screenshot-filename, which contains the following strings:
##
## %~p - the supplied prefix %~f - the frame count %~e - the value of
## screenshot-extension All other % strings in strftime().

proc make_screenshot_filename*(_: typedesc[GraphicsOutput]): Filename {.importcpp: "GraphicsOutput::make_screenshot_filename()", header: "graphicsOutput.h".} ## \
## Saves a screenshot of the region to a default filename, and returns the
## filename, or empty string if the screenshot failed.  The default filename
## is generated from the supplied prefix and from the Config variable
## screenshot-filename, which contains the following strings:
##
## %~p - the supplied prefix %~f - the frame count %~e - the value of
## screenshot-extension All other % strings in strftime().

proc save_screenshot_default*(this: GraphicsOutput, prefix: string): Filename {.importcpp: "#->save_screenshot_default(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Saves a screenshot of the region to a default filename, and returns the
## filename, or empty string if the screenshot failed.  The filename is
## generated by make_screenshot_filename().

proc save_screenshot_default*(this: GraphicsOutput): Filename {.importcpp: "#->save_screenshot_default()".} ## \
## Saves a screenshot of the region to a default filename, and returns the
## filename, or empty string if the screenshot failed.  The filename is
## generated by make_screenshot_filename().

proc save_screenshot*(this: GraphicsOutput, filename: Filename, image_comment: string): bool {.importcpp: "#->save_screenshot(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Saves a screenshot of the region to the indicated filename.  The image
## comment is an optional user readable string that will be saved with the
## header of the image (if the file format supports embedded data; for example
## jpg allows comments).  Returns true on success, false on failure.

proc save_screenshot*(this: GraphicsOutput, filename: Filename): bool {.importcpp: "#->save_screenshot(#)".} ## \
## Saves a screenshot of the region to the indicated filename.  The image
## comment is an optional user readable string that will be saved with the
## header of the image (if the file format supports embedded data; for example
## jpg allows comments).  Returns true on success, false on failure.

proc get_screenshot*(this: GraphicsOutput): Texture {.importcpp: "#->get_screenshot()".} ## \
## Captures the most-recently rendered image from the framebuffer and returns
## it as Texture, or NULL on failure.

proc get_screenshot*(this: GraphicsOutput, image: PNMImage): bool {.importcpp: "#->get_screenshot(#)".} ## \
## Captures the most-recently rendered image from the framebuffer into the
## indicated PNMImage.  Returns true on success, false on failure.

proc get_texture_card*(this: GraphicsOutput): NodePath {.importcpp: "#->get_texture_card()".} ## \
## Returns a PandaNode containing a square polygon.  The dimensions are
## (-1,0,-1) to (1,0,1). The texture coordinates are such that the texture of
## this GraphicsOutput is aligned properly to the polygon.  The GraphicsOutput
## promises to surgically update the Geom inside the PandaNode if necessary to
## maintain this invariant.
##
## Each invocation of this function returns a freshly- allocated PandaNode.
## You can therefore safely modify the RenderAttribs of the PandaNode.  The
## PandaNode is initially textured with the texture of this GraphicOutput.

proc share_depth_buffer*(this: GraphicsOutput, graphics_output: GraphicsOutput): bool {.importcpp: "#->share_depth_buffer(#)".} ## \
## Will attempt to use the depth buffer of the input graphics_output.  The
## buffer sizes must be exactly the same.

proc unshare_depth_buffer*(this: GraphicsOutput) {.importcpp: "#->unshare_depth_buffer()".} ## \
## Discontinue sharing the depth buffer.

proc get_supports_render_texture*(this: GraphicsOutput): bool {.importcpp: "#->get_supports_render_texture()".} ## \
## Returns true if this particular GraphicsOutput can render directly into a
## texture, or false if it must always copy-to-texture at the end of each
## frame to achieve this effect.

proc flip_ready*(this: GraphicsOutput): bool {.importcpp: "#->flip_ready()".} ## \
## These are not intended to be called directly by the user, but they're
## published anyway since they might occasionally be useful for low-level
## debugging.

proc get_host*(this: GraphicsOutput): GraphicsOutput {.importcpp: "#->get_host()".} ## \
## This is normally called only from within make_texture_buffer().  When
## called on a ParasiteBuffer, it returns the host of that buffer; but when
## called on some other buffer, it returns the buffer itself.

proc get_class_type*(_: typedesc[GraphicsOutput]): TypeHandle {.importcpp: "GraphicsOutput::get_class_type()", header: "graphicsOutput.h".}

proc set_camera*(this: DisplayRegion, camera: NodePath) {.importcpp: "#->set_camera(#)".} ## \
## Sets the camera that is associated with this DisplayRegion.  There is a
## one-to-many association between cameras and DisplayRegions; one camera may
## be shared by multiple DisplayRegions.
##
## The camera is actually set via a NodePath, which clarifies which instance
## of the camera (if there happen to be multiple instances) we should use.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc get_camera*(this: DisplayRegion, current_thread: Thread): NodePath {.importcpp: "#->get_camera(#)".} ## \
## Returns the camera associated with this DisplayRegion, or an empty NodePath
## if no camera is associated.

proc get_camera*(this: DisplayRegion): NodePath {.importcpp: "#->get_camera()".} ## \
## Returns the camera associated with this DisplayRegion, or an empty NodePath
## if no camera is associated.

proc set_active*(this: DisplayRegion, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets the active flag associated with the DisplayRegion.  If the
## DisplayRegion is marked inactive, nothing is rendered.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc is_active*(this: DisplayRegion): bool {.importcpp: "#->is_active()".} ## \
## Returns the active flag associated with the DisplayRegion.

proc set_sort*(this: DisplayRegion, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Sets the sort value associated with the DisplayRegion.  Within a window,
## DisplayRegions will be rendered in order from the lowest sort value to the
## highest.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc get_sort*(this: DisplayRegion): int {.importcpp: "#->get_sort()".} ## \
## Returns the sort value associated with the DisplayRegion.

proc set_tex_view_offset*(this: DisplayRegion, tex_view_offset: int) {.importcpp: "#->set_tex_view_offset(#)".} ## \
## Sets the current texture view offset for this DisplayRegion.  This is
## normally set to zero.  If nonzero, it is used to select a particular view
## of any multiview textures that are rendered within this DisplayRegion.
##
## For a StereoDisplayRegion, this is normally 0 for the left eye, and 1 for
## the right eye, to support stereo textures.  This is set automatically when
## you call set_stereo_channel().

proc get_tex_view_offset*(this: DisplayRegion): int {.importcpp: "#->get_tex_view_offset()".} ## \
## Returns the current texture view offset for this DisplayRegion.  This is
## normally set to zero.  If nonzero, it is used to select a particular view
## of any multiview textures that are rendered within this DisplayRegion.
##
## For a StereoDisplayRegion, this is normally 0 for the left eye, and 1 for
## the right eye, to support stereo textures.

proc set_incomplete_render*(this: DisplayRegion, incomplete_render: bool) {.importcpp: "#->set_incomplete_render(#)".} ## \
## Sets the incomplete_render flag.  When this is true, the frame will be
## rendered even if some of the geometry or textures in the scene are not
## available (e.g.  they have been temporarily paged out).  When this is
## false, the frame will be held up while this data is reloaded.
##
## This flag may also be set on the GraphicsStateGuardian.  It will be
## considered true for a given DisplayRegion only if it is true on both the
## GSG and on the DisplayRegion.
##
## See GraphicsStateGuardian::set_incomplete_render() for more detail.

proc get_incomplete_render*(this: DisplayRegion): bool {.importcpp: "#->get_incomplete_render()".} ## \
## Returns the incomplete_render flag.  See set_incomplete_render().

proc set_texture_reload_priority*(this: DisplayRegion, texture_reload_priority: int) {.importcpp: "#->set_texture_reload_priority(#)".} ## \
## Specifies an integer priority which is assigned to any asynchronous texture
## reload requests spawned while processing this DisplayRegion.  This controls
## which textures are loaded first when multiple textures need to be reloaded
## at once; it also controls the relative priority between asynchronous
## texture loads and asynchronous model or animation loads.
##
## Specifying a larger number here makes the textures rendered by this
## DisplayRegion load up first.  This may be particularly useful to do, for
## instance, for the DisplayRegion that renders the gui.

proc get_texture_reload_priority*(this: DisplayRegion): int {.importcpp: "#->get_texture_reload_priority()".} ## \
## Returns the priority which is assigned to asynchronous texture reload
## requests.  See set_texture_reload_priority().

proc set_lens_index*(this: DisplayRegion, index: int) {.importcpp: "#->set_lens_index(#)".} ## \
## Sets the lens index, allows for multiple lenses to be attached to a camera.
## This is useful for a variety of setups, such as fish eye rendering.  The
## default is 0.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc get_lens_index*(this: DisplayRegion): int {.importcpp: "#->get_lens_index()".} ## \
## Returns the specific lens of the associated Camera that will be used for
## rendering this scene.  Most Cameras hold only one lens, but for multiple
## lenses this method may be used to selected between them.

proc set_cull_traverser*(this: DisplayRegion, trav: CullTraverser) {.importcpp: "#->set_cull_traverser(#)".} ## \
## Specifies the CullTraverser that will be used to draw the contents of this
## DisplayRegion.  Normally the default CullTraverser is sufficient, but this
## may be changed to change the default cull behavior.

proc get_cull_traverser*(this: DisplayRegion): CullTraverser {.importcpp: "#->get_cull_traverser()".} ## \
## Returns the CullTraverser that will be used to draw the contents of this
## DisplayRegion.

proc set_cube_map_index*(this: DisplayRegion, cube_map_index: int) {.importcpp: "#->set_cube_map_index(#)".} ## \
## Deprecated; replaced by set_target_tex_page().

proc set_target_tex_page*(this: DisplayRegion, page: int) {.importcpp: "#->set_target_tex_page(#)".} ## \
## This is a special parameter that is only used when rendering the faces of a
## cube map or multipage and/or multiview texture.
##
## This sets up the DisplayRegion to render to the ith page and jth view of
## its associated texture(s); the value must be consistent with the range of
## values availble to the texture.  A normal DisplayRegion that is not
## associated with any particular page should be set to page -1 and view 0.
##
## This is particularly useful when rendering cube maps and/or stereo
## textures.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc get_target_tex_page*(this: DisplayRegion): int {.importcpp: "#->get_target_tex_page()".} ## \
## Returns the target page number associated with this particular
## DisplayRegion, or -1 if it is not associated with a page.  See
## set_target_tex_page().

proc set_scissor_enabled*(this: DisplayRegion, scissor_enabled: bool) {.importcpp: "#->set_scissor_enabled(#)".} ## \
## Sets whether or not scissor testing is enabled for this region.  The
## default is true, except for the overlay display region.

proc get_scissor_enabled*(this: DisplayRegion): bool {.importcpp: "#->get_scissor_enabled()".} ## \
## Returns whether or not scissor testing is enabled for this region.  The
## default is true, except for the overlay display region.

proc set_cull_callback*(this: DisplayRegion, `object`: CallbackObject) {.importcpp: "#->set_cull_callback(#)".} ## \
## Sets the CallbackObject that will be notified when the DisplayRegion is
## visited during the cull traversal.  This callback will be made during the
## cull thread.
##
## The cull traversal is responsible for determining which nodes are visible
## and within the view frustum, and for accumulating state and transform, and
## generally building up the list of CullableObjects that are to be eventually
## passed to the draw traversal for rendering.
##
## At the time the cull traversal callback is made, the traversal for this
## DisplayRegion has not yet started.
##
## The callback is passed an instance of a DisplayRegionCullCallbackData,
## which contains pointers to the current scene information, as well as the
## current DisplayRegion and GSG.  The callback *replaces* the normal cull
## behavior, so if your callback does nothing, the scene graph will not be
## traversed and therefore nothing will be drawn.  If you wish the normal cull
## traversal to be performed for this DisplayRegion, you must call
## cbdata->upcall() from your callback.

proc clear_cull_callback*(this: DisplayRegion) {.importcpp: "#->clear_cull_callback()".} ## \
## Removes the callback set by an earlier call to set_cull_callback().

proc get_cull_callback*(this: DisplayRegion): CallbackObject {.importcpp: "#->get_cull_callback()".} ## \
## Returns the CallbackObject set by set_cull_callback().

proc set_draw_callback*(this: DisplayRegion, `object`: CallbackObject) {.importcpp: "#->set_draw_callback(#)".} ## \
## Sets the CallbackObject that will be notified when the contents of
## DisplayRegion is drawn during the draw traversal.  This callback will be
## made during the draw thread.
##
## The draw traversal is responsible for actually issuing the commands to the
## graphics engine to draw primitives.  Its job is to walk through the list of
## CullableObjects build up by the cull traversal, as quickly as possible,
## issuing the appropriate commands to draw each one.
##
## At the time the draw traversal callback is made, the graphics state is in
## the initial state, and no projection matrix or modelview matrix is in
## effect.  begin_scene() has not yet been called, and no objects have yet
## been drawn.  However, the viewport has already been set to the appropriate
## part of the window, and the clear commands for this DisplayRegion (if any)
## have been issued.
##
## The callback is passed an instance of a DisplayRegionDrawCallbackData,
## which contains pointers to the current scene information, as well as the
## current DisplayRegion and GSG.  The callback *replaces* the normal draw
## behavior, so if your callback does nothing, nothing in the DisplayRegion
## will be drawn.  If you wish the draw traversal to continue to draw the
## contents of this DisplayRegion, you must call cbdata->upcall() from your
## callback.

proc clear_draw_callback*(this: DisplayRegion) {.importcpp: "#->clear_draw_callback()".} ## \
## Removes the callback set by an earlier call to set_draw_callback().

proc get_draw_callback*(this: DisplayRegion): CallbackObject {.importcpp: "#->get_draw_callback()".} ## \
## Returns the CallbackObject set by set_draw_callback().

proc get_pixel_width*(this: DisplayRegion, i: int): int {.importcpp: "#->get_pixel_width(#)".} ## \
## Returns the width of the DisplayRegion in pixels.

proc get_pixel_width*(this: DisplayRegion): int {.importcpp: "#->get_pixel_width()".} ## \
## Returns the width of the DisplayRegion in pixels.

proc get_pixel_height*(this: DisplayRegion, i: int): int {.importcpp: "#->get_pixel_height(#)".} ## \
## Returns the height of the DisplayRegion in pixels.

proc get_pixel_height*(this: DisplayRegion): int {.importcpp: "#->get_pixel_height()".} ## \
## Returns the height of the DisplayRegion in pixels.

proc get_pixel_size*(this: DisplayRegion, i: int): LVecBase2i {.importcpp: "#->get_pixel_size(#)".} ## \
## Returns the size of the DisplayRegion in pixels.

proc get_pixel_size*(this: DisplayRegion): LVecBase2i {.importcpp: "#->get_pixel_size()".} ## \
## Returns the size of the DisplayRegion in pixels.

proc output*(this: DisplayRegion, `out`: ostream) {.importcpp: "#->output(#)".}

proc make_screenshot_filename*(_: typedesc[DisplayRegion], prefix: string): Filename {.importcpp: "DisplayRegion::make_screenshot_filename(nimStringToStdString(#))", header: "displayRegion.h".} ## \
## Synthesizes a suitable default filename for passing to save_screenshot().
##
## The default filename is generated from the supplied prefix and from the
## Config variable screenshot-filename, which contains the following strings:
##
## %~p - the supplied prefix %~f - the frame count %~e - the value of
## screenshot-extension All other % strings in strftime().

proc make_screenshot_filename*(_: typedesc[DisplayRegion]): Filename {.importcpp: "DisplayRegion::make_screenshot_filename()", header: "displayRegion.h".} ## \
## Synthesizes a suitable default filename for passing to save_screenshot().
##
## The default filename is generated from the supplied prefix and from the
## Config variable screenshot-filename, which contains the following strings:
##
## %~p - the supplied prefix %~f - the frame count %~e - the value of
## screenshot-extension All other % strings in strftime().

proc save_screenshot_default*(this: DisplayRegion, prefix: string): Filename {.importcpp: "#->save_screenshot_default(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Saves a screenshot of the region to a default filename, and returns the
## filename, or empty string if the screenshot failed.  The filename is
## generated by make_screenshot_filename().

proc save_screenshot_default*(this: DisplayRegion): Filename {.importcpp: "#->save_screenshot_default()".} ## \
## Saves a screenshot of the region to a default filename, and returns the
## filename, or empty string if the screenshot failed.  The filename is
## generated by make_screenshot_filename().

proc save_screenshot*(this: DisplayRegion, filename: Filename, image_comment: string): bool {.importcpp: "#->save_screenshot(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Saves a screenshot of the region to the indicated filename.  Returns true
## on success, false on failure.

proc save_screenshot*(this: DisplayRegion, filename: Filename): bool {.importcpp: "#->save_screenshot(#)".} ## \
## Saves a screenshot of the region to the indicated filename.  Returns true
## on success, false on failure.

proc get_screenshot*(this: DisplayRegion): Texture {.importcpp: "#->get_screenshot()".} ## \
## Captures the most-recently rendered image from the framebuffer and returns
## it as a Texture, or NULL on failure.

proc get_screenshot*(this: DisplayRegion, image: PNMImage): bool {.importcpp: "#->get_screenshot(#)".} ## \
## Captures the most-recently rendered image from the framebuffer into the
## indicated PNMImage.  Returns true on success, false on failure.

proc clear_cull_result*(this: DisplayRegion) {.importcpp: "#->clear_cull_result()".}

proc make_cull_result_graph*(this: DisplayRegion): PandaNode {.importcpp: "#->make_cull_result_graph()".} ## \
## Returns a special scene graph constructed to represent the results of the
## last frame's cull operation.
##
## This will be a hierarchy of nodes, one node for each bin, each of which
## will in term be a parent of a number of GeomNodes, representing the
## geometry drawn in each bin.
##
## This is useful mainly for high-level debugging and abstraction tools; it
## should not be mistaken for the low-level cull result itself, which is
## constructed and maintained internally.  No such scene graph is normally
## constructed during the rendering of a frame; this is an artificial
## construct created for the purpose of making it easy to analyze the results
## of the cull operation.

proc get_class_type*(_: typedesc[DisplayRegion]): TypeHandle {.importcpp: "DisplayRegion::get_class_type()", header: "displayRegion.h".}

proc get_left_eye*(this: StereoDisplayRegion): DisplayRegion {.importcpp: "#->get_left_eye()".} ## \
## Returns a pointer to the left DisplayRegion managed by this stereo object.

proc get_right_eye*(this: StereoDisplayRegion): DisplayRegion {.importcpp: "#->get_right_eye()".} ## \
## Returns a pointer to the right DisplayRegion managed by this stereo object.

proc get_class_type*(_: typedesc[StereoDisplayRegion]): TypeHandle {.importcpp: "StereoDisplayRegion::get_class_type()", header: "stereoDisplayRegion.h".}

proc get_depth_bits*(this: FrameBufferProperties): int {.importcpp: "#.get_depth_bits()".} ## \
## Individual queries.

proc get_color_bits*(this: FrameBufferProperties): int {.importcpp: "#.get_color_bits()".}

proc get_red_bits*(this: FrameBufferProperties): int {.importcpp: "#.get_red_bits()".}

proc get_green_bits*(this: FrameBufferProperties): int {.importcpp: "#.get_green_bits()".}

proc get_blue_bits*(this: FrameBufferProperties): int {.importcpp: "#.get_blue_bits()".}

proc get_alpha_bits*(this: FrameBufferProperties): int {.importcpp: "#.get_alpha_bits()".}

proc get_stencil_bits*(this: FrameBufferProperties): int {.importcpp: "#.get_stencil_bits()".}

proc get_accum_bits*(this: FrameBufferProperties): int {.importcpp: "#.get_accum_bits()".}

proc get_aux_rgba*(this: FrameBufferProperties): int {.importcpp: "#.get_aux_rgba()".}

proc get_aux_hrgba*(this: FrameBufferProperties): int {.importcpp: "#.get_aux_hrgba()".}

proc get_aux_float*(this: FrameBufferProperties): int {.importcpp: "#.get_aux_float()".}

proc get_multisamples*(this: FrameBufferProperties): int {.importcpp: "#.get_multisamples()".}

proc get_coverage_samples*(this: FrameBufferProperties): int {.importcpp: "#.get_coverage_samples()".} ## \
## If coverage samples are specified, and there is hardware support, we use
## coverage multisampling.

proc get_back_buffers*(this: FrameBufferProperties): int {.importcpp: "#.get_back_buffers()".}

proc get_indexed_color*(this: FrameBufferProperties): bool {.importcpp: "#.get_indexed_color()".}

proc get_rgb_color*(this: FrameBufferProperties): bool {.importcpp: "#.get_rgb_color()".}

proc get_stereo*(this: FrameBufferProperties): bool {.importcpp: "#.get_stereo()".}

proc get_force_hardware*(this: FrameBufferProperties): bool {.importcpp: "#.get_force_hardware()".}

proc get_force_software*(this: FrameBufferProperties): bool {.importcpp: "#.get_force_software()".}

proc get_srgb_color*(this: FrameBufferProperties): bool {.importcpp: "#.get_srgb_color()".}

proc get_float_color*(this: FrameBufferProperties): bool {.importcpp: "#.get_float_color()".}

proc get_float_depth*(this: FrameBufferProperties): bool {.importcpp: "#.get_float_depth()".}

proc set_depth_bits*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_depth_bits(#)".} ## \
## Individual assigners.

proc set_color_bits*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_color_bits(#)".} ## \
## Sets the number of requested color bits as a single number that represents
## the sum of the individual numbers of red, green and blue bits.  Panda won't
## care how the individual bits are divided up.
##
## See also set_rgba_bits, which allows you to specify requirements for the
## individual components.

proc set_rgba_bits*(this: FrameBufferProperties, r: int, g: int, b: int, a: int) {.importcpp: "#.set_rgba_bits(#, #, #, #)".} ## \
## Convenience method for setting the red, green, blue and alpha bits in one
## go.

proc set_red_bits*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_red_bits(#)".}

proc set_green_bits*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_green_bits(#)".}

proc set_blue_bits*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_blue_bits(#)".}

proc set_alpha_bits*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_alpha_bits(#)".}

proc set_stencil_bits*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_stencil_bits(#)".}

proc set_accum_bits*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_accum_bits(#)".}

proc set_aux_rgba*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_aux_rgba(#)".}

proc set_aux_hrgba*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_aux_hrgba(#)".}

proc set_aux_float*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_aux_float(#)".}

proc set_multisamples*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_multisamples(#)".}

proc set_coverage_samples*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_coverage_samples(#)".} ## \
## If coverage samples are specified, and there is hardware support, we use
## coverage multisampling

proc set_back_buffers*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_back_buffers(#)".}

proc set_indexed_color*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_indexed_color(#)".}

proc set_rgb_color*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_rgb_color(#)".}

proc set_stereo*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_stereo(#)".}

proc set_force_hardware*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_force_hardware(#)".}

proc set_force_software*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_force_software(#)".}

proc set_srgb_color*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_srgb_color(#)".}

proc set_float_color*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_float_color(#)".}

proc set_float_depth*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_float_depth(#)".}

proc initFrameBufferProperties*(): FrameBufferProperties {.importcpp: "FrameBufferProperties()".}

proc initFrameBufferProperties*(param0: FrameBufferProperties): FrameBufferProperties {.importcpp: "FrameBufferProperties(#)".}

proc get_default*(_: typedesc[FrameBufferProperties]): FrameBufferProperties {.importcpp: "FrameBufferProperties::get_default()", header: "frameBufferProperties.h".} ## \
## Returns a FrameBufferProperties structure with all of the default values
## filled in according to the user's config file.

proc `==`*(this: FrameBufferProperties, other: FrameBufferProperties): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: FrameBufferProperties, other: FrameBufferProperties): bool {.importcpp: "#.operator !=(#)".}

proc clear*(this: FrameBufferProperties) {.importcpp: "#.clear()".} ## \
## Unsets all properties that have been specified so far, and resets the
## FrameBufferProperties structure to its initial empty state.

proc set_all_specified*(this: FrameBufferProperties) {.importcpp: "#.set_all_specified()".} ## \
## Marks all bits as having been specified.

proc subsumes*(this: FrameBufferProperties, other: FrameBufferProperties): bool {.importcpp: "#.subsumes(#)".} ## \
## Returns true if this set of properties makes strictly greater or equal
## demands of the framebuffer than the other set of framebuffer properties.

proc add_properties*(this: FrameBufferProperties, other: FrameBufferProperties) {.importcpp: "#.add_properties(#)".} ## \
## Sets any properties that are explicitly specified in other on this object.
## Leaves other properties unchanged.

proc output*(this: FrameBufferProperties, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Generates a string representation.

proc set_one_bit_per_channel*(this: FrameBufferProperties) {.importcpp: "#.set_one_bit_per_channel()".} ## \
## If any of the depth, color, alpha, accum, or stencil properties is set to
## more than one, then they are reduced to one.

proc is_stereo*(this: FrameBufferProperties): bool {.importcpp: "#.is_stereo()".}

proc is_single_buffered*(this: FrameBufferProperties): bool {.importcpp: "#.is_single_buffered()".}

proc get_quality*(this: FrameBufferProperties, reqs: FrameBufferProperties): int {.importcpp: "#.get_quality(#)".} ## \
## Assumes that these properties are a description of a window.
##
## Measures how well this window satisfies a specified set of requirements.  A
## higher quality number means that more requirements were satisfied.  A
## quality of zero means that the window is unsuitable.
##
## The routine deducts a lot if the window fails to provide a requested
## feature.  It deducts less if the window provides a feature, but at a
## degraded level of functionality (ie, the user asks for rgba8, color, but
## the window only provides rgba4).  The routine also deducts a small amount
## for unnecessary features.  For example, if the window has an accumulation
## buffer when one is not requested will reduce quality slightly.  Maximum
## quality is obtained when the window exactly matches the request.
##
## If you want to know whether the window satisfies all of the requirements,
## use the "subsumes" function.

proc is_any_specified*(this: FrameBufferProperties): bool {.importcpp: "#.is_any_specified()".} ## \
## Returns true if any properties have been specified, false otherwise.

proc is_basic*(this: FrameBufferProperties): bool {.importcpp: "#.is_basic()".} ## \
## Returns true if the properties are extremely basic.  The following count as
## basic: rgb or rgba, depth.  If anything else is specified, the properties
## are non-basic.

proc get_aux_mask*(this: FrameBufferProperties): int {.importcpp: "#.get_aux_mask()".} ## \
## Converts the aux bitplanes of the framebuffer into a RenderBuffer::Type.

proc get_buffer_mask*(this: FrameBufferProperties): int {.importcpp: "#.get_buffer_mask()".} ## \
## Converts the non-aux bitplanes of the framebuffer into a
## RenderBuffer::Type.

proc verify_hardware_software*(this: FrameBufferProperties, props: FrameBufferProperties, renderer: string): bool {.importcpp: "#.verify_hardware_software(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Validates that the properties represent the desired kind of renderer
## (hardware or software).  If not, prints out an error message and returns
## false.

proc setup_color_texture*(this: FrameBufferProperties, tex: Texture): bool {.importcpp: "#.setup_color_texture(#)".} ## \
## Sets the texture up for render-to-texture matching these framebuffer
## properties.
##
## Returns true if there was a format that had enough bits, false otherwise.
## Of course, this is no guarantee that a particular graphics back-end
## supports rendering to textures of that format.

proc setup_depth_texture*(this: FrameBufferProperties, tex: Texture): bool {.importcpp: "#.setup_depth_texture(#)".} ## \
## Sets the texture up for render-to-texture matching these framebuffer
## properties.
##
## Returns true if there was a format that had enough bits, false otherwise.
## Of course, this is no guarantee that a particular graphics back-end
## supports rendering to textures of that format.

proc button_down*(this: GraphicsWindowInputDevice, button: ButtonHandle, time: float64) {.importcpp: "#->button_down(#, #)".} ## \
## The following interface is for the various kinds of GraphicsWindows to
## record the data incoming on the device.

proc button_down*(this: GraphicsWindowInputDevice, button: ButtonHandle) {.importcpp: "#->button_down(#)".} ## \
## The following interface is for the various kinds of GraphicsWindows to
## record the data incoming on the device.

proc button_resume_down*(this: GraphicsWindowInputDevice, button: ButtonHandle, time: float64) {.importcpp: "#->button_resume_down(#, #)".} ## \
## Records that the indicated button was depressed earlier, and we only just
## detected the event after the fact.  This is mainly useful for tracking the
## state of modifier keys.

proc button_resume_down*(this: GraphicsWindowInputDevice, button: ButtonHandle) {.importcpp: "#->button_resume_down(#)".} ## \
## Records that the indicated button was depressed earlier, and we only just
## detected the event after the fact.  This is mainly useful for tracking the
## state of modifier keys.

proc button_up*(this: GraphicsWindowInputDevice, button: ButtonHandle, time: float64) {.importcpp: "#->button_up(#, #)".} ## \
## Records that the indicated button has been released.

proc button_up*(this: GraphicsWindowInputDevice, button: ButtonHandle) {.importcpp: "#->button_up(#)".} ## \
## Records that the indicated button has been released.

proc keystroke*(this: GraphicsWindowInputDevice, keycode: int, time: float64) {.importcpp: "#->keystroke(#, #)".} ## \
## Records that the indicated keystroke has been generated.

proc keystroke*(this: GraphicsWindowInputDevice, keycode: int) {.importcpp: "#->keystroke(#)".} ## \
## Records that the indicated keystroke has been generated.

proc candidate*(this: GraphicsWindowInputDevice, candidate_string: string, highlight_start: clonglong, highlight_end: clonglong, cursor_pos: clonglong) {.importcpp: "#->candidate(nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Records that the indicated candidate string has been highlighted.  This is
## used to implement IME support for typing in international languages,
## especially Chinese/Japanese/Korean.

proc focus_lost*(this: GraphicsWindowInputDevice, time: float64) {.importcpp: "#->focus_lost(#)".} ## \
## This should be called when the window focus is lost, so that we may miss
## upcoming button events (especially "up" events) for the next period of
## time.  It generates keyboard and mouse "up" events for those buttons that
## we previously sent unpaired "down" events, so that the Panda application
## will believe all buttons are now released.

proc focus_lost*(this: GraphicsWindowInputDevice) {.importcpp: "#->focus_lost()".} ## \
## This should be called when the window focus is lost, so that we may miss
## upcoming button events (especially "up" events) for the next period of
## time.  It generates keyboard and mouse "up" events for those buttons that
## we previously sent unpaired "down" events, so that the Panda application
## will believe all buttons are now released.

proc raw_button_down*(this: GraphicsWindowInputDevice, button: ButtonHandle, time: float64) {.importcpp: "#->raw_button_down(#, #)".} ## \
## Records that the indicated button has been depressed.

proc raw_button_down*(this: GraphicsWindowInputDevice, button: ButtonHandle) {.importcpp: "#->raw_button_down(#)".} ## \
## Records that the indicated button has been depressed.

proc raw_button_up*(this: GraphicsWindowInputDevice, button: ButtonHandle, time: float64) {.importcpp: "#->raw_button_up(#, #)".} ## \
## Records that the indicated button has been released.

proc raw_button_up*(this: GraphicsWindowInputDevice, button: ButtonHandle) {.importcpp: "#->raw_button_up(#)".} ## \
## Records that the indicated button has been released.

proc get_pointer*(this: GraphicsWindowInputDevice): PointerData {.importcpp: "#->get_pointer()".} ## \
## Returns the PointerData associated with the input device's pointer.  This
## only makes sense if has_pointer() also returns true.

proc set_pointer_in_window*(this: GraphicsWindowInputDevice, x: float64, y: float64, time: float64) {.importcpp: "#->set_pointer_in_window(#, #, #)".} ## \
## To be called by a particular kind of GraphicsWindow to indicate that the
## pointer is within the window, at the given pixel coordinates.

proc set_pointer_in_window*(this: GraphicsWindowInputDevice, x: float64, y: float64) {.importcpp: "#->set_pointer_in_window(#, #)".} ## \
## To be called by a particular kind of GraphicsWindow to indicate that the
## pointer is within the window, at the given pixel coordinates.

proc set_pointer_out_of_window*(this: GraphicsWindowInputDevice, time: float64) {.importcpp: "#->set_pointer_out_of_window(#)".} ## \
## To be called by a particular kind of GraphicsWindow to indicate that the
## pointer is no longer within the window.

proc set_pointer_out_of_window*(this: GraphicsWindowInputDevice) {.importcpp: "#->set_pointer_out_of_window()".} ## \
## To be called by a particular kind of GraphicsWindow to indicate that the
## pointer is no longer within the window.

proc update_pointer*(this: GraphicsWindowInputDevice, data: PointerData, time: float64) {.importcpp: "#->update_pointer(#, #)".} ## \
## To be called by a particular kind of GraphicsWindow to indicate that the
## pointer data has changed.

proc update_pointer*(this: GraphicsWindowInputDevice, data: PointerData) {.importcpp: "#->update_pointer(#)".} ## \
## To be called by a particular kind of GraphicsWindow to indicate that the
## pointer data has changed.

proc pointer_moved*(this: GraphicsWindowInputDevice, x: float64, y: float64, time: float64) {.importcpp: "#->pointer_moved(#, #, #)".} ## \
## To be called by a particular kind of GraphicsWindow to indicate that the
## pointer has moved by the given relative amount.

proc pointer_moved*(this: GraphicsWindowInputDevice, x: float64, y: float64) {.importcpp: "#->pointer_moved(#, #)".} ## \
## To be called by a particular kind of GraphicsWindow to indicate that the
## pointer has moved by the given relative amount.

proc remove_pointer*(this: GraphicsWindowInputDevice, id: int) {.importcpp: "#->remove_pointer(#)".} ## \
## To be called by a particular kind of GraphicsWindow to indicate that the
## pointer no longer exists.

proc get_class_type*(_: typedesc[GraphicsWindowInputDevice]): TypeHandle {.importcpp: "GraphicsWindowInputDevice::get_class_type()", header: "graphicsWindowInputDevice.h".}

proc get_x*(this: TouchInfo): int {.importcpp: "#.get_x()".}

proc get_y*(this: TouchInfo): int {.importcpp: "#.get_y()".}

proc get_id*(this: TouchInfo): int {.importcpp: "#.get_id()".}

proc get_flags*(this: TouchInfo): int {.importcpp: "#.get_flags()".}

proc initTouchInfo*(param0: TouchInfo): TouchInfo {.importcpp: "TouchInfo(#)".}

proc get_hwnd*(this: GraphicsWindowProcCallbackData): clonglong {.importcpp: "#.get_hwnd()".} ## \
## Returns the Windows proc hwnd parameter.

proc get_msg*(this: GraphicsWindowProcCallbackData): int {.importcpp: "#.get_msg()".} ## \
## Returns the Windows proc msg parameter.

proc get_wparam*(this: GraphicsWindowProcCallbackData): int {.importcpp: "#.get_wparam()".} ## \
## Returns the Windows proc wparam parameter.

proc get_lparam*(this: GraphicsWindowProcCallbackData): int {.importcpp: "#.get_lparam()".} ## \
## Returns the Windows proc lparam parameter.

proc is_touch_event*(this: GraphicsWindowProcCallbackData): bool {.importcpp: "#.is_touch_event()".} ## \
## Returns whether the event is a touch event.

proc get_num_touches*(this: GraphicsWindowProcCallbackData): int {.importcpp: "#.get_num_touches()".} ## \
## Returns the current number of touches on the window.

proc get_touch_info*(this: GraphicsWindowProcCallbackData, index: int): TouchInfo {.importcpp: "#.get_touch_info(#)".} ## \
## Returns the TouchInfo object describing the specified touch.

proc get_class_type*(_: typedesc[GraphicsWindowProcCallbackData]): TypeHandle {.importcpp: "GraphicsWindowProcCallbackData::get_class_type()", header: "graphicsWindowProcCallbackData.h".}

proc get_properties*(this: GraphicsWindow): WindowProperties {.importcpp: "#->get_properties()".} ## \
## Returns the current properties of the window.

proc get_requested_properties*(this: GraphicsWindow): WindowProperties {.importcpp: "#->get_requested_properties()".} ## \
## Returns the properties of the window that are currently requested.  These
## properties will be applied to the window (if valid) at the next execution
## of process_events().

proc clear_rejected_properties*(this: GraphicsWindow) {.importcpp: "#->clear_rejected_properties()".} ## \
## Empties the set of failed properties that will be returned by
## get_rejected_properties().

proc get_rejected_properties*(this: GraphicsWindow): WindowProperties {.importcpp: "#->get_rejected_properties()".} ## \
## Returns the set of properties that have recently been requested, but could
## not be applied to the window for some reason.  This set of properties will
## remain unchanged until they are changed by a new failed request, or
## clear_rejected_properties() is called.

proc request_properties*(this: GraphicsWindow, requested_properties: WindowProperties) {.importcpp: "#->request_properties(#)".} ## \
## Requests a property change on the window.  For example, use this method to
## request a window change size or minimize or something.
##
## The change is not made immediately; rather, the request is saved and will
## be applied the next time the window task is run (probably at the next
## frame).

proc is_closed*(this: GraphicsWindow): bool {.importcpp: "#->is_closed()".} ## \
## Returns true if the window has not yet been opened, or has been fully
## closed, false if it is open.  The window is not opened immediately after
## GraphicsEngine::make_output() is called; nor is it closed immediately after
## GraphicsEngine::remove_window() is called.  Either operation may take a
## frame or two.

proc is_fullscreen*(this: GraphicsWindow): bool {.importcpp: "#->is_fullscreen()".} ## \
## Returns true if the window has been opened as a fullscreen window, false
## otherwise.

proc set_window_event*(this: GraphicsWindow, window_event: string) {.importcpp: "#->set_window_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of the event that is generated when this window is
## modified externally, e.g.  to be resized or closed by the user.
##
## By default, all windows have the same window event unless they are
## explicitly changed.  When the event is generated, it includes one
## parameter: the window itself.

proc get_window_event*(this: GraphicsWindow): string {.importcpp: "nimStringFromStdString(#->get_window_event())", header: stringConversionCode.} ## \
## Returns the name of the event that is generated when this window is
## modified externally, e.g.  to be resized or closed by the user.  See
## set_window_event().

proc set_close_request_event*(this: GraphicsWindow, close_request_event: string) {.importcpp: "#->set_close_request_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the event that is triggered when the user requests to close the
## window, e.g.  via alt-F4, or clicking on the close box.
##
## The default for each window is for this event to be the empty string, which
## means the window-close request is handled immediately by Panda (and the
## window will be closed without the app getting a chance to intervene).  If
## you set this to a nonempty string, then the window is not closed, but
## instead the event is thrown.  It is then up to the app to respond
## appropriately, for instance by presenting an "are you sure?"  dialog box,
## and eventually calling close_window() when the user is sure.
##
## It is considered poor form to set this string and then not handle the
## event.  This can frustrate the user by making it difficult for him to
## cleanly shut down the application (and may force the user to hard-kill the
## app, or reboot the machine).

proc get_close_request_event*(this: GraphicsWindow): string {.importcpp: "nimStringFromStdString(#->get_close_request_event())", header: stringConversionCode.} ## \
## Returns the name of the event set via set_close_request_event().  If this
## string is nonempty, then when the user requests to close window, this event
## will be generated instead.  See set_close_request_event().

proc set_unexposed_draw*(this: GraphicsWindow, unexposed_draw: bool) {.importcpp: "#->set_unexposed_draw(#)".} ## \
## If this flag is false, the window is redrawn only after it has received a
## recent "unexpose" or "draw" event from the underlying windowing system.  If
## this flag is true, the window is redrawn every frame regardless.  Setting
## this false may prevent the window from redrawing unnecessarily when it is
## hidden, and may play nicer with other windows on the desktop, but may
## adversely affect frame rate even when the window is fully visible; setting
## it true will ensure that the window contents are always current.

proc get_unexposed_draw*(this: GraphicsWindow): bool {.importcpp: "#->get_unexposed_draw()".} ## \
## See set_unexposed_draw().

proc get_window_handle*(this: GraphicsWindow): WindowHandle {.importcpp: "#->get_window_handle()".} ## \
## Returns the WindowHandle corresponding to this window on the desktop.  This
## is mainly useful for communicating with external libraries.  Use
## window_handle->get_os_handle()->get_handle(), or
## window_handle->get_string_handle(), to get the actual OS-specific window
## handle object, whatever type that might be.

proc get_num_input_devices*(this: GraphicsWindow): int {.importcpp: "#->get_num_input_devices()".} ## \
## Returns the number of separate input devices associated with the window.
## Typically, a window will have exactly one input device: the keyboard/mouse
## pair.  However, some windows may have no input devices, and others may add
## additional devices, for instance for a joystick.

proc get_input_device*(this: GraphicsWindow, i: int): InputDevice {.importcpp: "#->get_input_device(#)".} ## \
## Returns the nth input device associated with the window.  Typically, a
## window will have exactly one input device: the keyboard/mouse pair.

proc get_input_device_name*(this: GraphicsWindow, device: int): string {.importcpp: "nimStringFromStdString(#->get_input_device_name(#))", header: stringConversionCode.} ## \
## Returns the name of the nth input device.

proc has_pointer*(this: GraphicsWindow, device: int): bool {.importcpp: "#->has_pointer(#)".} ## \
## Returns true if the nth input device has a screen-space pointer (for
## instance, a mouse), false otherwise.

proc has_keyboard*(this: GraphicsWindow, device: int): bool {.importcpp: "#->has_keyboard(#)".} ## \
## Returns true if the nth input device has a keyboard, false otherwise.

proc get_keyboard_map*(this: GraphicsWindow): ButtonMap {.importcpp: "#->get_keyboard_map()".} ## \
## Returns a ButtonMap containing the association between raw buttons and
## virtual buttons.

proc enable_pointer_events*(this: GraphicsWindow, device: int) {.importcpp: "#->enable_pointer_events(#)".} ## \
## Turn on the generation of pointer events.

proc disable_pointer_events*(this: GraphicsWindow, device: int) {.importcpp: "#->disable_pointer_events(#)".} ## \
## Turn off the generation of pointer events.

proc get_pointer*(this: GraphicsWindow, device: int): MouseData {.importcpp: "#->get_pointer(#)".} ## \
## Returns the MouseData associated with the nth input device's pointer.
## Using this to access raw mice (with an index other than 0) is deprecated,
## see the InputDeviceManager interface instead.

proc move_pointer*(this: GraphicsWindow, device: int, x: int, y: int): bool {.importcpp: "#->move_pointer(#, #, #)".} ## \
## Forces the pointer to the indicated position within the window, if
## possible.
##
## Returns true if successful, false on failure.  This may fail if the mouse
## is not currently within the window, or if the API doesn't support this
## operation.

proc close_ime*(this: GraphicsWindow) {.importcpp: "#->close_ime()".} ## \
## Forces the ime window to close if any

proc get_class_type*(_: typedesc[GraphicsWindow]): TypeHandle {.importcpp: "GraphicsWindow::get_class_type()", header: "graphicsWindow.h".}

proc set_events_callback*(this: CallbackGraphicsWindow, `object`: CallbackObject) {.importcpp: "#->set_events_callback(#)".} ## \
## Sets the CallbackObject that will be notified when this window is polled
## for window events, including mouse and keyboard events, as well as window
## resize events and other system-generated events.
##
## This callback will receive a CallbackGraphicsWindow::EventsCallbackData.
##
## This callback should process any system-generated events, and call
## data->upcall() to process requested property change requests made via
## request_properties().

proc clear_events_callback*(this: CallbackGraphicsWindow) {.importcpp: "#->clear_events_callback()".} ## \
## Removes the callback set by an earlier call to set_events_callback().

proc get_events_callback*(this: CallbackGraphicsWindow): CallbackObject {.importcpp: "#->get_events_callback()".} ## \
## Returns the CallbackObject set by set_events_callback().

proc set_properties_callback*(this: CallbackGraphicsWindow, `object`: CallbackObject) {.importcpp: "#->set_properties_callback(#)".} ## \
## Sets the CallbackObject that will be notified when this window receives a
## property change request from user code (e.g.  via request_properties).
##
## This callback will receive a
## CallbackGraphicsWindow::PropertiesCallbackData, which provides a
## get_properties() method that returns a modifiable reference to a
## WindowsProperties object.  This object will contain only those properties
## requested by user code.  The callback should handle any of the requests it
## finds, including and especially set_open(), and remove them from the object
## when it has handled them.  Any unhandled properties should be left
## unchanged in the properties object.

proc clear_properties_callback*(this: CallbackGraphicsWindow) {.importcpp: "#->clear_properties_callback()".} ## \
## Removes the callback set by an earlier call to set_properties_callback().

proc get_properties_callback*(this: CallbackGraphicsWindow): CallbackObject {.importcpp: "#->get_properties_callback()".} ## \
## Returns the CallbackObject set by set_properties_callback().

proc set_render_callback*(this: CallbackGraphicsWindow, `object`: CallbackObject) {.importcpp: "#->set_render_callback(#)".} ## \
## Sets the CallbackObject that will be notified when this window is invoked
## (in the draw thread) to render its contents, and/or flip the graphics
## buffers.
##
## This callback will actually serve several different functions.  It
## receivces a RenderCallbackData, and you can query data->get_callback_type()
## to return the actual function of each particular callback.

proc clear_render_callback*(this: CallbackGraphicsWindow) {.importcpp: "#->clear_render_callback()".} ## \
## Removes the callback set by an earlier call to set_render_callback().

proc get_render_callback*(this: CallbackGraphicsWindow): CallbackObject {.importcpp: "#->get_render_callback()".} ## \
## Returns the CallbackObject set by set_render_callback().

proc create_input_device*(this: CallbackGraphicsWindow, name: string): int {.importcpp: "#->create_input_device(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a new input device (mouse) to the window with the indicated name.
## Returns the index of the new device.

proc get_class_type*(_: typedesc[CallbackGraphicsWindow]): TypeHandle {.importcpp: "CallbackGraphicsWindow::get_class_type()", header: "callbackGraphicsWindow.h".}

proc `==`*(this: DisplayMode, other: DisplayMode): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: DisplayMode, other: DisplayMode): bool {.importcpp: "#.operator !=(#)".}

proc output*(this: DisplayMode, `out`: ostream) {.importcpp: "#.output(#)".}

proc initDisplayMode*(): DisplayMode {.importcpp: "DisplayMode()".}

proc initDisplayMode*(param0: DisplayMode): DisplayMode {.importcpp: "DisplayMode(#)".}

proc get_scene_setup*(this: DisplayRegionCullCallbackData): SceneSetup {.importcpp: "#.get_scene_setup()".} ## \
## Returns a pointer to the SceneSetup object, which contains information
## about the camera and such.

proc get_class_type*(_: typedesc[DisplayRegionCullCallbackData]): TypeHandle {.importcpp: "DisplayRegionCullCallbackData::get_class_type()", header: "displayRegionCullCallbackData.h".}

proc get_cull_result*(this: DisplayRegionDrawCallbackData): CullResult {.importcpp: "#.get_cull_result()".} ## \
## Returns a pointer to the CullResult, the list of CullableObjects that
## should be drawn in this DisplayRegion.

proc get_scene_setup*(this: DisplayRegionDrawCallbackData): SceneSetup {.importcpp: "#.get_scene_setup()".} ## \
## Returns a pointer to the SceneSetup object, which contains information
## about the camera and such.

proc get_class_type*(_: typedesc[DisplayRegionDrawCallbackData]): TypeHandle {.importcpp: "DisplayRegionDrawCallbackData::get_class_type()", header: "displayRegionDrawCallbackData.h".}

proc initDisplaySearchParameters*(): DisplaySearchParameters {.importcpp: "DisplaySearchParameters()".}

proc initDisplaySearchParameters*(param0: DisplaySearchParameters): DisplaySearchParameters {.importcpp: "DisplaySearchParameters(#)".}

proc set_minimum_width*(this: DisplaySearchParameters, minimum_width: int) {.importcpp: "#.set_minimum_width(#)".}

proc set_maximum_width*(this: DisplaySearchParameters, maximum_width: int) {.importcpp: "#.set_maximum_width(#)".}

proc set_minimum_height*(this: DisplaySearchParameters, minimum_height: int) {.importcpp: "#.set_minimum_height(#)".}

proc set_maximum_height*(this: DisplaySearchParameters, maximum_height: int) {.importcpp: "#.set_maximum_height(#)".}

proc set_minimum_bits_per_pixel*(this: DisplaySearchParameters, minimum_bits_per_pixel: int) {.importcpp: "#.set_minimum_bits_per_pixel(#)".}

proc set_maximum_bits_per_pixel*(this: DisplaySearchParameters, maximum_bits_per_pixel: int) {.importcpp: "#.set_maximum_bits_per_pixel(#)".}

proc set_size*(this: GraphicsBuffer, x: int, y: int) {.importcpp: "#->set_size(#, #)".} ## \
## This is called by the GraphicsEngine to request that the buffer resize
## itself.  Although calls to get the size will return the new value, much of
## the actual resizing work doesn't take place until the next begin_frame.
## Not all buffers are resizeable.

proc get_class_type*(_: typedesc[GraphicsBuffer]): TypeHandle {.importcpp: "GraphicsBuffer::get_class_type()", header: "graphicsBuffer.h".}

proc get_num_pipe_types*(this: GraphicsPipeSelection): int {.importcpp: "#->get_num_pipe_types()".} ## \
## Returns the number of different types of GraphicsPipes that are available
## to create through this interface.

proc get_pipe_type*(this: GraphicsPipeSelection, n: int): TypeHandle {.importcpp: "#->get_pipe_type(#)".} ## \
## Returns the nth type of GraphicsPipe available through this interface.

proc print_pipe_types*(this: GraphicsPipeSelection) {.importcpp: "#->print_pipe_types()".} ## \
## Writes a list of the currently known GraphicsPipe types to nout, for the
## user's information.

proc make_pipe*(this: GraphicsPipeSelection, `type`: TypeHandle): GraphicsPipe {.importcpp: "#->make_pipe(#)".} ## \
## Creates a new GraphicsPipe of the indicated type (or a type more specific
## than the indicated type, if necessary) and returns it.  Returns NULL if the
## type cannot be matched.

proc make_pipe*(this: GraphicsPipeSelection, type_name: string, module_name: string): GraphicsPipe {.importcpp: "#->make_pipe(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates a new GraphicsPipe of the indicated type (or a type more specific
## than the indicated type, if necessary) and returns it.  Returns NULL if the
## type cannot be matched.
##
## If the type is not already defined, this will implicitly load the named
## module, or if module_name is empty, it will call load_aux_modules().

proc make_pipe*(this: GraphicsPipeSelection, type_name: string): GraphicsPipe {.importcpp: "#->make_pipe(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates a new GraphicsPipe of the indicated type (or a type more specific
## than the indicated type, if necessary) and returns it.  Returns NULL if the
## type cannot be matched.
##
## If the type is not already defined, this will implicitly load the named
## module, or if module_name is empty, it will call load_aux_modules().

proc make_module_pipe*(this: GraphicsPipeSelection, module_name: string): GraphicsPipe {.importcpp: "#->make_module_pipe(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a new GraphicsPipe of a type defined by the indicated module.
## Returns NULL if the module is not found or does not properly recommend a
## GraphicsPipe.

proc make_default_pipe*(this: GraphicsPipeSelection): GraphicsPipe {.importcpp: "#->make_default_pipe()".} ## \
## Creates a new GraphicsPipe of some arbitrary type.  The user may specify a
## preference using the Configrc file; otherwise, one will be chosen
## arbitrarily.

proc get_num_aux_modules*(this: GraphicsPipeSelection): int {.importcpp: "#->get_num_aux_modules()".} ## \
## Returns the number of display modules that are still to be loaded.  If this
## is nonzero, then calling load_aux_modules() will likely increase the number
## of GraphicsPipes available.

proc load_aux_modules*(this: GraphicsPipeSelection) {.importcpp: "#->load_aux_modules()".} ## \
## Loads all the modules named in the aux-display Configrc variable, making as
## many graphics pipes as possible available.

proc get_global_ptr*(_: typedesc[GraphicsPipeSelection]): GraphicsPipeSelection {.importcpp: "GraphicsPipeSelection::get_global_ptr()", header: "graphicsPipeSelection.h".} ## \
## Returns a pointer to the one global GraphicsPipeSelection object.

proc newMouseAndKeyboard*(window: GraphicsWindow, device: int, name: string): MouseAndKeyboard {.importcpp: "new MouseAndKeyboard(#, #, nimStringToStdString(#))", header: stringConversionCode.}

proc newMouseAndKeyboard*(param0: MouseAndKeyboard): MouseAndKeyboard {.importcpp: "new MouseAndKeyboard(#)".}

proc set_source*(this: MouseAndKeyboard, window: GraphicsWindow, device: int) {.importcpp: "#->set_source(#, #)".} ## \
## Redirects the class to get the data from the mouse and keyboard associated
## with a different window and/or device number.

proc get_class_type*(_: typedesc[MouseAndKeyboard]): TypeHandle {.importcpp: "MouseAndKeyboard::get_class_type()", header: "mouseAndKeyboard.h".}

proc make_int*(_: typedesc[NativeWindowHandle], window: clonglong): WindowHandle {.importcpp: "NativeWindowHandle::make_int(#)", header: "nativeWindowHandle.h".} ## \
## Constructs a new WindowHandle with an int value, which is understood to be
## either an HWND or a Window, cast to int.  This method exists for the
## convenience of Python, which likes to deal with ints; C++ code should use
## one of the more specific make_x11() or make_win32() methods instead.

proc make_subprocess*(_: typedesc[NativeWindowHandle], filename: Filename): WindowHandle {.importcpp: "NativeWindowHandle::make_subprocess(#)", header: "nativeWindowHandle.h".} ## \
## Constructs a new WindowHandle that references a SubprocessWindowBuffer read
## in another process, with the named pipe filename that it uses for
## communication.
##
## This is (at present, and maybe always) useful only on the OS X platform,
## where parenting child windows is particularly problematic.

proc get_class_type*(_: typedesc[NativeWindowHandle]): TypeHandle {.importcpp: "NativeWindowHandle::get_class_type()", header: "nativeWindowHandle.h".}

proc set_size*(this: ParasiteBuffer, x: int, y: int) {.importcpp: "#->set_size(#, #)".} ## \
## This is called by the GraphicsEngine to request that the buffer resize
## itself.  Although calls to get the size will return the new value, much of
## the actual resizing work doesn't take place until the next begin_frame.
## Not all buffers are resizeable.

proc get_class_type*(_: typedesc[ParasiteBuffer]): TypeHandle {.importcpp: "ParasiteBuffer::get_class_type()", header: "parasiteBuffer.h".}

converter upcast_to_TypedReferenceCount*(this: Thread): TypedReferenceCount {.importcpp: "(PT(TypedReferenceCount)(#))".}

converter upcast_to_Namable*(this: Thread): Namable {.importcpp: "((Namable *)(#.p()))".}

proc bind_thread*(_: typedesc[Thread], name: string, sync_name: string): Thread {.importcpp: "Thread::bind_thread(nimStringToStdString(#), nimStringToStdString(#))", header: "thread.h".} ## \
## Returns a new Panda Thread object associated with the current thread (which
## has been created externally). This can be used to bind a unique Panda
## Thread object with an external thread, such as a new Python thread.
##
## It is particularly useful to bind a Panda Thread object to an external
## thread for the purposes of PStats monitoring.  Without this call, each
## external thread will be assigned the same global ExternalThread object,
## which means they will all appear in the same PStats graph.
##
## It is the caller's responsibility to save the returned Thread pointer for
## the lifetime of the external thread.  It is an error for the Thread pointer
## to destruct while the external thread is still in the system.
##
## It is also an error to call this method from the main thread, or twice
## within a given thread, unless it is given the same name each time (in which
## case the same pointer will be returned each time).

proc get_sync_name*(this: Thread): string {.importcpp: "nimStringFromStdString(#->get_sync_name())", header: stringConversionCode.} ## \
## Returns the sync name of the thread.  This name collects threads into "sync
## groups", which are expected to run synchronously.  This is mainly used for
## the benefit of PStats; threads with the same sync name can be ticked all at
## once via the thread_tick() call.

proc get_pstats_index*(this: Thread): int {.importcpp: "#->get_pstats_index()".} ## \
## Returns the PStats index associated with this thread, or -1 if no index has
## yet been associated with this thread.  This is used internally by the
## PStatClient; you should not need to call this directly.

proc get_python_index*(this: Thread): int {.importcpp: "#->get_python_index()".} ## \
## Returns the Python index associated with this thread, or -1 if no index has
## yet been associated with this thread.  This is used internally by the
## direct.stdpy.thread module; you should not need to call this directly.

proc get_unique_id*(this: Thread): string {.importcpp: "nimStringFromStdString(#->get_unique_id())", header: stringConversionCode.} ## \
## Returns a string that is guaranteed to be unique to this thread, across all
## processes on the machine, during at least the lifetime of this process.

proc get_pipeline_stage*(this: Thread): int {.importcpp: "#->get_pipeline_stage()".} ## \
## Returns the Pipeline stage number associated with this thread.  The default
## stage is 0 if no stage is specified otherwise.  See set_pipeline_stage().

proc set_pipeline_stage*(this: Thread, pipeline_stage: int) {.importcpp: "#->set_pipeline_stage(#)".} ## \
## Specifies the Pipeline stage number associated with this thread.  The
## default stage is 0 if no stage is specified otherwise.
##
## This must be a value in the range [0 .. pipeline->get_num_stages() - 1].
## It specifies the values that this thread observes for all pipelined data.
## Typically, an application thread will leave this at 0, but a render thread
## may set it to 1 or 2 (to operate on the previous frame's data, or the
## second previous frame's data).

proc set_min_pipeline_stage*(this: Thread, min_pipeline_stage: int) {.importcpp: "#->set_min_pipeline_stage(#)".} ## \
## Sets this thread's pipeline stage number to at least the indicated value,
## unless it is already larger.  See set_pipeline_stage().

proc get_main_thread*(_: typedesc[Thread]): Thread {.importcpp: "Thread::get_main_thread()", header: "thread.h".} ## \
## Returns a pointer to the "main" Thread object--this is the Thread that
## started the whole process.

proc get_external_thread*(_: typedesc[Thread]): Thread {.importcpp: "Thread::get_external_thread()", header: "thread.h".} ## \
## Returns a pointer to the "external" Thread object--this is a special Thread
## object that corresponds to any thread spawned outside of Panda's threading
## interface.  Note that multiple different threads may share this same
## pointer.

proc get_current_thread*(_: typedesc[Thread]): Thread {.importcpp: "Thread::get_current_thread()", header: "thread.h".} ## \
## Returns a pointer to the currently-executing Thread object.  If this is
## called from the main thread, this will return the same value as
## get_main_thread().
##
## This will always return some valid Thread pointer.  It will never return
## NULL, even if the current thread was spawned outside of Panda's threading
## system, although all non-Panda threads will return the exact same Thread
## pointer.

proc get_current_pipeline_stage*(_: typedesc[Thread]): int {.importcpp: "Thread::get_current_pipeline_stage()", header: "thread.h".} ## \
## Returns the integer pipeline stage associated with the current thread.
## This is the same thing as get_current_thread()->get_pipeline_stage(), but
## it may be faster to retrieve in some contexts.

proc is_threading_supported*(_: typedesc[Thread]): bool {.importcpp: "Thread::is_threading_supported()", header: "thread.h".} ## \
## Returns true if threading support has been compiled in and enabled, or
## false if no threading is available (and Thread::start() will always fail).

proc is_true_threads*(_: typedesc[Thread]): bool {.importcpp: "Thread::is_true_threads()", header: "thread.h".} ## \
## Returns true if a real threading library is available that supports actual
## OS-implemented threads, or false if the only threading we can provide is
## simulated user-space threading.

proc is_simple_threads*(_: typedesc[Thread]): bool {.importcpp: "Thread::is_simple_threads()", header: "thread.h".} ## \
## Returns true if Panda is currently compiled for "simple threads", which is
## to say, cooperative context switching only, reducing the need for quite so
## many critical section protections.  This is not necessarily the opposite of
## "true threads", since one possible implementation of simple threads is via
## true threads with mutex protection to ensure only one runs at a time.

proc sleep*(_: typedesc[Thread], seconds: float64) {.importcpp: "Thread::sleep(#)", header: "thread.h".} ## \
## Suspends the current thread for at least the indicated amount of time.  It
## might be suspended for longer.

proc force_yield*(_: typedesc[Thread]) {.importcpp: "Thread::force_yield()", header: "thread.h".} ## \
## Suspends the current thread for the rest of the current epoch.

proc consider_yield*(_: typedesc[Thread]) {.importcpp: "Thread::consider_yield()", header: "thread.h".} ## \
## Possibly suspends the current thread for the rest of the current epoch, if
## it has run for enough this epoch.  This is especially important for the
## simple thread implementation, which relies on cooperative yields like this.

proc output*(this: Thread, `out`: ostream) {.importcpp: "#->output(#)".}

proc output_blocker*(this: Thread, `out`: ostream) {.importcpp: "#->output_blocker(#)".} ## \
## Writes a description of the mutex or condition variable that this thread is
## blocked on.  Writes nothing if there is no blocker, or if we are not in
## DEBUG_THREADS mode.

proc write_status*(_: typedesc[Thread], `out`: ostream) {.importcpp: "Thread::write_status(#)", header: "thread.h".}

proc is_started*(this: Thread): bool {.importcpp: "#->is_started()".} ## \
## Returns true if the thread has been started, false if it has not, or if
## join() has already been called.

proc is_joinable*(this: Thread): bool {.importcpp: "#->is_joinable()".} ## \
## Returns the value of joinable that was passed to the start() call.

proc start*(this: Thread, priority: ThreadPriority, joinable: bool): bool {.importcpp: "#->start(#, #)".} ## \
## Starts the thread executing.  It is only valid to call this once.
##
## The thread will begin executing its thread_main() function, and will
## terminate when thread_main() returns.
##
## priority is intended as a hint to the relative importance of this thread.
## This may be ignored by the thread implementation.
##
## joinable should be set true if you intend to call join() to wait for the
## thread to terminate, or false if you don't care and you will never call
## join(). Note that the reference count on the Thread object is incremented
## while the thread itself is running, so if you just want to fire and forget
## a thread, you may pass joinable = false, and never store the Thread object.
## It will automatically destruct itself when it finishes.
##
## The return value is true if the thread is successfully started, false
## otherwise.

proc join*(this: Thread) {.importcpp: "#->join()".} ## \
## Blocks the calling process until the thread terminates.  If the thread has
## already terminated, this returns immediately.

proc preempt*(this: Thread) {.importcpp: "#->preempt()".} ## \
## Indicates that this thread should run as soon as possible, preemptying any
## other threads that may be scheduled to run.  This may not be implemented on
## every platform.

proc get_current_task*(this: Thread): TypedReferenceCount {.importcpp: "#->get_current_task()".} ## \
## Returns the task currently executing on this thread (via the
## AsyncTaskManager), if any, or NULL if the thread is not currently servicing
## a task.

proc set_python_index*(this: Thread, index: int) {.importcpp: "#->set_python_index(#)".} ## \
## Stores a Python index to be associated with this thread.  This is used
## internally by the thread module; you should not need to call this directly.

proc prepare_for_exit*(_: typedesc[Thread]) {.importcpp: "Thread::prepare_for_exit()", header: "thread.h".} ## \
## Should be called by the main thread just before exiting the program, this
## blocks until any remaining thread cleanup has finished.

proc get_class_type*(_: typedesc[Thread]): TypeHandle {.importcpp: "Thread::get_class_type()", header: "thread.h".}

proc acquire*(this: MutexDirect) {.importcpp: "#.acquire()".} ## \
## Grabs the mutex if it is available.  If it is not available, blocks until
## it becomes available, then grabs it.  In either case, the function does not
## return until the mutex is held; you should then call unlock().
##
## This method is considered const so that you can lock and unlock const
## mutexes, mainly to allow thread-safe access to otherwise const data.
##
## Also see MutexHolder.

proc try_acquire*(this: MutexDirect): bool {.importcpp: "#.try_acquire()".} ## \
## Returns immediately, with a true value indicating the mutex has been
## acquired, and false indicating it has not.

proc release*(this: MutexDirect) {.importcpp: "#.release()".} ## \
## Releases the mutex.  It is an error to call this if the mutex was not
## already locked.
##
## This method is considered const so that you can lock and unlock const
## mutexes, mainly to allow thread-safe access to otherwise const data.

proc debug_is_locked*(this: MutexDirect): bool {.importcpp: "#.debug_is_locked()".} ## \
## Returns true if the current thread has locked the Mutex, false otherwise.
## This method is only intended for use in debugging, hence the method name;
## in the MutexDirect case, it always returns true, since there's not a
## reliable way to determine this otherwise.

proc set_name*(this: MutexDirect, name: string) {.importcpp: "#.set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc clear_name*(this: MutexDirect) {.importcpp: "#.clear_name()".} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc has_name*(this: MutexDirect): bool {.importcpp: "#.has_name()".} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc get_name*(this: MutexDirect): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc output*(this: MutexDirect, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## This method is declared virtual in MutexDebug, but non-virtual in
## MutexDirect.

proc initMutex*(): Mutex {.importcpp: "Mutex()".}

proc initMutex*(name: string): Mutex {.importcpp: "Mutex(nimStringToStdString(#))", header: stringConversionCode.}

proc get_mutex*(this: ConditionVarDirect): MutexDirect {.importcpp: "#.get_mutex()".} ## \
## Returns the mutex associated with this condition variable.

proc wait*(this: ConditionVarDirect) {.importcpp: "#.wait()".} ## \
## Waits on the condition.  The caller must already be holding the lock
## associated with the condition variable before calling this function.
##
## wait() will release the lock, then go to sleep until some other thread
## calls notify() on this condition variable.  At that time at least one
## thread waiting on the same ConditionVarDirect will grab the lock again, and
## then return from wait().
##
## It is possible that wait() will return even if no one has called notify().
## It is the responsibility of the calling process to verify the condition on
## return from wait, and possibly loop back to wait again if necessary.
##
## Note the semantics of a condition variable: the mutex must be held before
## wait() is called, and it will still be held when wait() returns.  However,
## it will be temporarily released during the wait() call itself.

proc wait*(this: ConditionVarDirect, timeout: float64) {.importcpp: "#.wait(#)".} ## \
## Waits on the condition, with a timeout.  The function will return when the
## condition variable is notified, or the timeout occurs.  There is no way to
## directly tell which happened, and it is possible that neither in fact
## happened (spurious wakeups are possible).
##
## See wait() with no parameters for more.

proc notify*(this: ConditionVarDirect) {.importcpp: "#.notify()".} ## \
## Informs one of the other threads who are currently blocked on wait() that
## the relevant condition has changed.  If multiple threads are currently
## waiting, at least one of them will be woken up, although there is no way to
## predict which one.  It is possible that more than one thread will be woken
## up.
##
## The caller must be holding the mutex associated with the condition variable
## before making this call, which will not release the mutex.
##
## If no threads are waiting, this is a no-op: the notify event is lost.

proc output*(this: ConditionVarDirect, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## This method is declared virtual in ConditionVarDebug, but non-virtual in
## ConditionVarDirect.

proc initConditionVar*(mutex: Mutex): ConditionVar {.importcpp: "ConditionVar(#)".} ## \
## You must pass in a Mutex to the condition variable constructor.  This mutex
## may be shared by other condition variables, if desired.  It is the caller's
## responsibility to ensure the Mutex object does not destruct during the
## lifetime of the condition variable.

proc get_mutex*(this: ConditionVar): Mutex {.importcpp: "#.get_mutex()".} ## \
## Returns the mutex associated with this condition variable.

proc get_mutex*(this: ConditionVarFullDirect): MutexDirect {.importcpp: "#.get_mutex()".} ## \
## Returns the mutex associated with this condition variable.

proc wait*(this: ConditionVarFullDirect) {.importcpp: "#.wait()".} ## \
## Waits on the condition.  The caller must already be holding the lock
## associated with the condition variable before calling this function.
##
## wait() will release the lock, then go to sleep until some other thread
## calls notify() on this condition variable.  At that time at least one
## thread waiting on the same ConditionVarFullDirect will grab the lock again,
## and then return from wait().
##
## It is possible that wait() will return even if no one has called notify().
## It is the responsibility of the calling process to verify the condition on
## return from wait, and possibly loop back to wait again if necessary.
##
## Note the semantics of a condition variable: the mutex must be held before
## wait() is called, and it will still be held when wait() returns.  However,
## it will be temporarily released during the wait() call itself.

proc wait*(this: ConditionVarFullDirect, timeout: float64) {.importcpp: "#.wait(#)".} ## \
## Waits on the condition, with a timeout.  The function will return when the
## condition variable is notified, or the timeout occurs.  There is no way to
## directly tell which happened, and it is possible that neither in fact
## happened (spurious wakeups are possible).
##
## See wait() with no parameters for more.

proc notify*(this: ConditionVarFullDirect) {.importcpp: "#.notify()".} ## \
## Informs one of the other threads who are currently blocked on wait() that
## the relevant condition has changed.  If multiple threads are currently
## waiting, at least one of them will be woken up, although there is no way to
## predict which one.  It is possible that more than one thread will be woken
## up.
##
## The caller must be holding the mutex associated with the condition variable
## before making this call, which will not release the mutex.
##
## If no threads are waiting, this is a no-op: the notify is lost.

proc notify_all*(this: ConditionVarFullDirect) {.importcpp: "#.notify_all()".} ## \
## Informs all of the other threads who are currently blocked on wait() that
## the relevant condition has changed.
##
## The caller must be holding the mutex associated with the condition variable
## before making this call, which will not release the mutex.
##
## If no threads are waiting, this is a no-op: the notify event is lost.

proc output*(this: ConditionVarFullDirect, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## This method is declared virtual in ConditionVarFullDebug, but non-virtual
## in ConditionVarFullDirect.

proc initConditionVarFull*(mutex: Mutex): ConditionVarFull {.importcpp: "ConditionVarFull(#)".} ## \
## You must pass in a Mutex to the condition variable constructor.  This mutex
## may be shared by other condition variables, if desired.  It is the caller's
## responsibility to ensure the Mutex object does not destruct during the
## lifetime of the condition variable.

proc get_mutex*(this: ConditionVarFull): Mutex {.importcpp: "#.get_mutex()".} ## \
## Returns the mutex associated with this condition variable.

proc acquire*(this: ReMutexDirect) {.importcpp: "#.acquire()".} ## \
## Grabs the reMutex if it is available.  If it is not available, blocks until
## it becomes available, then grabs it.  In either case, the function does not
## return until the reMutex is held; you should then call unlock().
##
## This method is considered const so that you can lock and unlock const
## reMutexes, mainly to allow thread-safe access to otherwise const data.
##
## Also see ReMutexHolder.

proc acquire*(this: ReMutexDirect, current_thread: Thread) {.importcpp: "#.acquire(#)".} ## \
## This variant on acquire() accepts the current thread as a parameter, if it
## is already known, as an optimization.

proc try_acquire*(this: ReMutexDirect): bool {.importcpp: "#.try_acquire()".} ## \
## Returns immediately, with a true value indicating the mutex has been
## acquired, and false indicating it has not.

proc try_acquire*(this: ReMutexDirect, current_thread: Thread): bool {.importcpp: "#.try_acquire(#)".} ## \
## Returns immediately, with a true value indicating the mutex has been
## acquired, and false indicating it has not.

proc elevate_lock*(this: ReMutexDirect) {.importcpp: "#.elevate_lock()".} ## \
## This method increments the lock count, assuming the calling thread already
## holds the lock.  After this call, release() will need to be called one
## additional time to release the lock.
##
## This method really performs the same function as acquire(), but it offers a
## potential (slight) performance benefit when the calling thread knows that
## it already holds the lock.  It is an error to call this when the calling
## thread does not hold the lock.

proc release*(this: ReMutexDirect) {.importcpp: "#.release()".} ## \
## Releases the reMutex.  It is an error to call this if the reMutex was not
## already locked.
##
## This method is considered const so that you can lock and unlock const
## reMutexes, mainly to allow thread-safe access to otherwise const data.

proc debug_is_locked*(this: ReMutexDirect): bool {.importcpp: "#.debug_is_locked()".} ## \
## Returns true if the current thread has locked the ReMutex, false otherwise.
## This method is only intended for use in debugging, hence the method name;
## in the ReMutexDirect case, it always returns true, since there's not a
## reliable way to determine this otherwise.

proc set_name*(this: ReMutexDirect, name: string) {.importcpp: "#.set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc clear_name*(this: ReMutexDirect) {.importcpp: "#.clear_name()".} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc has_name*(this: ReMutexDirect): bool {.importcpp: "#.has_name()".} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc get_name*(this: ReMutexDirect): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc output*(this: ReMutexDirect, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## This method is declared virtual in MutexDebug, but non-virtual in
## ReMutexDirect.

proc initReMutex*(): ReMutex {.importcpp: "ReMutex()".}

proc initReMutex*(name: string): ReMutex {.importcpp: "ReMutex(nimStringToStdString(#))", header: stringConversionCode.}

proc get_class_type*(_: typedesc[ExternalThread]): TypeHandle {.importcpp: "ExternalThread::get_class_type()", header: "externalThread.h".}

proc acquire*(this: LightMutexDirect) {.importcpp: "#.acquire()".} ## \
## Grabs the lightMutex if it is available.  If it is not available, blocks
## until it becomes available, then grabs it.  In either case, the function
## does not return until the lightMutex is held; you should then call
## unlock().
##
## This method is considered const so that you can lock and unlock const
## lightMutexes, mainly to allow thread-safe access to otherwise const data.
##
## Also see LightMutexHolder.

proc release*(this: LightMutexDirect) {.importcpp: "#.release()".} ## \
## Releases the lightMutex.  It is an error to call this if the lightMutex was
## not already locked.
##
## This method is considered const so that you can lock and unlock const
## lightMutexes, mainly to allow thread-safe access to otherwise const data.

proc debug_is_locked*(this: LightMutexDirect): bool {.importcpp: "#.debug_is_locked()".} ## \
## Returns true if the current thread has locked the LightMutex, false
## otherwise.  This method is only intended for use in debugging, hence the
## method name; in the LightMutexDirect case, it always returns true, since
## there's not a reliable way to determine this otherwise.

proc set_name*(this: LightMutexDirect, name: string) {.importcpp: "#.set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## The lightMutex name is only defined when compiling in DEBUG_THREADS mode.

proc clear_name*(this: LightMutexDirect) {.importcpp: "#.clear_name()".} ## \
## The lightMutex name is only defined when compiling in DEBUG_THREADS mode.

proc has_name*(this: LightMutexDirect): bool {.importcpp: "#.has_name()".} ## \
## The lightMutex name is only defined when compiling in DEBUG_THREADS mode.

proc get_name*(this: LightMutexDirect): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## The lightMutex name is only defined when compiling in DEBUG_THREADS mode.

proc output*(this: LightMutexDirect, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## This method is declared virtual in LightMutexDebug, but non-virtual in
## LightMutexDirect.

proc initLightMutex*(): LightMutex {.importcpp: "LightMutex()".}

proc initLightMutex*(name: string): LightMutex {.importcpp: "LightMutex(nimStringToStdString(#))", header: stringConversionCode.}

proc acquire*(this: LightReMutexDirect) {.importcpp: "#.acquire()".} ## \
## Grabs the lightReMutex if it is available.  If it is not available, blocks
## until it becomes available, then grabs it.  In either case, the function
## does not return until the lightReMutex is held; you should then call
## unlock().
##
## This method is considered const so that you can lock and unlock const
## lightReMutexes, mainly to allow thread-safe access to otherwise const data.
##
## Also see LightReMutexHolder.

proc acquire*(this: LightReMutexDirect, current_thread: Thread) {.importcpp: "#.acquire(#)".} ## \
## This variant on acquire() accepts the current thread as a parameter, if it
## is already known, as an optimization.

proc elevate_lock*(this: LightReMutexDirect) {.importcpp: "#.elevate_lock()".} ## \
## This method increments the lock count, assuming the calling thread already
## holds the lock.  After this call, release() will need to be called one
## additional time to release the lock.
##
## This method really performs the same function as acquire(), but it offers a
## potential (slight) performance benefit when the calling thread knows that
## it already holds the lock.  It is an error to call this when the calling
## thread does not hold the lock.

proc release*(this: LightReMutexDirect) {.importcpp: "#.release()".} ## \
## Releases the lightReMutex.  It is an error to call this if the lightReMutex
## was not already locked.
##
## This method is considered const so that you can lock and unlock const
## lightReMutexes, mainly to allow thread-safe access to otherwise const data.

proc debug_is_locked*(this: LightReMutexDirect): bool {.importcpp: "#.debug_is_locked()".} ## \
## Returns true if the current thread has locked the LightReMutex, false
## otherwise.  This method is only intended for use in debugging, hence the
## method name; in the LightReMutexDirect case, it always returns true, since
## there's not a reliable way to determine this otherwise.

proc set_name*(this: LightReMutexDirect, name: string) {.importcpp: "#.set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc clear_name*(this: LightReMutexDirect) {.importcpp: "#.clear_name()".} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc has_name*(this: LightReMutexDirect): bool {.importcpp: "#.has_name()".} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc get_name*(this: LightReMutexDirect): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc output*(this: LightReMutexDirect, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## This method is declared virtual in MutexDebug, but non-virtual in
## LightReMutexDirect.

proc initLightReMutex*(): LightReMutex {.importcpp: "LightReMutex()".}

proc initLightReMutex*(name: string): LightReMutex {.importcpp: "LightReMutex(nimStringToStdString(#))", header: stringConversionCode.}

proc get_class_type*(_: typedesc[MainThread]): TypeHandle {.importcpp: "MainThread::get_class_type()", header: "mainThread.h".}

proc initSemaphore*(initial_count: int): Semaphore {.importcpp: "Semaphore(#)".}

proc initSemaphore*(): Semaphore {.importcpp: "Semaphore()".}

proc acquire*(this: Semaphore) {.importcpp: "#.acquire()".} ## \
## Decrements the internal count.  If the count was already at zero, blocks
## until the count is nonzero, then decrements it.

proc try_acquire*(this: Semaphore): bool {.importcpp: "#.try_acquire()".} ## \
## If the semaphore can be acquired without blocking, does so and returns
## true.  Otherwise, returns false.

proc release*(this: Semaphore): int {.importcpp: "#.release()".} ## \
## Increments the semaphore's internal count.  This may wake up another thread
## blocked on acquire().
##
## Returns the count of the semaphore upon release.

proc get_count*(this: Semaphore): int {.importcpp: "#.get_count()".} ## \
## Returns the current semaphore count.  Note that this call is not thread-
## safe (the count may change at any time).

proc output*(this: Semaphore, `out`: ostream) {.importcpp: "#.output(#)".}

proc get_class_type*(_: typedesc[PythonThread]): TypeHandle {.importcpp: "PythonThread::get_class_type()", header: "pythonThread.h".}

proc initEventParameter*(): EventParameter {.importcpp: "EventParameter()".}

proc initEventParameter*(copy: EventParameter): EventParameter {.importcpp: "EventParameter(#)".}

proc initEventParameter*(`ptr`: TypedReferenceCount): EventParameter {.importcpp: "EventParameter(#)".} ## \
## Defines an EventParameter that stores a pointer to a TypedReferenceCount
## object.  Note that a TypedReferenceCount is not the same kind of pointer as
## a TypedWritableReferenceCount, hence we require both constructors.
##
## This accepts a const pointer, even though it stores (and eventually
## returns) a non-const pointer.  This is just the simplest way to allow both
## const and non-const pointers to be stored, but it does lose the constness.
## Be careful.

proc initEventParameter*(`ptr`: TypedWritableReferenceCount): EventParameter {.importcpp: "EventParameter(#)".} ## \
## Defines an EventParameter that stores a pointer to any kind of
## TypedWritableReferenceCount object.  This is the most general constructor.
##
## This accepts a const pointer, even though it stores (and eventually
## returns) a non-const pointer.  This is just the simplest way to allow both
## const and non-const pointers to be stored, but it does lose the constness.
## Be careful.

proc initEventParameter*(value: float64): EventParameter {.importcpp: "EventParameter(#)".} ## \
## Defines an EventParameter that stores a floating-point value.

proc initEventParameter*(value: int): EventParameter {.importcpp: "EventParameter(#)".} ## \
## Defines an EventParameter that stores an integer value.

proc initEventParameter*(param0: type(nil)): EventParameter {.importcpp: "EventParameter(#)".}

proc initEventParameter*(value: string): EventParameter {.importcpp: "EventParameter(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Defines an EventParameter that stores a string value.

proc is_empty*(this: EventParameter): bool {.importcpp: "#.is_empty()".} ## \
## These functions are conveniences to easily determine if the
## EventParameter is one of the predefined parameter types, and retrieve the
## corresponding value.  Of course, it is possible that the EventParameter
## is some user-defined type, and is none of these.

proc is_int*(this: EventParameter): bool {.importcpp: "#.is_int()".} ## \
## Returns true if the EventParameter stores an integer value, false
## otherwise.

proc get_int_value*(this: EventParameter): int {.importcpp: "#.get_int_value()".} ## \
## Retrieves the value stored in the EventParameter.  It is only valid to call
## this if is_int() has already returned true.

proc is_double*(this: EventParameter): bool {.importcpp: "#.is_double()".} ## \
## Returns true if the EventParameter stores a double floating-point value,
## false otherwise.

proc get_double_value*(this: EventParameter): float64 {.importcpp: "#.get_double_value()".} ## \
## Retrieves the value stored in the EventParameter.  It is only valid to call
## this if is_double() has already returned true.

proc is_string*(this: EventParameter): bool {.importcpp: "#.is_string()".} ## \
## Returns true if the EventParameter stores a string value, false otherwise.

proc get_string_value*(this: EventParameter): string {.importcpp: "nimStringFromStdString(#.get_string_value())", header: stringConversionCode.} ## \
## Retrieves the value stored in the EventParameter.  It is only valid to call
## this if is_string() has already returned true.

proc is_wstring*(this: EventParameter): bool {.importcpp: "#.is_wstring()".} ## \
## Returns true if the EventParameter stores a wstring value, false otherwise.

proc get_wstring_value*(this: EventParameter): string {.importcpp: "nimStringFromStdString(#.get_wstring_value())", header: stringConversionCode.} ## \
## Retrieves the value stored in the EventParameter.  It is only valid to call
## this if is_wstring() has already returned true.

proc is_typed_ref_count*(this: EventParameter): bool {.importcpp: "#.is_typed_ref_count()".} ## \
## Returns true if the EventParameter stores a TypedReferenceCount pointer,
## false otherwise.  Note that a TypedReferenceCount is not exactly the same
## kind of pointer as a TypedWritableReferenceCount, hence the need for this
## separate call.

proc get_typed_ref_count_value*(this: EventParameter): TypedReferenceCount {.importcpp: "#.get_typed_ref_count_value()".} ## \
## Retrieves the value stored in the EventParameter.  It is only valid to call
## this if is_typed_ref_count() has already returned true.

proc get_ptr*(this: EventParameter): TypedWritableReferenceCount {.importcpp: "#.get_ptr()".} ## \
## Retrieves a pointer to the actual value stored in the parameter.  The
## TypeHandle of this pointer may be examined to determine the actual type of
## parameter it contains.  This is the only way to retrieve the value when it
## is not one of the above predefined types.

proc output*(this: EventParameter, `out`: ostream) {.importcpp: "#.output(#)".}

proc newAsyncFuture*(): AsyncFuture {.importcpp: "new AsyncFuture()".} ## \
## Initializes the future in the pending state.

proc newAsyncFuture*(param0: AsyncFuture): AsyncFuture {.importcpp: "new AsyncFuture(#)".}

proc done*(this: AsyncFuture): bool {.importcpp: "#->done()".} ## \
## Returns true if the future is done or has been cancelled.  It is always
## safe to call this.

proc cancelled*(this: AsyncFuture): bool {.importcpp: "#->cancelled()".} ## \
## Returns true if the future was cancelled.  It is always safe to call this.

proc cancel*(this: AsyncFuture): bool {.importcpp: "#->cancel()".} ## \
## Cancels the future.  Returns true if it was cancelled, or false if the
## future was already done.  Either way, done() will return true after this
## call returns.
##
## In the case of a task, this is equivalent to remove().

proc set_done_event*(this: AsyncFuture, done_event: string) {.importcpp: "#->set_done_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the event name that will be triggered when the future finishes.  Will
## not be triggered if the future is cancelled, but it will be triggered for
## a coroutine task that exits with an exception.

proc get_done_event*(this: AsyncFuture): string {.importcpp: "nimStringFromStdString(#->get_done_event())", header: stringConversionCode.} ## \
## Returns the event name that will be triggered when the future finishes.
## See set_done_event().

proc output*(this: AsyncFuture, `out`: ostream) {.importcpp: "#->output(#)".}

proc wait*(this: AsyncFuture) {.importcpp: "#->wait()".} ## \
## Waits until the future is done.

proc wait*(this: AsyncFuture, timeout: float64) {.importcpp: "#->wait(#)".} ## \
## Waits until the future is done, or until the timeout is reached.

proc get_class_type*(_: typedesc[AsyncFuture]): TypeHandle {.importcpp: "AsyncFuture::get_class_type()", header: "asyncFuture.h".}

converter upcast_to_AsyncFuture*(this: AsyncTask): AsyncFuture {.importcpp: "(PT(AsyncFuture)(#))".}

converter upcast_to_Namable*(this: AsyncTask): Namable {.importcpp: "((Namable *)(#.p()))".}

proc is_alive*(this: AsyncTask): bool {.importcpp: "#->is_alive()".} ## \
## Returns true if the task is currently active or sleeping on some task
## chain, meaning that it will be executed in its turn, or false if it is not
## active.  If the task has recently been removed while it is in the middle of
## execution, this will return false, because the task will not run again once
## it finishes.

proc get_manager*(this: AsyncTask): AsyncTaskManager {.importcpp: "#->get_manager()".} ## \
## Returns the AsyncTaskManager that this task is active on.  This will be
## NULL if the state is S_inactive.

proc remove*(this: AsyncTask): bool {.importcpp: "#->remove()".} ## \
## Removes the task from its active manager, if any, and makes the state
## S_inactive (or possible S_servicing_removed).  This is a no-op if the state
## is already S_inactive.

proc set_delay*(this: AsyncTask, delay: float64) {.importcpp: "#->set_delay(#)".} ## \
## Specifies the amount of time, in seconds, by which this task will be
## delayed after it has been added to the AsyncTaskManager.  At least the
## specified amount of time (and possibly more) will elapse before the task
## begins.
##
## You may specify a delay of 0.0 to guarantee that the task will run in the
## next epoch following the one in which it is added.
##
## Setting this value after the task has already been added will not affect
## the task's wake time; it will only affect the task if it is re-added to the
## queue in the future, for instance if the task returns DS_again.  However,
## see recalc_wake_time() if you wish to apply the delay effect immediately.

proc clear_delay*(this: AsyncTask) {.importcpp: "#->clear_delay()".} ## \
## Removes any delay specified for the task.  The next time the task is added
## to the queue, it will run immediately.  This does not affect the task's
## wake time if it has already been added to the queue.

proc has_delay*(this: AsyncTask): bool {.importcpp: "#->has_delay()".} ## \
## Returns true if a delay has been set for this task via set_delay(), or
## false otherwise.

proc get_delay*(this: AsyncTask): float64 {.importcpp: "#->get_delay()".} ## \
## Returns the delay value that has been set via set_delay, if any.

proc get_wake_time*(this: AsyncTask): float64 {.importcpp: "#->get_wake_time()".} ## \
## If this task has been added to an AsyncTaskManager with a delay in effect,
## this returns the time at which the task is expected to awaken.  It has no
## meaning if the task has not yet been added to a queue, or if there was no
## delay in effect at the time the task was added.
##
## If the task's status is not S_sleeping, this returns 0.0.

proc recalc_wake_time*(this: AsyncTask) {.importcpp: "#->recalc_wake_time()".} ## \
## If the task is currently sleeping on a task chain, this resets its wake
## time to the current time + get_delay().  It is as if the task had suddenly
## returned DS_again.  The task will sleep for its current delay seconds
## before running again.  This method may therefore be used to make the task
## wake up sooner or later than it would have otherwise.
##
## If the task is not already sleeping, this method has no effect.

proc get_start_time*(this: AsyncTask): float64 {.importcpp: "#->get_start_time()".} ## \
## Returns the time at which the task was started, according to the task
## manager's clock.
##
## It is only valid to call this if the task's status is not S_inactive.

proc get_elapsed_time*(this: AsyncTask): float64 {.importcpp: "#->get_elapsed_time()".} ## \
## Returns the amount of time that has elapsed since the task was started,
## according to the task manager's clock.
##
## It is only valid to call this if the task's status is not S_inactive.

proc get_start_frame*(this: AsyncTask): int {.importcpp: "#->get_start_frame()".} ## \
## Returns the frame number at which the task was started, according to the
## task manager's clock.
##
## It is only valid to call this if the task's status is not S_inactive.

proc get_elapsed_frames*(this: AsyncTask): int {.importcpp: "#->get_elapsed_frames()".} ## \
## Returns the number of frames that have elapsed since the task was started,
## according to the task manager's clock.
##
## It is only valid to call this if the task's status is not S_inactive.

proc set_name*(this: AsyncTask, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.}

proc clear_name*(this: AsyncTask) {.importcpp: "#->clear_name()".} ## \
## Resets the task's name to empty.

proc get_name_prefix*(this: AsyncTask): string {.importcpp: "nimStringFromStdString(#->get_name_prefix())", header: stringConversionCode.} ## \
## Returns the initial part of the name, up to but not including any trailing
## digits following a hyphen or underscore.

proc get_task_id*(this: AsyncTask): int {.importcpp: "#->get_task_id()".} ## \
## Returns a number guaranteed to be unique for each different AsyncTask
## object in the universe.

proc set_task_chain*(this: AsyncTask, chain_name: string) {.importcpp: "#->set_task_chain(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the AsyncTaskChain on which this task will be running.  Each task
## chain runs tasks independently of the others.

proc get_task_chain*(this: AsyncTask): string {.importcpp: "nimStringFromStdString(#->get_task_chain())", header: stringConversionCode.} ## \
## Returns the AsyncTaskChain on which this task will be running.  Each task
## chain runs tasks independently of the others.

proc set_sort*(this: AsyncTask, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Specifies a sort value for this task.  Within a given AsyncTaskManager, all
## of the tasks with a given sort value are guaranteed to be completed before
## any tasks with a higher sort value are begun.
##
## To put it another way, two tasks might execute in parallel with each other
## only if they both have the same sort value.  Tasks with a lower sort value
## are executed first.
##
## This is different from the priority, which makes no such exclusion
## guarantees.

proc get_sort*(this: AsyncTask): int {.importcpp: "#->get_sort()".} ## \
## Returns the task's current sort value.  See set_sort().

proc set_priority*(this: AsyncTask, priority: int) {.importcpp: "#->set_priority(#)".} ## \
## Specifies a priority value for this task.  In general, tasks with a higher
## priority value are executed before tasks with a lower priority value (but
## only for tasks with the same sort value).
##
## Unlike the sort value, tasks with different priorities may execute at the
## same time, if the AsyncTaskManager has more than one thread servicing
## tasks.
##
## Also see AsyncTaskChain::set_timeslice_priority(), which changes the
## meaning of this value.  In the default mode, when the timeslice_priority
## flag is false, all tasks always run once per epoch, regardless of their
## priority values (that is, the priority controls the order of the task
## execution only, not the number of times it runs).  On the other hand, if
## you set the timeslice_priority flag to true, then changing a task's
## priority has an effect on the number of times it runs.

proc get_priority*(this: AsyncTask): int {.importcpp: "#->get_priority()".} ## \
## Returns the task's current priority value.  See set_priority().

proc set_done_event*(this: AsyncTask, done_event: string) {.importcpp: "#->set_done_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the event name that will be triggered when the task finishes.  This
## should only be called before the task has been started, or after it has
## finished and before it is about to be restarted (i.e.  when get_state()
## returns S_inactive).

proc get_dt*(this: AsyncTask): float64 {.importcpp: "#->get_dt()".} ## \
## Returns the amount of time elapsed during the task's previous run cycle, in
## seconds.

proc get_max_dt*(this: AsyncTask): float64 {.importcpp: "#->get_max_dt()".} ## \
## Returns the maximum amount of time elapsed during any one of the task's
## previous run cycles, in seconds.

proc get_average_dt*(this: AsyncTask): float64 {.importcpp: "#->get_average_dt()".} ## \
## Returns the average amount of time elapsed during each of the task's
## previous run cycles, in seconds.

proc output*(this: AsyncTask, `out`: ostream) {.importcpp: "#->output(#)".}

converter upcast_to_TypedReferenceCount*(this: AsyncTaskManager): TypedReferenceCount {.importcpp: "(PT(TypedReferenceCount)(#))".}

converter upcast_to_Namable*(this: AsyncTaskManager): Namable {.importcpp: "((Namable *)(#.p()))".}

proc newAsyncTaskManager*(name: string): AsyncTaskManager {.importcpp: "new AsyncTaskManager(nimStringToStdString(#))", header: stringConversionCode.}

proc cleanup*(this: AsyncTaskManager) {.importcpp: "#->cleanup()".} ## \
## Stops all threads and messily empties the task list.  This is intended to
## be called on destruction only.

proc set_clock*(this: AsyncTaskManager, clock: ClockObject) {.importcpp: "#->set_clock(#)".} ## \
## Replaces the clock pointer used within the AsyncTaskManager.  This is used
## to control when tasks with a set_delay() specified will be scheduled.  It
## can also be ticked automatically each epoch, if set_tick_clock() is true.
##
## The default is the global clock pointer.

proc get_clock*(this: AsyncTaskManager): ClockObject {.importcpp: "#->get_clock()".} ## \
## Returns the clock pointer used within the AsyncTaskManager.  See
## set_clock().

proc get_num_task_chains*(this: AsyncTaskManager): int {.importcpp: "#->get_num_task_chains()".} ## \
## Returns the number of different task chains.

proc get_task_chain*(this: AsyncTaskManager, n: int): AsyncTaskChain {.importcpp: "#->get_task_chain(#)".} ## \
## Returns the nth task chain.

proc make_task_chain*(this: AsyncTaskManager, name: string): AsyncTaskChain {.importcpp: "#->make_task_chain(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates a new AsyncTaskChain of the indicated name and stores it within the
## AsyncTaskManager.  If a task chain with this name already exists, returns
## it instead.

proc find_task_chain*(this: AsyncTaskManager, name: string): AsyncTaskChain {.importcpp: "#->find_task_chain(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Searches a new AsyncTaskChain of the indicated name and returns it if it
## exists, or NULL otherwise.

proc remove_task_chain*(this: AsyncTaskManager, name: string): bool {.importcpp: "#->remove_task_chain(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the AsyncTaskChain of the indicated name.  If the chain still has
## tasks, this will block until all tasks are finished.
##
## Returns true if successful, or false if the chain did not exist.

proc add*(this: AsyncTaskManager, task: AsyncTask) {.importcpp: "#->add(#)".} ## \
## Adds the indicated task to the active queue.  It is an error if the task is
## already added to this or any other active queue.

proc has_task*(this: AsyncTaskManager, task: AsyncTask): bool {.importcpp: "#->has_task(#)".} ## \
## Returns true if the indicated task has been added to this AsyncTaskManager,
## false otherwise.

proc find_task*(this: AsyncTaskManager, name: string): AsyncTask {.importcpp: "#->find_task(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the first task found with the indicated name, or NULL if there is
## no task with the indicated name.
##
## If there are multiple tasks with the same name, returns one of them
## arbitrarily.

proc find_tasks*(this: AsyncTaskManager, name: string): AsyncTaskCollection {.importcpp: "#->find_tasks(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the list of tasks found with the indicated name.

proc find_tasks_matching*(this: AsyncTaskManager, pattern: GlobPattern): AsyncTaskCollection {.importcpp: "#->find_tasks_matching(#)".} ## \
## Returns the list of tasks found whose name matches the indicated glob
## pattern, e.g.  "my_task_*".

proc remove*(this: AsyncTaskManager, task: AsyncTask): bool {.importcpp: "#->remove(#)".} ## \
## Removes the indicated task from the active queue.  Returns true if the task
## is successfully removed, or false if it wasn't there.

proc remove*(this: AsyncTaskManager, tasks: AsyncTaskCollection): clonglong {.importcpp: "#->remove(#)".} ## \
## Removes all of the tasks in the AsyncTaskCollection.  Returns the number of
## tasks removed.

proc wait_for_tasks*(this: AsyncTaskManager) {.importcpp: "#->wait_for_tasks()".} ## \
## Blocks until the task list is empty.

proc stop_threads*(this: AsyncTaskManager) {.importcpp: "#->stop_threads()".} ## \
## Stops any threads that are currently running.  If any tasks are still
## pending and have not yet been picked up by a thread, they will not be
## serviced unless poll() or start_threads() is later called.

proc start_threads*(this: AsyncTaskManager) {.importcpp: "#->start_threads()".} ## \
## Starts any requested threads to service the tasks on the queue.  This is
## normally not necessary, since adding a task will start the threads
## automatically.

proc get_num_tasks*(this: AsyncTaskManager): clonglong {.importcpp: "#->get_num_tasks()".} ## \
## Returns the number of tasks that are currently active or sleeping within
## the task manager.

proc get_tasks*(this: AsyncTaskManager): AsyncTaskCollection {.importcpp: "#->get_tasks()".} ## \
## Returns the set of tasks that are active or sleeping on the task manager,
## at the time of the call.

proc get_active_tasks*(this: AsyncTaskManager): AsyncTaskCollection {.importcpp: "#->get_active_tasks()".} ## \
## Returns the set of tasks that are active (and not sleeping) on the task
## manager, at the time of the call.

proc get_sleeping_tasks*(this: AsyncTaskManager): AsyncTaskCollection {.importcpp: "#->get_sleeping_tasks()".} ## \
## Returns the set of tasks that are sleeping (and not active) on the task
## manager, at the time of the call.

proc initAsyncTaskCollection*(): AsyncTaskCollection {.importcpp: "AsyncTaskCollection()".}

proc initAsyncTaskCollection*(copy: AsyncTaskCollection): AsyncTaskCollection {.importcpp: "AsyncTaskCollection(#)".}

proc add_task*(this: AsyncTaskCollection, task: AsyncTask) {.importcpp: "#.add_task(#)".} ## \
## Adds a new AsyncTask to the collection.

proc remove_task*(this: AsyncTaskCollection, task: AsyncTask): bool {.importcpp: "#.remove_task(#)".} ## \
## Removes the indicated AsyncTask from the collection.  Returns true if the
## task was removed, false if it was not a member of the collection.

proc remove_task*(this: AsyncTaskCollection, index: clonglong) {.importcpp: "#.remove_task(#)".} ## \
## Removes the nth AsyncTask from the collection.

proc add_tasks_from*(this: AsyncTaskCollection, other: AsyncTaskCollection) {.importcpp: "#.add_tasks_from(#)".} ## \
## Adds all the AsyncTasks indicated in the other collection to this task.
## The other tasks are simply appended to the end of the tasks in this list;
## duplicates are not automatically removed.

proc remove_tasks_from*(this: AsyncTaskCollection, other: AsyncTaskCollection) {.importcpp: "#.remove_tasks_from(#)".} ## \
## Removes from this collection all of the AsyncTasks listed in the other
## collection.

proc remove_duplicate_tasks*(this: AsyncTaskCollection) {.importcpp: "#.remove_duplicate_tasks()".} ## \
## Removes any duplicate entries of the same AsyncTasks on this collection.
## If a AsyncTask appears multiple times, the first appearance is retained;
## subsequent appearances are removed.

proc has_task*(this: AsyncTaskCollection, task: AsyncTask): bool {.importcpp: "#.has_task(#)".} ## \
## Returns true if the indicated AsyncTask appears in this collection, false
## otherwise.

proc clear*(this: AsyncTaskCollection) {.importcpp: "#.clear()".} ## \
## Removes all AsyncTasks from the collection.

proc find_task*(this: AsyncTaskCollection, name: string): AsyncTask {.importcpp: "#.find_task(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the task in the collection with the indicated name, if any, or NULL
## if no task has that name.

proc get_num_tasks*(this: AsyncTaskCollection): clonglong {.importcpp: "#.get_num_tasks()".} ## \
## Returns the number of AsyncTasks in the collection.

proc get_task*(this: AsyncTaskCollection, index: clonglong): AsyncTask {.importcpp: "#.get_task(#)".} ## \
## Returns the nth AsyncTask in the collection.

proc `[]`*(this: AsyncTaskCollection, index: clonglong): AsyncTask {.importcpp: "#.operator [](#)".} ## \
## Returns the nth AsyncTask in the collection.  This is the same as
## get_task(), but it may be a more convenient way to access it.

proc size*(this: AsyncTaskCollection): clonglong {.importcpp: "#.size()".} ## \
## Returns the number of tasks in the collection.  This is the same thing as
## get_num_tasks().

proc `+=`*(this: AsyncTaskCollection, other: AsyncTaskCollection): AsyncTaskCollection {.importcpp: "#.operator +=(#)".}

proc `+`*(this: AsyncTaskCollection, other: AsyncTaskCollection): AsyncTaskCollection {.importcpp: "#.operator +(#)".}

proc output*(this: AsyncTaskCollection, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes a brief one-line description of the AsyncTaskCollection to the
## indicated output stream.

proc write*(this: AsyncTaskCollection, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes a complete multi-line description of the AsyncTaskCollection to the
## indicated output stream.

proc write*(this: AsyncTaskCollection, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a complete multi-line description of the AsyncTaskCollection to the
## indicated output stream.

proc poll*(this: AsyncTaskManager) {.importcpp: "#->poll()".} ## \
## Runs through all the tasks in the task list, once, if the task manager is
## running in single-threaded mode (no threads available).  This method does
## nothing in threaded mode, so it may safely be called in either case.

proc get_next_wake_time*(this: AsyncTaskManager): float64 {.importcpp: "#->get_next_wake_time()".} ## \
## Returns the scheduled time (on the manager's clock) of the next sleeping
## task, on any task chain, to awaken.  Returns -1 if there are no sleeping
## tasks.

proc output*(this: AsyncTaskManager, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: AsyncTaskManager, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: AsyncTaskManager, `out`: ostream) {.importcpp: "#->write(#)".}

proc get_global_ptr*(_: typedesc[AsyncTaskManager]): AsyncTaskManager {.importcpp: "AsyncTaskManager::get_global_ptr()", header: "asyncTaskManager.h".} ## \
## Returns a pointer to the global AsyncTaskManager.  This is the
## AsyncTaskManager that most code should use for queueing tasks and suchlike.

proc get_class_type*(_: typedesc[AsyncTaskManager]): TypeHandle {.importcpp: "AsyncTaskManager::get_class_type()", header: "asyncTaskManager.h".}

proc get_class_type*(_: typedesc[AsyncTask]): TypeHandle {.importcpp: "AsyncTask::get_class_type()", header: "asyncTask.h".}

proc newAsyncTask*(param0: AsyncTask): AsyncTask {.importcpp: "new AsyncTask(#)".}

converter upcast_to_TypedReferenceCount*(this: AsyncTaskChain): TypedReferenceCount {.importcpp: "(PT(TypedReferenceCount)(#))".}

converter upcast_to_Namable*(this: AsyncTaskChain): Namable {.importcpp: "((Namable *)(#.p()))".}

proc set_tick_clock*(this: AsyncTaskChain, tick_clock: bool) {.importcpp: "#->set_tick_clock(#)".} ## \
## Sets the tick_clock flag.  When this is true, get_clock()->tick() will be
## called automatically at each task epoch.  This is false by default.

proc get_tick_clock*(this: AsyncTaskChain): bool {.importcpp: "#->get_tick_clock()".} ## \
## Returns the tick_clock flag.  See set_tick_clock().

proc set_num_threads*(this: AsyncTaskChain, num_threads: int) {.importcpp: "#->set_num_threads(#)".} ## \
## Changes the number of threads for this task chain.  This may require
## stopping the threads if they are already running.

proc get_num_threads*(this: AsyncTaskChain): int {.importcpp: "#->get_num_threads()".} ## \
## Returns the number of threads that will be servicing tasks for this chain.
## Also see get_num_running_threads().

proc get_num_running_threads*(this: AsyncTaskChain): int {.importcpp: "#->get_num_running_threads()".} ## \
## Returns the number of threads that have been created and are actively
## running.  This will return 0 before the threads have been started; it will
## also return 0 if thread support is not available.

proc set_thread_priority*(this: AsyncTaskChain, priority: ThreadPriority) {.importcpp: "#->set_thread_priority(#)".} ## \
## Changes the priority associated with threads that serve this task chain.
## This may require stopping the threads if they are already running.

proc get_thread_priority*(this: AsyncTaskChain): ThreadPriority {.importcpp: "#->get_thread_priority()".} ## \
## Returns the priority associated with threads that serve this task chain.

proc set_frame_budget*(this: AsyncTaskChain, frame_budget: float64) {.importcpp: "#->set_frame_budget(#)".} ## \
## Sets the maximum amount of time per frame the tasks on this chain are
## granted for execution.  If this is less than zero, there is no limit; if it
## is >= 0, it represents a maximum amount of time (in seconds) that will be
## used to execute tasks.  If this time is exceeded in any one frame, the task
## chain will stop executing tasks until the next frame, as defined by the
## TaskManager's clock.

proc get_frame_budget*(this: AsyncTaskChain): float64 {.importcpp: "#->get_frame_budget()".} ## \
## Returns the maximum amount of time per frame the tasks on this chain are
## granted for execution.  See set_frame_budget().

proc set_frame_sync*(this: AsyncTaskChain, frame_sync: bool) {.importcpp: "#->set_frame_sync(#)".} ## \
## Sets the frame_sync flag.  When this flag is true, this task chain will be
## forced to sync with the TaskManager's clock.  It will run no faster than
## one epoch per clock frame.
##
## When this flag is false, the default, the task chain will finish all of its
## tasks and then immediately start from the first task again, regardless of
## the clock frame.  When it is true, the task chain will finish all of its
## tasks and then wait for the clock to tick to the next frame before resuming
## the first task.
##
## This only makes sense for threaded task chains.  Non-threaded task chains
## are automatically synchronous.

proc get_frame_sync*(this: AsyncTaskChain): bool {.importcpp: "#->get_frame_sync()".} ## \
## Returns the frame_sync flag.  See set_frame_sync().

proc set_timeslice_priority*(this: AsyncTaskChain, timeslice_priority: bool) {.importcpp: "#->set_timeslice_priority(#)".} ## \
## Sets the timeslice_priority flag.  This changes the interpretation of
## priority, and the number of times per epoch each task will run.
##
## When this flag is true, some tasks might not run in any given epoch.
## Instead, tasks with priority higher than 1 will be given precedence, in
## proportion to the amount of time they have already used.  This gives
## higher-priority tasks more runtime than lower-priority tasks.  Each task
## gets the amount of time proportional to its priority value, so a task with
## priority 100 will get five times as much processing time as a task with
## priority 20.  For these purposes, priority values less than 1 are deemed to
## be equal to 1.
##
## When this flag is false (the default), all tasks are run exactly once each
## epoch, round-robin style.  Priority is only used to determine which task
## runs first within tasks of the same sort value.

proc get_timeslice_priority*(this: AsyncTaskChain): bool {.importcpp: "#->get_timeslice_priority()".} ## \
## Returns the timeslice_priority flag.  This changes the interpretation of
## priority, and the number of times per epoch each task will run.  See
## set_timeslice_priority().

proc stop_threads*(this: AsyncTaskChain) {.importcpp: "#->stop_threads()".} ## \
## Stops any threads that are currently running.  If any tasks are still
## pending and have not yet been picked up by a thread, they will not be
## serviced unless poll() or start_threads() is later called.

proc start_threads*(this: AsyncTaskChain) {.importcpp: "#->start_threads()".} ## \
## Starts any requested threads to service the tasks on the queue.  This is
## normally not necessary, since adding a task will start the threads
## automatically.

proc is_started*(this: AsyncTaskChain): bool {.importcpp: "#->is_started()".} ## \
## Returns true if the thread(s) have been started and are ready to service
## requests, false otherwise.  If this is false, the next call to add() or
## add_and_do() will automatically start the threads.

proc has_task*(this: AsyncTaskChain, task: AsyncTask): bool {.importcpp: "#->has_task(#)".} ## \
## Returns true if the indicated task has been added to this AsyncTaskChain,
## false otherwise.

proc wait_for_tasks*(this: AsyncTaskChain) {.importcpp: "#->wait_for_tasks()".} ## \
## Blocks until the task list is empty.

proc get_num_tasks*(this: AsyncTaskChain): int {.importcpp: "#->get_num_tasks()".} ## \
## Returns the number of tasks that are currently active or sleeping within
## the task chain.

proc get_tasks*(this: AsyncTaskChain): AsyncTaskCollection {.importcpp: "#->get_tasks()".} ## \
## Returns the set of tasks that are active or sleeping on the task chain, at
## the time of the call.

proc get_active_tasks*(this: AsyncTaskChain): AsyncTaskCollection {.importcpp: "#->get_active_tasks()".} ## \
## Returns the set of tasks that are active (and not sleeping) on the task
## chain, at the time of the call.

proc get_sleeping_tasks*(this: AsyncTaskChain): AsyncTaskCollection {.importcpp: "#->get_sleeping_tasks()".} ## \
## Returns the set of tasks that are sleeping (and not active) on the task
## chain, at the time of the call.

proc poll*(this: AsyncTaskChain) {.importcpp: "#->poll()".} ## \
## Runs through all the tasks in the task list, once, if the task chain is
## running in single-threaded mode (no threads available).  This method does
## nothing in threaded mode, so it may safely be called in either case.
##
## Normally, you would not call this function directly; instead, call
## AsyncTaskManager::poll(), which polls all of the task chains in sequence.

proc get_next_wake_time*(this: AsyncTaskChain): float64 {.importcpp: "#->get_next_wake_time()".} ## \
## Returns the scheduled time (on the manager's clock) of the next sleeping
## task, on any task chain, to awaken.  Returns -1 if there are no sleeping
## tasks.

proc output*(this: AsyncTaskChain, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: AsyncTaskChain, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: AsyncTaskChain, `out`: ostream) {.importcpp: "#->write(#)".}

proc get_class_type*(_: typedesc[AsyncTaskChain]): TypeHandle {.importcpp: "AsyncTaskChain::get_class_type()", header: "asyncTaskChain.h".}

proc newAsyncTaskPause*(param0: AsyncTaskPause): AsyncTaskPause {.importcpp: "new AsyncTaskPause(#)".}

proc newAsyncTaskPause*(delay: float64): AsyncTaskPause {.importcpp: "new AsyncTaskPause(#)".}

proc get_class_type*(_: typedesc[AsyncTaskPause]): TypeHandle {.importcpp: "AsyncTaskPause::get_class_type()", header: "asyncTaskPause.h".}

converter upcast_to_AsyncTask*(this: AsyncTaskSequence): AsyncTask {.importcpp: "(PT(AsyncTask)(#))".}

converter upcast_to_AsyncTaskCollection*(this: AsyncTaskSequence): AsyncTaskCollection {.importcpp: "((AsyncTaskCollection *)(#.p()))".}

proc newAsyncTaskSequence*(param0: AsyncTaskSequence): AsyncTaskSequence {.importcpp: "new AsyncTaskSequence(#)".}

proc newAsyncTaskSequence*(name: string): AsyncTaskSequence {.importcpp: "new AsyncTaskSequence(nimStringToStdString(#))", header: stringConversionCode.}

proc set_repeat_count*(this: AsyncTaskSequence, repeat_count: int) {.importcpp: "#->set_repeat_count(#)".} ## \
## Sets the repeat count of the sequence.  If the count is 0 or 1, the
## sequence will run exactly once.  If it is greater than 0, it will run that
## number of times.  If it is negative, it will run forever until it is
## explicitly removed.

proc get_repeat_count*(this: AsyncTaskSequence): int {.importcpp: "#->get_repeat_count()".} ## \
## Returns the repeat count of the sequence.  See set_repeat_count().

proc get_current_task_index*(this: AsyncTaskSequence): clonglong {.importcpp: "#->get_current_task_index()".} ## \
## Returns the index of the task within the sequence that is currently being
## executed (or that will be executed at the next epoch).

proc get_class_type*(_: typedesc[AsyncTaskSequence]): TypeHandle {.importcpp: "AsyncTaskSequence::get_class_type()", header: "asyncTaskSequence.h".}

proc `==`*(this: ButtonEvent, other: ButtonEvent): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: ButtonEvent, other: ButtonEvent): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: ButtonEvent, other: ButtonEvent): bool {.importcpp: "#.operator <(#)".}

proc newButtonEventList*(): ButtonEventList {.importcpp: "new ButtonEventList()".}

proc newButtonEventList*(copy: ButtonEventList): ButtonEventList {.importcpp: "new ButtonEventList(#)".}

proc add_event*(this: ButtonEventList, event: ButtonEvent) {.importcpp: "#->add_event(#)".} ## \
## Adds a new event to the end of the list.

proc get_num_events*(this: ButtonEventList): int {.importcpp: "#->get_num_events()".} ## \
## Returns the number of events in the list.

proc get_event*(this: ButtonEventList, n: int): ButtonEvent {.importcpp: "#->get_event(#)".} ## \
## Returns the nth event in the list.  This does not remove the event from the
## list; the only way to remove events is to empty the whole list with
## clear().

proc clear*(this: ButtonEventList) {.importcpp: "#->clear()".} ## \
## Empties all the events from the list.

proc add_events*(this: ButtonEventList, other: ButtonEventList) {.importcpp: "#->add_events(#)".} ## \
## Appends the events from the other list onto the end of this one.

proc update_mods*(this: ButtonEventList, mods: ModifierButtons) {.importcpp: "#->update_mods(#)".} ## \
## Updates the indicated ModifierButtons object with all of the button up/down
## transitions indicated in the list.

proc write*(this: ButtonEventList, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: ButtonEventList, `out`: ostream) {.importcpp: "#->write(#)".}

proc get_class_type*(_: typedesc[ButtonEventList]): TypeHandle {.importcpp: "ButtonEventList::get_class_type()", header: "buttonEventList.h".}

proc newEvent*(copy: Event): Event {.importcpp: "new Event(#)".}

proc newEvent*(event_name: string): Event {.importcpp: "new Event(nimStringToStdString(#))", header: stringConversionCode.}

proc set_name*(this: Event, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.}

proc clear_name*(this: Event) {.importcpp: "#->clear_name()".} ## \
## Resets the Event's name to empty.

proc has_name*(this: Event): bool {.importcpp: "#->has_name()".} ## \
## Returns true if the Event has a nonempty name set, false if the name is
## empty.

proc get_name*(this: Event): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.}

proc add_parameter*(this: Event, obj: EventParameter) {.importcpp: "#->add_parameter(#)".}

proc get_num_parameters*(this: Event): int {.importcpp: "#->get_num_parameters()".}

proc get_parameter*(this: Event, n: int): EventParameter {.importcpp: "#->get_parameter(#)".}

proc has_receiver*(this: Event): bool {.importcpp: "#->has_receiver()".}

proc clear_receiver*(this: Event) {.importcpp: "#->clear_receiver()".}

proc output*(this: Event, `out`: ostream) {.importcpp: "#->output(#)".}

proc get_class_type*(_: typedesc[Event]): TypeHandle {.importcpp: "Event::get_class_type()", header: "event.h".}

proc initEventHandler*(ev_queue: EventQueue): EventHandler {.importcpp: "EventHandler(#)".}

proc get_future*(this: EventHandler, event_name: string): AsyncFuture {.importcpp: "#.get_future(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a pending future that will be marked as done when the event is next
## fired.

proc process_events*(this: EventHandler) {.importcpp: "#.process_events()".} ## \
## The main processing loop of the EventHandler.  This function must be called
## periodically to service events.  Walks through each pending event and calls
## its assigned hooks.

proc dispatch_event*(this: EventHandler, event: Event) {.importcpp: "#.dispatch_event(#)".} ## \
## Calls the hooks assigned to the indicated single event.

proc write*(this: EventHandler, `out`: ostream) {.importcpp: "#.write(#)".}

proc get_global_event_handler*(_: typedesc[EventHandler], queue: EventQueue): EventHandler {.importcpp: "EventHandler::get_global_event_handler(#)", header: "eventHandler.h".} ## \
## Returns a pointer to the one global EventHandler object.  If the global
## object has not yet been created, this will create it.

proc get_global_event_handler*(_: typedesc[EventHandler]): EventHandler {.importcpp: "EventHandler::get_global_event_handler()", header: "eventHandler.h".} ## \
## Returns a pointer to the one global EventHandler object.  If the global
## object has not yet been created, this will create it.

proc get_class_type*(_: typedesc[EventHandler]): TypeHandle {.importcpp: "EventHandler::get_class_type()", header: "eventHandler.h".}

proc newEventQueue*(): EventQueue {.importcpp: "new EventQueue()".}

proc queue_event*(this: EventQueue, event: Event) {.importcpp: "#->queue_event(#)".}

proc clear*(this: EventQueue) {.importcpp: "#->clear()".} ## \
## Empties all events on the queue, throwing them on the floor.

proc is_queue_empty*(this: EventQueue): bool {.importcpp: "#->is_queue_empty()".}

proc is_queue_full*(this: EventQueue): bool {.importcpp: "#->is_queue_full()".} ## \
## @deprecated Always returns false; the queue can never be full.

proc dequeue_event*(this: EventQueue): Event {.importcpp: "#->dequeue_event()".}

proc get_global_event_queue*(_: typedesc[EventQueue]): EventQueue {.importcpp: "EventQueue::get_global_event_queue()", header: "eventQueue.h".} ## \
## Returns a pointer to the one global EventQueue object.  If the global
## object has not yet been created, this will create it.

proc newPointerEventList*(): PointerEventList {.importcpp: "new PointerEventList()".}

proc get_num_events*(this: PointerEventList): clonglong {.importcpp: "#->get_num_events()".} ## \
## Returns the number of events in the list.

proc get_in_window*(this: PointerEventList, n: clonglong): bool {.importcpp: "#->get_in_window(#)".} ## \
## Get the in-window flag of the nth event.

proc get_xpos*(this: PointerEventList, n: clonglong): int {.importcpp: "#->get_xpos(#)".} ## \
## Get the x-coordinate of the nth event.

proc get_ypos*(this: PointerEventList, n: clonglong): int {.importcpp: "#->get_ypos(#)".} ## \
## Get the y-coordinate of the nth event.

proc get_dx*(this: PointerEventList, n: clonglong): float64 {.importcpp: "#->get_dx(#)".} ## \
## Get the x-delta of the nth event.

proc get_dy*(this: PointerEventList, n: clonglong): float64 {.importcpp: "#->get_dy(#)".} ## \
## Get the y-delta of the nth event.

proc get_sequence*(this: PointerEventList, n: clonglong): int {.importcpp: "#->get_sequence(#)".} ## \
## Get the sequence number of the nth event.

proc get_length*(this: PointerEventList, n: clonglong): float64 {.importcpp: "#->get_length(#)".} ## \
## Get the length of the nth event.

proc get_direction*(this: PointerEventList, n: clonglong): float64 {.importcpp: "#->get_direction(#)".} ## \
## Get the direction of the nth event.

proc get_rotation*(this: PointerEventList, n: clonglong): float64 {.importcpp: "#->get_rotation(#)".} ## \
## Get the rotation of the nth event.

proc get_time*(this: PointerEventList, n: clonglong): float64 {.importcpp: "#->get_time(#)".} ## \
## Get the timestamp of the nth event.

proc clear*(this: PointerEventList) {.importcpp: "#->clear()".} ## \
## Empties all the events from the list.

proc pop_front*(this: PointerEventList) {.importcpp: "#->pop_front()".} ## \
## Discards the first event on the list.

proc add_event*(this: PointerEventList, data: PointerData, seq: int, time: float64) {.importcpp: "#->add_event(#, #, #)".} ## \
## Adds a new event from the given PointerData object.

proc add_event*(this: PointerEventList, in_win: bool, xpos: int, ypos: int, xdelta: float64, ydelta: float64, seq: int, time: float64) {.importcpp: "#->add_event(#, #, #, #, #, #, #)".} ## \
## Adds a new event to the end of the list based on the given mouse movement.

proc add_event*(this: PointerEventList, in_win: bool, xpos: int, ypos: int, seq: int, time: float64) {.importcpp: "#->add_event(#, #, #, #, #)".} ## \
## Adds a new event to the end of the list.  Automatically calculates the dx,
## dy, length, direction, and rotation for all but the first event.

proc encircles*(this: PointerEventList, x: int, y: int): bool {.importcpp: "#->encircles(#, #)".} ## \
## Returns true if the trail loops around the specified point.

proc total_turns*(this: PointerEventList, sec: float64): float64 {.importcpp: "#->total_turns(#)".} ## \
## returns the total angular deviation that the trail has made in the
## specified time period.  A small number means that the trail is moving in a
## relatively straight line, a large number means that the trail is zig-
## zagging or spinning.  The result is in degrees.

proc match_pattern*(this: PointerEventList, pattern: string, rot: float64, seglen: float64): float64 {.importcpp: "#->match_pattern(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## This function is not implemented yet.  It is a work in progress.  The
## intent is as follows:
##
## Returns a nonzero value if the mouse movements match the specified pattern.
## The higher the value, the better the match.  The pattern is a sequence of
## compass directions (ie, "E", "NE", etc) separated by spaces.  If rot is
## nonzero, then the pattern is rotated counterclockwise by the specified
## amount before testing.  Seglen is the minimum length a mouse movement needs
## to be in order to be considered significant.

proc get_class_type*(_: typedesc[PointerEventList]): TypeHandle {.importcpp: "PointerEventList::get_class_type()", header: "pointerEventList.h".}

proc newPythonTask*(): PythonTask {.importcpp: "new PythonTask()".}

proc newPythonTask*(param0: PythonTask): PythonTask {.importcpp: "new PythonTask(#)".}

proc has_delay*(this: PythonTask): bool {.importcpp: "#->has_delay()".} ## \
## Returns true if a delay has been set for this task via set_delay(), or
## false otherwise.

proc clear_delay*(this: PythonTask) {.importcpp: "#->clear_delay()".} ## \
## Removes any delay specified for the task.  The next time the task is added
## to the queue, it will run immediately.  This does not affect the task's
## wake time if it has already been added to the queue.

proc get_class_type*(_: typedesc[PythonTask]): TypeHandle {.importcpp: "PythonTask::get_class_type()", header: "pythonTask.h".}

proc initAdaptiveLru*(name: string, max_size: clonglong): AdaptiveLru {.importcpp: "AdaptiveLru(nimStringToStdString(#), #)", header: stringConversionCode.}

proc get_total_size*(this: AdaptiveLru): clonglong {.importcpp: "#.get_total_size()".} ## \
## Returns the total size of all objects currently active on the LRU.

proc get_max_size*(this: AdaptiveLru): clonglong {.importcpp: "#.get_max_size()".} ## \
## Returns the max size of all objects that are allowed to be active on the
## LRU.

proc set_max_size*(this: AdaptiveLru, max_size: clonglong) {.importcpp: "#.set_max_size(#)".} ## \
## Changes the max size of all objects that are allowed to be active on the
## LRU.
##
## If the size is (size_t)-1, there is no limit.

proc count_active_size*(this: AdaptiveLru): clonglong {.importcpp: "#.count_active_size()".} ## \
## Returns the total size of the pages that were enqueued since the last call
## to begin_epoch().

proc consider_evict*(this: AdaptiveLru) {.importcpp: "#.consider_evict()".} ## \
## Evicts a sequence of objects if the queue is full.

proc evict_to*(this: AdaptiveLru, target_size: clonglong) {.importcpp: "#.evict_to(#)".} ## \
## Evicts a sequence of objects until the queue fits within the indicated
## target size, regardless of its normal max size.

proc begin_epoch*(this: AdaptiveLru) {.importcpp: "#.begin_epoch()".} ## \
## Marks the end of the previous epoch and the beginning of the next one.
## This will evict any objects that are pending eviction, and also update any
## internal bookkeeping.

proc validate*(this: AdaptiveLru): bool {.importcpp: "#.validate()".} ## \
## Checks that the LRU is internally self-consistent.  Returns true if
## successful, false if there is some problem.

proc output*(this: AdaptiveLru, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: AdaptiveLru, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc set_weight*(this: AdaptiveLru, weight: float32) {.importcpp: "#.set_weight(#)".} ## \
## The following methods are specific to AdaptiveLru, and do not exist in
## the SimpleLru implementation.  In most cases, the defaults will be
## sufficient, so you do not need to mess with them.

proc get_weight*(this: AdaptiveLru): float32 {.importcpp: "#.get_weight()".} ## \
## Returns the weight value used to compute the exponential moving average.

proc set_max_updates_per_frame*(this: AdaptiveLru, max_updates_per_frame: int) {.importcpp: "#.set_max_updates_per_frame(#)".} ## \
## Specifies the maximum number of pages the AdaptiveLru will update each
## frame.  This is a performance optimization: keeping this number low limits
## the impact of the AdaptiveLru's adaptive algorithm.

proc get_max_updates_per_frame*(this: AdaptiveLru): int {.importcpp: "#.get_max_updates_per_frame()".} ## \
## Returns the maximum number of pages the AdaptiveLru will update each frame.

proc initAdaptiveLruPage*(copy: AdaptiveLruPage): AdaptiveLruPage {.importcpp: "AdaptiveLruPage(#)".}

proc initAdaptiveLruPage*(lru_size: clonglong): AdaptiveLruPage {.importcpp: "AdaptiveLruPage(#)".}

proc get_lru*(this: AdaptiveLruPage): AdaptiveLru {.importcpp: "#.get_lru()".} ## \
## Returns the LRU that manages this page, or NULL if it is not currently
## managed by any LRU.

proc enqueue_lru*(this: AdaptiveLruPage, lru: AdaptiveLru) {.importcpp: "#.enqueue_lru(#)".} ## \
## Adds the page to the LRU for the first time, or marks it recently-accessed
## if it has already been added.
##
## If lru is NULL, it means to remove this page from its LRU.

proc dequeue_lru*(this: AdaptiveLruPage) {.importcpp: "#.dequeue_lru()".} ## \
## Removes the page from its AdaptiveLru.

proc mark_used_lru*(this: AdaptiveLruPage, lru: AdaptiveLru) {.importcpp: "#.mark_used_lru(#)".} ## \
## To be called when the page is used; this will move it to the tail of the
## specified AdaptiveLru queue.

proc get_lru_size*(this: AdaptiveLruPage): clonglong {.importcpp: "#.get_lru_size()".} ## \
## Returns the size of this page as reported to the LRU, presumably in bytes.

proc set_lru_size*(this: AdaptiveLruPage, lru_size: clonglong) {.importcpp: "#.set_lru_size(#)".} ## \
## Specifies the size of this page, presumably in bytes, although any unit is
## possible.

proc evict_lru*(this: AdaptiveLruPage) {.importcpp: "#.evict_lru()".} ## \
## Evicts the page from the LRU.  Called internally when the LRU determines
## that it is full.  May also be called externally when necessary to
## explicitly evict the page.
##
## It is legal for this method to either evict the page as requested, do
## nothing (in which case the eviction will be requested again at the next
## epoch), or requeue itself on the tail of the queue (in which case the
## eviction will be requested again much later).

proc output*(this: AdaptiveLruPage, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: AdaptiveLruPage, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc get_num_frames*(this: AdaptiveLruPage): int {.importcpp: "#.get_num_frames()".} ## \
## Returns the number of frames since the page was first added to its LRU.
## Returns 0 if it does not have an LRU.

proc get_num_inactive_frames*(this: AdaptiveLruPage): int {.importcpp: "#.get_num_inactive_frames()".} ## \
## Returns the number of frames since the page was last accessed on its LRU.
## Returns 0 if it does not have an LRU.

proc initGeomEnums*(): GeomEnums {.importcpp: "GeomEnums()".}

proc initGeomEnums*(param0: GeomEnums): GeomEnums {.importcpp: "GeomEnums(#)".}

proc initGeomVertexAnimationSpec*(): GeomVertexAnimationSpec {.importcpp: "GeomVertexAnimationSpec()".}

proc initGeomVertexAnimationSpec*(other: GeomVertexAnimationSpec): GeomVertexAnimationSpec {.importcpp: "GeomVertexAnimationSpec(#)".}

proc get_num_transforms*(this: GeomVertexAnimationSpec): int {.importcpp: "#.get_num_transforms()".} ## \
## This is only meaningful for animation_type AT_hardware.  It specifies the
## maximum number of transforms that might be simultaneously applied to any
## one vertex by the data in this format.

proc get_indexed_transforms*(this: GeomVertexAnimationSpec): bool {.importcpp: "#.get_indexed_transforms()".} ## \
## This is only meaningful for animation_type AT_hardware.  If true, it
## indicates that the format uses indexed animation tables.  It is false if
## each vertex will reference the first _num_transforms table entries only.

proc set_none*(this: GeomVertexAnimationSpec) {.importcpp: "#.set_none()".} ## \
## Specifies that no vertex animation is represented by this spec.

proc set_panda*(this: GeomVertexAnimationSpec) {.importcpp: "#.set_panda()".} ## \
## Specifies that vertex animation is to be performed by Panda.  This is the
## most general setting and can handle any kind of vertex animation
## represented.

proc set_hardware*(this: GeomVertexAnimationSpec, num_transforms: int, indexed_transforms: bool) {.importcpp: "#.set_hardware(#, #)".} ## \
## Specifies that vertex animation is to be performed by the graphics hardware
## (or at least by the graphics backend API, which is actually still free to
## animate the vertices on the CPU).
##
## This is only legal if the graphics hardware can support the specified
## limits on number of transforms and/or indexed transforms.  Also, no current
## graphics API's support morphing.

proc output*(this: GeomVertexAnimationSpec, `out`: ostream) {.importcpp: "#.output(#)".}

proc make*(_: typedesc[InternalName], name: string, index: int): InternalName {.importcpp: "InternalName::make(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Make using a string and an integer.  Concatenates the two.

proc append*(this: InternalName, basename: string): InternalName {.importcpp: "#->append(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Constructs a new InternalName based on this name, with the indicated string
## following it.  This is a cheaper way to construct a hierarchical name than
## InternalName::make(parent->get_name() + ".basename").

proc get_parent*(this: InternalName): InternalName {.importcpp: "#->get_parent()".} ## \
## Return the parent of this InternalName.  All names have a parent, except
## the root name.

proc get_name*(this: InternalName): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the complete name represented by the InternalName and all of its
## parents.

proc join*(this: InternalName, sep: string): string {.importcpp: "nimStringFromStdString(#->join(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Like get_name, but uses a custom separator instead of ".".

proc get_basename*(this: InternalName): string {.importcpp: "nimStringFromStdString(#->get_basename())", header: stringConversionCode.} ## \
## Return the name represented by just this particular InternalName object,
## ignoring its parents names.  This is everything after the rightmost dot.

proc find_ancestor*(this: InternalName, basename: string): int {.importcpp: "#->find_ancestor(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the index of the ancestor with the indicated basename, or -1 if no
## ancestor has that basename.  Returns 0 if this name has the basename.
##
## This index value may be passed to get_ancestor() or get_net_basename() to
## retrieve more information about the indicated name.

proc get_ancestor*(this: InternalName, n: int): InternalName {.importcpp: "#->get_ancestor(#)".} ## \
## Returns the ancestor with the indicated index number.  0 is this name
## itself, 1 is the name's parent, 2 is the parent's parent, and so on.  If
## there are not enough ancestors, returns the root InternalName.

proc get_top*(this: InternalName): InternalName {.importcpp: "#->get_top()".} ## \
## Returns the oldest ancestor in the InternalName's chain, not counting the
## root.  This will be the first name in the string, e.g.  "texcoord.foo.bar"
## will return the InternalName "texcoord".

proc get_net_basename*(this: InternalName, n: int): string {.importcpp: "nimStringFromStdString(#->get_net_basename(#))", header: stringConversionCode.} ## \
## Returns the basename of this name prefixed by the indicated number of
## ancestors.  0 is this name's basename, 1 is parent.basename, 2 is
## grandparent.parent.basename, and so on.

proc output*(this: InternalName, `out`: ostream) {.importcpp: "#->output(#)".}

proc get_root*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_root()", header: "internalName.h".} ## \
## Returns the standard root InternalName.  This is the root of all other
## InternalNames.  It has no name itself, and it is the only InternalName with
## no parent.

proc get_error*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_error()", header: "internalName.h".} ## \
## Returns the standard InternalName "error".

proc get_vertex*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_vertex()", header: "internalName.h".} ## \
## Returns the standard InternalName "vertex".  This is the column header for
## the 3-d or 4-d vertex position information for each vertex.

proc get_normal*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_normal()", header: "internalName.h".} ## \
## Returns the standard InternalName "normal".  This is the column header for
## the 3-d lighting normal for each vertex.

proc get_tangent*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_tangent()", header: "internalName.h".} ## \
## Returns the standard InternalName "tangent".  This is the column header for
## the tangent vector associated with each vertex, which is a unit vector
## usually perpendicular to the normal and in the direction of the U texture
## coordinate change.  It is used for deriving bump maps.

proc get_tangent_name*(_: typedesc[InternalName], name: string): InternalName {.importcpp: "InternalName::get_tangent_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the InternalName "tangent.name", where name is the supplied string.
## This is the column header for the tangent associated with the named texture
## coordinate set.

proc get_binormal*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_binormal()", header: "internalName.h".} ## \
## Returns the standard InternalName "binormal".  This is the column header
## for the tangent vector associated with each vertex, which is a unit vector
## usually perpendicular to both the normal and the tangent, and in the
## direction of the V texture coordinate change.  It is used for deriving bump
## maps.

proc get_binormal_name*(_: typedesc[InternalName], name: string): InternalName {.importcpp: "InternalName::get_binormal_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the InternalName "binormal.name", where name is the supplied
## string.  This is the column header for the binormal associated with the
## named texture coordinate set.

proc get_texcoord*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_texcoord()", header: "internalName.h".} ## \
## Returns the standard InternalName "texcoord".  This is the column header
## for the default texture coordinate set for each vertex.  It is also used
## for identifying the default texture coordinate set in a TextureStage.

proc get_texcoord_name*(_: typedesc[InternalName], name: string): InternalName {.importcpp: "InternalName::get_texcoord_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the InternalName "texcoord.name", where name is the supplied
## string.  This is the column header for the named texture coordinate set for
## each vertex.  It is also used for identifying the named texture coordinate
## set in a TextureStage.

proc get_color*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_color()", header: "internalName.h".} ## \
## Returns the standard InternalName "color".  This is the column header for
## the 4-component color value for each vertex.

proc get_rotate*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_rotate()", header: "internalName.h".} ## \
## Returns the standard InternalName "rotate".  This is the column header for
## the floating-point rotate value, which represents a number of degrees
## counter-clockwise to rotate each point or point sprite.

proc get_size*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_size()", header: "internalName.h".} ## \
## Returns the standard InternalName "size".  This is the column header for
## the floating-point size value, which overrides the thickness parameter of
## the RenderModeAttrib on a per-vertex (e.g.  per-point) basis.

proc get_aspect_ratio*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_aspect_ratio()", header: "internalName.h".} ## \
## Returns the standard InternalName "aspect_ratio". This is the column header
## for the floating-point aspect ratio value, which is used to define non-
## square points.  This number is the ratio x / y, where y is the point size
## (above).

proc get_transform_blend*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_transform_blend()", header: "internalName.h".} ## \
## Returns the standard InternalName "transform_blend". This is the column
## header for the integer transform_blend index, which is used to define
## vertex animation on the CPU by indexing to a particular vertex weighting
## from the TransformBlendTable.

proc get_transform_weight*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_transform_weight()", header: "internalName.h".} ## \
## Returns the standard InternalName "transform_weight". This is the column
## header for the n-component transform_weight value, which is used in
## conjuntion with "transform_index" to define vertex animation on the
## graphics card.  The transform_weight value specifies the weight of the nth
## transform.  By convention, there are 1 fewer weight values than transforms,
## since the weights are assumed to sum to 1 (and the last value is therefore
## implicit).

proc get_transform_index*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_transform_index()", header: "internalName.h".} ## \
## Returns the standard InternalName "transform_index". This is the column
## header for the n-component transform_index value, which is used in
## conjuntion with "transform_weight" to define vertex animation on the
## graphics card.  The transform_index value specifies the nth transform, by
## lookup in the TransformTable.  The transform_index column may be omitted,
## in which case the nth transform is the nth entry in the table.

proc get_morph*(_: typedesc[InternalName], column: InternalName, slider: string): InternalName {.importcpp: "InternalName::get_morph(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns an InternalName derived from the given base column name and the
## given slider name, which is the column header for the offset vector that
## should be applied to the base column name when the named morph slider is
## engaged.
##
## Each morph slider requires a set of n morph columns, one for each base
## column it applies to.

proc get_index*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_index()", header: "internalName.h".} ## \
## Returns the standard InternalName "index".  This is the column header for
## the integer vertex index.  It is not used in the vertex data itself, but is
## used in the GeomPrimitive structure to index into the vertex data.

proc get_world*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_world()", header: "internalName.h".} ## \
## Returns the standard InternalName "world".  This is used as a keyword in
## the shader subsystem.

proc get_camera*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_camera()", header: "internalName.h".} ## \
## Returns the standard InternalName "camera".  This is used as a keyword in
## the shader subsystem.

proc get_model*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_model()", header: "internalName.h".} ## \
## Returns the standard InternalName "model".  This is used as a keyword in
## the shader subsystem.

proc get_view*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_view()", header: "internalName.h".} ## \
## Returns the standard InternalName "view".  This is used as a keyword in the
## shader subsystem.

proc get_class_type*(_: typedesc[InternalName]): TypeHandle {.importcpp: "InternalName::get_class_type()", header: "internalName.h".}

proc initGeomVertexColumn*(copy: GeomVertexColumn): GeomVertexColumn {.importcpp: "GeomVertexColumn(#)".}

proc get_name*(this: GeomVertexColumn): InternalName {.importcpp: "#.get_name()".} ## \
## Returns the name of this particular data field, e.g.  "vertex" or "normal".
## The name may be a user-defined string, or it may be one of the standard
## system-defined field types.  Only the system-defined field types are used
## for the actual rendering.

proc get_num_components*(this: GeomVertexColumn): int {.importcpp: "#.get_num_components()".} ## \
## Returns the number of components of the column: the number of instances of
## the NumericType in each element.  This is usually, but not always, the same
## thing as get_num_values().

proc get_num_values*(this: GeomVertexColumn): int {.importcpp: "#.get_num_values()".} ## \
## Returns the number of numeric values of the column: the number of distinct
## numeric values that go into each element.  This is usually, but not always,
## the same thing as get_num_components(); the difference is in the case of a
## composite numeric type like NT_packed_dcba, which has four numeric values
## per component.

proc get_num_elements*(this: GeomVertexColumn): int {.importcpp: "#.get_num_elements()".} ## \
## Returns the number of times this column is repeated.  This is usually 1,
## except for matrices.

proc get_start*(this: GeomVertexColumn): int {.importcpp: "#.get_start()".} ## \
## Returns the byte within the array record at which this column starts.  This
## can be set to non-zero to implement interleaved arrays.

proc get_column_alignment*(this: GeomVertexColumn): int {.importcpp: "#.get_column_alignment()".} ## \
## Returns the alignment requirements for this column.  If this is greater
## than 1, it restricts the column to appear only on memory addresses that are
## integer multiples of this value; this has implications for this column's
## start value, as well as the stride of the resulting array.

proc get_element_stride*(this: GeomVertexColumn): int {.importcpp: "#.get_element_stride()".} ## \
## This value is only relevant for matrix types.  Returns the number of bytes
## to add to access the next row of the matrix.

proc get_component_bytes*(this: GeomVertexColumn): int {.importcpp: "#.get_component_bytes()".} ## \
## Returns the number of bytes used by each component (that is, by one element
## of the numeric type).

proc get_total_bytes*(this: GeomVertexColumn): int {.importcpp: "#.get_total_bytes()".} ## \
## Returns the number of bytes used by each element of the column:
## component_bytes * num_components.

proc has_homogeneous_coord*(this: GeomVertexColumn): bool {.importcpp: "#.has_homogeneous_coord()".} ## \
## Returns true if this Contents type is one that includes a homogeneous
## coordinate in the fourth component, or false otherwise.  If this is true,
## correct operation on the vertex data may require scaling by the homogeneous
## coordinate from time to time (but in general this is handled automatically
## if you use the 3-component or smaller forms of get_data() and set_data()).

proc overlaps_with*(this: GeomVertexColumn, start_byte: int, num_bytes: int): bool {.importcpp: "#.overlaps_with(#, #)".} ## \
## Returns true if this column overlaps with any of the bytes in the indicated
## range, false if it does not.

proc is_bytewise_equivalent*(this: GeomVertexColumn, other: GeomVertexColumn): bool {.importcpp: "#.is_bytewise_equivalent(#)".} ## \
## Returns true if the data store of this column is exactly the same as that
## of the other, irrespective of name or start position within the record.

proc set_name*(this: GeomVertexColumn, name: InternalName) {.importcpp: "#.set_name(#)".} ## \
## Replaces the name of an existing column.  This is only legal on an
## unregistered format (i.e.  when constructing the format initially).

proc set_num_components*(this: GeomVertexColumn, num_components: int) {.importcpp: "#.set_num_components(#)".} ## \
## Changes the number of components of an existing column.  This is only legal
## on an unregistered format (i.e.  when constructing the format initially).

proc set_start*(this: GeomVertexColumn, start: int) {.importcpp: "#.set_start(#)".} ## \
## Changes the start byte of an existing column.  This is only legal on an
## unregistered format (i.e.  when constructing the format initially).

proc set_column_alignment*(this: GeomVertexColumn, column_alignment: int) {.importcpp: "#.set_column_alignment(#)".} ## \
## Changes the column alignment of an existing column.  This is only legal on
## an unregistered format (i.e.  when constructing the format initially).

proc output*(this: GeomVertexColumn, `out`: ostream) {.importcpp: "#.output(#)".}

converter upcast_to_TypedWritableReferenceCount*(this: GeomVertexArrayFormat): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcast_to_GeomEnums*(this: GeomVertexArrayFormat): GeomEnums {.importcpp: "((GeomEnums *)(#.p()))".}

proc newGeomVertexArrayFormat*(): GeomVertexArrayFormat {.importcpp: "new GeomVertexArrayFormat()".}

proc newGeomVertexArrayFormat*(copy: GeomVertexArrayFormat): GeomVertexArrayFormat {.importcpp: "new GeomVertexArrayFormat(#)".}

proc unref*(this: GeomVertexArrayFormat): bool {.importcpp: "#->unref()".} ## \
## This method overrides ReferenceCount::unref() to unregister the object when
## its reference count goes to zero.

proc is_registered*(this: GeomVertexArrayFormat): bool {.importcpp: "#->is_registered()".} ## \
## Returns true if this format has been registered, false if it has not.  It
## may not be used for a Geom until it has been registered, but once
## registered, it may no longer be modified.

proc register_format*(_: typedesc[GeomVertexArrayFormat], format: GeomVertexArrayFormat): GeomVertexArrayFormat {.importcpp: "GeomVertexArrayFormat::register_format(#)", header: "geomVertexArrayFormat.h".} ## \
## Adds the indicated format to the registry, if there is not an equivalent
## format already there; in either case, returns the pointer to the equivalent
## format now in the registry.
##
## This is similar to GeomVertexFormat::register_format(), except that you
## generally need not call it explicitly.  Calling
## GeomVertexFormat::register_format() automatically registers all of the
## nested array formats.

proc get_stride*(this: GeomVertexArrayFormat): int {.importcpp: "#->get_stride()".} ## \
## Returns the total number of bytes reserved in the array for each vertex.

proc set_stride*(this: GeomVertexArrayFormat, stride: int) {.importcpp: "#->set_stride(#)".} ## \
## Changes the total number of bytes reserved in the array for each vertex.
## You may not reduce this below get_total_bytes(), but you may increase it
## arbitrarily.

proc get_pad_to*(this: GeomVertexArrayFormat): int {.importcpp: "#->get_pad_to()".} ## \
## Returns the byte divisor to which the data record must be padded to meet
## hardware limitations.  For instance, if this is 4, the stride will be
## automatically rounded up to the next multiple of 4 bytes.  This value is
## automatically increased as needed to ensure the individual numeric
## components in the array are word-aligned.

proc set_pad_to*(this: GeomVertexArrayFormat, pad_to: int) {.importcpp: "#->set_pad_to(#)".} ## \
## Explicitly sets the byte divisor to which the data record must be padded to
## meet hardware limitations.  See get_pad_to().  Normally it is not necessary
## to call this unless you have some specific requirements for row-to-row data
## alignment.  Note that this value may be automatically increased at each
## subsequent call to add_column().

proc get_divisor*(this: GeomVertexArrayFormat): int {.importcpp: "#->get_divisor()".} ## \
## Returns the divisor attribute for the data in this array.  If 0, it
## contains per-vertex data.  If 1, it contains per-instance data.  If higher
## than 1, the read row is advanced for each n instances.

proc set_divisor*(this: GeomVertexArrayFormat, divisor: int) {.importcpp: "#->set_divisor(#)".} ## \
## Set this to 0 to indicate that this array contains per-vertex data, or to 1
## to indicate that it contains per-instance data.  If higher than 1, the read
## row is advanced for each n instances.

proc get_total_bytes*(this: GeomVertexArrayFormat): int {.importcpp: "#->get_total_bytes()".} ## \
## Returns the total number of bytes used by the data types within the format,
## including gaps between elements.

proc add_column*(this: GeomVertexArrayFormat, column: GeomVertexColumn): int {.importcpp: "#->add_column(#)".} ## \
## Adds a new column to the specification.  This is a table of per-vertex
## floating-point numbers such as "vertex" or "normal"; you must specify where
## in each record the table starts, and how many components (dimensions) exist
## per vertex.
##
## Adding a column with the same name as a previous type, or that overlaps
## with one or more previous types, quietly removes the previous type(s).
##
## The return value is the index number of the new data type.

proc remove_column*(this: GeomVertexArrayFormat, name: InternalName) {.importcpp: "#->remove_column(#)".} ## \
## Removes the column with the indicated name, if any.  This leaves a gap in
## the byte structure.

proc clear_columns*(this: GeomVertexArrayFormat) {.importcpp: "#->clear_columns()".} ## \
## Removes all columns previously added, sets the stride to zero, and prepares
## to start over.

proc pack_columns*(this: GeomVertexArrayFormat) {.importcpp: "#->pack_columns()".} ## \
## Removes wasted space between columns.

proc align_columns_for_animation*(this: GeomVertexArrayFormat) {.importcpp: "#->align_columns_for_animation()".} ## \
## Reprocesses the columns in the format to align the C_point and C_vector
## columns to 16-byte boundaries to allow for the more efficient SSE2
## operations (assuming SSE2 is enabled in the build).
##
## The caller is responsible for testing vertex_animation_align_16 to decide
## whether to call this method.

proc get_num_columns*(this: GeomVertexArrayFormat): int {.importcpp: "#->get_num_columns()".} ## \
## Returns the number of different columns in the array.

proc get_column*(this: GeomVertexArrayFormat, name: InternalName): GeomVertexColumn {.importcpp: "#->get_column(#)".} ## \
## Returns the specification with the indicated name, or NULL if the name is
## not used.

proc get_column*(this: GeomVertexArrayFormat, i: int): GeomVertexColumn {.importcpp: "#->get_column(#)".} ## \
## Returns the ith column of the array.

proc get_column*(this: GeomVertexArrayFormat, start_byte: int, num_bytes: int): GeomVertexColumn {.importcpp: "#->get_column(#, #)".} ## \
## Returns the first specification that overlaps with any of the indicated
## bytes in the range, or NULL if none do.

proc has_column*(this: GeomVertexArrayFormat, name: InternalName): bool {.importcpp: "#->has_column(#)".} ## \
## Returns true if the array has the named column, false otherwise.

proc is_data_subset_of*(this: GeomVertexArrayFormat, other: GeomVertexArrayFormat): bool {.importcpp: "#->is_data_subset_of(#)".} ## \
## Returns true if all of the fields in this array format are also present and
## equivalent in the other array format, and in the same byte positions, and
## the stride is the same.  That is, true if this format can share the same
## data pointer as the other format (with possibly some unused gaps).

proc count_unused_space*(this: GeomVertexArrayFormat): int {.importcpp: "#->count_unused_space()".} ## \
## Returns the number of bytes per row that are not assigned to any column.

proc output*(this: GeomVertexArrayFormat, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: GeomVertexArrayFormat, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: GeomVertexArrayFormat, `out`: ostream) {.importcpp: "#->write(#)".}

proc write_with_data*(this: GeomVertexArrayFormat, `out`: ostream, indent_level: int, array_data: GeomVertexArrayData) {.importcpp: "#->write_with_data(#, #, #)".}

proc get_format_string*(this: GeomVertexArrayFormat, pad: bool): string {.importcpp: "nimStringFromStdString(#->get_format_string(#))", header: stringConversionCode.} ## \
## Returns a string with format codes representing the exact memory layout of
## the columns in memory, as understood by Python's struct module.  If pad is
## true, extra padding bytes are added to the end as 'x' characters as needed.

proc get_format_string*(this: GeomVertexArrayFormat): string {.importcpp: "nimStringFromStdString(#->get_format_string())", header: stringConversionCode.} ## \
## Returns a string with format codes representing the exact memory layout of
## the columns in memory, as understood by Python's struct module.  If pad is
## true, extra padding bytes are added to the end as 'x' characters as needed.

proc get_class_type*(_: typedesc[GeomVertexArrayFormat]): TypeHandle {.importcpp: "GeomVertexArrayFormat::get_class_type()", header: "geomVertexArrayFormat.h".}

converter upcast_to_TypedWritableReferenceCount*(this: GeomVertexFormat): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcast_to_GeomEnums*(this: GeomVertexFormat): GeomEnums {.importcpp: "((GeomEnums *)(#.p()))".}

proc newGeomVertexFormat*(): GeomVertexFormat {.importcpp: "new GeomVertexFormat()".}

proc newGeomVertexFormat*(array_format: GeomVertexArrayFormat): GeomVertexFormat {.importcpp: "new GeomVertexFormat(#)".}

proc newGeomVertexFormat*(copy: GeomVertexFormat): GeomVertexFormat {.importcpp: "new GeomVertexFormat(#)".}

proc unref*(this: GeomVertexFormat): bool {.importcpp: "#->unref()".} ## \
## This method overrides ReferenceCount::unref() to unregister the object when
## its reference count goes to zero.

proc is_registered*(this: GeomVertexFormat): bool {.importcpp: "#->is_registered()".} ## \
## Returns true if this format has been registered, false if it has not.  It
## may not be used for a Geom until it has been registered, but once
## registered, it may no longer be modified.

proc register_format*(_: typedesc[GeomVertexFormat], format: GeomVertexArrayFormat): GeomVertexFormat {.importcpp: "GeomVertexFormat::register_format(#)", header: "geomVertexFormat.h".} ## \
## This flavor of register_format() implicitly creates a one-array vertex
## format from the array definition.

proc register_format*(_: typedesc[GeomVertexFormat], format: GeomVertexFormat): GeomVertexFormat {.importcpp: "GeomVertexFormat::register_format(#)", header: "geomVertexFormat.h".} ## \
## Adds the indicated format to the registry, if there is not an equivalent
## format already there; in either case, returns the pointer to the equivalent
## format now in the registry.
##
## This must be called before a format may be used in a Geom.  After this
## call, you should discard the original pointer you passed in (which may or
## may not now be invalid) and let its reference count decrement normally; you
## should use only the returned value from this point on.

proc get_animation*(this: GeomVertexFormat): GeomVertexAnimationSpec {.importcpp: "#->get_animation()".} ## \
## Returns the GeomVertexAnimationSpec that indicates how this format's
## vertices are set up for animation.

proc set_animation*(this: GeomVertexFormat, animation: GeomVertexAnimationSpec) {.importcpp: "#->set_animation(#)".} ## \
## Resets the GeomVertexAnimationSpec that indicates how this format's
## vertices are set up for animation.  You should also, of course, change the
## columns in the tables accordingly.
##
## This may not be called once the format has been registered.

proc get_post_animated_format*(this: GeomVertexFormat): GeomVertexFormat {.importcpp: "#->get_post_animated_format()".} ## \
## Returns a suitable vertex format for sending the animated vertices to the
## graphics backend.  This is the same format as the source format, with the
## CPU-animation data elements removed.
##
## This may only be called after the format has been registered.  The return
## value will have been already registered.

proc get_union_format*(this: GeomVertexFormat, other: GeomVertexFormat): GeomVertexFormat {.importcpp: "#->get_union_format(#)".} ## \
## Returns a new GeomVertexFormat that includes all of the columns defined in
## either this GeomVertexFormat or the other one.  If any column is defined in
## both formats with different sizes (for instance, texcoord2 vs.  texcoord3),
## the new format will include the larger of the two definitions.
##
## This may only be called after both source formats have been registered.
## The return value will also have been already registered.

proc get_num_arrays*(this: GeomVertexFormat): clonglong {.importcpp: "#->get_num_arrays()".} ## \
## Returns the number of individual arrays required by the format.  If the
## array data is completely interleaved, this will be 1; if it is completely
## parallel, this will be the same as the number of data types.

proc get_array*(this: GeomVertexFormat, array: clonglong): GeomVertexArrayFormat {.importcpp: "#->get_array(#)".} ## \
## Returns the description of the nth array used by the format.

proc modify_array*(this: GeomVertexFormat, array: clonglong): GeomVertexArrayFormat {.importcpp: "#->modify_array(#)".} ## \
## Returns a modifiable pointer to the indicated array.  This means
## duplicating it if it is shared or registered.
##
## This may not be called once the format has been registered.

proc set_array*(this: GeomVertexFormat, array: clonglong, format: GeomVertexArrayFormat) {.importcpp: "#->set_array(#, #)".} ## \
## Replaces the definition of the indicated array.
##
## This may not be called once the format has been registered.

proc remove_array*(this: GeomVertexFormat, array: clonglong) {.importcpp: "#->remove_array(#)".} ## \
## Removes the nth array from the format.
##
## This may not be called once the format has been registered.

proc add_array*(this: GeomVertexFormat, array_format: GeomVertexArrayFormat): clonglong {.importcpp: "#->add_array(#)".} ## \
## Adds the indicated array definition to the list of arrays included within
## this vertex format definition.  The return value is the index number of the
## new array.
##
## This may not be called once the format has been registered.

proc insert_array*(this: GeomVertexFormat, array: clonglong, array_format: GeomVertexArrayFormat) {.importcpp: "#->insert_array(#, #)".} ## \
## Adds the indicated array definition to the list of arrays at the indicated
## position.  This works just like add_array(), except that you can specify
## which array index the new array should have.
##
## This may not be called once the format has been registered.

proc clear_arrays*(this: GeomVertexFormat) {.importcpp: "#->clear_arrays()".} ## \
## Removes all of the array definitions from the format and starts over.
##
## This may not be called once the format has been registered.

proc remove_empty_arrays*(this: GeomVertexFormat) {.importcpp: "#->remove_empty_arrays()".} ## \
## Removes the arrays that define no columns.
##
## This may not be called once the format has been registered.

proc get_num_columns*(this: GeomVertexFormat): clonglong {.importcpp: "#->get_num_columns()".} ## \
## Returns the total number of different columns in the specification, across
## all arrays.

proc get_array_with*(this: GeomVertexFormat, name: InternalName): int {.importcpp: "#->get_array_with(#)".} ## \
## Returns the index number of the array with the indicated column, or -1 if
## no arrays contained that name.
##
## The return value can be passed to get_array_format() to get the format of
## the array.  It may also be passed to GeomVertexData::get_array_data() or
## get_data() or set_data() to manipulate the actual array data.
##
## This may only be called after the format has been registered.

proc get_array_with*(this: GeomVertexFormat, i: clonglong): int {.importcpp: "#->get_array_with(#)".} ## \
## Returns the index number of the array with the ith column.
##
## The return value can be passed to get_array_format() to get the format of
## the array.  It may also be passed to GeomVertexData::get_array_data() or
## get_data() or set_data() to manipulate the actual array data.

proc get_column*(this: GeomVertexFormat, name: InternalName): GeomVertexColumn {.importcpp: "#->get_column(#)".} ## \
## Returns the specification with the indicated name, or NULL if the name is
## not used.  Use get_array_with() to determine which array this column is
## associated with.

proc get_column*(this: GeomVertexFormat, i: clonglong): GeomVertexColumn {.importcpp: "#->get_column(#)".} ## \
## Returns the ith column of the specification, across all arrays.

proc has_column*(this: GeomVertexFormat, name: InternalName): bool {.importcpp: "#->has_column(#)".} ## \
## Returns true if the format has the named column, false otherwise.

proc get_column_name*(this: GeomVertexFormat, i: clonglong): InternalName {.importcpp: "#->get_column_name(#)".} ## \
## Returns the name of the ith column, across all arrays.

proc remove_column*(this: GeomVertexFormat, name: InternalName, keep_empty_array: bool) {.importcpp: "#->remove_column(#, #)".} ## \
## Removes the named column from the format, from whichever array it exists
## in.  If there are other columns remaining in the array, the array is left
## with a gap where the column used to be; if this was the only column in the
## array, the array is removed (unless keep_empty_array is true).
##
## This may not be called once the format has been registered.

proc remove_column*(this: GeomVertexFormat, name: InternalName) {.importcpp: "#->remove_column(#)".} ## \
## Removes the named column from the format, from whichever array it exists
## in.  If there are other columns remaining in the array, the array is left
## with a gap where the column used to be; if this was the only column in the
## array, the array is removed (unless keep_empty_array is true).
##
## This may not be called once the format has been registered.

proc pack_columns*(this: GeomVertexFormat) {.importcpp: "#->pack_columns()".} ## \
## Removes wasted space between columns.

proc align_columns_for_animation*(this: GeomVertexFormat) {.importcpp: "#->align_columns_for_animation()".} ## \
## Reprocesses the columns in the format to align the C_point and C_vector
## columns to 16-byte boundaries to allow for the more efficient SSE2
## operations (assuming SSE2 is enabled in the build).
##
## Also see maybe_align_columns_for_animation().

proc maybe_align_columns_for_animation*(this: GeomVertexFormat) {.importcpp: "#->maybe_align_columns_for_animation()".} ## \
## Calls align_columns_for_animation() if this format's AnimationSpec
## indicates that it contains animated vertices, and if vertex-animation-
## align-16 is true.

proc get_num_points*(this: GeomVertexFormat): clonglong {.importcpp: "#->get_num_points()".} ## \
## Returns the number of columns within the format that represent points in
## space.
##
## This may only be called after the format has been registered.

proc get_point*(this: GeomVertexFormat, n: clonglong): InternalName {.importcpp: "#->get_point(#)".} ## \
## Returns the name of the nth point column.  This represents a point in
## space, which should be transformed by any spatial transform matrix.
##
## This may only be called after the format has been registered.

proc get_num_vectors*(this: GeomVertexFormat): clonglong {.importcpp: "#->get_num_vectors()".} ## \
## Returns the number of columns within the format that represent directional
## vectors.
##
## This may only be called after the format has been registered.

proc get_vector*(this: GeomVertexFormat, n: clonglong): InternalName {.importcpp: "#->get_vector(#)".} ## \
## Returns the name of the nth vector column.  This represents a directional
## vector, which should be transformed by any spatial transform matrix as a
## vector.
##
## This may only be called after the format has been registered.

proc get_num_texcoords*(this: GeomVertexFormat): clonglong {.importcpp: "#->get_num_texcoords()".} ## \
## Returns the number of columns within the format that represent texture
## coordinates.
##
## This may only be called after the format has been registered.

proc get_texcoord*(this: GeomVertexFormat, n: clonglong): InternalName {.importcpp: "#->get_texcoord(#)".} ## \
## Returns the name of the nth texcoord column.  This represents a texture
## coordinate.
##
## This may only be called after the format has been registered.

proc get_num_morphs*(this: GeomVertexFormat): clonglong {.importcpp: "#->get_num_morphs()".} ## \
## Returns the number of columns within the format that represent morph
## deltas.
##
## This may only be called after the format has been registered.

proc get_morph_slider*(this: GeomVertexFormat, n: clonglong): InternalName {.importcpp: "#->get_morph_slider(#)".} ## \
## Returns the slider name associated with the nth morph column.  This is the
## name of the slider that will control the morph, and should be defined
## within the SliderTable associated with the GeomVertexData.
##
## This may only be called after the format has been registered.

proc get_morph_base*(this: GeomVertexFormat, n: clonglong): InternalName {.importcpp: "#->get_morph_base(#)".} ## \
## Returns the name of the base column that the nth morph modifies.  This
## column will also be defined within the format, and can be retrieved via
## get_array_with() and/or get_column().
##
## This may only be called after the format has been registered.

proc get_morph_delta*(this: GeomVertexFormat, n: clonglong): InternalName {.importcpp: "#->get_morph_delta(#)".} ## \
## Returns the name of the column that defines the nth morph.  This contains
## the delta offsets that are to be applied to the column defined by
## get_morph_base().  This column will be defined within the format, and can
## be retrieved via get_array_with() and/or get_column().
##
## This may only be called after the format has been registered.

proc output*(this: GeomVertexFormat, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: GeomVertexFormat, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: GeomVertexFormat, `out`: ostream) {.importcpp: "#->write(#)".}

proc write_with_data*(this: GeomVertexFormat, `out`: ostream, indent_level: int, data: GeomVertexData) {.importcpp: "#->write_with_data(#, #, #)".}

proc get_empty*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "GeomVertexFormat::get_empty()", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format containing no arrays at all, useful for
## pull-style vertex rendering.

proc get_v3*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "GeomVertexFormat::get_v3()", header: "geomVertexFormat.h".} ## \
## Some standard vertex formats.  No particular requirement to use one of
## these, but the DirectX renderers can use these formats directly, whereas
## any other format will have to be converted first.

proc get_v3n3*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "GeomVertexFormat::get_v3n3()", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format with a 3-component normal and a
## 3-component vertex position.

proc get_v3t2*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "GeomVertexFormat::get_v3t2()", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format with a 2-component texture coordinate pair
## and a 3-component vertex position.

proc get_v3n3t2*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "GeomVertexFormat::get_v3n3t2()", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format with a 2-component texture coordinate
## pair, a 3-component normal, and a 3-component vertex position.

proc get_v3cp*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "GeomVertexFormat::get_v3cp()", header: "geomVertexFormat.h".} ## \
## These formats, with the DirectX-style packed color, may not be supported
## directly by OpenGL.  If you use them and the driver does not support
## them, the GLGraphicsStateGuardian will automatically convert to native
## OpenGL form (with a small runtime overhead).

proc get_v3cpt2*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "GeomVertexFormat::get_v3cpt2()", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format with a 2-component texture coordinate
## pair, a packed color, and a 3-component vertex position.

proc get_v3n3cp*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "GeomVertexFormat::get_v3n3cp()", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format with a packed color, a 3-component normal,
## and a 3-component vertex position.

proc get_v3n3cpt2*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "GeomVertexFormat::get_v3n3cpt2()", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format with a 2-component texture coordinate
## pair, a packed color, a 3-component normal, and a 3-component vertex
## position.

proc get_v3c4*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "GeomVertexFormat::get_v3c4()", header: "geomVertexFormat.h".} ## \
## These formats, with an OpenGL-style four-byte color, are not supported
## directly by DirectX.  If you use them, the DXGraphicsStateGuardian will
## automatically convert to DirectX form (with a larger runtime overhead,
## since DirectX8, and old DirectX9 drivers, require everything to be
## interleaved together).

proc get_v3c4t2*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "GeomVertexFormat::get_v3c4t2()", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format with a 2-component texture coordinate
## pair, a 4-component color, and a 3-component vertex position.

proc get_v3n3c4*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "GeomVertexFormat::get_v3n3c4()", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format with a 4-component color, a 3-component
## normal, and a 3-component vertex position.

proc get_v3n3c4t2*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "GeomVertexFormat::get_v3n3c4t2()", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format with a 2-component texture coordinate
## pair, a 4-component color, a 3-component normal, and a 3-component vertex
## position.

proc get_class_type*(_: typedesc[GeomVertexFormat]): TypeHandle {.importcpp: "GeomVertexFormat::get_class_type()", header: "geomVertexFormat.h".}

converter upcast_to_Namable*(this: SimpleLru): Namable {.importcpp: "#.upcast_to_Namable()".}

proc initSimpleLru*(name: string, max_size: clonglong): SimpleLru {.importcpp: "SimpleLru(nimStringToStdString(#), #)", header: stringConversionCode.}

proc get_total_size*(this: SimpleLru): clonglong {.importcpp: "#.get_total_size()".} ## \
## Returns the total size of all objects currently active on the LRU.

proc get_max_size*(this: SimpleLru): clonglong {.importcpp: "#.get_max_size()".} ## \
## Returns the max size of all objects that are allowed to be active on the
## LRU.

proc set_max_size*(this: SimpleLru, max_size: clonglong) {.importcpp: "#.set_max_size(#)".} ## \
## Changes the max size of all objects that are allowed to be active on the
## LRU.
##
## If the size is (size_t)-1, there is no limit.

proc count_active_size*(this: SimpleLru): clonglong {.importcpp: "#.count_active_size()".} ## \
## Returns the total size of the pages that were enqueued since the last call
## to begin_epoch().

proc consider_evict*(this: SimpleLru) {.importcpp: "#.consider_evict()".} ## \
## Evicts a sequence of objects if the queue is full.

proc evict_to*(this: SimpleLru, target_size: clonglong) {.importcpp: "#.evict_to(#)".} ## \
## Evicts a sequence of objects until the queue fits within the indicated
## target size, regardless of its normal max size.

proc begin_epoch*(this: SimpleLru) {.importcpp: "#.begin_epoch()".} ## \
## Marks the end of the previous epoch and the beginning of the next one.
## This will evict any objects that are pending eviction, and also update any
## internal bookkeeping.

proc validate*(this: SimpleLru): bool {.importcpp: "#.validate()".} ## \
## Checks that the LRU is internally self-consistent.  Returns true if
## successful, false if there is some problem.

proc output*(this: SimpleLru, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: SimpleLru, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc initSimpleLruPage*(copy: SimpleLruPage): SimpleLruPage {.importcpp: "SimpleLruPage(#)".}

proc initSimpleLruPage*(lru_size: clonglong): SimpleLruPage {.importcpp: "SimpleLruPage(#)".}

proc get_lru*(this: SimpleLruPage): SimpleLru {.importcpp: "#.get_lru()".} ## \
## Returns the LRU that manages this page, or NULL if it is not currently
## managed by any LRU.

proc enqueue_lru*(this: SimpleLruPage, lru: SimpleLru) {.importcpp: "#.enqueue_lru(#)".} ## \
## Adds the page to the LRU for the first time, or marks it recently-accessed
## if it has already been added.
##
## If lru is NULL, it means to remove this page from its LRU.

proc dequeue_lru*(this: SimpleLruPage) {.importcpp: "#.dequeue_lru()".} ## \
## Removes the page from its SimpleLru.

proc mark_used_lru*(this: SimpleLruPage, lru: SimpleLru) {.importcpp: "#.mark_used_lru(#)".} ## \
## To be called when the page is used; this will move it to the tail of the
## specified SimpleLru queue.

proc get_lru_size*(this: SimpleLruPage): clonglong {.importcpp: "#.get_lru_size()".} ## \
## Returns the size of this page as reported to the LRU, presumably in bytes.

proc set_lru_size*(this: SimpleLruPage, lru_size: clonglong) {.importcpp: "#.set_lru_size(#)".} ## \
## Specifies the size of this page, presumably in bytes, although any unit is
## possible.

proc evict_lru*(this: SimpleLruPage) {.importcpp: "#.evict_lru()".} ## \
## Evicts the page from the LRU.  Called internally when the LRU determines
## that it is full.  May also be called externally when necessary to
## explicitly evict the page.
##
## It is legal for this method to either evict the page as requested, do
## nothing (in which case the eviction will be requested again at the next
## epoch), or requeue itself on the tail of the queue (in which case the
## eviction will be requested again much later).

proc output*(this: SimpleLruPage, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: SimpleLruPage, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc initSimpleAllocator*(max_size: clonglong, lock: Mutex): SimpleAllocator {.importcpp: "SimpleAllocator(#, #)".}

proc alloc*(this: SimpleAllocator, size: clonglong, alignment: clonglong): SimpleAllocatorBlock {.importcpp: "#.alloc(#, #)".} ## \
## Allocates a new block.  Returns NULL if a block of the requested size
## cannot be allocated.
##
## To free the allocated block, call block->free(), or simply delete the block
## pointer.

proc alloc*(this: SimpleAllocator, size: clonglong): SimpleAllocatorBlock {.importcpp: "#.alloc(#)".} ## \
## Allocates a new block.  Returns NULL if a block of the requested size
## cannot be allocated.
##
## To free the allocated block, call block->free(), or simply delete the block
## pointer.

proc is_empty*(this: SimpleAllocator): bool {.importcpp: "#.is_empty()".} ## \
## Returns true if there are no blocks allocated on this page, or false if
## there is at least one.

proc get_total_size*(this: SimpleAllocator): clonglong {.importcpp: "#.get_total_size()".} ## \
## Returns the total size of allocated objects.

proc get_max_size*(this: SimpleAllocator): clonglong {.importcpp: "#.get_max_size()".} ## \
## Returns the available space for allocated objects.

proc set_max_size*(this: SimpleAllocator, max_size: clonglong) {.importcpp: "#.set_max_size(#)".} ## \
## Changes the available space for allocated objects.  This will not affect
## any already-allocated objects, but will have an effect on future calls to
## alloc().

proc get_contiguous*(this: SimpleAllocator): clonglong {.importcpp: "#.get_contiguous()".} ## \
## Returns an upper-bound estimate of the size of the largest contiguous block
## that may be allocated.  It is guaranteed that an attempt to allocate a
## block larger than this will fail, though it is not guaranteed that an
## attempt to allocate a block this size or smaller will succeed.

proc get_first_block*(this: SimpleAllocator): SimpleAllocatorBlock {.importcpp: "#.get_first_block()".} ## \
## Returns a pointer to the first allocated block, or NULL if there are no
## allocated blocks.

proc output*(this: SimpleAllocator, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: SimpleAllocator, `out`: ostream) {.importcpp: "#.write(#)".}

proc free*(this: SimpleAllocatorBlock) {.importcpp: "#.free()".} ## \
## Releases the allocated space.

proc get_allocator*(this: SimpleAllocatorBlock): SimpleAllocator {.importcpp: "#.get_allocator()".} ## \
## Returns the SimpleAllocator object that owns this block.  Returns NULL if
## the block has been freed.

proc get_start*(this: SimpleAllocatorBlock): clonglong {.importcpp: "#.get_start()".} ## \
## Returns the starting point of this block.  It is an error to call this if
## the block has been freed.

proc get_size*(this: SimpleAllocatorBlock): clonglong {.importcpp: "#.get_size()".} ## \
## Returns the size of this block.  It is an error to call this if the block
## has been freed.

proc is_free*(this: SimpleAllocatorBlock): bool {.importcpp: "#.is_free()".} ## \
## Returns true if the block has been freed, false if it is still valid.

proc get_max_size*(this: SimpleAllocatorBlock): clonglong {.importcpp: "#.get_max_size()".} ## \
## Returns the maximum size this block can be reallocated to, as limited by
## the following block.

proc realloc*(this: SimpleAllocatorBlock, size: clonglong): bool {.importcpp: "#.realloc(#)".} ## \
## Changes the size of this block to the specified size.  Returns true if the
## change is accepted, false if there was not enough room.

proc get_next_block*(this: SimpleAllocatorBlock): SimpleAllocatorBlock {.importcpp: "#.get_next_block()".} ## \
## Returns a pointer to the next allocated block in the chain, or NULL if
## there are no more allocated blocks.

proc output*(this: SimpleAllocatorBlock, `out`: ostream) {.importcpp: "#.output(#)".}

proc is_valid*(this: VertexDataSaveFile): bool {.importcpp: "#.is_valid()".} ## \
## Returns true if the save file was successfully created and is ready for
## use, false if there was an error.

proc get_total_file_size*(this: VertexDataSaveFile): clonglong {.importcpp: "#.get_total_file_size()".} ## \
## Returns the amount of space consumed by the save file, including unused
## portions.

proc get_used_file_size*(this: VertexDataSaveFile): clonglong {.importcpp: "#.get_used_file_size()".} ## \
## Returns the amount of space within the save file that is currently in use.

converter upcast_to_SimpleAllocator*(this: VertexDataPage): SimpleAllocator {.importcpp: "#.upcast_to_SimpleAllocator()".}

converter upcast_to_SimpleLruPage*(this: VertexDataPage): SimpleLruPage {.importcpp: "#.upcast_to_SimpleLruPage()".}

proc request_resident*(this: VertexDataPage) {.importcpp: "#.request_resident()".} ## \
## Ensures that the page will become resident soon.  Future calls to
## get_page_data() will eventually return non-NULL.

proc alloc*(this: VertexDataPage, size: clonglong): VertexDataBlock {.importcpp: "#.alloc(#)".} ## \
## Allocates a new block.  Returns NULL if a block of the requested size
## cannot be allocated.
##
## To free the allocated block, call block->free(), or simply delete the block
## pointer.

proc get_first_block*(this: VertexDataPage): VertexDataBlock {.importcpp: "#.get_first_block()".} ## \
## Returns a pointer to the first allocated block, or NULL if there are no
## allocated blocks.

proc get_book*(this: VertexDataPage): VertexDataBook {.importcpp: "#.get_book()".} ## \
## Returns a pointer to the book that owns this page.

proc get_pending_lru*(_: typedesc[VertexDataPage]): SimpleLru {.importcpp: "VertexDataPage::get_pending_lru()", header: "vertexDataPage.h".} ## \
## Returns a pointer to the global LRU object that manages the
## VertexDataPage's that are pending processing by the thread.

proc get_save_file*(_: typedesc[VertexDataPage]): VertexDataSaveFile {.importcpp: "VertexDataPage::get_save_file()", header: "vertexDataPage.h".} ## \
## Returns the global VertexDataSaveFile that will be used to save vertex data
## buffers to disk when necessary.

proc save_to_disk*(this: VertexDataPage): bool {.importcpp: "#.save_to_disk()".} ## \
## Writes the page to disk, but does not evict it from memory or affect its
## LRU status.  If it gets evicted later without having been modified, it will
## not need to write itself to disk again.

proc get_num_threads*(_: typedesc[VertexDataPage]): int {.importcpp: "VertexDataPage::get_num_threads()", header: "vertexDataPage.h".} ## \
## Returns the number of threads that have been spawned to service vertex
## paging requests, or 0 if no threads have been spawned (which may mean
## either that all paging requests will be handled by the main thread, or
## simply that no paging requests have yet been issued).

proc get_num_pending_reads*(_: typedesc[VertexDataPage]): int {.importcpp: "VertexDataPage::get_num_pending_reads()", header: "vertexDataPage.h".} ## \
## Returns the number of read requests that are waiting to be serviced by a
## thread.

proc get_num_pending_writes*(_: typedesc[VertexDataPage]): int {.importcpp: "VertexDataPage::get_num_pending_writes()", header: "vertexDataPage.h".} ## \
## Returns the number of write requests that are waiting to be serviced by a
## thread.

proc stop_threads*(_: typedesc[VertexDataPage]) {.importcpp: "VertexDataPage::stop_threads()", header: "vertexDataPage.h".} ## \
## Call this to stop the paging threads, if they were started.  This may block
## until all of the pending tasks have been completed.

proc flush_threads*(_: typedesc[VertexDataPage]) {.importcpp: "VertexDataPage::flush_threads()", header: "vertexDataPage.h".} ## \
## Waits for all of the pending thread tasks to finish before returning.

proc output*(this: VertexDataPage, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: VertexDataPage, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc get_class_type*(_: typedesc[VertexDataPage]): TypeHandle {.importcpp: "VertexDataPage::get_class_type()", header: "vertexDataPage.h".}

proc initVertexDataBook*(block_size: clonglong): VertexDataBook {.importcpp: "VertexDataBook(#)".}

proc alloc*(this: VertexDataBook, size: clonglong): VertexDataBlock {.importcpp: "#.alloc(#)".} ## \
## Allocates and returns a new VertexDataBuffer of the requested size.

proc get_num_pages*(this: VertexDataBook): clonglong {.importcpp: "#.get_num_pages()".} ## \
## Returns the number of pages created for the book.

proc count_total_page_size*(this: VertexDataBook): clonglong {.importcpp: "#.count_total_page_size()".} ## \
## Returns the total size of all bytes owned by all pages owned by this book.

proc count_allocated_size*(this: VertexDataBook): clonglong {.importcpp: "#.count_allocated_size()".} ## \
## Returns the total size of all bytes allocated within pages owned by this
## book.

proc save_to_disk*(this: VertexDataBook) {.importcpp: "#.save_to_disk()".} ## \
## Writes all pages to disk immediately, just in case they get evicted later.
## It makes sense to make this call just before taking down a loading screen,
## to minimize chugs from saving pages inadvertently later.

converter upcast_to_SimpleAllocatorBlock*(this: VertexDataBlock): SimpleAllocatorBlock {.importcpp: "((SimpleAllocatorBlock *)(#.p()))".}

converter upcast_to_ReferenceCount*(this: VertexDataBlock): ReferenceCount {.importcpp: "(PT(ReferenceCount)(#))".}

proc get_page*(this: VertexDataBlock): VertexDataPage {.importcpp: "#->get_page()".} ## \
## Returns the page from which this buffer was allocated.

proc get_next_block*(this: VertexDataBlock): VertexDataBlock {.importcpp: "#->get_next_block()".} ## \
## Returns a pointer to the next allocated block in the chain, or NULL if
## there are no more allocated blocks.

converter upcast_to_CopyOnWriteObject*(this: GeomVertexArrayData): CopyOnWriteObject {.importcpp: "(PT(CopyOnWriteObject)(#))".}

converter upcast_to_SimpleLruPage*(this: GeomVertexArrayData): SimpleLruPage {.importcpp: "((SimpleLruPage *)(#.p()))".}

converter upcast_to_GeomEnums*(this: GeomVertexArrayData): GeomEnums {.importcpp: "((GeomEnums *)(#.p()))".}

proc newGeomVertexArrayData*(copy: GeomVertexArrayData): GeomVertexArrayData {.importcpp: "new GeomVertexArrayData(#)".}

proc compare_to*(this: GeomVertexArrayData, other: GeomVertexArrayData): int {.importcpp: "#->compare_to(#)".} ## \
## Returns 0 if the two arrays are equivalent, even if they are not the same
## pointer.

proc get_array_format*(this: GeomVertexArrayData): GeomVertexArrayFormat {.importcpp: "#->get_array_format()".} ## \
## Returns the format object that describes this array.

proc has_column*(this: GeomVertexArrayData, name: InternalName): bool {.importcpp: "#->has_column(#)".} ## \
## Returns true if the array has the named column, false otherwise.  This is
## really just a shortcut for asking the same thing from the format.

proc get_num_rows*(this: GeomVertexArrayData): int {.importcpp: "#->get_num_rows()".} ## \
## Returns the number of rows stored in the array, based on the number of
## bytes and the stride.  This should be the same for all arrays within a
## given GeomVertexData object.

proc set_num_rows*(this: GeomVertexArrayData, n: int): bool {.importcpp: "#->set_num_rows(#)".} ## \
## Sets the length of the array to n rows.
##
## Normally, you would not call this directly, since all of the arrays in a
## particular GeomVertexData must have the same number of rows; instead, call
## GeomVertexData::set_num_rows().
##
## The return value is true if the number of rows was changed, false if the
## object already contained n rows (or if there was some error).
##
## The new vertex data is initialized to 0, including the "color" column (but
## see GeomVertexData::set_num_rows()).
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc unclean_set_num_rows*(this: GeomVertexArrayData, n: int): bool {.importcpp: "#->unclean_set_num_rows(#)".} ## \
## This method behaves like set_num_rows(), except the new data is not
## initialized.  Furthermore, after this call, *any* of the data in the
## GeomVertexArrayData may be uninitialized, including the earlier rows.
##
## Normally, you would not call this directly, since all of the arrays in a
## particular GeomVertexData must have the same number of rows; instead, call
## GeomVertexData::unclean_set_num_rows().

proc reserve_num_rows*(this: GeomVertexArrayData, n: int): bool {.importcpp: "#->reserve_num_rows(#)".} ## \
## This ensures that enough memory space for n rows is allocated, so that you
## may increase the number of rows to n without causing a new memory
## allocation.  This is a performance optimization only; it is especially
## useful when you know ahead of time that you will be adding n rows to the
## data.

proc clear_rows*(this: GeomVertexArrayData) {.importcpp: "#->clear_rows()".} ## \
## Removes all of the rows in the array.  Functionally equivalent to
## set_num_rows(0).

proc get_data_size_bytes*(this: GeomVertexArrayData): clonglong {.importcpp: "#->get_data_size_bytes()".} ## \
## Returns the number of bytes stored in the array.

proc get_modified*(this: GeomVertexArrayData): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the array vertex data is modified.

proc output*(this: GeomVertexArrayData, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: GeomVertexArrayData, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: GeomVertexArrayData, `out`: ostream) {.importcpp: "#->write(#)".}

proc request_resident*(this: GeomVertexArrayData, current_thread: Thread): bool {.importcpp: "#->request_resident(#)".} ## \
## Returns true if the vertex data is currently resident in memory.  If this
## returns true, the next call to get_handle()->get_read_pointer() will
## probably not block.  If this returns false, the vertex data will be brought
## back into memory shortly; try again later.

proc request_resident*(this: GeomVertexArrayData): bool {.importcpp: "#->request_resident()".} ## \
## Returns true if the vertex data is currently resident in memory.  If this
## returns true, the next call to get_handle()->get_read_pointer() will
## probably not block.  If this returns false, the vertex data will be brought
## back into memory shortly; try again later.

proc get_handle*(this: GeomVertexArrayData, current_thread: Thread): GeomVertexArrayDataHandle {.importcpp: "#->get_handle(#)".} ## \
## Returns an object that can be used to read the actual data bytes stored in
## the array.  Calling this method locks the data, and will block any other
## threads attempting to read or write the data, until the returned object
## destructs.

proc get_handle*(this: GeomVertexArrayData): GeomVertexArrayDataHandle {.importcpp: "#->get_handle()".} ## \
## Returns an object that can be used to read the actual data bytes stored in
## the array.  Calling this method locks the data, and will block any other
## threads attempting to read or write the data, until the returned object
## destructs.

proc modify_handle*(this: GeomVertexArrayData, current_thread: Thread): GeomVertexArrayDataHandle {.importcpp: "#->modify_handle(#)".} ## \
## Returns an object that can be used to read or write the actual data bytes
## stored in the array.  Calling this method locks the data, and will block
## any other threads attempting to read or write the data, until the returned
## object destructs.

proc modify_handle*(this: GeomVertexArrayData): GeomVertexArrayDataHandle {.importcpp: "#->modify_handle()".} ## \
## Returns an object that can be used to read or write the actual data bytes
## stored in the array.  Calling this method locks the data, and will block
## any other threads attempting to read or write the data, until the returned
## object destructs.

proc prepare*(this: GeomVertexArrayData, prepared_objects: PreparedGraphicsObjects) {.importcpp: "#->prepare(#)".} ## \
## Indicates that the data should be enqueued to be prepared in the indicated
## prepared_objects at the beginning of the next frame.  This will ensure the
## data is already loaded into the GSG if it is expected to be rendered soon.
##
## Use this function instead of prepare_now() to preload datas from a user
## interface standpoint.

proc is_prepared*(this: GeomVertexArrayData, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->is_prepared(#)".} ## \
## Returns true if the data has already been prepared or enqueued for
## preparation on the indicated GSG, false otherwise.

proc prepare_now*(this: GeomVertexArrayData, prepared_objects: PreparedGraphicsObjects, gsg: GraphicsStateGuardianBase): VertexBufferContext {.importcpp: "#->prepare_now(#, #)".} ## \
## Creates a context for the data on the particular GSG, if it does not
## already exist.  Returns the new (or old) VertexBufferContext.  This assumes
## that the GraphicsStateGuardian is the currently active rendering context
## and that it is ready to accept new datas.  If this is not necessarily the
## case, you should use prepare() instead.
##
## Normally, this is not called directly except by the GraphicsStateGuardian;
## a data does not need to be explicitly prepared by the user before it may be
## rendered.

proc release*(this: GeomVertexArrayData, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->release(#)".} ## \
## Frees the data context only on the indicated object, if it exists there.
## Returns true if it was released, false if it had not been prepared.

proc release_all*(this: GeomVertexArrayData): int {.importcpp: "#->release_all()".} ## \
## Frees the context allocated on all objects for which the data has been
## declared.  Returns the number of contexts which have been freed.

proc get_independent_lru*(_: typedesc[GeomVertexArrayData]): SimpleLru {.importcpp: "GeomVertexArrayData::get_independent_lru()", header: "geomVertexArrayData.h".} ## \
## Returns a pointer to the global LRU object that manages the
## GeomVertexArrayData's that have not (yet) been paged out.

proc get_small_lru*(_: typedesc[GeomVertexArrayData]): SimpleLru {.importcpp: "GeomVertexArrayData::get_small_lru()", header: "geomVertexArrayData.h".} ## \
## Returns a pointer to the global LRU object that manages the
## GeomVertexArrayData's that are deemed too small to be paged out.

proc lru_epoch*(_: typedesc[GeomVertexArrayData]) {.importcpp: "GeomVertexArrayData::lru_epoch()", header: "geomVertexArrayData.h".} ## \
## Marks that an epoch has passed in each LRU.  Asks the LRU's to consider
## whether they should perform evictions.

proc get_book*(_: typedesc[GeomVertexArrayData]): VertexDataBook {.importcpp: "GeomVertexArrayData::get_book()", header: "geomVertexArrayData.h".} ## \
## Returns the global VertexDataBook that will be used to allocate vertex data
## buffers.

proc get_class_type*(_: typedesc[GeomVertexArrayData]): TypeHandle {.importcpp: "GeomVertexArrayData::get_class_type()", header: "geomVertexArrayData.h".}

converter upcast_to_ReferenceCount*(this: GeomVertexArrayDataHandle): ReferenceCount {.importcpp: "(PT(ReferenceCount)(#))".}

converter upcast_to_GeomEnums*(this: GeomVertexArrayDataHandle): GeomEnums {.importcpp: "((GeomEnums *)(#.p()))".}

proc get_object*(this: GeomVertexArrayDataHandle): GeomVertexArrayData {.importcpp: "#->get_object()".}

proc get_array_format*(this: GeomVertexArrayDataHandle): GeomVertexArrayFormat {.importcpp: "#->get_array_format()".}

proc get_num_rows*(this: GeomVertexArrayDataHandle): int {.importcpp: "#->get_num_rows()".}

proc set_num_rows*(this: GeomVertexArrayDataHandle, n: int): bool {.importcpp: "#->set_num_rows(#)".}

proc unclean_set_num_rows*(this: GeomVertexArrayDataHandle, n: int): bool {.importcpp: "#->unclean_set_num_rows(#)".}

proc reserve_num_rows*(this: GeomVertexArrayDataHandle, n: int): bool {.importcpp: "#->reserve_num_rows(#)".}

proc clear_rows*(this: GeomVertexArrayDataHandle) {.importcpp: "#->clear_rows()".}

proc get_data_size_bytes*(this: GeomVertexArrayDataHandle): clonglong {.importcpp: "#->get_data_size_bytes()".}

proc get_modified*(this: GeomVertexArrayDataHandle): UpdateSeq {.importcpp: "#->get_modified()".}

proc request_resident*(this: GeomVertexArrayDataHandle): bool {.importcpp: "#->request_resident()".} ## \
## Returns true if the vertex data is currently resident in memory.  If this
## returns true, the next call to get_handle()->get_read_pointer() will
## probably not block.  If this returns false, the vertex data will be brought
## back into memory shortly; try again later.

proc prepare_now*(this: GeomVertexArrayDataHandle, prepared_objects: PreparedGraphicsObjects, gsg: GraphicsStateGuardianBase): VertexBufferContext {.importcpp: "#->prepare_now(#, #)".} ## \
## Creates a context for the data on the particular GSG, if it does not
## already exist.  Returns the new (or old) VertexBufferContext.  This assumes
## that the GraphicsStateGuardian is the currently active rendering context
## and that it is ready to accept new datas.  If this is not necessarily the
## case, you should use prepare() instead.
##
## Normally, this is not called directly except by the GraphicsStateGuardian;
## a data does not need to be explicitly prepared by the user before it may be
## rendered.

proc copy_data_from*(this: GeomVertexArrayDataHandle, other: GeomVertexArrayDataHandle) {.importcpp: "#->copy_data_from(#)".} ## \
## Copies the entire data array from the other object.

proc copy_subdata_from*(this: GeomVertexArrayDataHandle, to_start: clonglong, to_size: clonglong, other: GeomVertexArrayDataHandle, from_start: clonglong, from_size: clonglong) {.importcpp: "#->copy_subdata_from(#, #, #, #, #)".} ## \
## Copies a portion of the data array from the other object into a portion of
## the data array of this object.  If to_size != from_size, the size of this
## data array is adjusted accordingly.

proc mark_used*(this: GeomVertexArrayDataHandle) {.importcpp: "#->mark_used()".} ## \
## Marks the array data recently-used.

proc get_class_type*(_: typedesc[GeomVertexArrayDataHandle]): TypeHandle {.importcpp: "GeomVertexArrayDataHandle::get_class_type()", header: "geomVertexArrayDataHandle.h".}

proc set_max_size*(this: GeomCacheManager, max_size: int) {.importcpp: "#.set_max_size(#)".} ## \
## Specifies the maximum number of entries in the cache for storing pre-
## processed data for rendering vertices.  This limit is flexible, and may be
## temporarily exceeded if many different Geoms are pre-processed during the
## space of a single frame.
##
## This is not a limit on the actual vertex data, which is what it is; it is
## also not a limit on the amount of memory used by the video driver or the
## system graphics interface, which Panda has no control over.

proc get_max_size*(this: GeomCacheManager): int {.importcpp: "#.get_max_size()".} ## \
## Returns the maximum number of entries in the cache for storing pre-
## processed data for rendering vertices.  See set_max_size().

proc get_total_size*(this: GeomCacheManager): int {.importcpp: "#.get_total_size()".} ## \
## Returns the number of entries currently in the cache.

proc flush*(this: GeomCacheManager) {.importcpp: "#.flush()".} ## \
## Immediately empties all elements in the cache.

proc get_global_ptr*(_: typedesc[GeomCacheManager]): GeomCacheManager {.importcpp: "GeomCacheManager::get_global_ptr()", header: "geomCacheManager.h".} ## \
## Returns the global cache manager pointer.

proc get_matrix*(this: VertexTransform, matrix: LMatrix4) {.importcpp: "#->get_matrix(#)".}

proc mult_matrix*(this: VertexTransform, result: LMatrix4, previous: LMatrix4) {.importcpp: "#->mult_matrix(#, #)".} ## \
## Premultiplies this transform's matrix with the indicated previous matrix,
## so that the result is the net composition of the given transform with this
## transform.  The result is stored in the parameter "result", which should
## not be the same matrix as previous.

proc accumulate_matrix*(this: VertexTransform, accum: LMatrix4, weight: float32) {.importcpp: "#->accumulate_matrix(#, #)".} ## \
## Adds the value of this transform's matrix, modified by the indicated
## weight, into the indicated accumulation matrix.  This is used to compute
## the result of several blended transforms.

proc get_modified*(this: VertexTransform, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number that's guaranteed to change at least every time
## the value reported by get_matrix() changes.

proc get_modified*(this: VertexTransform): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number that's guaranteed to change at least every time
## the value reported by get_matrix() changes.

proc output*(this: VertexTransform, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: VertexTransform, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc get_next_modified*(_: typedesc[VertexTransform], current_thread: Thread): UpdateSeq {.importcpp: "VertexTransform::get_next_modified(#)", header: "vertexTransform.h".} ## \
## Returns a monotonically increasing sequence.  Each time this is called, a
## new sequence number is returned, higher than the previous value.
##
## This is used to ensure that all VertexTransform::get_modified() calls
## return an increasing number in the same space, so that
## TransformBlend::get_modified() is easy to determine.  It is similar to
## Geom::get_modified(), but it is in a different space.

proc get_global_modified*(_: typedesc[VertexTransform], current_thread: Thread): UpdateSeq {.importcpp: "VertexTransform::get_global_modified(#)", header: "vertexTransform.h".} ## \
## Returns the currently highest VertexTransform::get_modified() value in the
## world.  This can be used as a quick way to determine if any
## VertexTransforms have changed value recently.

proc get_class_type*(_: typedesc[VertexTransform]): TypeHandle {.importcpp: "VertexTransform::get_class_type()", header: "vertexTransform.h".}

proc newTransformTable*(): TransformTable {.importcpp: "new TransformTable()".}

proc newTransformTable*(copy: TransformTable): TransformTable {.importcpp: "new TransformTable(#)".}

proc is_registered*(this: TransformTable): bool {.importcpp: "#->is_registered()".} ## \
## Returns true if this table has been registered.  Once it has been
## registered, the set of transforms in a TransformTable may not be further
## modified; but it must be registered before it can be assigned to a Geom.

proc register_table*(_: typedesc[TransformTable], table: TransformTable): TransformTable {.importcpp: "TransformTable::register_table(#)", header: "transformTable.h".} ## \
## Registers a TransformTable for use.  This is similar to
## GeomVertexFormat::register_format().  Once registered, a TransformTable may
## no longer be modified (although the individual VertexTransform objects may
## modify their reported transforms).
##
## This must be called before a table may be used in a Geom.  After this call,
## you should discard the original pointer you passed in (which may or may not
## now be invalid) and let its reference count decrement normally; you should
## use only the returned value from this point on.

proc get_num_transforms*(this: TransformTable): clonglong {.importcpp: "#->get_num_transforms()".} ## \
## Returns the number of transforms in the table.

proc get_transform*(this: TransformTable, n: clonglong): VertexTransform {.importcpp: "#->get_transform(#)".} ## \
## Returns the nth transform in the table.

proc get_modified*(this: TransformTable, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number that's guaranteed to change at least when any
## VertexTransforms in the table change.  (However, this is only true for a
## registered table.  An unregistered table may or may not reflect an update
## here when a VertexTransform changes.)

proc get_modified*(this: TransformTable): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number that's guaranteed to change at least when any
## VertexTransforms in the table change.  (However, this is only true for a
## registered table.  An unregistered table may or may not reflect an update
## here when a VertexTransform changes.)

proc set_transform*(this: TransformTable, n: clonglong, transform: VertexTransform) {.importcpp: "#->set_transform(#, #)".} ## \
## Replaces the nth transform.  Only valid for unregistered tables.

proc insert_transform*(this: TransformTable, n: clonglong, transform: VertexTransform) {.importcpp: "#->insert_transform(#, #)".} ## \
## Inserts a new transform to the table at the given index position.  If the
## index is beyond the end of the table, appends it to the end.  Only valid
## for unregistered tables.
##
## This does not automatically uniquify the pointer; if the transform is
## already present in the table, it will be added twice.

proc remove_transform*(this: TransformTable, n: clonglong) {.importcpp: "#->remove_transform(#)".} ## \
## Removes the nth transform.  Only valid for unregistered tables.

proc add_transform*(this: TransformTable, transform: VertexTransform): clonglong {.importcpp: "#->add_transform(#)".} ## \
## Adds a new transform to the table and returns the index number of the new
## transform.  Only valid for unregistered tables.
##
## This does not automatically uniquify the pointer; if the transform is
## already present in the table, it will be added twice.

proc write*(this: TransformTable, `out`: ostream) {.importcpp: "#->write(#)".}

proc get_class_type*(_: typedesc[TransformTable]): TypeHandle {.importcpp: "TransformTable::get_class_type()", header: "transformTable.h".}

proc initTransformBlend*(): TransformBlend {.importcpp: "TransformBlend()".}

proc initTransformBlend*(copy: TransformBlend): TransformBlend {.importcpp: "TransformBlend(#)".}

proc initTransformBlend*(transform0: VertexTransform, weight0: float32): TransformBlend {.importcpp: "TransformBlend(#, #)".}

proc initTransformBlend*(transform0: VertexTransform, weight0: float32, transform1: VertexTransform, weight1: float32): TransformBlend {.importcpp: "TransformBlend(#, #, #, #)".}

proc initTransformBlend*(transform0: VertexTransform, weight0: float32, transform1: VertexTransform, weight1: float32, transform2: VertexTransform, weight2: float32): TransformBlend {.importcpp: "TransformBlend(#, #, #, #, #, #)".}

proc initTransformBlend*(transform0: VertexTransform, weight0: float32, transform1: VertexTransform, weight1: float32, transform2: VertexTransform, weight2: float32, transform3: VertexTransform, weight3: float32): TransformBlend {.importcpp: "TransformBlend(#, #, #, #, #, #, #, #)".}

proc compare_to*(this: TransformBlend, other: TransformBlend): int {.importcpp: "#.compare_to(#)".} ## \
## Defines an arbitrary ordering for TransformBlend objects.

proc `<`*(this: TransformBlend, other: TransformBlend): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: TransformBlend, other: TransformBlend): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: TransformBlend, other: TransformBlend): bool {.importcpp: "#.operator !=(#)".}

proc add_transform*(this: TransformBlend, transform: VertexTransform, weight: float32) {.importcpp: "#.add_transform(#, #)".} ## \
## Adds a new transform to the blend.  If the transform already existed,
## increases its weight factor.

proc remove_transform*(this: TransformBlend, transform: VertexTransform) {.importcpp: "#.remove_transform(#)".} ## \
## Removes the indicated transform from the blend.

proc remove_transform*(this: TransformBlend, n: clonglong) {.importcpp: "#.remove_transform(#)".} ## \
## Removes the nth transform stored in the blend object.

proc limit_transforms*(this: TransformBlend, max_transforms: int) {.importcpp: "#.limit_transforms(#)".} ## \
## If the total number of transforms in the blend exceeds max_transforms,
## removes the n least-important transforms as needed to reduce the number of
## transforms to max_transforms.

proc normalize_weights*(this: TransformBlend) {.importcpp: "#.normalize_weights()".} ## \
## Rescales all of the weights on the various transforms so that they sum to
## 1.0.  It is generally a good idea to call this after adding or removing
## transforms from the blend.

proc has_transform*(this: TransformBlend, transform: VertexTransform): bool {.importcpp: "#.has_transform(#)".} ## \
## Returns true if the blend has the indicated transform, false otherwise.

proc get_weight*(this: TransformBlend, transform: VertexTransform): float32 {.importcpp: "#.get_weight(#)".} ## \
## Returns the weight associated with the indicated transform, or 0 if there
## is no entry for the transform.

proc get_weight*(this: TransformBlend, n: clonglong): float32 {.importcpp: "#.get_weight(#)".} ## \
## Returns the weight associated with the nth transform stored in the blend
## object.

proc get_num_transforms*(this: TransformBlend): clonglong {.importcpp: "#.get_num_transforms()".} ## \
## Returns the number of transforms stored in the blend object.

proc get_transform*(this: TransformBlend, n: clonglong): VertexTransform {.importcpp: "#.get_transform(#)".} ## \
## Returns the nth transform stored in the blend object.

proc set_transform*(this: TransformBlend, n: clonglong, transform: VertexTransform) {.importcpp: "#.set_transform(#, #)".} ## \
## Replaces the nth transform stored in the blend object.

proc set_weight*(this: TransformBlend, n: clonglong, weight: float32) {.importcpp: "#.set_weight(#, #)".} ## \
## Replaces the weight associated with the nth transform stored in the blend
## object.

proc update_blend*(this: TransformBlend, current_thread: Thread) {.importcpp: "#.update_blend(#)".} ## \
## Recomputes the internal representation of the blend value, if necessary.
## You should call this before calling get_blend() or transform_point().

proc get_blend*(this: TransformBlend, result: LMatrix4, current_thread: Thread) {.importcpp: "#.get_blend(#, #)".} ## \
## Returns the current value of the blend, based on the current value of all
## of the nested transform objects and their associated weights.
##
## You should call update_blend() to ensure that the cache is up-to-date
## before calling this.

proc transform_point*(this: TransformBlend, point: LPoint3d, current_thread: Thread) {.importcpp: "#.transform_point(#, #)".} ## \
## Transforms the indicated point by the blend matrix.
##
## You should call update_blend() to ensure that the cache is up-to-date
## before calling this.

proc transform_point*(this: TransformBlend, point: LPoint3f, current_thread: Thread) {.importcpp: "#.transform_point(#, #)".}

proc transform_point*(this: TransformBlend, point: LPoint4d, current_thread: Thread) {.importcpp: "#.transform_point(#, #)".} ## \
## Transforms the indicated point by the blend matrix.
##
## You should call update_blend() to ensure that the cache is up-to-date
## before calling this.

proc transform_point*(this: TransformBlend, point: LPoint4f, current_thread: Thread) {.importcpp: "#.transform_point(#, #)".}

proc transform_vector*(this: TransformBlend, point: LVector3d, current_thread: Thread) {.importcpp: "#.transform_vector(#, #)".} ## \
## Transforms the indicated vector by the blend matrix.
##
## You should call update_blend() to ensure that the cache is up-to-date
## before calling this.

proc transform_vector*(this: TransformBlend, point: LVector3f, current_thread: Thread) {.importcpp: "#.transform_vector(#, #)".}

proc get_modified*(this: TransformBlend, current_thread: Thread): UpdateSeq {.importcpp: "#.get_modified(#)".} ## \
## Returns a counter which is guaranteed to increment at least as often as the
## result of get_blend() changes.

proc get_modified*(this: TransformBlend): UpdateSeq {.importcpp: "#.get_modified()".} ## \
## Returns a counter which is guaranteed to increment at least as often as the
## result of get_blend() changes.

proc output*(this: TransformBlend, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: TransformBlend, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc get_class_type*(_: typedesc[TransformBlend]): TypeHandle {.importcpp: "TransformBlend::get_class_type()", header: "transformBlend.h".}

proc newTransformBlendTable*(): TransformBlendTable {.importcpp: "new TransformBlendTable()".}

proc newTransformBlendTable*(copy: TransformBlendTable): TransformBlendTable {.importcpp: "new TransformBlendTable(#)".}

proc get_num_blends*(this: TransformBlendTable): clonglong {.importcpp: "#->get_num_blends()".} ## \
## Returns the total number of different blend combinations in the table.

proc get_blend*(this: TransformBlendTable, n: clonglong): TransformBlend {.importcpp: "#->get_blend(#)".} ## \
## Returns the nth blend in the table.

proc get_modified*(this: TransformBlendTable, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a counter which is guaranteed to increment at least when any
## TransformBlends within the table have changed.

proc get_modified*(this: TransformBlendTable): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a counter which is guaranteed to increment at least when any
## TransformBlends within the table have changed.

proc set_blend*(this: TransformBlendTable, n: clonglong, blend: TransformBlend) {.importcpp: "#->set_blend(#, #)".} ## \
## Replaces the blend at the nth position with the indicated value.

proc remove_blend*(this: TransformBlendTable, n: clonglong) {.importcpp: "#->remove_blend(#)".} ## \
## Removes the blend at the nth position.

proc add_blend*(this: TransformBlendTable, blend: TransformBlend): clonglong {.importcpp: "#->add_blend(#)".} ## \
## Adds a new blend to the table, and returns its index number.  If there is
## already an identical blend in the table, simply returns that number
## instead.

proc get_num_transforms*(this: TransformBlendTable): int {.importcpp: "#->get_num_transforms()".} ## \
## Returns the number of unique VertexTransform objects represented in the
## table.  This will correspond to the size of the TransformTable object that
## would represent the same table.  This is also the same limit reflected by
## GraphicsStateGuardian::get_max_vertex_transform_indices().

proc get_max_simultaneous_transforms*(this: TransformBlendTable): int {.importcpp: "#->get_max_simultaneous_transforms()".} ## \
## Returns the maximum number of unique VertexTransform objects that are
## applied to any one vertex simultaneously.  This is the same limit reflected
## by GraphicsStateGuardian::get_max_vertex_transforms().

proc set_rows*(this: TransformBlendTable, rows: SparseArray) {.importcpp: "#->set_rows(#)".} ## \
## Specifies the subset of rows (vertices) in the associated GeomVertexData
## that this TransformBlendTable actually affects.

proc get_rows*(this: TransformBlendTable): SparseArray {.importcpp: "#->get_rows()".} ## \
## Returns the subset of rows (vertices) in the associated GeomVertexData that
## this TransformBlendTable actually affects.

proc modify_rows*(this: TransformBlendTable): SparseArray {.importcpp: "#->modify_rows()".} ## \
## Returns a modifiable reference to the SparseArray that specifies the subset
## of rows (vertices) in the associated GeomVertexData that this
## TransformBlendTable actually affects.

proc write*(this: TransformBlendTable, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc get_class_type*(_: typedesc[TransformBlendTable]): TypeHandle {.importcpp: "TransformBlendTable::get_class_type()", header: "transformBlendTable.h".}

proc get_name*(this: VertexSlider): InternalName {.importcpp: "#->get_name()".} ## \
## Returns the name of this particular slider.  Every unique blend shape
## within a particular Geom must be identified with a different name, which is
## shared by the slider that controls it.

proc get_slider*(this: VertexSlider): float32 {.importcpp: "#->get_slider()".}

proc get_modified*(this: VertexSlider, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number that's guaranteed to change at least every time
## the value reported by get_slider() changes.

proc get_modified*(this: VertexSlider): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number that's guaranteed to change at least every time
## the value reported by get_slider() changes.

proc output*(this: VertexSlider, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: VertexSlider, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc get_class_type*(_: typedesc[VertexSlider]): TypeHandle {.importcpp: "VertexSlider::get_class_type()", header: "vertexSlider.h".}

proc newSliderTable*(): SliderTable {.importcpp: "new SliderTable()".}

proc newSliderTable*(copy: SliderTable): SliderTable {.importcpp: "new SliderTable(#)".}

proc is_registered*(this: SliderTable): bool {.importcpp: "#->is_registered()".} ## \
## Returns true if this table has been registered.  Once it has been
## registered, the set of sliders in a SliderTable may not be further
## modified; but it must be registered before it can be assigned to a Geom.

proc register_table*(_: typedesc[SliderTable], table: SliderTable): SliderTable {.importcpp: "SliderTable::register_table(#)", header: "sliderTable.h".} ## \
## Registers a SliderTable for use.  This is similar to
## GeomVertexFormat::register_format().  Once registered, a SliderTable may no
## longer be modified (although the individual VertexSlider objects may modify
## their reported sliders).
##
## This must be called before a table may be used in a Geom.  After this call,
## you should discard the original pointer you passed in (which may or may not
## now be invalid) and let its reference count decrement normally; you should
## use only the returned value from this point on.

proc get_num_sliders*(this: SliderTable): clonglong {.importcpp: "#->get_num_sliders()".} ## \
## Returns the number of sliders in the table.

proc get_slider*(this: SliderTable, n: clonglong): VertexSlider {.importcpp: "#->get_slider(#)".} ## \
## Returns the nth slider in the table.

proc get_slider_rows*(this: SliderTable, n: clonglong): SparseArray {.importcpp: "#->get_slider_rows(#)".} ## \
## Returns the set of rows (vertices) governed by the nth slider in the table.

proc find_sliders*(this: SliderTable, name: InternalName): SparseArray {.importcpp: "#->find_sliders(#)".} ## \
## Returns a list of slider indices that represent the list of sliders with
## the indicated name, or an empty SparseArray if no slider in the table has
## that name.

proc has_slider*(this: SliderTable, name: InternalName): bool {.importcpp: "#->has_slider(#)".} ## \
## Returns true if the table has at least one slider by the indicated name,
## false otherwise.

proc is_empty*(this: SliderTable): bool {.importcpp: "#->is_empty()".} ## \
## Returns true if the table has no sliders, false if it has at least one.

proc get_modified*(this: SliderTable, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number that's guaranteed to change at least when any
## VertexSliders in the table change.  (However, this is only true for a
## registered table.  An unregistered table may or may not reflect an update
## here when a VertexSlider changes.)

proc get_modified*(this: SliderTable): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number that's guaranteed to change at least when any
## VertexSliders in the table change.  (However, this is only true for a
## registered table.  An unregistered table may or may not reflect an update
## here when a VertexSlider changes.)

proc set_slider*(this: SliderTable, n: clonglong, slider: VertexSlider) {.importcpp: "#->set_slider(#, #)".} ## \
## Replaces the nth slider.  Only valid for unregistered tables.

proc set_slider_rows*(this: SliderTable, n: clonglong, rows: SparseArray) {.importcpp: "#->set_slider_rows(#, #)".} ## \
## Replaces the rows affected by the nth slider.  Only valid for unregistered
## tables.

proc remove_slider*(this: SliderTable, n: clonglong) {.importcpp: "#->remove_slider(#)".} ## \
## Removes the nth slider.  Only valid for unregistered tables.

proc add_slider*(this: SliderTable, slider: VertexSlider, rows: SparseArray): clonglong {.importcpp: "#->add_slider(#, #)".} ## \
## Adds a new slider to the table, and returns the index number of the new
## slider.  Only valid for unregistered tables.

proc write*(this: SliderTable, `out`: ostream) {.importcpp: "#->write(#)".}

proc get_class_type*(_: typedesc[SliderTable]): TypeHandle {.importcpp: "SliderTable::get_class_type()", header: "sliderTable.h".}

converter upcast_to_CopyOnWriteObject*(this: GeomVertexData): CopyOnWriteObject {.importcpp: "(PT(CopyOnWriteObject)(#))".}

converter upcast_to_GeomEnums*(this: GeomVertexData): GeomEnums {.importcpp: "((GeomEnums *)(#.p()))".}

proc newGeomVertexData*(copy: GeomVertexData): GeomVertexData {.importcpp: "new GeomVertexData(#)".}

proc newGeomVertexData*(copy: GeomVertexData, format: GeomVertexFormat): GeomVertexData {.importcpp: "new GeomVertexData(#, #)".} ## \
## This constructor copies all of the basic properties of the source
## VertexData, like usage_hint and animation tables, but does not copy the
## actual data, and it allows you to specify a different format.

proc compare_to*(this: GeomVertexData, other: GeomVertexData): int {.importcpp: "#->compare_to(#)".} ## \
## Returns 0 if the two objects are equivalent, even if they are not the same
## pointer.

proc get_name*(this: GeomVertexData): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the name passed to the constructor, if any.  This name is reported
## on the PStats graph for vertex computations.

proc set_name*(this: GeomVertexData, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of the vertex data.  This name is reported on the PStats
## graph for vertex computations.

proc get_format*(this: GeomVertexData): GeomVertexFormat {.importcpp: "#->get_format()".} ## \
## Returns a pointer to the GeomVertexFormat structure that defines this data.

proc set_format*(this: GeomVertexData, format: GeomVertexFormat) {.importcpp: "#->set_format(#)".} ## \
## Changes the format of the vertex data.  If the data is not empty, this will
## implicitly change every row to match the new format.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc unclean_set_format*(this: GeomVertexData, format: GeomVertexFormat) {.importcpp: "#->unclean_set_format(#)".} ## \
## Changes the format of the vertex data, without reformatting the data to
## match.  The data is exactly the same after this operation, but will be
## reinterpreted according to the new format.  This assumes that the new
## format is fundamentally compatible with the old format; in particular, it
## must have the same number of arrays with the same stride in each one.  No
## checking is performed that the data remains sensible.

proc has_column*(this: GeomVertexData, name: InternalName): bool {.importcpp: "#->has_column(#)".} ## \
## Returns true if the data has the named column, false otherwise.  This is
## really just a shortcut for asking the same thing from the format.

proc get_num_rows*(this: GeomVertexData): int {.importcpp: "#->get_num_rows()".} ## \
## Returns the number of rows stored within all the arrays.  All arrays store
## data for the same n rows.

proc set_num_rows*(this: GeomVertexData, n: int): bool {.importcpp: "#->set_num_rows(#)".} ## \
## Sets the length of the array to n rows in all of the various arrays
## (presumably by adding rows).
##
## The new vertex data is initialized to 0, except for the "color" column,
## which is initialized to (1, 1, 1, 1).
##
## The return value is true if the number of rows was changed, false if the
## object already contained n rows (or if there was some error).
##
## This can be used when you know exactly how many rows you will be needing.
## It is faster than reserve_num_rows().  Also see unclean_set_num_rows() if
## you are planning to fill in all the data yourself.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc unclean_set_num_rows*(this: GeomVertexData, n: int): bool {.importcpp: "#->unclean_set_num_rows(#)".} ## \
## This method behaves like set_num_rows(), except the new data is not
## initialized.  Furthermore, after this call, *any* of the data in the
## GeomVertexData may be uninitialized, including the earlier rows.
##
## This is intended for applications that are about to completely fill the
## GeomVertexData with new data anyway; it provides a tiny performance boost
## over set_num_rows().
##
## This can be used when you know exactly how many rows you will be needing.
## It is faster than reserve_num_rows().

proc reserve_num_rows*(this: GeomVertexData, n: int): bool {.importcpp: "#->reserve_num_rows(#)".} ## \
## This ensures that enough memory space for n rows is allocated, so that you
## may increase the number of rows to n without causing a new memory
## allocation.  This is a performance optimization only; it is especially
## useful when you know ahead of time that you will be adding n rows to the
## data.
##
## If you know exactly how many rows you will be needing, it is significantly
## faster to use set_num_rows() or unclean_set_num_rows() instead.

proc clear_rows*(this: GeomVertexData) {.importcpp: "#->clear_rows()".} ## \
## Removes all of the rows from the arrays; functionally equivalent to
## set_num_rows(0) (but faster).
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc get_num_arrays*(this: GeomVertexData): clonglong {.importcpp: "#->get_num_arrays()".} ## \
## Returns the number of individual arrays stored within the data.  This must
## match get_format()->get_num_arrays().

proc get_array*(this: GeomVertexData, i: clonglong): GeomVertexArrayData {.importcpp: "#->get_array(#)".} ## \
## Returns a const pointer to the vertex data for the indicated array, for
## application code to directly examine (but not modify) the underlying vertex
## data.

proc get_array_handle*(this: GeomVertexData, i: clonglong): GeomVertexArrayDataHandle {.importcpp: "#->get_array_handle(#)".} ## \
## Equivalent to get_array(i).get_handle().

proc modify_array*(this: GeomVertexData, i: clonglong): GeomVertexArrayData {.importcpp: "#->modify_array(#)".} ## \
## Returns a modifiable pointer to the indicated vertex array, so that
## application code may directly manipulate the data.  You should avoid
## changing the length of this array, since all of the arrays should be kept
## in sync--use set_num_rows() instead.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc modify_array_handle*(this: GeomVertexData, i: clonglong): GeomVertexArrayDataHandle {.importcpp: "#->modify_array_handle(#)".} ## \
## Equivalent to modify_array(i).modify_handle().

proc set_array*(this: GeomVertexData, i: clonglong, array: GeomVertexArrayData) {.importcpp: "#->set_array(#, #)".} ## \
## Replaces the indicated vertex data array with a completely new array.  You
## should be careful that the new array has the same length and format as the
## old one, unless you know what you are doing.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc get_transform_table*(this: GeomVertexData): TransformTable {.importcpp: "#->get_transform_table()".} ## \
## Returns a const pointer to the TransformTable assigned to this data.
## Vertices within the table will index into this table to indicate their
## dynamic skinning information; this table is used when the vertex animation
## is to be performed by the graphics hardware (but also see
## get_transform_blend_table()).
##
## This will return NULL if the vertex data does not have a TransformTable
## assigned (which implies the vertices will not be animated by the graphics
## hardware).

proc set_transform_table*(this: GeomVertexData, table: TransformTable) {.importcpp: "#->set_transform_table(#)".} ## \
## Replaces the TransformTable on this vertex data with the indicated table.
## The length of this table should be consistent with the maximum table index
## assigned to the vertices under the "transform_index" name.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc clear_transform_table*(this: GeomVertexData) {.importcpp: "#->clear_transform_table()".} ## \
## Sets the TransformTable pointer to NULL, removing the table from the vertex
## data.  This disables hardware-driven vertex animation.

proc get_transform_blend_table*(this: GeomVertexData): TransformBlendTable {.importcpp: "#->get_transform_blend_table()".} ## \
## Returns a const pointer to the TransformBlendTable assigned to this data.
## Vertices within the table will index into this table to indicate their
## dynamic skinning information; this table is used when the vertex animation
## is to be performed by the CPU (but also see get_transform_table()).
##
## This will return NULL if the vertex data does not have a
## TransformBlendTable assigned (which implies the vertices will not be
## animated by the CPU).

proc modify_transform_blend_table*(this: GeomVertexData): TransformBlendTable {.importcpp: "#->modify_transform_blend_table()".} ## \
## Returns a modifiable pointer to the current TransformBlendTable on this
## vertex data, if any, or NULL if there is not a TransformBlendTable.  See
## get_transform_blend_table().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc set_transform_blend_table*(this: GeomVertexData, table: TransformBlendTable) {.importcpp: "#->set_transform_blend_table(#)".} ## \
## Replaces the TransformBlendTable on this vertex data with the indicated
## table.  The length of this table should be consistent with the maximum
## table index assigned to the vertices under the "transform_blend" name.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc clear_transform_blend_table*(this: GeomVertexData) {.importcpp: "#->clear_transform_blend_table()".} ## \
## Sets the TransformBlendTable pointer to NULL, removing the table from the
## vertex data.  This disables CPU-driven vertex animation.

proc get_slider_table*(this: GeomVertexData): SliderTable {.importcpp: "#->get_slider_table()".} ## \
## Returns a const pointer to the SliderTable assigned to this data.  Vertices
## within the vertex data will look up their morph offsets, if any, within
## this table.
##
## This will return NULL if the vertex data does not have a SliderTable
## assigned.

proc set_slider_table*(this: GeomVertexData, table: SliderTable) {.importcpp: "#->set_slider_table(#)".} ## \
## Replaces the SliderTable on this vertex data with the indicated table.
## There should be an entry in this table for each kind of morph offset
## defined in the vertex data.
##
## The SliderTable object must have been registered prior to setting it on the
## GeomVertexData.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc clear_slider_table*(this: GeomVertexData) {.importcpp: "#->clear_slider_table()".} ## \
## Sets the SliderTable pointer to NULL, removing the table from the vertex
## data.  This disables morph (blend shape) animation.

proc get_num_bytes*(this: GeomVertexData): int {.importcpp: "#->get_num_bytes()".} ## \
## Returns the total number of bytes consumed by the different arrays of the
## vertex data.

proc get_modified*(this: GeomVertexData, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the vertex data is modified.

proc get_modified*(this: GeomVertexData): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the vertex data is modified.

proc request_resident*(this: GeomVertexData): bool {.importcpp: "#->request_resident()".} ## \
## Returns true if the vertex data is currently resident in memory.  If this
## returns false, the vertex data will be brought back into memory shortly;
## try again later.

proc copy_from*(this: GeomVertexData, source: GeomVertexData, keep_data_objects: bool, current_thread: Thread) {.importcpp: "#->copy_from(#, #, #)".} ## \
## Copies all the data from the other array into the corresponding data types
## in this array, by matching data types name-by-name.
##
## keep_data_objects specifies what to do when one or more of the arrays can
## be copied without the need to apply any conversion operation.  If it is
## true, the original GeomVertexArrayData objects in this object are retained,
## and their data arrays are copied byte-by-byte from the source; if it is
## false, then the GeomVertexArrayData objects are copied pointerwise from the
## source.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc copy_from*(this: GeomVertexData, source: GeomVertexData, keep_data_objects: bool) {.importcpp: "#->copy_from(#, #)".} ## \
## Copies all the data from the other array into the corresponding data types
## in this array, by matching data types name-by-name.
##
## keep_data_objects specifies what to do when one or more of the arrays can
## be copied without the need to apply any conversion operation.  If it is
## true, the original GeomVertexArrayData objects in this object are retained,
## and their data arrays are copied byte-by-byte from the source; if it is
## false, then the GeomVertexArrayData objects are copied pointerwise from the
## source.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc copy_row_from*(this: GeomVertexData, dest_row: int, source: GeomVertexData, source_row: int, current_thread: Thread) {.importcpp: "#->copy_row_from(#, #, #, #)".} ## \
## Copies a single row of the data from the other array into the indicated row
## of this array.  In this case, the source format must exactly match the
## destination format.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc convert_to*(this: GeomVertexData, new_format: GeomVertexFormat): GeomVertexData {.importcpp: "#->convert_to(#)".} ## \
## Returns a new GeomVertexData that represents the same contents as this one,
## with all data types matched up name-by-name to the indicated new format.

proc scale_color*(this: GeomVertexData, color_scale: LVecBase4): GeomVertexData {.importcpp: "#->scale_color(#)".} ## \
## Returns a new GeomVertexData object with the color table modified in-place
## to apply the indicated scale.
##
## If the vertex data does not include a color column, a new one will not be
## added.

proc set_color*(this: GeomVertexData, color: LColor): GeomVertexData {.importcpp: "#->set_color(#)".} ## \
## Returns a new GeomVertexData object with the color data modified in-place
## with the new value.
##
## If the vertex data does not include a color column, a new one will not be
## added.

proc reverse_normals*(this: GeomVertexData): GeomVertexData {.importcpp: "#->reverse_normals()".} ## \
## Returns a new GeomVertexData object with the normal data modified in-place,
## so that each lighting normal is now facing in the opposite direction.
##
## If the vertex data does not include a normal column, this returns the
## original GeomVertexData object, unchanged.

proc animate_vertices*(this: GeomVertexData, force: bool, current_thread: Thread): GeomVertexData {.importcpp: "#->animate_vertices(#, #)".} ## \
## Returns a GeomVertexData that represents the results of computing the
## vertex animation on the CPU for this GeomVertexData.
##
## If there is no CPU-defined vertex animation on this object, this just
## returns the original object.
##
## If there is vertex animation, but the VertexTransform values have not
## changed since last time, this may return the same pointer it returned
## previously.  Even if the VertexTransform values have changed, it may still
## return the same pointer, but with its contents modified (this is preferred,
## since it allows the graphics backend to update vertex buffers optimally).
##
## If force is false, this method may return immediately with stale data, if
## the vertex data is not completely resident.  If force is true, this method
## will never return stale data, but may block until the data is available.

proc clear_animated_vertices*(this: GeomVertexData) {.importcpp: "#->clear_animated_vertices()".} ## \
## Removes the cache of animated vertices computed by a previous call to
## animate_vertices() within the same frame.  This will force the next call to
## animate_vertices() to recompute these values from scratch.  Normally it is
## not necessary to call this.

proc transform_vertices*(this: GeomVertexData, mat: LMatrix4) {.importcpp: "#->transform_vertices(#)".} ## \
## Applies the indicated transform matrix to all of the vertices in the
## GeomVertexData.  The transform is applied to all "point" and "vector" type
## columns described in the format.

proc transform_vertices*(this: GeomVertexData, mat: LMatrix4, rows: SparseArray) {.importcpp: "#->transform_vertices(#, #)".} ## \
## Applies the indicated transform matrix to all of the vertices mentioned in
## the sparse array.  The transform is applied to all "point" and "vector"
## type columns described in the format.

proc transform_vertices*(this: GeomVertexData, mat: LMatrix4, begin_row: int, end_row: int) {.importcpp: "#->transform_vertices(#, #, #)".} ## \
## Applies the indicated transform matrix to all of the vertices from
## begin_row up to but not including end_row.  The transform is applied to all
## "point" and "vector" type columns described in the format.

proc output*(this: GeomVertexData, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: GeomVertexData, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: GeomVertexData, `out`: ostream) {.importcpp: "#->write(#)".}

proc describe_vertex*(this: GeomVertexData, `out`: ostream, row: int) {.importcpp: "#->describe_vertex(#, #)".} ## \
## Writes a verbose, human-friendly description of the indicated vertex
## number.

proc clear_cache*(this: GeomVertexData) {.importcpp: "#->clear_cache()".} ## \
## Removes all of the previously-cached results of convert_to().
##
## This blows away the entire cache, upstream and downstream the pipeline.
## Use clear_cache_stage() instead if you only want to blow away the cache at
## the current stage and upstream.

proc clear_cache_stage*(this: GeomVertexData) {.importcpp: "#->clear_cache_stage()".} ## \
## Removes all of the previously-cached results of convert_to(), at the
## current pipeline stage and upstream.  Does not affect the downstream cache.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc get_class_type*(_: typedesc[GeomVertexData]): TypeHandle {.importcpp: "GeomVertexData::get_class_type()", header: "geomVertexData.h".}

proc newAnimateVerticesRequest*(param0: AnimateVerticesRequest): AnimateVerticesRequest {.importcpp: "new AnimateVerticesRequest(#)".}

proc newAnimateVerticesRequest*(geom_vertex_data: GeomVertexData): AnimateVerticesRequest {.importcpp: "new AnimateVerticesRequest(#)".} ## \
## Create a new AnimateVerticesRequest.

proc is_ready*(this: AnimateVerticesRequest): bool {.importcpp: "#->is_ready()".} ## \
## Returns true if this request has completed, false if it is still pending.
## Equivalent to `req.done() and not req.cancelled()`.
## @see done()

proc get_class_type*(_: typedesc[AnimateVerticesRequest]): TypeHandle {.importcpp: "AnimateVerticesRequest::get_class_type()", header: "animateVerticesRequest.h".}

proc get_class_type*(_: typedesc[SavedContext]): TypeHandle {.importcpp: "SavedContext::get_class_type()", header: "savedContext.h".}

converter upcast_to_SavedContext*(this: BufferContext): SavedContext {.importcpp: "#.upcast_to_SavedContext()".}

proc get_data_size_bytes*(this: BufferContext): clonglong {.importcpp: "#.get_data_size_bytes()".} ## \
## Returns the number of bytes previously reported for the data object.  This
## is used to track changes in the data object's allocated size; if it changes
## from this, we need to create a new buffer.  This is also used to track
## memory utilization in PStats.

proc get_modified*(this: BufferContext): UpdateSeq {.importcpp: "#.get_modified()".} ## \
## Returns the UpdateSeq that was recorded the last time mark_loaded() was
## called.

proc get_active*(this: BufferContext): bool {.importcpp: "#.get_active()".} ## \
## Returns the active flag associated with this object.  An object is
## considered "active" if it was rendered in the current frame.

proc get_resident*(this: BufferContext): bool {.importcpp: "#.get_resident()".} ## \
## Returns the resident flag associated with this object.  An object is
## considered "resident" if it appears to be resident in texture memory.

proc get_class_type*(_: typedesc[BufferContext]): TypeHandle {.importcpp: "BufferContext::get_class_type()", header: "bufferContext.h".}

converter upcast_to_CopyOnWriteObject*(this: GeomPrimitive): CopyOnWriteObject {.importcpp: "(PT(CopyOnWriteObject)(#))".}

converter upcast_to_GeomEnums*(this: GeomPrimitive): GeomEnums {.importcpp: "((GeomEnums *)(#.p()))".}

proc make_copy*(this: GeomPrimitive): GeomPrimitive {.importcpp: "#->make_copy()".}

proc get_geom_rendering*(this: GeomPrimitive): int {.importcpp: "#->get_geom_rendering()".} ## \
## Returns the set of GeomRendering bits that represent the rendering
## properties required to properly render this primitive.

proc is_composite*(this: GeomPrimitive): bool {.importcpp: "#->is_composite()".} ## \
## Returns true if the primitive is a composite primitive such as a tristrip
## or trifan, or false if it is a fundamental primitive such as a collection
## of triangles.

proc is_indexed*(this: GeomPrimitive): bool {.importcpp: "#->is_indexed()".} ## \
## Returns true if the primitive is indexed, false otherwise.  An indexed
## primitive stores a table of index numbers into its GeomVertexData, so that
## it can reference the vertices in any order.  A nonindexed primitive, on the
## other hand, stores only the first vertex number and number of vertices
## used, so that it can only reference the vertices consecutively.

proc get_first_vertex*(this: GeomPrimitive): int {.importcpp: "#->get_first_vertex()".} ## \
## Returns the first vertex number referenced by the primitive.  This is
## particularly important in the case of a nonindexed primitive, in which case
## get_first_vertex() and get_num_vertices() completely define the extent of
## the vertex range.

proc get_num_vertices*(this: GeomPrimitive): int {.importcpp: "#->get_num_vertices()".} ## \
## Returns the number of indices used by all the primitives in this object.

proc get_vertex*(this: GeomPrimitive, i: int): int {.importcpp: "#->get_vertex(#)".} ## \
## Returns the ith vertex index in the table.

proc add_vertex*(this: GeomPrimitive, vertex: int) {.importcpp: "#->add_vertex(#)".} ## \
## Adds the indicated vertex to the list of vertex indices used by the
## graphics primitive type.  To define a primitive, you must call add_vertex()
## for each vertex of the new primitive, and then call close_primitive() after
## you have specified the last vertex of each primitive.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc add_vertices*(this: GeomPrimitive, v1: int, v2: int) {.importcpp: "#->add_vertices(#, #)".} ## \
## Adds several vertices in a row.

proc add_vertices*(this: GeomPrimitive, v1: int, v2: int, v3: int) {.importcpp: "#->add_vertices(#, #, #)".} ## \
## Adds several vertices in a row.

proc add_vertices*(this: GeomPrimitive, v1: int, v2: int, v3: int, v4: int) {.importcpp: "#->add_vertices(#, #, #, #)".} ## \
## Adds several vertices in a row.

proc add_consecutive_vertices*(this: GeomPrimitive, start: int, num_vertices: int) {.importcpp: "#->add_consecutive_vertices(#, #)".} ## \
## Adds a consecutive sequence of vertices, beginning at start, to the
## primitive.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc add_next_vertices*(this: GeomPrimitive, num_vertices: int) {.importcpp: "#->add_next_vertices(#)".} ## \
## Adds the next n vertices in sequence, beginning from the last vertex added
## to the primitive + 1.
##
## This is most useful when you are building up a primitive and a
## GeomVertexData at the same time, and you just want the primitive to
## reference the first n vertices from the data, then the next n, and so on.

proc reserve_num_vertices*(this: GeomPrimitive, num_vertices: int) {.importcpp: "#->reserve_num_vertices(#)".} ## \
## This ensures that enough memory space for n vertices is allocated, so that
## you may increase the number of vertices to n without causing a new memory
## allocation.  This is a performance optimization only; it is especially
## useful when you know ahead of time that you will be adding n vertices to
## the primitive.
##
## Note that the total you specify here should also include implicit vertices
## which may be added at each close_primitive() call, according to
## get_num_unused_vertices_per_primitive().
##
## Note also that making this call will implicitly make the primitive indexed
## if it is not already, which could result in a performance *penalty*.  If
## you would prefer not to lose the nonindexed nature of your existing
## GeomPrimitives, check is_indexed() before making this call.

proc close_primitive*(this: GeomPrimitive): bool {.importcpp: "#->close_primitive()".} ## \
## Indicates that the previous n calls to add_vertex(), since the last call to
## close_primitive(), have fully defined a new primitive.  Returns true if
## successful, false otherwise.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc clear_vertices*(this: GeomPrimitive) {.importcpp: "#->clear_vertices()".} ## \
## Removes all of the vertices and primitives from the object, so they can be
## re-added.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc offset_vertices*(this: GeomPrimitive, offset: int) {.importcpp: "#->offset_vertices(#)".} ## \
## Adds the indicated offset to all vertices used by the primitive.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc offset_vertices*(this: GeomPrimitive, offset: int, begin_row: int, end_row: int) {.importcpp: "#->offset_vertices(#, #, #)".} ## \
## Adds the indicated offset to the indicated segment of vertices used by the
## primitive.  Unlike the other version of offset_vertices, this makes the
## geometry indexed if it isn't already.
##
## Note that end_row indicates one past the last row that should be offset.
## In other words, the number of vertices touched is (end_row - begin_row).
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc make_nonindexed*(this: GeomPrimitive, dest: GeomVertexData, source: GeomVertexData) {.importcpp: "#->make_nonindexed(#, #)".} ## \
## Converts the primitive from indexed to nonindexed by duplicating vertices
## as necessary into the indicated dest GeomVertexData.  Note: does not
## support primitives with strip cut indices.

proc pack_vertices*(this: GeomPrimitive, dest: GeomVertexData, source: GeomVertexData) {.importcpp: "#->pack_vertices(#, #)".} ## \
## Packs the vertices used by the primitive from the indicated source array
## onto the end of the indicated destination array.

proc make_indexed*(this: GeomPrimitive) {.importcpp: "#->make_indexed()".} ## \
## Converts the primitive from nonindexed form to indexed form.  This will
## simply create an index table that is numbered consecutively from
## get_first_vertex(); it does not automatically collapse together identical
## vertices that may have been split apart by a previous call to
## make_nonindexed().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc get_num_primitives*(this: GeomPrimitive): int {.importcpp: "#->get_num_primitives()".} ## \
## Returns the number of individual primitives stored within this object.  All
## primitives are the same type.

proc get_primitive_start*(this: GeomPrimitive, n: int): int {.importcpp: "#->get_primitive_start(#)".} ## \
## Returns the element within the _vertices list at which the nth primitive
## starts.
##
## If i is one more than the highest valid primitive vertex, the return value
## will be one more than the last valid vertex.  Thus, it is generally true
## that the vertices used by a particular primitive i are the set
## get_primitive_start(n) <= vi < get_primitive_start(n + 1) (although this
## range also includes the unused vertices between primitives).

proc get_primitive_end*(this: GeomPrimitive, n: int): int {.importcpp: "#->get_primitive_end(#)".} ## \
## Returns the element within the _vertices list at which the nth primitive
## ends.  This is one past the last valid element for the nth primitive.

proc get_primitive_num_vertices*(this: GeomPrimitive, n: int): int {.importcpp: "#->get_primitive_num_vertices(#)".} ## \
## Returns the number of vertices used by the nth primitive.  This is the same
## thing as get_primitive_end(n) - get_primitive_start(n).

proc get_num_used_vertices*(this: GeomPrimitive): int {.importcpp: "#->get_num_used_vertices()".} ## \
## Returns the number of vertices used by all of the primitives.  This is the
## same as summing get_primitive_num_vertices(n) for n in
## get_num_primitives().  It is like get_num_vertices except that it excludes
## all of the degenerate vertices and strip-cut indices.

proc get_num_faces*(this: GeomPrimitive): int {.importcpp: "#->get_num_faces()".} ## \
## Returns the number of triangles or other fundamental type (such as line
## segments) represented by all the primitives in this object.

proc get_primitive_num_faces*(this: GeomPrimitive, n: int): int {.importcpp: "#->get_primitive_num_faces(#)".} ## \
## Returns the number of triangles or other fundamental type (such as line
## segments) represented by the nth primitive in this object.

proc get_min_vertex*(this: GeomPrimitive): int {.importcpp: "#->get_min_vertex()".} ## \
## Returns the minimum vertex index number used by all the primitives in this
## object.

proc get_primitive_min_vertex*(this: GeomPrimitive, n: int): int {.importcpp: "#->get_primitive_min_vertex(#)".} ## \
## Returns the minimum vertex index number used by the nth primitive in this
## object.

proc get_max_vertex*(this: GeomPrimitive): int {.importcpp: "#->get_max_vertex()".} ## \
## Returns the maximum vertex index number used by all the primitives in this
## object.

proc get_primitive_max_vertex*(this: GeomPrimitive, n: int): int {.importcpp: "#->get_primitive_max_vertex(#)".} ## \
## Returns the maximum vertex index number used by the nth primitive in this
## object.

proc decompose*(this: GeomPrimitive): GeomPrimitive {.importcpp: "#->decompose()".} ## \
## Decomposes a complex primitive type into a simpler primitive type, for
## instance triangle strips to triangles, and returns a pointer to the new
## primitive definition.  If the decomposition cannot be performed, this might
## return the original object.
##
## This method is useful for application code that wants to iterate through
## the set of triangles on the primitive without having to write handlers for
## each possible kind of primitive type.

proc rotate*(this: GeomPrimitive): GeomPrimitive {.importcpp: "#->rotate()".} ## \
## Returns a new primitive with the shade_model reversed (if it is flat
## shaded), if possible.  If the primitive type cannot be rotated, returns the
## original primitive, unrotated.
##
## If the current shade_model indicates flat_vertex_last, this should bring
## the last vertex to the first position; if it indicates flat_vertex_first,
## this should bring the first vertex to the last position.

proc doubleside*(this: GeomPrimitive): GeomPrimitive {.importcpp: "#->doubleside()".} ## \
## Duplicates triangles in the primitive so that each triangle is back-to-back
## with another triangle facing in the opposite direction.  Note that this
## doesn't affect vertex normals, so this operation alone won't work in the
## presence of lighting (but see SceneGraphReducer::doubleside()).
##
## Also see CullFaceAttrib, which can enable rendering of both sides of a
## triangle without having to duplicate it (but which doesn't necessarily work
## in the presence of lighting).

proc reverse*(this: GeomPrimitive): GeomPrimitive {.importcpp: "#->reverse()".} ## \
## Reverses the winding order in the primitive so that each triangle is facing
## in the opposite direction it was originally.  Note that this doesn't affect
## vertex normals, so this operation alone won't work in the presence of
## lighting (but see SceneGraphReducer::reverse()).
##
## Also see CullFaceAttrib, which can change the visible direction of a
## triangle without having to duplicate it (but which doesn't necessarily work
## in the presence of lighting).

proc make_points*(this: GeomPrimitive): GeomPrimitive {.importcpp: "#->make_points()".} ## \
## Returns a new GeomPoints primitive that represents each of the vertices in
## the original primitive, rendered exactly once.  If the original primitive
## is already a GeomPoints primitive, returns the original primitive
## unchanged.

proc make_lines*(this: GeomPrimitive): GeomPrimitive {.importcpp: "#->make_lines()".} ## \
## Returns a new GeomLines primitive that represents each of the edges in the
## original primitive rendered as a line.  If the original primitive is
## already a GeomLines primitive, returns the original primitive unchanged.

proc make_patches*(this: GeomPrimitive): GeomPrimitive {.importcpp: "#->make_patches()".} ## \
## Decomposes a complex primitive type into a simpler primitive type, for
## instance triangle strips to triangles, puts these in a new GeomPatches
## object and returns a pointer to the new primitive definition.  If the
## decomposition cannot be performed, this might return the original object.
##
## This method is useful for application code that wants to use tesselation
## shaders on arbitrary geometry.

proc make_adjacency*(this: GeomPrimitive): GeomPrimitive {.importcpp: "#->make_adjacency()".} ## \
## Adds adjacency information to this primitive.  May return null if this type
## of geometry does not support adjacency information.
##
## @since 1.10.0

proc get_num_bytes*(this: GeomPrimitive): int {.importcpp: "#->get_num_bytes()".} ## \
## Returns the number of bytes consumed by the primitive and its index
## table(s).

proc get_data_size_bytes*(this: GeomPrimitive): int {.importcpp: "#->get_data_size_bytes()".} ## \
## Returns the number of bytes stored in the vertices array.

proc get_modified*(this: GeomPrimitive): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the vertex index array is modified.

proc request_resident*(this: GeomPrimitive, current_thread: Thread): bool {.importcpp: "#->request_resident(#)".} ## \
## Returns true if the primitive data is currently resident in memory.  If
## this returns false, the primitive data will be brought back into memory
## shortly; try again later.

proc request_resident*(this: GeomPrimitive): bool {.importcpp: "#->request_resident()".} ## \
## Returns true if the primitive data is currently resident in memory.  If
## this returns false, the primitive data will be brought back into memory
## shortly; try again later.

proc check_valid*(this: GeomPrimitive, vertex_data: GeomVertexData): bool {.importcpp: "#->check_valid(#)".} ## \
## Verifies that the primitive only references vertices that actually exist
## within the indicated GeomVertexData.  Returns true if the primitive appears
## to be valid, false otherwise.

proc output*(this: GeomPrimitive, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: GeomPrimitive, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc get_vertices*(this: GeomPrimitive): GeomVertexArrayData {.importcpp: "#->get_vertices()".} ## \
## Returns a const pointer to the vertex index array so application code can
## read it directly.  This might return NULL if the primitive is nonindexed.
## Do not attempt to modify the returned array; use modify_vertices() or
## set_vertices() for this.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc get_vertices_handle*(this: GeomPrimitive, current_thread: Thread): GeomVertexArrayDataHandle {.importcpp: "#->get_vertices_handle(#)".} ## \
## Equivalent to get_vertices().get_handle().

proc modify_vertices*(this: GeomPrimitive, num_vertices: int): GeomVertexArrayData {.importcpp: "#->modify_vertices(#)".} ## \
## Returns a modifiable pointer to the vertex index list, so application code
## can directly fiddle with this data.  Use with caution, since there are no
## checks that the data will be left in a stable state.
##
## If this is called on a nonindexed primitive, it will implicitly be
## converted to an indexed primitive.
##
## If num_vertices is not -1, it specifies an artificial limit to the number
## of vertices in the array.  Otherwise, all of the vertices in the array will
## be used.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc modify_vertices*(this: GeomPrimitive): GeomVertexArrayData {.importcpp: "#->modify_vertices()".} ## \
## Returns a modifiable pointer to the vertex index list, so application code
## can directly fiddle with this data.  Use with caution, since there are no
## checks that the data will be left in a stable state.
##
## If this is called on a nonindexed primitive, it will implicitly be
## converted to an indexed primitive.
##
## If num_vertices is not -1, it specifies an artificial limit to the number
## of vertices in the array.  Otherwise, all of the vertices in the array will
## be used.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc modify_vertices_handle*(this: GeomPrimitive, current_thread: Thread): GeomVertexArrayDataHandle {.importcpp: "#->modify_vertices_handle(#)".} ## \
## Equivalent to modify_vertices().get_handle().

proc set_vertices*(this: GeomPrimitive, vertices: GeomVertexArrayData, num_vertices: int) {.importcpp: "#->set_vertices(#, #)".} ## \
## Completely replaces the vertex index list with a new table.  Chances are
## good that you should also replace the ends list with set_ends() at the same
## time.
##
## If num_vertices is not -1, it specifies an artificial limit to the number
## of vertices in the array.  Otherwise, all of the vertices in the array will
## be used.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc set_vertices*(this: GeomPrimitive, vertices: GeomVertexArrayData) {.importcpp: "#->set_vertices(#)".} ## \
## Completely replaces the vertex index list with a new table.  Chances are
## good that you should also replace the ends list with set_ends() at the same
## time.
##
## If num_vertices is not -1, it specifies an artificial limit to the number
## of vertices in the array.  Otherwise, all of the vertices in the array will
## be used.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc set_nonindexed_vertices*(this: GeomPrimitive, first_vertex: int, num_vertices: int) {.importcpp: "#->set_nonindexed_vertices(#, #)".} ## \
## Sets the primitive up as a nonindexed primitive, using the indicated vertex
## range.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc get_index_stride*(this: GeomPrimitive): int {.importcpp: "#->get_index_stride()".} ## \
## A convenience function to return the gap between successive index numbers,
## in bytes, of the index data.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc get_strip_cut_index*(this: GeomPrimitive): int {.importcpp: "#->get_strip_cut_index()".} ## \
## If relevant, returns the index value that may be used in some cases to
## signify the end of a primitive.  This is typically the highest value that
## the numeric type can store.

proc get_mins*(this: GeomPrimitive): GeomVertexArrayData {.importcpp: "#->get_mins()".} ## \
## Returns a const pointer to the primitive mins array so application code can
## read it directly.  Do not attempt to modify the returned array; use
## set_minmax() for this.
##
## Note that simple primitive types, like triangles, do not have a mins array.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc get_maxs*(this: GeomPrimitive): GeomVertexArrayData {.importcpp: "#->get_maxs()".} ## \
## Returns a const pointer to the primitive maxs array so application code can
## read it directly.  Do not attempt to modify the returned array; use
## set_minmax().
##
## Note that simple primitive types, like triangles, do not have a maxs array.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc set_minmax*(this: GeomPrimitive, min_vertex: int, max_vertex: int, mins: GeomVertexArrayData, maxs: GeomVertexArrayData) {.importcpp: "#->set_minmax(#, #, #, #)".} ## \
## Explicitly specifies the minimum and maximum vertices, as well as the lists
## of per-component min and max.
##
## Use this method with extreme caution.  It's generally better to let the
## GeomPrimitive compute these explicitly, unless for some reason you can do
## it faster and you absolutely need the speed improvement.
##
## Note that any modification to the vertex array will normally cause this to
## be recomputed, unless you set it immediately again.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc clear_minmax*(this: GeomPrimitive) {.importcpp: "#->clear_minmax()".} ## \
## Undoes a previous call to set_minmax(), and allows the minimum and maximum
## values to be recomputed normally.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc get_num_vertices_per_primitive*(this: GeomPrimitive): int {.importcpp: "#->get_num_vertices_per_primitive()".} ## \
## If the primitive type is a simple type in which all primitives have the
## same number of vertices, like triangles, returns the number of vertices per
## primitive.  If the primitive type is a more complex type in which different
## primitives might have different numbers of vertices, for instance a
## triangle strip, returns 0.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc get_min_num_vertices_per_primitive*(this: GeomPrimitive): int {.importcpp: "#->get_min_num_vertices_per_primitive()".} ## \
## Returns the minimum number of vertices that must be added before
## close_primitive() may legally be called.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc get_num_unused_vertices_per_primitive*(this: GeomPrimitive): int {.importcpp: "#->get_num_unused_vertices_per_primitive()".} ## \
## Returns the number of vertices that are added between primitives that
## aren't, strictly speaking, part of the primitives themselves.  This is
## used, for instance, to define degenerate triangles to connect otherwise
## disconnected triangle strips.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc get_class_type*(_: typedesc[GeomPrimitive]): TypeHandle {.importcpp: "GeomPrimitive::get_class_type()", header: "geomPrimitive.h".}

proc newTextureStage*(copy: TextureStage): TextureStage {.importcpp: "new TextureStage(#)".} ## \
## Initialize the texture stage from other

proc newTextureStage*(name: string): TextureStage {.importcpp: "new TextureStage(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Initialize the texture stage at construction

proc set_name*(this: TextureStage, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of this texture stage

proc get_name*(this: TextureStage): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the name of this texture stage

proc set_sort*(this: TextureStage, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Changes the order in which the texture associated with this stage is
## rendered relative to the other texture stages.  When geometry is rendered
## with multiple textures, the textures are rendered in order from the lowest
## sort number to the highest sort number.
##
## Also see set_priority(), which is used to select the most important
## textures for rendering when some must be omitted because of hardware
## limitations.

proc get_sort*(this: TextureStage): int {.importcpp: "#->get_sort()".} ## \
## Returns the sort order of this texture stage.

proc set_priority*(this: TextureStage, priority: int) {.importcpp: "#->set_priority(#)".} ## \
## Changes the relative importance of the texture associated with this stage
## relative to the other texture stages that are applied simultaneously.
##
## This is unrelated to set_sort(), which controls the order in which multiple
## textures are applied.  The priority number is used to decide which of the
## requested textures are to be selected for rendering when more textures are
## requested than the hardware will support.  The highest-priority n textures
## are selected for rendering, and then rendered in order by their sort
## factor.

proc get_priority*(this: TextureStage): int {.importcpp: "#->get_priority()".} ## \
## Returns the priority associated with this stage.
##
## This is specially helpful for cards that do not support more than n stages
## of multi-texturing.

proc set_texcoord_name*(this: TextureStage, name: InternalName) {.importcpp: "#->set_texcoord_name(#)".} ## \
## Indicate which set of UV's this texture stage will use.  Geometry may have
## any number of associated UV sets, each of which must have a unique name.

proc set_texcoord_name*(this: TextureStage, texcoord_name: string) {.importcpp: "#->set_texcoord_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Indicate which set of UV's this texture stage will use.  Geometry may have
## any number of associated UV sets, each of which must have a unique name.

proc get_texcoord_name*(this: TextureStage): InternalName {.importcpp: "#->get_texcoord_name()".} ## \
## See set_texcoord_name.  The default is InternalName::get_texcoord().

proc get_tangent_name*(this: TextureStage): InternalName {.importcpp: "#->get_tangent_name()".} ## \
## Returns the set of tangents this texture stage will use.  This is the same
## as get_texcoord_name(), except that the first part is "tangent".

proc get_binormal_name*(this: TextureStage): InternalName {.importcpp: "#->get_binormal_name()".} ## \
## Returns the set of binormals this texture stage will use.  This is the same
## as get_binormal_name(), except that the first part is "binormal".

proc is_fixed_function*(this: TextureStage): bool {.importcpp: "#->is_fixed_function()".} ## \
## Returns true if the TextureStage is relevant to the classic fixed function
## pipeline.  This excludes texture stages such as normal mapping and the
## like.

proc set_color*(this: TextureStage, color: LColor) {.importcpp: "#->set_color(#)".} ## \
## Set the color for this stage

proc get_color*(this: TextureStage): LColor {.importcpp: "#->get_color()".} ## \
## return the color for this stage

proc set_rgb_scale*(this: TextureStage, rgb_scale: int) {.importcpp: "#->set_rgb_scale(#)".} ## \
## Sets an additional factor that will scale all three r, g, b components
## after the texture has been applied.  This is used only when the mode is
## CM_combine.
##
## The only legal values are 1, 2, or 4.

proc get_rgb_scale*(this: TextureStage): int {.importcpp: "#->get_rgb_scale()".} ## \
## See set_rgb_scale().

proc set_alpha_scale*(this: TextureStage, alpha_scale: int) {.importcpp: "#->set_alpha_scale(#)".} ## \
## Sets an additional factor that will scale the alpha component after the
## texture has been applied.  This is used only when the mode is CM_combine.
##
## The only legal values are 1, 2, or 4.

proc get_alpha_scale*(this: TextureStage): int {.importcpp: "#->get_alpha_scale()".} ## \
## See set_alpha_scale().

proc set_saved_result*(this: TextureStage, saved_result: bool) {.importcpp: "#->set_saved_result(#)".} ## \
## Sets the saved_result flag.  When this is true, the output of this stage
## will be supplied as the "last_saved_result" source for any future stages,
## until the next TextureStage with a saved_result set true is encountered.
##
## This can be used to reuse the results of this texture stage as input to
## more than one stage later in the pipeline.
##
## The last texture in the pipeline (the one with the highest sort value)
## should not have this flag set.

proc get_saved_result*(this: TextureStage): bool {.importcpp: "#->get_saved_result()".} ## \
## Returns the current setting of the saved_result flag.  See
## set_saved_result().

proc set_tex_view_offset*(this: TextureStage, tex_view_offset: int) {.importcpp: "#->set_tex_view_offset(#)".} ## \
## Sets the tex_view_offset value.  This is used only when a special multiview
## texture is bound to the TextureStage, and it selects the particular view of
## the texture that is to be used.
##
## This value is added to the similar parameter on DisplayRegion to derive the
## final texture view index that is selected for rendering.

proc get_tex_view_offset*(this: TextureStage): int {.importcpp: "#->get_tex_view_offset()".} ## \
## Returns the current setting of the tex_view_offset.  See
## set_tex_view_offset().

proc get_num_combine_rgb_operands*(this: TextureStage): int {.importcpp: "#->get_num_combine_rgb_operands()".} ## \
## Returns the number of meaningful operands that may be retrieved via
## get_combine_rgb_sourceN() and get_combine_rgb_operandN().

proc get_num_combine_alpha_operands*(this: TextureStage): int {.importcpp: "#->get_num_combine_alpha_operands()".} ## \
## Returns the number of meaningful operands that may be retrieved via
## get_combine_alpha_sourceN() and get_combine_alpha_operandN().

proc involves_color_scale*(this: TextureStage): bool {.importcpp: "#->involves_color_scale()".} ## \
## Returns true if the TextureStage is affected by the setting of the current
## ColorScaleAttrib, false otherwise.

proc uses_color*(this: TextureStage): bool {.importcpp: "#->uses_color()".} ## \
## Returns true if the TextureStage makes use of whatever color is specified
## in set_color(), false otherwise.

proc uses_primary_color*(this: TextureStage): bool {.importcpp: "#->uses_primary_color()".} ## \
## Returns true if the TextureStage makes use of the CS_primary_color combine
## source.

proc uses_last_saved_result*(this: TextureStage): bool {.importcpp: "#->uses_last_saved_result()".} ## \
## Returns true if the TextureStage makes use of the CS_primary_color combine
## source.

proc `==`*(this: TextureStage, other: TextureStage): bool {.importcpp: "#->operator ==(#)".}

proc `!=`*(this: TextureStage, other: TextureStage): bool {.importcpp: "#->operator !=(#)".}

proc `<`*(this: TextureStage, other: TextureStage): bool {.importcpp: "#->operator <(#)".}

proc compare_to*(this: TextureStage, other: TextureStage): int {.importcpp: "#->compare_to(#)".} ## \
## Returns a number less than zero if this TextureStage sorts before the other
## one, greater than zero if it sorts after, or zero if they are equivalent.
## The sorting order is arbitrary and largely meaningless, except to
## differentiate different stages.

proc write*(this: TextureStage, `out`: ostream) {.importcpp: "#->write(#)".} ## \
## Writes the details of this stage

proc output*(this: TextureStage, `out`: ostream) {.importcpp: "#->output(#)".} ## \
## Just a single line output

proc get_default*(_: typedesc[TextureStage]): TextureStage {.importcpp: "TextureStage::get_default()", header: "textureStage.h".} ## \
## Returns the default TextureStage that will be used for all texturing that
## does not name a particular stage.  This generally handles the normal
## single-texture case.

proc get_class_type*(_: typedesc[TextureStage]): TypeHandle {.importcpp: "TextureStage::get_class_type()", header: "textureStage.h".}

converter upcast_to_CopyOnWriteObject*(this: Geom): CopyOnWriteObject {.importcpp: "(PT(CopyOnWriteObject)(#))".}

converter upcast_to_GeomEnums*(this: Geom): GeomEnums {.importcpp: "((GeomEnums *)(#.p()))".}

proc newGeom*(data: GeomVertexData): Geom {.importcpp: "new Geom(#)".}

proc make_copy*(this: Geom): Geom {.importcpp: "#->make_copy()".} ## \
## Returns a newly-allocated Geom that is a shallow copy of this one.  It will
## be a different Geom pointer, but its internal data may or may not be shared
## with that of the original Geom.

proc get_geom_rendering*(this: Geom): int {.importcpp: "#->get_geom_rendering()".} ## \
## Returns the set of GeomRendering bits that represent the rendering
## properties required to properly render this Geom.

proc get_vertex_data*(this: Geom, current_thread: Thread): GeomVertexData {.importcpp: "#->get_vertex_data(#)".} ## \
## Returns a const pointer to the GeomVertexData, for application code to
## directly examine (but not modify) the geom's underlying data.

proc get_vertex_data*(this: Geom): GeomVertexData {.importcpp: "#->get_vertex_data()".} ## \
## Returns a const pointer to the GeomVertexData, for application code to
## directly examine (but not modify) the geom's underlying data.

proc modify_vertex_data*(this: Geom): GeomVertexData {.importcpp: "#->modify_vertex_data()".} ## \
## Returns a modifiable pointer to the GeomVertexData, so that application
## code may directly maniuplate the geom's underlying data.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc set_vertex_data*(this: Geom, data: GeomVertexData) {.importcpp: "#->set_vertex_data(#)".} ## \
## Replaces the Geom's underlying vertex data table with a completely new
## table.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc offset_vertices*(this: Geom, data: GeomVertexData, offset: int) {.importcpp: "#->offset_vertices(#, #)".} ## \
## Replaces a Geom's vertex table with a new table, and simultaneously adds
## the indicated offset to all vertex references within the Geom's primitives.
## This is intended to be used to combine multiple GeomVertexDatas from
## different Geoms into a single big buffer, with each Geom referencing a
## subset of the vertices in the buffer.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc make_nonindexed*(this: Geom, composite_only: bool): int {.importcpp: "#->make_nonindexed(#)".} ## \
## Converts the geom from indexed to nonindexed by duplicating vertices as
## necessary.  If composite_only is true, then only composite primitives such
## as trifans and tristrips are converted.  Returns the number of
## GeomPrimitive objects converted.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc get_animated_vertex_data*(this: Geom, force: bool, current_thread: Thread): GeomVertexData {.importcpp: "#->get_animated_vertex_data(#, #)".} ## \
## Returns a GeomVertexData that represents the results of computing the
## vertex animation on the CPU for this Geom's vertex data.
##
## If there is no CPU-defined vertex animation on this object, this just
## returns the original object.
##
## If there is vertex animation, but the VertexTransform values have not
## changed since last time, this may return the same pointer it returned
## previously.  Even if the VertexTransform values have changed, it may still
## return the same pointer, but with its contents modified (this is preferred,
## since it allows the graphics backend to update vertex buffers optimally).
##
## If force is false, this method may return immediately with stale data, if
## the vertex data is not completely resident.  If force is true, this method
## will never return stale data, but may block until the data is available.

proc get_animated_vertex_data*(this: Geom, force: bool): GeomVertexData {.importcpp: "#->get_animated_vertex_data(#)".} ## \
## Returns a GeomVertexData that represents the results of computing the
## vertex animation on the CPU for this Geom's vertex data.
##
## If there is no CPU-defined vertex animation on this object, this just
## returns the original object.
##
## If there is vertex animation, but the VertexTransform values have not
## changed since last time, this may return the same pointer it returned
## previously.  Even if the VertexTransform values have changed, it may still
## return the same pointer, but with its contents modified (this is preferred,
## since it allows the graphics backend to update vertex buffers optimally).
##
## If force is false, this method may return immediately with stale data, if
## the vertex data is not completely resident.  If force is true, this method
## will never return stale data, but may block until the data is available.

proc is_empty*(this: Geom): bool {.importcpp: "#->is_empty()".} ## \
## Returns true if there appear to be no vertices to be rendered by this Geom,
## false if has some actual data.

proc get_num_primitives*(this: Geom): clonglong {.importcpp: "#->get_num_primitives()".} ## \
## Returns the number of GeomPrimitive objects stored within the Geom, each of
## which represents a number of primitives of a particular type.

proc get_primitive*(this: Geom, i: clonglong): GeomPrimitive {.importcpp: "#->get_primitive(#)".} ## \
## Returns a const pointer to the ith GeomPrimitive object stored within the
## Geom.  Use this call only to inspect the ith object; use modify_primitive()
## or set_primitive() if you want to modify it.

proc modify_primitive*(this: Geom, i: clonglong): GeomPrimitive {.importcpp: "#->modify_primitive(#)".} ## \
## Returns a modifiable pointer to the ith GeomPrimitive object stored within
## the Geom, so application code can directly manipulate the properties of
## this primitive.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc set_primitive*(this: Geom, i: clonglong, primitive: GeomPrimitive) {.importcpp: "#->set_primitive(#, #)".} ## \
## Replaces the ith GeomPrimitive object stored within the Geom with the new
## object.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc insert_primitive*(this: Geom, i: clonglong, primitive: GeomPrimitive) {.importcpp: "#->insert_primitive(#, #)".} ## \
## Inserts a new GeomPrimitive structure to the Geom object.  This specifies a
## particular subset of vertices that are used to define geometric primitives
## of the indicated type.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc add_primitive*(this: Geom, primitive: GeomPrimitive) {.importcpp: "#->add_primitive(#)".} ## \
## Inserts a new GeomPrimitive structure to the Geom object.  This specifies a
## particular subset of vertices that are used to define geometric primitives
## of the indicated type.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc remove_primitive*(this: Geom, i: clonglong) {.importcpp: "#->remove_primitive(#)".} ## \
## Removes the ith primitive from the list.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc clear_primitives*(this: Geom) {.importcpp: "#->clear_primitives()".} ## \
## Removes all the primitives from the Geom object (but keeps the same table
## of vertices).  You may then re-add primitives one at a time via calls to
## add_primitive().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc decompose*(this: Geom): Geom {.importcpp: "#->decompose()".} ## \
## Decomposes all of the primitives within this Geom, returning the result.
## See GeomPrimitive::decompose().

proc doubleside*(this: Geom): Geom {.importcpp: "#->doubleside()".} ## \
## Doublesides all of the primitives within this Geom, returning the result.
## See GeomPrimitive::doubleside().

proc reverse*(this: Geom): Geom {.importcpp: "#->reverse()".} ## \
## Reverses all of the primitives within this Geom, returning the result.  See
## GeomPrimitive::reverse().

proc rotate*(this: Geom): Geom {.importcpp: "#->rotate()".} ## \
## Rotates all of the primitives within this Geom, returning the result.  See
## GeomPrimitive::rotate().

proc unify*(this: Geom, max_indices: int, preserve_order: bool): Geom {.importcpp: "#->unify(#, #)".} ## \
## Unifies all of the primitives contained within this Geom into a single (or
## as few as possible, within the constraints of max_indices) primitive
## objects.  This may require decomposing the primitives if, for instance, the
## Geom contains both triangle strips and triangle fans.
##
## max_indices represents the maximum number of indices that will be put in
## any one GeomPrimitive.  If preserve_order is true, then the primitives will
## not be reordered during the operation, even if this results in a suboptimal
## result.

proc make_points*(this: Geom): Geom {.importcpp: "#->make_points()".} ## \
## Returns a new Geom with points at all the vertices.  See
## GeomPrimitive::make_points().

proc make_lines*(this: Geom): Geom {.importcpp: "#->make_lines()".} ## \
## Returns a new Geom with lines at all the edges.  See
## GeomPrimitive::make_lines().

proc make_patches*(this: Geom): Geom {.importcpp: "#->make_patches()".} ## \
## Returns a new Geom with each primitive converted into a patch.  Calls
## decompose() first.

proc make_adjacency*(this: Geom): Geom {.importcpp: "#->make_adjacency()".} ## \
## Returns a new Geom with each primitive converted into a corresponding
## version with adjacency information.
##
## @since 1.10.0

proc decompose_in_place*(this: Geom) {.importcpp: "#->decompose_in_place()".} ## \
## Decomposes all of the primitives within this Geom, leaving the results in
## place.  See GeomPrimitive::decompose().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc doubleside_in_place*(this: Geom) {.importcpp: "#->doubleside_in_place()".} ## \
## Doublesides all of the primitives within this Geom, leaving the results in
## place.  See GeomPrimitive::doubleside().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc reverse_in_place*(this: Geom) {.importcpp: "#->reverse_in_place()".} ## \
## Reverses all of the primitives within this Geom, leaving the results in
## place.  See GeomPrimitive::reverse().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc rotate_in_place*(this: Geom) {.importcpp: "#->rotate_in_place()".} ## \
## Rotates all of the primitives within this Geom, leaving the results in
## place.  See GeomPrimitive::rotate().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc unify_in_place*(this: Geom, max_indices: int, preserve_order: bool) {.importcpp: "#->unify_in_place(#, #)".} ## \
## Unifies all of the primitives contained within this Geom into a single (or
## as few as possible, within the constraints of max_indices) primitive
## objects.  This may require decomposing the primitives if, for instance, the
## Geom contains both triangle strips and triangle fans.
##
## max_indices represents the maximum number of indices that will be put in
## any one GeomPrimitive.  If preserve_order is true, then the primitives will
## not be reordered during the operation, even if this results in a suboptimal
## result.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc make_points_in_place*(this: Geom) {.importcpp: "#->make_points_in_place()".} ## \
## Replaces the GeomPrimitives within this Geom with corresponding GeomPoints.
## See GeomPrimitive::make_points().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc make_lines_in_place*(this: Geom) {.importcpp: "#->make_lines_in_place()".} ## \
## Replaces the GeomPrimitives within this Geom with corresponding GeomLines,
## representing a wireframe of the primitives.  See
## GeomPrimitive::make_lines().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc make_patches_in_place*(this: Geom) {.importcpp: "#->make_patches_in_place()".} ## \
## Replaces the GeomPrimitives within this Geom with corresponding
## GeomPatches.  See GeomPrimitive::make_patches().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc make_adjacency_in_place*(this: Geom) {.importcpp: "#->make_adjacency_in_place()".} ## \
## Replaces the GeomPrimitives within this Geom with corresponding versions
## with adjacency information.  See GeomPrimitive::make_adjacency().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.
##
## @since 1.10.0

proc copy_primitives_from*(this: Geom, other: Geom): bool {.importcpp: "#->copy_primitives_from(#)".} ## \
## Copies the primitives from the indicated Geom into this one.  This does
## require that both Geoms contain the same fundamental type primitives, both
## have a compatible shade model, and both use the same GeomVertexData.  Both
## Geoms must also be the same specific class type (i.e.  if one is a
## GeomTextGlyph, they both must be.)
##
## Returns true if the copy is successful, or false otherwise (because the
## Geoms were mismatched).

proc get_num_bytes*(this: Geom): int {.importcpp: "#->get_num_bytes()".} ## \
## Returns the number of bytes consumed by the geom and its primitives (but
## not including its vertex table).

proc get_modified*(this: Geom, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## any of the primitives in the Geom is modified, or the set of primitives is
## modified.  However, this does not include modifications to the vertex data,
## which should be tested separately.

proc get_modified*(this: Geom): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## any of the primitives in the Geom is modified, or the set of primitives is
## modified.  However, this does not include modifications to the vertex data,
## which should be tested separately.

proc request_resident*(this: Geom): bool {.importcpp: "#->request_resident()".} ## \
## Returns true if all the primitive arrays are currently resident in memory.
## If this returns false, the data will be brought back into memory shortly;
## try again later.
##
## This does not also test the Geom's associated GeomVertexData.  That must be
## tested separately.

proc transform_vertices*(this: Geom, mat: LMatrix4) {.importcpp: "#->transform_vertices(#)".} ## \
## Applies the indicated transform to all of the vertices in the Geom.  If the
## Geom happens to share a vertex table with another Geom, this operation will
## duplicate the vertex table instead of breaking the other Geom; however, if
## multiple Geoms with shared tables are transformed by the same matrix, they
## will no longer share tables after the operation.  Consider using the
## GeomTransformer if you will be applying the same transform to multiple
## Geoms.

proc check_valid*(this: Geom): bool {.importcpp: "#->check_valid()".} ## \
## Verifies that the all of the primitives within the geom reference vertices
## that actually exist within the geom's GeomVertexData.  Returns true if the
## geom appears to be valid, false otherwise.

proc check_valid*(this: Geom, vertex_data: GeomVertexData): bool {.importcpp: "#->check_valid(#)".} ## \
## Verifies that the all of the primitives within the geom reference vertices
## that actually exist within the indicated GeomVertexData.  Returns true if
## the geom appears to be valid, false otherwise.

proc get_bounds*(this: Geom, current_thread: Thread): BoundingVolume {.importcpp: "#->get_bounds(#)".} ## \
## Returns the bounding volume for the Geom.

proc get_bounds*(this: Geom): BoundingVolume {.importcpp: "#->get_bounds()".} ## \
## Returns the bounding volume for the Geom.

proc get_nested_vertices*(this: Geom, current_thread: Thread): int {.importcpp: "#->get_nested_vertices(#)".} ## \
## Returns the number of vertices rendered by all primitives within the Geom.

proc get_nested_vertices*(this: Geom): int {.importcpp: "#->get_nested_vertices()".} ## \
## Returns the number of vertices rendered by all primitives within the Geom.

proc mark_bounds_stale*(this: Geom) {.importcpp: "#->mark_bounds_stale()".} ## \
## Marks the bounding volume of the Geom as stale so that it should be
## recomputed.  Usually it is not necessary to call this explicitly.

proc set_bounds*(this: Geom, volume: BoundingVolume) {.importcpp: "#->set_bounds(#)".} ## \
## Resets the bounding volume so that it is the indicated volume.  When it is
## explicitly set, the bounding volume will no longer be automatically
## computed; call clear_bounds() if you would like to return the bounding
## volume to its default behavior.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc clear_bounds*(this: Geom) {.importcpp: "#->clear_bounds()".} ## \
## Reverses the effect of a previous call to set_bounds(), and allows the
## bounding volume to be automatically computed once more based on the
## vertices.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc output*(this: Geom, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: Geom, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: Geom, `out`: ostream) {.importcpp: "#->write(#)".}

proc clear_cache*(this: Geom) {.importcpp: "#->clear_cache()".} ## \
## Removes all of the previously-cached results of munge_geom().
##
## This blows away the entire cache, upstream and downstream the pipeline.
## Use clear_cache_stage() instead if you only want to blow away the cache at
## the current stage and upstream.

proc clear_cache_stage*(this: Geom, current_thread: Thread) {.importcpp: "#->clear_cache_stage(#)".} ## \
## Removes all of the previously-cached results of munge_geom(), at the
## current pipeline stage and upstream.  Does not affect the downstream cache.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc prepare*(this: Geom, prepared_objects: PreparedGraphicsObjects) {.importcpp: "#->prepare(#)".} ## \
## Indicates that the geom should be enqueued to be prepared in the indicated
## prepared_objects at the beginning of the next frame.  This will ensure the
## geom is already loaded into geom memory if it is expected to be rendered
## soon.
##
## Use this function instead of prepare_now() to preload geoms from a user
## interface standpoint.

proc is_prepared*(this: Geom, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->is_prepared(#)".} ## \
## Returns true if the geom has already been prepared or enqueued for
## preparation on the indicated GSG, false otherwise.

proc release*(this: Geom, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->release(#)".} ## \
## Frees the geom context only on the indicated object, if it exists there.
## Returns true if it was released, false if it had not been prepared.

proc release_all*(this: Geom): int {.importcpp: "#->release_all()".} ## \
## Frees the context allocated on all objects for which the geom has been
## declared.  Returns the number of contexts which have been freed.

proc prepare_now*(this: Geom, prepared_objects: PreparedGraphicsObjects, gsg: GraphicsStateGuardianBase): GeomContext {.importcpp: "#->prepare_now(#, #)".} ## \
## Creates a context for the geom on the particular GSG, if it does not
## already exist.  Returns the new (or old) GeomContext.  This assumes that
## the GraphicsStateGuardian is the currently active rendering context and
## that it is ready to accept new geoms.  If this is not necessarily the case,
## you should use prepare() instead.
##
## Normally, this is not called directly except by the GraphicsStateGuardian;
## a geom does not need to be explicitly prepared by the user before it may be
## rendered.

proc get_class_type*(_: typedesc[Geom]): TypeHandle {.importcpp: "Geom::get_class_type()", header: "geom.h".}

proc get_geom*(this: GeomContext): Geom {.importcpp: "#.get_geom()".}

proc get_class_type*(_: typedesc[GeomContext]): TypeHandle {.importcpp: "GeomContext::get_class_type()", header: "geomContext.h".}

proc newGeomLines*(copy: GeomLines): GeomLines {.importcpp: "new GeomLines(#)".}

proc get_class_type*(_: typedesc[GeomLines]): TypeHandle {.importcpp: "GeomLines::get_class_type()", header: "geomLines.h".}

proc newGeomLinesAdjacency*(copy: GeomLinesAdjacency): GeomLinesAdjacency {.importcpp: "new GeomLinesAdjacency(#)".}

proc get_class_type*(_: typedesc[GeomLinesAdjacency]): TypeHandle {.importcpp: "GeomLinesAdjacency::get_class_type()", header: "geomLinesAdjacency.h".}

proc newGeomLinestrips*(copy: GeomLinestrips): GeomLinestrips {.importcpp: "new GeomLinestrips(#)".}

proc get_class_type*(_: typedesc[GeomLinestrips]): TypeHandle {.importcpp: "GeomLinestrips::get_class_type()", header: "geomLinestrips.h".}

proc newGeomLinestripsAdjacency*(copy: GeomLinestripsAdjacency): GeomLinestripsAdjacency {.importcpp: "new GeomLinestripsAdjacency(#)".}

proc get_class_type*(_: typedesc[GeomLinestripsAdjacency]): TypeHandle {.importcpp: "GeomLinestripsAdjacency::get_class_type()", header: "geomLinestripsAdjacency.h".}

proc newGeomPatches*(copy: GeomPatches): GeomPatches {.importcpp: "new GeomPatches(#)".}

proc get_class_type*(_: typedesc[GeomPatches]): TypeHandle {.importcpp: "GeomPatches::get_class_type()", header: "geomPatches.h".}

proc newGeomPoints*(copy: GeomPoints): GeomPoints {.importcpp: "new GeomPoints(#)".}

proc get_class_type*(_: typedesc[GeomPoints]): TypeHandle {.importcpp: "GeomPoints::get_class_type()", header: "geomPoints.h".}

proc newGeomTriangles*(copy: GeomTriangles): GeomTriangles {.importcpp: "new GeomTriangles(#)".}

proc get_class_type*(_: typedesc[GeomTriangles]): TypeHandle {.importcpp: "GeomTriangles::get_class_type()", header: "geomTriangles.h".}

proc newGeomTrianglesAdjacency*(copy: GeomTrianglesAdjacency): GeomTrianglesAdjacency {.importcpp: "new GeomTrianglesAdjacency(#)".}

proc get_class_type*(_: typedesc[GeomTrianglesAdjacency]): TypeHandle {.importcpp: "GeomTrianglesAdjacency::get_class_type()", header: "geomTrianglesAdjacency.h".}

proc newGeomTrifans*(copy: GeomTrifans): GeomTrifans {.importcpp: "new GeomTrifans(#)".}

proc get_class_type*(_: typedesc[GeomTrifans]): TypeHandle {.importcpp: "GeomTrifans::get_class_type()", header: "geomTrifans.h".}

proc newGeomTristrips*(copy: GeomTristrips): GeomTristrips {.importcpp: "new GeomTristrips(#)".}

proc get_class_type*(_: typedesc[GeomTristrips]): TypeHandle {.importcpp: "GeomTristrips::get_class_type()", header: "geomTristrips.h".}

proc newGeomTristripsAdjacency*(copy: GeomTristripsAdjacency): GeomTristripsAdjacency {.importcpp: "new GeomTristripsAdjacency(#)".}

proc get_class_type*(_: typedesc[GeomTristripsAdjacency]): TypeHandle {.importcpp: "GeomTristripsAdjacency::get_class_type()", header: "geomTristripsAdjacency.h".}

proc initGeomVertexReader*(array_data: GeomVertexArrayData, current_thread: Thread): GeomVertexReader {.importcpp: "GeomVertexReader(#, #)".} ## \
## Constructs a new reader to process the vertices of the indicated array
## only.

proc initGeomVertexReader*(array_data: GeomVertexArrayData): GeomVertexReader {.importcpp: "GeomVertexReader(#)".} ## \
## Constructs a new reader to process the vertices of the indicated array
## only.

proc initGeomVertexReader*(array_data: GeomVertexArrayData, column: int, current_thread: Thread): GeomVertexReader {.importcpp: "GeomVertexReader(#, #, #)".} ## \
## Constructs a new reader to process the vertices of the indicated array
## only.

proc initGeomVertexReader*(array_data: GeomVertexArrayData, column: int): GeomVertexReader {.importcpp: "GeomVertexReader(#, #)".} ## \
## Constructs a new reader to process the vertices of the indicated array
## only.

proc initGeomVertexReader*(vertex_data: GeomVertexData, name: InternalName, current_thread: Thread): GeomVertexReader {.importcpp: "GeomVertexReader(#, #, #)".} ## \
## Constructs a new reader to process the vertices of the indicated data
## object.  This flavor creates the reader specifically to process the named
## data type.

proc initGeomVertexReader*(vertex_data: GeomVertexData, name: InternalName): GeomVertexReader {.importcpp: "GeomVertexReader(#, #)".} ## \
## Constructs a new reader to process the vertices of the indicated data
## object.  This flavor creates the reader specifically to process the named
## data type.

proc initGeomVertexReader*(vertex_data: GeomVertexData, current_thread: Thread): GeomVertexReader {.importcpp: "GeomVertexReader(#, #)".} ## \
## Constructs a new reader to process the vertices of the indicated data
## object.

proc initGeomVertexReader*(vertex_data: GeomVertexData): GeomVertexReader {.importcpp: "GeomVertexReader(#)".} ## \
## Constructs a new reader to process the vertices of the indicated data
## object.

proc initGeomVertexReader*(copy: GeomVertexReader): GeomVertexReader {.importcpp: "GeomVertexReader(#)".}

proc initGeomVertexReader*(current_thread: Thread): GeomVertexReader {.importcpp: "GeomVertexReader(#)".} ## \
## Constructs an invalid GeomVertexReader.  You must use the assignment
## operator to assign a valid GeomVertexReader to this object before you can
## use it.

proc initGeomVertexReader*(): GeomVertexReader {.importcpp: "GeomVertexReader()".} ## \
## Constructs an invalid GeomVertexReader.  You must use the assignment
## operator to assign a valid GeomVertexReader to this object before you can
## use it.

proc get_vertex_data*(this: GeomVertexReader): GeomVertexData {.importcpp: "#.get_vertex_data()".} ## \
## Returns the vertex data object that the reader is processing.  This may
## return NULL if the reader was constructed with just an array pointer.

proc get_array_data*(this: GeomVertexReader): GeomVertexArrayData {.importcpp: "#.get_array_data()".} ## \
## Returns the particular array object that the reader is currently
## processing.

proc get_array_handle*(this: GeomVertexReader): GeomVertexArrayDataHandle {.importcpp: "#.get_array_handle()".} ## \
## Returns the read handle to the array object that the read is currently
## processing.  This low-level call should be used with caution.

proc get_stride*(this: GeomVertexReader): clonglong {.importcpp: "#.get_stride()".} ## \
## Returns the per-row stride (bytes between consecutive rows) of the
## underlying vertex array.  This low-level information is normally not needed
## to use the GeomVertexReader directly.

proc get_current_thread*(this: GeomVertexReader): Thread {.importcpp: "#.get_current_thread()".} ## \
## Returns the Thread pointer of the currently-executing thread, as passed to
## the constructor of this object.

proc set_force*(this: GeomVertexReader, force: bool) {.importcpp: "#.set_force(#)".} ## \
## Sets the value of the force flag.  When this is true (the default), vertex
## data will be paged in from disk if necessary.  When this is false, the
## GeomVertexData will simply return a failure code when attempting to read
## vertex data that is not resident (but will put it on the queue to become
## resident later).
##
## Normally, vertex data is always resident, so this will not be an issue.  It
## is only possible for vertex data to be nonresident if you have enabled
## vertex paging via the GeomVertexArrayData and VertexDataPage interfaces.

proc get_force*(this: GeomVertexReader): bool {.importcpp: "#.get_force()".} ## \
## Returns the value of the force flag.  See set_force().

proc set_column*(this: GeomVertexReader, name: InternalName): bool {.importcpp: "#.set_column(#)".} ## \
## Sets up the reader to use the data type with the indicated name.
##
## This also resets the read row number to the start row (the same value
## passed to a previous call to set_row(), or 0 if set_row() was never
## called.)
##
## The return value is true if the data type is valid, false otherwise.

proc set_column*(this: GeomVertexReader, column: int): bool {.importcpp: "#.set_column(#)".} ## \
## Sets up the reader to use the nth data type of the GeomVertexFormat,
## numbering from 0.
##
## This also resets the read row number to the start row (the same value
## passed to a previous call to set_row(), or 0 if set_row() was never
## called.)
##
## The return value is true if the data type is valid, false otherwise.

proc set_column*(this: GeomVertexReader, array: int, column: GeomVertexColumn): bool {.importcpp: "#.set_column(#, #)".} ## \
## Sets up the reader to use the indicated column description on the given
## array.
##
## This also resets the current read row number to the start row (the same
## value passed to a previous call to set_row(), or 0 if set_row() was never
## called.)
##
## The return value is true if the data type is valid, false otherwise.

proc clear*(this: GeomVertexReader) {.importcpp: "#.clear()".} ## \
## Resets the GeomVertexReader to the initial state.

proc has_column*(this: GeomVertexReader): bool {.importcpp: "#.has_column()".} ## \
## Returns true if a valid data type has been successfully set, or false if
## the data type does not exist (or if get_force() is false and the vertex
## data is nonresident).

proc get_array*(this: GeomVertexReader): int {.importcpp: "#.get_array()".} ## \
## Returns the array index containing the data type that the reader is working
## on.

proc get_column*(this: GeomVertexReader): GeomVertexColumn {.importcpp: "#.get_column()".} ## \
## Returns the description of the data type that the reader is working on.

proc set_row_unsafe*(this: GeomVertexReader, row: int) {.importcpp: "#.set_row_unsafe(#)".} ## \
## Sets the start row to the indicated value, without internal checks.  This
## is the same as set_row(), but it does not check for the possibility that
## the array has been reallocated internally for some reason; use only when
## you are confident that the array is unchanged and you really need every bit
## of available performance.

proc set_row*(this: GeomVertexReader, row: int) {.importcpp: "#.set_row(#)".} ## \
## Sets the start row to the indicated value.  The reader will begin reading
## from the indicated row; each subsequent get_data*() call will return the
## data from the subsequent row.  If set_column() is called, the reader will
## return to this row.

proc get_start_row*(this: GeomVertexReader): int {.importcpp: "#.get_start_row()".} ## \
## Returns the row index at which the reader started.  It will return to this
## row if you reset the current column.

proc get_read_row*(this: GeomVertexReader): int {.importcpp: "#.get_read_row()".} ## \
## Returns the row index from which the data will be retrieved by the next
## call to get_data*().

proc is_at_end*(this: GeomVertexReader): bool {.importcpp: "#.is_at_end()".} ## \
## Returns true if the reader is currently at the end of the list of vertices,
## false otherwise.  If this is true, another call to get_data*() will result
## in a crash.

proc get_data1f*(this: GeomVertexReader): float32 {.importcpp: "#.get_data1f()".} ## \
## Returns the data associated with the read row, expressed as a 1-component
## value, and advances the read row.

proc get_data2f*(this: GeomVertexReader): LVecBase2f {.importcpp: "#.get_data2f()".} ## \
## Returns the data associated with the read row, expressed as a 2-component
## value, and advances the read row.

proc get_data3f*(this: GeomVertexReader): LVecBase3f {.importcpp: "#.get_data3f()".} ## \
## Returns the data associated with the read row, expressed as a 3-component
## value, and advances the read row.

proc get_data4f*(this: GeomVertexReader): LVecBase4f {.importcpp: "#.get_data4f()".} ## \
## Returns the data associated with the read row, expressed as a 4-component
## value, and advances the read row.

proc get_matrix3f*(this: GeomVertexReader): LMatrix3f {.importcpp: "#.get_matrix3f()".} ## \
## Returns the 3-by-3 matrix associated with the read row and advances the
## read row.  This is a special method that only works when the column in
## question contains a matrix of an appropriate size.

proc get_matrix4f*(this: GeomVertexReader): LMatrix4f {.importcpp: "#.get_matrix4f()".} ## \
## Returns the 4-by-4 matrix associated with the read row and advances the
## read row.  This is a special method that only works when the column in
## question contains a matrix of an appropriate size.

proc get_data1d*(this: GeomVertexReader): float64 {.importcpp: "#.get_data1d()".} ## \
## Returns the data associated with the read row, expressed as a 1-component
## value, and advances the read row.

proc get_data2d*(this: GeomVertexReader): LVecBase2d {.importcpp: "#.get_data2d()".} ## \
## Returns the data associated with the read row, expressed as a 2-component
## value, and advances the read row.

proc get_data3d*(this: GeomVertexReader): LVecBase3d {.importcpp: "#.get_data3d()".} ## \
## Returns the data associated with the read row, expressed as a 3-component
## value, and advances the read row.

proc get_data4d*(this: GeomVertexReader): LVecBase4d {.importcpp: "#.get_data4d()".} ## \
## Returns the data associated with the read row, expressed as a 4-component
## value, and advances the read row.

proc get_matrix3d*(this: GeomVertexReader): LMatrix3d {.importcpp: "#.get_matrix3d()".} ## \
## Returns the 3-by-3 matrix associated with the read row and advances the
## read row.  This is a special method that only works when the column in
## question contains a matrix of an appropriate size.

proc get_matrix4d*(this: GeomVertexReader): LMatrix4d {.importcpp: "#.get_matrix4d()".} ## \
## Returns the 4-by-4 matrix associated with the read row and advances the
## read row.  This is a special method that only works when the column in
## question contains a matrix of an appropriate size.

proc get_data1*(this: GeomVertexReader): float32 {.importcpp: "#.get_data1()".} ## \
## Returns the data associated with the read row, expressed as a 1-component
## value, and advances the read row.

proc get_data2*(this: GeomVertexReader): LVecBase2 {.importcpp: "#.get_data2()".} ## \
## Returns the data associated with the read row, expressed as a 2-component
## value, and advances the read row.

proc get_data3*(this: GeomVertexReader): LVecBase3 {.importcpp: "#.get_data3()".} ## \
## Returns the data associated with the read row, expressed as a 3-component
## value, and advances the read row.

proc get_data4*(this: GeomVertexReader): LVecBase4 {.importcpp: "#.get_data4()".} ## \
## Returns the data associated with the read row, expressed as a 4-component
## value, and advances the read row.

proc get_matrix3*(this: GeomVertexReader): LMatrix3 {.importcpp: "#.get_matrix3()".} ## \
## Returns the 3-by-3 matrix associated with the read row and advances the
## read row.  This is a special method that only works when the column in
## question contains a matrix of an appropriate size.

proc get_matrix4*(this: GeomVertexReader): LMatrix4 {.importcpp: "#.get_matrix4()".} ## \
## Returns the 4-by-4 matrix associated with the read row and advances the
## read row.  This is a special method that only works when the column in
## question contains a matrix of an appropriate size.

proc get_data1i*(this: GeomVertexReader): int {.importcpp: "#.get_data1i()".} ## \
## Returns the data associated with the read row, expressed as a 1-component
## value, and advances the read row.

proc get_data2i*(this: GeomVertexReader): LVecBase2i {.importcpp: "#.get_data2i()".} ## \
## Returns the data associated with the read row, expressed as a 2-component
## value, and advances the read row.

proc get_data3i*(this: GeomVertexReader): LVecBase3i {.importcpp: "#.get_data3i()".} ## \
## Returns the data associated with the read row, expressed as a 3-component
## value, and advances the read row.

proc get_data4i*(this: GeomVertexReader): LVecBase4i {.importcpp: "#.get_data4i()".} ## \
## Returns the data associated with the read row, expressed as a 4-component
## value, and advances the read row.

proc output*(this: GeomVertexReader, `out`: ostream) {.importcpp: "#.output(#)".}

proc initGeomVertexWriter*(array_data: GeomVertexArrayData, current_thread: Thread): GeomVertexWriter {.importcpp: "GeomVertexWriter(#, #)".} ## \
## Constructs a new writer to process the vertices of the indicated array
## only.

proc initGeomVertexWriter*(array_data: GeomVertexArrayData): GeomVertexWriter {.importcpp: "GeomVertexWriter(#)".} ## \
## Constructs a new writer to process the vertices of the indicated array
## only.

proc initGeomVertexWriter*(array_data: GeomVertexArrayData, column: int, current_thread: Thread): GeomVertexWriter {.importcpp: "GeomVertexWriter(#, #, #)".} ## \
## Constructs a new writer to process the vertices of the indicated array
## only.

proc initGeomVertexWriter*(array_data: GeomVertexArrayData, column: int): GeomVertexWriter {.importcpp: "GeomVertexWriter(#, #)".} ## \
## Constructs a new writer to process the vertices of the indicated array
## only.

proc initGeomVertexWriter*(vertex_data: GeomVertexData, name: InternalName, current_thread: Thread): GeomVertexWriter {.importcpp: "GeomVertexWriter(#, #, #)".} ## \
## Constructs a new writer to process the vertices of the indicated data
## object.  This flavor creates the writer specifically to process the named
## data type.

proc initGeomVertexWriter*(vertex_data: GeomVertexData, name: InternalName): GeomVertexWriter {.importcpp: "GeomVertexWriter(#, #)".} ## \
## Constructs a new writer to process the vertices of the indicated data
## object.  This flavor creates the writer specifically to process the named
## data type.

proc initGeomVertexWriter*(vertex_data: GeomVertexData, current_thread: Thread): GeomVertexWriter {.importcpp: "GeomVertexWriter(#, #)".} ## \
## Constructs a new writer to process the vertices of the indicated data
## object.

proc initGeomVertexWriter*(vertex_data: GeomVertexData): GeomVertexWriter {.importcpp: "GeomVertexWriter(#)".} ## \
## Constructs a new writer to process the vertices of the indicated data
## object.

proc initGeomVertexWriter*(copy: GeomVertexWriter): GeomVertexWriter {.importcpp: "GeomVertexWriter(#)".}

proc initGeomVertexWriter*(current_thread: Thread): GeomVertexWriter {.importcpp: "GeomVertexWriter(#)".} ## \
## Constructs an invalid GeomVertexWriter.  You must use the assignment
## operator to assign a valid GeomVertexWriter to this object before you can
## use it.

proc initGeomVertexWriter*(): GeomVertexWriter {.importcpp: "GeomVertexWriter()".} ## \
## Constructs an invalid GeomVertexWriter.  You must use the assignment
## operator to assign a valid GeomVertexWriter to this object before you can
## use it.

proc get_vertex_data*(this: GeomVertexWriter): GeomVertexData {.importcpp: "#.get_vertex_data()".} ## \
## Returns the vertex data object that the writer is processing.  This may
## return NULL if the writer was constructed with just an array pointer.

proc get_array_data*(this: GeomVertexWriter): GeomVertexArrayData {.importcpp: "#.get_array_data()".} ## \
## Returns the particular array object that the writer is currently
## processing.

proc get_array_handle*(this: GeomVertexWriter): GeomVertexArrayDataHandle {.importcpp: "#.get_array_handle()".} ## \
## Returns the write handle to the array object that the writer is currently
## processing.  This low-level call should be used with caution; be careful
## with modifying the data in the handle out from under the GeomVertexWriter.

proc get_stride*(this: GeomVertexWriter): clonglong {.importcpp: "#.get_stride()".} ## \
## Returns the per-row stride (bytes between consecutive rows) of the
## underlying vertex array.  This low-level information is normally not needed
## to use the GeomVertexWriter directly.

proc get_current_thread*(this: GeomVertexWriter): Thread {.importcpp: "#.get_current_thread()".} ## \
## Returns the Thread pointer of the currently-executing thread, as passed to
## the constructor of this object.

proc set_column*(this: GeomVertexWriter, name: InternalName): bool {.importcpp: "#.set_column(#)".} ## \
## Sets up the writer to use the data type with the indicated name.
##
## This also resets the write number to the start row (the same value passed
## to a previous call to set_row(), or 0 if set_row() was never called.)
##
## The return value is true if the data type is valid, false otherwise.

proc set_column*(this: GeomVertexWriter, column: int): bool {.importcpp: "#.set_column(#)".} ## \
## Sets up the writer to use the nth data type of the GeomVertexFormat,
## numbering from 0.
##
## This also resets the write row number to the start row (the same value
## passed to a previous call to set_row(), or 0 if set_row() was never
## called.)
##
## The return value is true if the data type is valid, false otherwise.

proc set_column*(this: GeomVertexWriter, array: int, column: GeomVertexColumn): bool {.importcpp: "#.set_column(#, #)".} ## \
## Sets up the writer to use the indicated column description on the given
## array.
##
## This also resets the current write row number to the start row (the same
## value passed to a previous call to set_row(), or 0 if set_row() was never
## called.)
##
## The return value is true if the data type is valid, false otherwise.

proc clear*(this: GeomVertexWriter) {.importcpp: "#.clear()".} ## \
## Resets the GeomVertexWriter to the initial state.

proc reserve_num_rows*(this: GeomVertexWriter, num_rows: int): bool {.importcpp: "#.reserve_num_rows(#)".} ## \
## This ensures that enough memory space for num_rows is allocated, so that
## you may add up to num_rows rows without causing a new memory allocation.
## This is a performance optimization only; it is especially useful when you
## know the number of rows you will be adding ahead of time.

proc has_column*(this: GeomVertexWriter): bool {.importcpp: "#.has_column()".} ## \
## Returns true if a valid data type has been successfully set, or false if
## the data type does not exist.

proc get_array*(this: GeomVertexWriter): int {.importcpp: "#.get_array()".} ## \
## Returns the array index containing the data type that the writer is working
## on.

proc get_column*(this: GeomVertexWriter): GeomVertexColumn {.importcpp: "#.get_column()".} ## \
## Returns the description of the data type that the writer is working on.

proc set_row_unsafe*(this: GeomVertexWriter, row: int) {.importcpp: "#.set_row_unsafe(#)".} ## \
## Sets the start row to the indicated value, without internal checks.  This
## is the same as set_row(), but it does not check for the possibility that
## the array has been reallocated internally for some reason; use only when
## you are confident that the array is unchanged and you really need every bit
## of available performance.

proc set_row*(this: GeomVertexWriter, row: int) {.importcpp: "#.set_row(#)".} ## \
## Sets the start row to the indicated value.  The writer will begin writing
## to the indicated row; each subsequent set_data*() call will store the data
## into the subsequent row.  If set_column() is called, the writer will return
## to this row.

proc get_start_row*(this: GeomVertexWriter): int {.importcpp: "#.get_start_row()".} ## \
## Returns the row index at which the writer started.  It will return to this
## row if you reset the current column.

proc get_write_row*(this: GeomVertexWriter): int {.importcpp: "#.get_write_row()".} ## \
## Returns the row index to which the data will be written at the next call to
## set_data*() or add_data*().

proc is_at_end*(this: GeomVertexWriter): bool {.importcpp: "#.is_at_end()".} ## \
## Returns true if the writer is currently at the end of the list of vertices,
## false otherwise.  If this is true, another call to set_data*() will result
## in a crash, but another call to add_data*() will add a new row.

proc set_data1f*(this: GeomVertexWriter, data: float32) {.importcpp: "#.set_data1f(#)".} ## \
## Sets the write row to a particular 1-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data2f*(this: GeomVertexWriter, data: LVecBase2f) {.importcpp: "#.set_data2f(#)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data2f*(this: GeomVertexWriter, x: float32, y: float32) {.importcpp: "#.set_data2f(#, #)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data3f*(this: GeomVertexWriter, data: LVecBase3f) {.importcpp: "#.set_data3f(#)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data3f*(this: GeomVertexWriter, x: float32, y: float32, z: float32) {.importcpp: "#.set_data3f(#, #, #)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data4f*(this: GeomVertexWriter, data: LVecBase4f) {.importcpp: "#.set_data4f(#)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data4f*(this: GeomVertexWriter, x: float32, y: float32, z: float32, w: float32) {.importcpp: "#.set_data4f(#, #, #, #)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_matrix3f*(this: GeomVertexWriter, mat: LMatrix3f) {.importcpp: "#.set_matrix3f(#)".} ## \
## Sets the write row to a 3-by-3 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## It is an error for the write row to advance past the end of data.

proc set_matrix4f*(this: GeomVertexWriter, mat: LMatrix4f) {.importcpp: "#.set_matrix4f(#)".} ## \
## Sets the write row to a 4-by-4 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## It is an error for the write row to advance past the end of data.

proc set_data1d*(this: GeomVertexWriter, data: float64) {.importcpp: "#.set_data1d(#)".} ## \
## Sets the write row to a particular 1-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data2d*(this: GeomVertexWriter, data: LVecBase2d) {.importcpp: "#.set_data2d(#)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data2d*(this: GeomVertexWriter, x: float64, y: float64) {.importcpp: "#.set_data2d(#, #)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data3d*(this: GeomVertexWriter, data: LVecBase3d) {.importcpp: "#.set_data3d(#)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data3d*(this: GeomVertexWriter, x: float64, y: float64, z: float64) {.importcpp: "#.set_data3d(#, #, #)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data4d*(this: GeomVertexWriter, data: LVecBase4d) {.importcpp: "#.set_data4d(#)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data4d*(this: GeomVertexWriter, x: float64, y: float64, z: float64, w: float64) {.importcpp: "#.set_data4d(#, #, #, #)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_matrix3d*(this: GeomVertexWriter, mat: LMatrix3d) {.importcpp: "#.set_matrix3d(#)".} ## \
## Sets the write row to a 3-by-3 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## It is an error for the write row to advance past the end of data.

proc set_matrix4d*(this: GeomVertexWriter, mat: LMatrix4d) {.importcpp: "#.set_matrix4d(#)".} ## \
## Sets the write row to a 4-by-4 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## It is an error for the write row to advance past the end of data.

proc set_data1*(this: GeomVertexWriter, data: float32) {.importcpp: "#.set_data1(#)".} ## \
## Sets the write row to a particular 1-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data2*(this: GeomVertexWriter, data: LVecBase2) {.importcpp: "#.set_data2(#)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data2*(this: GeomVertexWriter, x: float32, y: float32) {.importcpp: "#.set_data2(#, #)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data3*(this: GeomVertexWriter, data: LVecBase3) {.importcpp: "#.set_data3(#)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data3*(this: GeomVertexWriter, x: float32, y: float32, z: float32) {.importcpp: "#.set_data3(#, #, #)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data4*(this: GeomVertexWriter, data: LVecBase4) {.importcpp: "#.set_data4(#)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data4*(this: GeomVertexWriter, x: float32, y: float32, z: float32, w: float32) {.importcpp: "#.set_data4(#, #, #, #)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_matrix3*(this: GeomVertexWriter, mat: LMatrix3) {.importcpp: "#.set_matrix3(#)".} ## \
## Sets the write row to a 3-by-3 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## It is an error for the write row to advance past the end of data.

proc set_matrix4*(this: GeomVertexWriter, mat: LMatrix4) {.importcpp: "#.set_matrix4(#)".} ## \
## Sets the write row to a 4-by-4 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## It is an error for the write row to advance past the end of data.

proc set_data1i*(this: GeomVertexWriter, data: int) {.importcpp: "#.set_data1i(#)".} ## \
## Sets the write row to a particular 1-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data2i*(this: GeomVertexWriter, data: LVecBase2i) {.importcpp: "#.set_data2i(#)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data2i*(this: GeomVertexWriter, a: int, b: int) {.importcpp: "#.set_data2i(#, #)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data3i*(this: GeomVertexWriter, data: LVecBase3i) {.importcpp: "#.set_data3i(#)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data3i*(this: GeomVertexWriter, a: int, b: int, c: int) {.importcpp: "#.set_data3i(#, #, #)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data4i*(this: GeomVertexWriter, data: LVecBase4i) {.importcpp: "#.set_data4i(#)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc set_data4i*(this: GeomVertexWriter, a: int, b: int, c: int, d: int) {.importcpp: "#.set_data4i(#, #, #, #)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc add_data1f*(this: GeomVertexWriter, data: float32) {.importcpp: "#.add_data1f(#)".} ## \
## Sets the write row to a particular 1-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data2f*(this: GeomVertexWriter, data: LVecBase2f) {.importcpp: "#.add_data2f(#)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data2f*(this: GeomVertexWriter, x: float32, y: float32) {.importcpp: "#.add_data2f(#, #)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data3f*(this: GeomVertexWriter, data: LVecBase3f) {.importcpp: "#.add_data3f(#)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data3f*(this: GeomVertexWriter, x: float32, y: float32, z: float32) {.importcpp: "#.add_data3f(#, #, #)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data4f*(this: GeomVertexWriter, data: LVecBase4f) {.importcpp: "#.add_data4f(#)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data4f*(this: GeomVertexWriter, x: float32, y: float32, z: float32, w: float32) {.importcpp: "#.add_data4f(#, #, #, #)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_matrix3f*(this: GeomVertexWriter, mat: LMatrix3f) {.importcpp: "#.add_matrix3f(#)".} ## \
## Sets the write row to a 3-by-3 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_matrix4f*(this: GeomVertexWriter, mat: LMatrix4f) {.importcpp: "#.add_matrix4f(#)".} ## \
## Sets the write row to a 4-by-4 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data1d*(this: GeomVertexWriter, data: float64) {.importcpp: "#.add_data1d(#)".} ## \
## Sets the write row to a particular 1-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data2d*(this: GeomVertexWriter, data: LVecBase2d) {.importcpp: "#.add_data2d(#)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data2d*(this: GeomVertexWriter, x: float64, y: float64) {.importcpp: "#.add_data2d(#, #)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data3d*(this: GeomVertexWriter, data: LVecBase3d) {.importcpp: "#.add_data3d(#)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data3d*(this: GeomVertexWriter, x: float64, y: float64, z: float64) {.importcpp: "#.add_data3d(#, #, #)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data4d*(this: GeomVertexWriter, data: LVecBase4d) {.importcpp: "#.add_data4d(#)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data4d*(this: GeomVertexWriter, x: float64, y: float64, z: float64, w: float64) {.importcpp: "#.add_data4d(#, #, #, #)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_matrix3d*(this: GeomVertexWriter, mat: LMatrix3d) {.importcpp: "#.add_matrix3d(#)".} ## \
## Sets the write row to a 3-by-3 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_matrix4d*(this: GeomVertexWriter, mat: LMatrix4d) {.importcpp: "#.add_matrix4d(#)".} ## \
## Sets the write row to a 4-by-4 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data1*(this: GeomVertexWriter, data: float32) {.importcpp: "#.add_data1(#)".} ## \
## Sets the write row to a particular 1-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data2*(this: GeomVertexWriter, data: LVecBase2) {.importcpp: "#.add_data2(#)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data2*(this: GeomVertexWriter, x: float32, y: float32) {.importcpp: "#.add_data2(#, #)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data3*(this: GeomVertexWriter, data: LVecBase3) {.importcpp: "#.add_data3(#)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data3*(this: GeomVertexWriter, x: float32, y: float32, z: float32) {.importcpp: "#.add_data3(#, #, #)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data4*(this: GeomVertexWriter, data: LVecBase4) {.importcpp: "#.add_data4(#)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data4*(this: GeomVertexWriter, x: float32, y: float32, z: float32, w: float32) {.importcpp: "#.add_data4(#, #, #, #)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_matrix3*(this: GeomVertexWriter, mat: LMatrix3) {.importcpp: "#.add_matrix3(#)".} ## \
## Sets the write row to a 3-by-3 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_matrix4*(this: GeomVertexWriter, mat: LMatrix4) {.importcpp: "#.add_matrix4(#)".} ## \
## Sets the write row to a 4-by-4 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data1i*(this: GeomVertexWriter, data: int) {.importcpp: "#.add_data1i(#)".} ## \
## Sets the write row to a particular 1-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data2i*(this: GeomVertexWriter, data: LVecBase2i) {.importcpp: "#.add_data2i(#)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data2i*(this: GeomVertexWriter, a: int, b: int) {.importcpp: "#.add_data2i(#, #)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data3i*(this: GeomVertexWriter, data: LVecBase3i) {.importcpp: "#.add_data3i(#)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data3i*(this: GeomVertexWriter, a: int, b: int, c: int) {.importcpp: "#.add_data3i(#, #, #)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data4i*(this: GeomVertexWriter, data: LVecBase4i) {.importcpp: "#.add_data4i(#)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc add_data4i*(this: GeomVertexWriter, a: int, b: int, c: int, d: int) {.importcpp: "#.add_data4i(#, #, #, #)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc output*(this: GeomVertexWriter, `out`: ostream) {.importcpp: "#.output(#)".}

converter upcast_to_GeomVertexWriter*(this: GeomVertexRewriter): GeomVertexWriter {.importcpp: "#.upcast_to_GeomVertexWriter()".}

converter upcast_to_GeomVertexReader*(this: GeomVertexRewriter): GeomVertexReader {.importcpp: "#.upcast_to_GeomVertexReader()".}

proc initGeomVertexRewriter*(array_data: GeomVertexArrayData, current_thread: Thread): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#, #)".} ## \
## Constructs a new rewriter to process the vertices of the indicated array
## only.

proc initGeomVertexRewriter*(array_data: GeomVertexArrayData): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#)".} ## \
## Constructs a new rewriter to process the vertices of the indicated array
## only.

proc initGeomVertexRewriter*(array_data: GeomVertexArrayData, column: int, current_thread: Thread): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#, #, #)".} ## \
## Constructs a new rewriter to process the vertices of the indicated array
## only.

proc initGeomVertexRewriter*(array_data: GeomVertexArrayData, column: int): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#, #)".} ## \
## Constructs a new rewriter to process the vertices of the indicated array
## only.

proc initGeomVertexRewriter*(vertex_data: GeomVertexData, name: InternalName, current_thread: Thread): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#, #, #)".} ## \
## Constructs a new rewriter to process the vertices of the indicated data
## object.  This flavor creates the rewriter specifically to process the named
## data type.

proc initGeomVertexRewriter*(vertex_data: GeomVertexData, name: InternalName): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#, #)".} ## \
## Constructs a new rewriter to process the vertices of the indicated data
## object.  This flavor creates the rewriter specifically to process the named
## data type.

proc initGeomVertexRewriter*(vertex_data: GeomVertexData, current_thread: Thread): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#, #)".} ## \
## Constructs a new rewriter to process the vertices of the indicated data
## object.

proc initGeomVertexRewriter*(vertex_data: GeomVertexData): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#)".} ## \
## Constructs a new rewriter to process the vertices of the indicated data
## object.

proc initGeomVertexRewriter*(copy: GeomVertexRewriter): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#)".}

proc initGeomVertexRewriter*(current_thread: Thread): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#)".} ## \
## Constructs an invalid GeomVertexRewriter.  You must use the assignment
## operator to assign a valid GeomVertexRewriter to this object before you can
## use it.

proc initGeomVertexRewriter*(): GeomVertexRewriter {.importcpp: "GeomVertexRewriter()".} ## \
## Constructs an invalid GeomVertexRewriter.  You must use the assignment
## operator to assign a valid GeomVertexRewriter to this object before you can
## use it.

proc get_vertex_data*(this: GeomVertexRewriter): GeomVertexData {.importcpp: "#.get_vertex_data()".} ## \
## Returns the vertex data object that the rewriter is processing.

proc get_array_data*(this: GeomVertexRewriter): GeomVertexArrayData {.importcpp: "#.get_array_data()".} ## \
## Returns the particular array object that the rewriter is currently
## processing.

proc get_array_handle*(this: GeomVertexRewriter): GeomVertexArrayDataHandle {.importcpp: "#.get_array_handle()".} ## \
## Returns the write handle to the array object that the rewriter is currently
## processing.  This low-level call should be used with caution; be careful
## with modifying the data in the handle out from under the
## GeomVertexRewriter.

proc get_stride*(this: GeomVertexRewriter): clonglong {.importcpp: "#.get_stride()".} ## \
## Returns the per-row stride (bytes between consecutive rows) of the
## underlying vertex array.  This low-level information is normally not needed
## to use the GeomVertexRewriter directly.

proc get_current_thread*(this: GeomVertexRewriter): Thread {.importcpp: "#.get_current_thread()".} ## \
## Returns the Thread pointer of the currently-executing thread, as passed to
## the constructor of this object.

proc set_column*(this: GeomVertexRewriter, name: InternalName): bool {.importcpp: "#.set_column(#)".} ## \
## Sets up the rewriter to use the data type with the indicated name.
##
## This also resets both the read and write row numbers to the start row (the
## same value passed to a previous call to set_row(), or 0 if set_row() was
## never called.)
##
## The return value is true if the data type is valid, false otherwise.

proc set_column*(this: GeomVertexRewriter, column: int): bool {.importcpp: "#.set_column(#)".} ## \
## Sets up the rewriter to use the nth data type of the GeomVertexFormat,
## numbering from 0.
##
## This also resets both the read and write row numbers to the start row (the
## same value passed to a previous call to set_row(), or 0 if set_row() was
## never called.)
##
## The return value is true if the data type is valid, false otherwise.

proc set_column*(this: GeomVertexRewriter, array: int, column: GeomVertexColumn): bool {.importcpp: "#.set_column(#, #)".} ## \
## Sets up the rewriter to use the indicated column description on the given
## array.
##
## This also resets both the read and write row numbers to the start row (the
## same value passed to a previous call to set_row(), or 0 if set_row() was
## never called.)
##
## The return value is true if the data type is valid, false otherwise.

proc clear*(this: GeomVertexRewriter) {.importcpp: "#.clear()".} ## \
## Resets the GeomVertexRewriter to the initial state.

proc has_column*(this: GeomVertexRewriter): bool {.importcpp: "#.has_column()".} ## \
## Returns true if a valid data type has been successfully set, or false if
## the data type does not exist.

proc get_array*(this: GeomVertexRewriter): int {.importcpp: "#.get_array()".} ## \
## Returns the array index containing the data type that the rewriter is
## working on.

proc get_column*(this: GeomVertexRewriter): GeomVertexColumn {.importcpp: "#.get_column()".} ## \
## Returns the description of the data type that the rewriter is working on.

proc set_row_unsafe*(this: GeomVertexRewriter, row: int) {.importcpp: "#.set_row_unsafe(#)".} ## \
## Sets the start row to the indicated value, without internal checks.  This
## is the same as set_row(), but it does not check for the possibility that
## the array has been reallocated internally for some reason; use only when
## you are confident that the array is unchanged and you really need every bit
## of available performance.

proc set_row*(this: GeomVertexRewriter, row: int) {.importcpp: "#.set_row(#)".} ## \
## Sets the start, write, and write index to the indicated value.  The
## rewriter will begin traversing from the given row.

proc get_start_row*(this: GeomVertexRewriter): int {.importcpp: "#.get_start_row()".} ## \
## Returns the row index at which the rewriter started.  It will return to
## this row if you reset the current column.

proc is_at_end*(this: GeomVertexRewriter): bool {.importcpp: "#.is_at_end()".} ## \
## Returns true if the reader or writer is currently at the end of the list of
## vertices, false otherwise.

proc output*(this: GeomVertexRewriter, `out`: ostream) {.importcpp: "#.output(#)".}

proc initSamplerState*(): SamplerState {.importcpp: "SamplerState()".} ## \
## Creates a new SamplerState initialized to the default values.

proc initSamplerState*(param0: SamplerState): SamplerState {.importcpp: "SamplerState(#)".}

proc get_default*(_: typedesc[SamplerState]): SamplerState {.importcpp: "SamplerState::get_default()", header: "samplerState.h".} ## \
## Returns a reference to the global default immutable SamplerState object.

proc set_anisotropic_degree*(this: SamplerState, anisotropic_degree: int) {.importcpp: "#.set_anisotropic_degree(#)".} ## \
## Specifies the level of anisotropic filtering to apply to the SamplerState.
## Set this 0 to indicate the default value, which is specified in the
## SamplerState-anisotropic-degree config variable.
##
## To explicitly disable anisotropic filtering, set this value to 1.  To
## explicitly enable anisotropic filtering, set it to a value higher than 1;
## larger numbers indicate greater degrees of filtering.

proc set_border_color*(this: SamplerState, color: LColor) {.importcpp: "#.set_border_color(#)".} ## \
## Specifies the solid color of the SamplerState's border.  Some OpenGL
## implementations use a border for tiling SamplerStates; in Panda, it is only
## used for specifying the clamp color.

proc set_min_lod*(this: SamplerState, min_lod: float32) {.importcpp: "#.set_min_lod(#)".} ## \
## Sets the minimum level of detail that will be used when sampling this
## texture.  This may be a negative value.

proc set_max_lod*(this: SamplerState, max_lod: float32) {.importcpp: "#.set_max_lod(#)".} ## \
## Sets the maximum level of detail that will be used when sampling this
## texture.  This may exceed the number of mipmap levels that the texture has.

proc set_lod_bias*(this: SamplerState, lod_bias: float32) {.importcpp: "#.set_lod_bias(#)".} ## \
## Sets the value that will be added to the level of detail when sampling the
## texture.  This may be a negative value, although some graphics hardware may
## not support the use of negative LOD values.

proc get_anisotropic_degree*(this: SamplerState): int {.importcpp: "#.get_anisotropic_degree()".} ## \
## Returns the degree of anisotropic filtering that should be applied to the
## texture.  This value may return 0, indicating the default value; see also
## get_effective_anisotropic_degree.

proc get_effective_anisotropic_degree*(this: SamplerState): int {.importcpp: "#.get_effective_anisotropic_degree()".} ## \
## Returns the degree of anisotropic filtering that should be applied to the
## texture.  This value will normally not return 0, unless there is an error
## in the config file.

proc get_border_color*(this: SamplerState): LColor {.importcpp: "#.get_border_color()".} ## \
## Returns the solid color of the texture's border.  Some OpenGL
## implementations use a border for tiling textures; in Panda, it is only used
## for specifying the clamp color.

proc get_min_lod*(this: SamplerState): float32 {.importcpp: "#.get_min_lod()".} ## \
## Returns the minimum level of detail that will be observed when sampling
## this texture.

proc get_max_lod*(this: SamplerState): float32 {.importcpp: "#.get_max_lod()".} ## \
## Returns the maximum level of detail that will be observed when sampling
## this texture.

proc get_lod_bias*(this: SamplerState): float32 {.importcpp: "#.get_lod_bias()".} ## \
## Returns the bias that will be added to the texture level of detail when
## sampling this texture.

proc uses_mipmaps*(this: SamplerState): bool {.importcpp: "#.uses_mipmaps()".} ## \
## Returns true if the minfilter settings on this sampler indicate the use of
## mipmapping, false otherwise.

proc `==`*(this: SamplerState, other: SamplerState): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: SamplerState, other: SamplerState): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: SamplerState, other: SamplerState): bool {.importcpp: "#.operator <(#)".}

proc prepare*(this: SamplerState, prepared_objects: PreparedGraphicsObjects) {.importcpp: "#.prepare(#)".} ## \
## Indicates that the sampler should be enqueued to be prepared in the
## indicated prepared_objects at the beginning of the next frame.
##
## Use this function instead of prepare_now() to preload samplers from a user
## interface standpoint.

proc is_prepared*(this: SamplerState, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#.is_prepared(#)".} ## \
## Returns true if the sampler has already been prepared or enqueued for
## preparation on the indicated GSG, false otherwise.

proc release*(this: SamplerState, prepared_objects: PreparedGraphicsObjects) {.importcpp: "#.release(#)".} ## \
## Frees the texture context only on the indicated object, if it exists there.
## Returns true if it was released, false if it had not been prepared.

proc get_class_type*(_: typedesc[SamplerState]): TypeHandle {.importcpp: "SamplerState::get_class_type()", header: "samplerState.h".}

converter upcast_to_TypedWritableReferenceCount*(this: Texture): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcast_to_Namable*(this: Texture): Namable {.importcpp: "((Namable *)(#.p()))".}

proc newTexture*(name: string): Texture {.importcpp: "new Texture(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Constructs an empty texture.  The default is to set up the texture as an
## empty 2-d texture; follow up with one of the variants of setup_texture() if
## this is not what you want.

proc newTexture*(): Texture {.importcpp: "new Texture()".} ## \
## Constructs an empty texture.  The default is to set up the texture as an
## empty 2-d texture; follow up with one of the variants of setup_texture() if
## this is not what you want.

proc make_copy*(this: Texture): Texture {.importcpp: "#->make_copy()".} ## \
## Returns a new copy of the same Texture.  This copy, if applied to geometry,
## will be copied into texture as a separate texture from the original, so it
## will be duplicated in texture memory (and may be independently modified if
## desired).
##
## If the Texture is a VideoTexture, the resulting duplicate may be animated
## independently of the original.

proc clear*(this: Texture) {.importcpp: "#->clear()".} ## \
## Reinitializes the texture to its default, empty state (except for the
## name).

proc setup_1d_texture*(this: Texture) {.importcpp: "#->setup_1d_texture()".} ## \
## Sets the texture as an empty 1-d texture with no dimensions.  Follow up
## with read() or load() to fill the texture properties and image data, or use
## set_clear_color to let the texture be cleared to a solid color.

proc setup_2d_texture*(this: Texture) {.importcpp: "#->setup_2d_texture()".} ## \
## Sets the texture as an empty 2-d texture with no dimensions.  Follow up
## with read() or load() to fill the texture properties and image data, or use
## set_clear_color to let the texture be cleared to a solid color.

proc setup_3d_texture*(this: Texture, z_size: int) {.importcpp: "#->setup_3d_texture(#)".} ## \
## Sets the texture as an empty 3-d texture with no dimensions (though if you
## know the depth ahead of time, it saves a bit of reallocation later). Follow
## up with read() or load() to fill the texture properties and image data, or
## use set_clear_color to let the texture be cleared to a solid color.

proc setup_3d_texture*(this: Texture) {.importcpp: "#->setup_3d_texture()".} ## \
## Sets the texture as an empty 3-d texture with no dimensions (though if you
## know the depth ahead of time, it saves a bit of reallocation later). Follow
## up with read() or load() to fill the texture properties and image data, or
## use set_clear_color to let the texture be cleared to a solid color.

proc setup_cube_map*(this: Texture) {.importcpp: "#->setup_cube_map()".} ## \
## Sets the texture as an empty cube map texture with no dimensions.  Follow
## up with read() or load() to fill the texture properties and image data, or
## use set_clear_color to let the texture be cleared to a solid color.

proc setup_2d_texture_array*(this: Texture, z_size: int) {.importcpp: "#->setup_2d_texture_array(#)".} ## \
## Sets the texture as an empty 2-d texture array with no dimensions (though
## if you know the depth ahead of time, it saves a bit of reallocation later).
## Follow up with read() or load() to fill the texture properties and image
## data, or use set_clear_color to let the texture be cleared to a solid
## color.

proc setup_2d_texture_array*(this: Texture) {.importcpp: "#->setup_2d_texture_array()".} ## \
## Sets the texture as an empty 2-d texture array with no dimensions (though
## if you know the depth ahead of time, it saves a bit of reallocation later).
## Follow up with read() or load() to fill the texture properties and image
## data, or use set_clear_color to let the texture be cleared to a solid
## color.

proc setup_cube_map_array*(this: Texture, num_cube_maps: int) {.importcpp: "#->setup_cube_map_array(#)".} ## \
## Sets the texture as cube map array with N cube maps.  Note that this number
## is not the same as the z_size.  Follow up with read() or load() to fill the
## texture properties and image data, or use set_clear_color to let the
## texture be cleared to a solid color.
##
## @since 1.10.0

proc generate_normalization_cube_map*(this: Texture, size: int) {.importcpp: "#->generate_normalization_cube_map(#)".} ## \
## Generates a special cube map image in the texture that can be used to apply
## bump mapping effects: for each texel in the cube map that is indexed by the
## 3-d texture coordinates (x, y, z), the resulting value is the normalized
## vector (x, y, z) (compressed from -1..1 into 0..1).

proc generate_alpha_scale_map*(this: Texture) {.importcpp: "#->generate_alpha_scale_map()".} ## \
## Generates a special 256x1 1-d texture that can be used to apply an
## arbitrary alpha scale to objects by judicious use of texture matrix.  The
## texture is a gradient, with an alpha of 0 on the left (U = 0), and 255 on
## the right (U = 1).

proc clear_image*(this: Texture) {.importcpp: "#->clear_image()".} ## \
## Clears the texture data without changing its format or resolution.  The
## texture is cleared on both the graphics hardware and from RAM, unlike
## clear_ram_image, which only removes the data from RAM.
##
## If a clear color has been specified using set_clear_color, the texture will
## be cleared using a solid color.
##
## The texture data will be cleared the first time in which the texture is
## used after this method is called.

proc has_clear_color*(this: Texture): bool {.importcpp: "#->has_clear_color()".} ## \
## Returns true if a color was previously set using set_clear_color.

proc get_clear_color*(this: Texture): LColor {.importcpp: "#->get_clear_color()".} ## \
## Returns the color that was previously set using set_clear_color.

proc set_clear_color*(this: Texture, color: LColor) {.importcpp: "#->set_clear_color(#)".} ## \
## Sets the color that will be used to fill the texture image in absence of
## any image data.  It is used when any of the setup_texture functions or
## clear_image is called and image data is not provided using read() or
## modify_ram_image().
##
## This does not affect a texture that has already been cleared; call
## clear_image to clear it again.

proc clear_clear_color*(this: Texture) {.importcpp: "#->clear_clear_color()".} ## \
## The opposite of set_clear_color.  If the image is cleared after setting
## this, its contents may be undefined (or may in fact not be cleared at all).

proc read*(this: Texture, fullpath: Filename, alpha_fullpath: Filename, primary_file_num_channels: int, alpha_file_channel: int, options: LoaderOptions): bool {.importcpp: "#->read(#, #, #, #, #)".} ## \
## Combine a 3-component image with a grayscale image to get a 4-component
## image.
##
## See the description of the full-parameter read() method for the meaning of
## the primary_file_num_channels and alpha_file_channel parameters.

proc read*(this: Texture, fullpath: Filename, alpha_fullpath: Filename, primary_file_num_channels: int, alpha_file_channel: int): bool {.importcpp: "#->read(#, #, #, #)".} ## \
## Combine a 3-component image with a grayscale image to get a 4-component
## image.
##
## See the description of the full-parameter read() method for the meaning of
## the primary_file_num_channels and alpha_file_channel parameters.

proc read*(this: Texture, fullpath: Filename, alpha_fullpath: Filename, primary_file_num_channels: int, alpha_file_channel: int, z: int, n: int, read_pages: bool, read_mipmaps: bool, record: BamCacheRecord, options: LoaderOptions): bool {.importcpp: "#->read(#, #, #, #, #, #, #, #, #, #)".} ## \
## Reads the texture from the indicated filename.  If
## primary_file_num_channels is not 0, it specifies the number of components
## to downgrade the image to if it is greater than this number.
##
## If the filename has the extension .txo, this implicitly reads a texture
## object instead of a filename (which replaces all of the texture
## properties).  In this case, all the rest of the parameters are ignored, and
## the filename should not contain any hash marks; just the one named file
## will be read, since a single .txo file can contain all pages and mipmaps
## necessary to define a texture.
##
## If alpha_fullpath is not empty, it specifies the name of a file from which
## to retrieve the alpha.  In this case, alpha_file_channel represents the
## numeric channel of this image file to use as the resulting texture's alpha
## channel; usually, this is 0 to indicate the grayscale combination of r, g,
## b; or it may be a one-based channel number, e.g.  1 for the red channel, 2
## for the green channel, and so on.
##
## If read pages is false, then z indicates the page number into which this
## image will be assigned.  Normally this is 0 for the first (or only) page of
## the texture.  3-D textures have one page for each level of depth, and cube
## map textures always have six pages.
##
## If read_pages is true, multiple images will be read at once, one for each
## page of a cube map or a 3-D texture.  In this case, the filename should
## contain a sequence of one or more hash marks ("#") which will be filled in
## with the z value of each page, zero-based.  In this case, the z parameter
## indicates the maximum z value that will be loaded, or 0 to load all
## filenames that exist.
##
## If read_mipmaps is false, then n indicates the mipmap level to which this
## image will be assigned.  Normally this is 0 for the base texture image, but
## it is possible to load custom mipmap levels into the later images.  After
## the base texture image is loaded (thus defining the size of the texture),
## you can call get_expected_num_mipmap_levels() to determine the maximum
## sensible value for n.
##
## If read_mipmaps is true, multiple images will be read as above, but this
## time the images represent the different mipmap levels of the texture image.
## In this case, the n parameter indicates the maximum n value that will be
## loaded, or 0 to load all filenames that exist (up to the expected number of
## mipmap levels).
##
## If both read_pages and read_mipmaps is true, then both sequences will be
## read; the filename should contain two sequences of hash marks, separated by
## some character such as a hyphen, underscore, or dot.  The first hash mark
## sequence will be filled in with the mipmap level, while the second hash
## mark sequence will be the page index.
##
## This method implicitly sets keep_ram_image to false.

proc read*(this: Texture, fullpath: Filename, alpha_fullpath: Filename, primary_file_num_channels: int, alpha_file_channel: int, z: int, n: int, read_pages: bool, read_mipmaps: bool, record: BamCacheRecord): bool {.importcpp: "#->read(#, #, #, #, #, #, #, #, #)".} ## \
## Reads the texture from the indicated filename.  If
## primary_file_num_channels is not 0, it specifies the number of components
## to downgrade the image to if it is greater than this number.
##
## If the filename has the extension .txo, this implicitly reads a texture
## object instead of a filename (which replaces all of the texture
## properties).  In this case, all the rest of the parameters are ignored, and
## the filename should not contain any hash marks; just the one named file
## will be read, since a single .txo file can contain all pages and mipmaps
## necessary to define a texture.
##
## If alpha_fullpath is not empty, it specifies the name of a file from which
## to retrieve the alpha.  In this case, alpha_file_channel represents the
## numeric channel of this image file to use as the resulting texture's alpha
## channel; usually, this is 0 to indicate the grayscale combination of r, g,
## b; or it may be a one-based channel number, e.g.  1 for the red channel, 2
## for the green channel, and so on.
##
## If read pages is false, then z indicates the page number into which this
## image will be assigned.  Normally this is 0 for the first (or only) page of
## the texture.  3-D textures have one page for each level of depth, and cube
## map textures always have six pages.
##
## If read_pages is true, multiple images will be read at once, one for each
## page of a cube map or a 3-D texture.  In this case, the filename should
## contain a sequence of one or more hash marks ("#") which will be filled in
## with the z value of each page, zero-based.  In this case, the z parameter
## indicates the maximum z value that will be loaded, or 0 to load all
## filenames that exist.
##
## If read_mipmaps is false, then n indicates the mipmap level to which this
## image will be assigned.  Normally this is 0 for the base texture image, but
## it is possible to load custom mipmap levels into the later images.  After
## the base texture image is loaded (thus defining the size of the texture),
## you can call get_expected_num_mipmap_levels() to determine the maximum
## sensible value for n.
##
## If read_mipmaps is true, multiple images will be read as above, but this
## time the images represent the different mipmap levels of the texture image.
## In this case, the n parameter indicates the maximum n value that will be
## loaded, or 0 to load all filenames that exist (up to the expected number of
## mipmap levels).
##
## If both read_pages and read_mipmaps is true, then both sequences will be
## read; the filename should contain two sequences of hash marks, separated by
## some character such as a hyphen, underscore, or dot.  The first hash mark
## sequence will be filled in with the mipmap level, while the second hash
## mark sequence will be the page index.
##
## This method implicitly sets keep_ram_image to false.

proc read*(this: Texture, fullpath: Filename, alpha_fullpath: Filename, primary_file_num_channels: int, alpha_file_channel: int, z: int, n: int, read_pages: bool, read_mipmaps: bool): bool {.importcpp: "#->read(#, #, #, #, #, #, #, #)".} ## \
## Reads the texture from the indicated filename.  If
## primary_file_num_channels is not 0, it specifies the number of components
## to downgrade the image to if it is greater than this number.
##
## If the filename has the extension .txo, this implicitly reads a texture
## object instead of a filename (which replaces all of the texture
## properties).  In this case, all the rest of the parameters are ignored, and
## the filename should not contain any hash marks; just the one named file
## will be read, since a single .txo file can contain all pages and mipmaps
## necessary to define a texture.
##
## If alpha_fullpath is not empty, it specifies the name of a file from which
## to retrieve the alpha.  In this case, alpha_file_channel represents the
## numeric channel of this image file to use as the resulting texture's alpha
## channel; usually, this is 0 to indicate the grayscale combination of r, g,
## b; or it may be a one-based channel number, e.g.  1 for the red channel, 2
## for the green channel, and so on.
##
## If read pages is false, then z indicates the page number into which this
## image will be assigned.  Normally this is 0 for the first (or only) page of
## the texture.  3-D textures have one page for each level of depth, and cube
## map textures always have six pages.
##
## If read_pages is true, multiple images will be read at once, one for each
## page of a cube map or a 3-D texture.  In this case, the filename should
## contain a sequence of one or more hash marks ("#") which will be filled in
## with the z value of each page, zero-based.  In this case, the z parameter
## indicates the maximum z value that will be loaded, or 0 to load all
## filenames that exist.
##
## If read_mipmaps is false, then n indicates the mipmap level to which this
## image will be assigned.  Normally this is 0 for the base texture image, but
## it is possible to load custom mipmap levels into the later images.  After
## the base texture image is loaded (thus defining the size of the texture),
## you can call get_expected_num_mipmap_levels() to determine the maximum
## sensible value for n.
##
## If read_mipmaps is true, multiple images will be read as above, but this
## time the images represent the different mipmap levels of the texture image.
## In this case, the n parameter indicates the maximum n value that will be
## loaded, or 0 to load all filenames that exist (up to the expected number of
## mipmap levels).
##
## If both read_pages and read_mipmaps is true, then both sequences will be
## read; the filename should contain two sequences of hash marks, separated by
## some character such as a hyphen, underscore, or dot.  The first hash mark
## sequence will be filled in with the mipmap level, while the second hash
## mark sequence will be the page index.
##
## This method implicitly sets keep_ram_image to false.

proc read*(this: Texture, fullpath: Filename, options: LoaderOptions): bool {.importcpp: "#->read(#, #)".} ## \
## Reads the named filename into the texture.

proc read*(this: Texture, fullpath: Filename): bool {.importcpp: "#->read(#)".} ## \
## Reads the named filename into the texture.

proc read*(this: Texture, fullpath: Filename, z: int, n: int, read_pages: bool, read_mipmaps: bool, options: LoaderOptions): bool {.importcpp: "#->read(#, #, #, #, #, #)".} ## \
## Reads a single file into a single page or mipmap level, or automatically
## reads a series of files into a series of pages and/or mipmap levels.
##
## See the description of the full-parameter read() method for the meaning of
## the various parameters.

proc read*(this: Texture, fullpath: Filename, z: int, n: int, read_pages: bool, read_mipmaps: bool): bool {.importcpp: "#->read(#, #, #, #, #)".} ## \
## Reads a single file into a single page or mipmap level, or automatically
## reads a series of files into a series of pages and/or mipmap levels.
##
## See the description of the full-parameter read() method for the meaning of
## the various parameters.

proc write*(this: Texture, fullpath: Filename): bool {.importcpp: "#->write(#)".} ## \
## Writes the texture to the named filename.

proc write*(this: Texture, fullpath: Filename, z: int, n: int, write_pages: bool, write_mipmaps: bool): bool {.importcpp: "#->write(#, #, #, #, #)".} ## \
## Writes a single page or mipmap level to a single file, or automatically
## writes a series of pages and/or mipmap levels to a numbered series of
## files.
##
## If the filename ends in the extension .txo, this implicitly writes a Panda
## texture object (.txo) instead of an image file.  In this case, the
## remaining parameters are ignored, and only one file is written, which will
## contain all of the pages and resident mipmap levels in the texture.
##
## If write_pages is false, then z indicates the page number to write.  3-D
## textures have one page number for each level of depth; cube maps have six
## pages number 0 through 5.  Other kinds of textures have only one page,
## numbered 0.  If there are multiple views, the range of z is increased; the
## total range is [0, get_num_pages()).
##
## If write_pages is true, then all pages of the texture will be written.  In
## this case z is ignored, and the filename should contain a sequence of hash
## marks ("#") which will be filled in with the page index number.
##
## If write_mipmaps is false, then n indicates the mipmap level number to
## write.  Normally, this is 0, for the base texture image.  Normally, the
## mipmap levels of a texture are not available in RAM (they are generated
## automatically by the graphics card). However, if you have the mipmap levels
## available, for instance because you called generate_ram_mipmap_images() to
## generate them internally, or you called
## GraphicsEngine::extract_texture_data() to retrieve them from the graphics
## card, then you may write out each mipmap level with this parameter.
##
## If write_mipmaps is true, then all mipmap levels of the texture will be
## written.  In this case n is ignored, and the filename should contain a
## sequence of hash marks ("#") which will be filled in with the mipmap level
## number.
##
## If both write_pages and write_mipmaps is true, then all pages and all
## mipmap levels will be written.  In this case, the filename should contain
## two different sequences of hash marks, separated by a character such as a
## hyphen, underscore, or dot.  The first hash mark sequence will be filled in
## with the mipmap level, while the second hash mark sequence will be the page
## index.

proc read_txo*(this: Texture, `in`: istream, filename: string): bool {.importcpp: "#->read_txo(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reads the texture from a Panda texture object.  This defines the complete
## Texture specification, including the image data as well as all texture
## properties.  This only works if the txo file contains a static Texture
## image, as opposed to a subclass of Texture such as a movie texture.
##
## Pass a real filename if it is available, or empty string if it is not.

proc read_txo*(this: Texture, `in`: istream): bool {.importcpp: "#->read_txo(#)".} ## \
## Reads the texture from a Panda texture object.  This defines the complete
## Texture specification, including the image data as well as all texture
## properties.  This only works if the txo file contains a static Texture
## image, as opposed to a subclass of Texture such as a movie texture.
##
## Pass a real filename if it is available, or empty string if it is not.

proc make_from_txo*(_: typedesc[Texture], `in`: istream, filename: string): Texture {.importcpp: "Texture::make_from_txo(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Constructs a new Texture object from the txo file.  This is similar to
## Texture::read_txo(), but it constructs and returns a new object, which
## allows it to return a subclass of Texture (for instance, a movie texture).
##
## Pass a real filename if it is available, or empty string if it is not.

proc make_from_txo*(_: typedesc[Texture], `in`: istream): Texture {.importcpp: "Texture::make_from_txo(#)", header: "texture.h".} ## \
## Constructs a new Texture object from the txo file.  This is similar to
## Texture::read_txo(), but it constructs and returns a new object, which
## allows it to return a subclass of Texture (for instance, a movie texture).
##
## Pass a real filename if it is available, or empty string if it is not.

proc write_txo*(this: Texture, `out`: ostream, filename: string): bool {.importcpp: "#->write_txo(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Writes the texture to a Panda texture object.  This defines the complete
## Texture specification, including the image data as well as all texture
## properties.
##
## The filename is just for reference.

proc write_txo*(this: Texture, `out`: ostream): bool {.importcpp: "#->write_txo(#)".} ## \
## Writes the texture to a Panda texture object.  This defines the complete
## Texture specification, including the image data as well as all texture
## properties.
##
## The filename is just for reference.

proc read_dds*(this: Texture, `in`: istream, filename: string, header_only: bool): bool {.importcpp: "#->read_dds(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Reads the texture from a DDS file object.  This is a Microsoft-defined file
## format; it is similar in principle to a txo object, in that it is designed
## to contain the texture image in a form as similar as possible to its
## runtime image, and it can contain mipmaps, pre-compressed textures, and so
## on.
##
## As with read_txo, the filename is just for reference.

proc read_dds*(this: Texture, `in`: istream, filename: string): bool {.importcpp: "#->read_dds(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reads the texture from a DDS file object.  This is a Microsoft-defined file
## format; it is similar in principle to a txo object, in that it is designed
## to contain the texture image in a form as similar as possible to its
## runtime image, and it can contain mipmaps, pre-compressed textures, and so
## on.
##
## As with read_txo, the filename is just for reference.

proc read_dds*(this: Texture, `in`: istream): bool {.importcpp: "#->read_dds(#)".} ## \
## Reads the texture from a DDS file object.  This is a Microsoft-defined file
## format; it is similar in principle to a txo object, in that it is designed
## to contain the texture image in a form as similar as possible to its
## runtime image, and it can contain mipmaps, pre-compressed textures, and so
## on.
##
## As with read_txo, the filename is just for reference.

proc read_ktx*(this: Texture, `in`: istream, filename: string, header_only: bool): bool {.importcpp: "#->read_ktx(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Reads the texture from a KTX file object.  This is a Khronos-defined file
## format; it is similar in principle to a dds object, in that it is designed
## to contain the texture image in a form as similar as possible to its
## runtime image, and it can contain mipmaps, pre-compressed textures, and so
## on.
##
## As with read_dds, the filename is just for reference.

proc read_ktx*(this: Texture, `in`: istream, filename: string): bool {.importcpp: "#->read_ktx(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reads the texture from a KTX file object.  This is a Khronos-defined file
## format; it is similar in principle to a dds object, in that it is designed
## to contain the texture image in a form as similar as possible to its
## runtime image, and it can contain mipmaps, pre-compressed textures, and so
## on.
##
## As with read_dds, the filename is just for reference.

proc read_ktx*(this: Texture, `in`: istream): bool {.importcpp: "#->read_ktx(#)".} ## \
## Reads the texture from a KTX file object.  This is a Khronos-defined file
## format; it is similar in principle to a dds object, in that it is designed
## to contain the texture image in a form as similar as possible to its
## runtime image, and it can contain mipmaps, pre-compressed textures, and so
## on.
##
## As with read_dds, the filename is just for reference.

proc load*(this: Texture, pnmimage: PNMImage, options: LoaderOptions): bool {.importcpp: "#->load(#, #)".} ## \
## Replaces the texture with the indicated image.

proc load*(this: Texture, pnmimage: PNMImage): bool {.importcpp: "#->load(#)".} ## \
## Replaces the texture with the indicated image.

proc load*(this: Texture, pnmimage: PNMImage, z: int, n: int, options: LoaderOptions): bool {.importcpp: "#->load(#, #, #, #)".} ## \
## Stores the indicated image in the given page and mipmap level.  See read().

proc load*(this: Texture, pnmimage: PNMImage, z: int, n: int): bool {.importcpp: "#->load(#, #, #)".} ## \
## Stores the indicated image in the given page and mipmap level.  See read().

proc load*(this: Texture, pfm: PfmFile, options: LoaderOptions): bool {.importcpp: "#->load(#, #)".} ## \
## Replaces the texture with the indicated image.

proc load*(this: Texture, pfm: PfmFile): bool {.importcpp: "#->load(#)".} ## \
## Replaces the texture with the indicated image.

proc load*(this: Texture, pfm: PfmFile, z: int, n: int, options: LoaderOptions): bool {.importcpp: "#->load(#, #, #, #)".} ## \
## Stores the indicated image in the given page and mipmap level.  See read().

proc load*(this: Texture, pfm: PfmFile, z: int, n: int): bool {.importcpp: "#->load(#, #, #)".} ## \
## Stores the indicated image in the given page and mipmap level.  See read().

proc load_sub_image*(this: Texture, pnmimage: PNMImage, x: int, y: int, z: int, n: int): bool {.importcpp: "#->load_sub_image(#, #, #, #, #)".} ## \
## Stores the indicated image in a region of the texture.  The texture
## properties remain unchanged.  This can be more efficient than updating an
## entire texture, but has a few restrictions: for one, you must ensure that
## the texture is still in RAM (eg.  using set_keep_ram_image) and it may not
## be compressed.

proc load_sub_image*(this: Texture, pnmimage: PNMImage, x: int, y: int, z: int): bool {.importcpp: "#->load_sub_image(#, #, #, #)".} ## \
## Stores the indicated image in a region of the texture.  The texture
## properties remain unchanged.  This can be more efficient than updating an
## entire texture, but has a few restrictions: for one, you must ensure that
## the texture is still in RAM (eg.  using set_keep_ram_image) and it may not
## be compressed.

proc load_sub_image*(this: Texture, pnmimage: PNMImage, x: int, y: int): bool {.importcpp: "#->load_sub_image(#, #, #)".} ## \
## Stores the indicated image in a region of the texture.  The texture
## properties remain unchanged.  This can be more efficient than updating an
## entire texture, but has a few restrictions: for one, you must ensure that
## the texture is still in RAM (eg.  using set_keep_ram_image) and it may not
## be compressed.

proc store*(this: Texture, pnmimage: PNMImage): bool {.importcpp: "#->store(#)".} ## \
## Saves the texture to the indicated PNMImage, but does not write it to disk.

proc store*(this: Texture, pnmimage: PNMImage, z: int, n: int): bool {.importcpp: "#->store(#, #, #)".} ## \
## Saves the indicated page and mipmap level of the texture to the PNMImage.

proc store*(this: Texture, pfm: PfmFile): bool {.importcpp: "#->store(#)".} ## \
## Saves the texture to the indicated PfmFile, but does not write it to disk.

proc store*(this: Texture, pfm: PfmFile, z: int, n: int): bool {.importcpp: "#->store(#, #, #)".} ## \
## Saves the indicated page and mipmap level of the texture to the PfmFile.

proc reload*(this: Texture): bool {.importcpp: "#->reload()".} ## \
## Re-reads the Texture from its disk file.  Useful when you know the image on
## disk has recently changed, and you want to update the Texture image.
##
## Returns true on success, false on failure (in which case, the Texture may
## or may not still be valid).

proc load_related*(this: Texture, suffix: InternalName): Texture {.importcpp: "#->load_related(#)".} ## \
## Loads a texture whose filename is derived by concatenating a suffix to the
## filename of this texture.  May return NULL, for example, if this texture
## doesn't have a filename.

proc has_filename*(this: Texture): bool {.importcpp: "#->has_filename()".} ## \
## Returns true if the filename has been set and is available.  See
## set_filename().

proc get_filename*(this: Texture): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the filename that has been set.  This is the name of the file as it
## was requested.  Also see get_fullpath().

proc set_filename*(this: Texture, filename: Filename) {.importcpp: "#->set_filename(#)".} ## \
## Sets the name of the file that contains the image's contents.  Normally,
## this is set automatically when the image is loaded, for instance via
## Texture::read().
##
## The Texture's get_name() function used to return the filename, but now
## returns just the basename (without the extension), which is a more useful
## name for identifying an image in show code.

proc clear_filename*(this: Texture) {.importcpp: "#->clear_filename()".} ## \
## Removes the alpha filename, if it was previously set.  See set_filename().

proc has_alpha_filename*(this: Texture): bool {.importcpp: "#->has_alpha_filename()".} ## \
## Returns true if the alpha_filename has been set and is available.  See
## set_alpha_filename().

proc get_alpha_filename*(this: Texture): Filename {.importcpp: "#->get_alpha_filename()".} ## \
## Returns the alpha_filename that has been set.  If this is set, it
## represents the name of the alpha component, which is stored in a separate
## file.  See also get_filename(), and get_alpha_fullpath().

proc set_alpha_filename*(this: Texture, alpha_filename: Filename) {.importcpp: "#->set_alpha_filename(#)".} ## \
## Sets the name of the file that contains the image's alpha channel contents.
## Normally, this is set automatically when the image is loaded, for instance
## via Texture::read().
##
## The Texture's get_filename() function returns the name of the image file
## that was loaded into the buffer.  In the case where a texture specified two
## separate files to load, a 1- or 3-channel color image and a 1-channel alpha
## image, this Filename is update to contain the name of the image file that
## was loaded into the buffer's alpha channel.

proc clear_alpha_filename*(this: Texture) {.importcpp: "#->clear_alpha_filename()".} ## \
## Removes the alpha filename, if it was previously set.  See
## set_alpha_filename().

proc has_fullpath*(this: Texture): bool {.importcpp: "#->has_fullpath()".} ## \
## Returns true if the fullpath has been set and is available.  See
## set_fullpath().

proc get_fullpath*(this: Texture): Filename {.importcpp: "#->get_fullpath()".} ## \
## Returns the fullpath that has been set.  This is the full path to the file
## as it was found along the texture search path.

proc set_fullpath*(this: Texture, fullpath: Filename) {.importcpp: "#->set_fullpath(#)".} ## \
## Sets the full pathname to the file that contains the image's contents, as
## found along the search path.  Normally, this is set automatically when the
## image is loaded, for instance via Texture::read().

proc clear_fullpath*(this: Texture) {.importcpp: "#->clear_fullpath()".} ## \
## Removes the alpha fullpath, if it was previously set.  See set_fullpath().

proc has_alpha_fullpath*(this: Texture): bool {.importcpp: "#->has_alpha_fullpath()".} ## \
## Returns true if the alpha_fullpath has been set and is available.  See
## set_alpha_fullpath().

proc get_alpha_fullpath*(this: Texture): Filename {.importcpp: "#->get_alpha_fullpath()".} ## \
## Returns the alpha_fullpath that has been set.  This is the full path to the
## alpha part of the image file as it was found along the texture search path.

proc set_alpha_fullpath*(this: Texture, alpha_fullpath: Filename) {.importcpp: "#->set_alpha_fullpath(#)".} ## \
## Sets the full pathname to the file that contains the image's alpha channel
## contents, as found along the search path.  Normally, this is set
## automatically when the image is loaded, for instance via Texture::read().

proc clear_alpha_fullpath*(this: Texture) {.importcpp: "#->clear_alpha_fullpath()".} ## \
## Removes the alpha fullpath, if it was previously set.  See
## set_alpha_fullpath().

proc get_x_size*(this: Texture): int {.importcpp: "#->get_x_size()".} ## \
## Returns the width of the texture image in texels.

proc set_x_size*(this: Texture, x_size: int) {.importcpp: "#->set_x_size(#)".} ## \
## Changes the x size indicated for the texture.  This also implicitly unloads
## the texture if it has already been loaded.

proc get_y_size*(this: Texture): int {.importcpp: "#->get_y_size()".} ## \
## Returns the height of the texture image in texels.  For a 1-d texture, this
## will be 1.

proc set_y_size*(this: Texture, y_size: int) {.importcpp: "#->set_y_size(#)".} ## \
## Changes the y size indicated for the texture.  This also implicitly unloads
## the texture if it has already been loaded.

proc get_z_size*(this: Texture): int {.importcpp: "#->get_z_size()".} ## \
## Returns the depth of the texture image in texels.  For a 1-d texture or 2-d
## texture, this will be 1. For a cube map texture, this will be 6.

proc set_z_size*(this: Texture, z_size: int) {.importcpp: "#->set_z_size(#)".} ## \
## Changes the z size indicated for the texture.  This also implicitly unloads
## the texture if it has already been loaded.

proc get_num_views*(this: Texture): int {.importcpp: "#->get_num_views()".} ## \
## Returns the number of "views" in the texture.  A view is a completely
## separate image stored within the Texture object.  Most textures have only
## one view, but a stereo texture, for instance, may have two views, a left
## and a right image.  Other uses for multiple views are not yet defined.
##
## If this value is greater than one, the additional views are accessed as
## additional pages beyond get_z_size().

proc set_num_views*(this: Texture, num_views: int) {.importcpp: "#->set_num_views(#)".} ## \
## Sets the number of "views" within a texture.  A view is a completely
## separate image stored within the Texture object.  Most textures have only
## one view, but a stereo texture, for instance, may have two views, a left
## and a right image.  Other uses for multiple views are not yet defined.
##
## If this value is greater than one, the additional views are accessed as
## additional pages beyond get_z_size().
##
## This also implicitly unloads the texture if it has already been loaded.

proc get_num_pages*(this: Texture): int {.importcpp: "#->get_num_pages()".} ## \
## Returns the total number of pages in the texture.  Each "page" is a 2-d
## texture image within the larger image--a face of a cube map, or a level of
## a 3-d texture.  Normally, get_num_pages() is the same as get_z_size().
## However, in a multiview texture, this returns get_z_size() *
## get_num_views().

proc get_num_components*(this: Texture): int {.importcpp: "#->get_num_components()".} ## \
## Returns the number of color components for each texel of the texture image.
## This is 3 for an rgb texture or 4 for an rgba texture; it may also be 1 or
## 2 for a grayscale texture.

proc get_component_width*(this: Texture): int {.importcpp: "#->get_component_width()".} ## \
## Returns the number of bytes stored for each color component of a texel.
## Typically this is 1, but it may be 2 for 16-bit texels.

proc get_anisotropic_degree*(this: Texture): int {.importcpp: "#->get_anisotropic_degree()".} ## \
## Returns the degree of anisotropic filtering that should be applied to the
## texture.  This value may return 0, indicating the default value; see also
## get_effective_anisotropic_degree.
##
## This returns the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

proc get_effective_anisotropic_degree*(this: Texture): int {.importcpp: "#->get_effective_anisotropic_degree()".} ## \
## Returns the degree of anisotropic filtering that should be applied to the
## texture.  This value will normally not return 0, unless there is an error
## in the config file.
##
## This returns the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

proc set_anisotropic_degree*(this: Texture, anisotropic_degree: int) {.importcpp: "#->set_anisotropic_degree(#)".} ## \
## Specifies the level of anisotropic filtering to apply to the texture.  Set
## this 0 to indicate the default value, which is specified in the texture-
## anisotropic-degree config variable.
##
## To explicitly disable anisotropic filtering, set this value to 1.  To
## explicitly enable anisotropic filtering, set it to a value higher than 1;
## larger numbers indicate greater degrees of filtering.
##
## This sets the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

proc get_border_color*(this: Texture): LColor {.importcpp: "#->get_border_color()".} ## \
## Returns the solid color of the texture's border.  Some OpenGL
## implementations use a border for tiling textures; in Panda, it is only used
## for specifying the clamp color.
##
## This returns the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

proc set_border_color*(this: Texture, color: LColor) {.importcpp: "#->set_border_color(#)".} ## \
## Specifies the solid color of the texture's border.  Some OpenGL
## implementations use a border for tiling textures; in Panda, it is only used
## for specifying the clamp color.
##
## This sets the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

proc has_compression*(this: Texture): bool {.importcpp: "#->has_compression()".} ## \
## Returns true if the texture indicates it wants to be compressed, either
## with CM_on or higher, or CM_default and compressed-textures is true.
##
## If true returned, this is not a guarantee that the texture is actually
## successfully compressed on the GSG.  It may be that the GSG does not
## support the requested compression mode, in which case the texture may
## actually be stored uncompressed in texture memory.

proc get_render_to_texture*(this: Texture): bool {.importcpp: "#->get_render_to_texture()".} ## \
## Returns a flag on the texture that indicates whether the texture is
## intended to be used as a direct-render target, by binding a framebuffer to
## a texture and rendering directly into the texture.
##
## Normally, a user should not need to set this flag directly; it is set
## automatically by the low-level display code when a texture is bound to a
## framebuffer.

proc set_render_to_texture*(this: Texture, render_to_texture: bool) {.importcpp: "#->set_render_to_texture(#)".} ## \
## Sets a flag on the texture that indicates whether the texture is intended
## to be used as a direct-render target, by binding a framebuffer to a texture
## and rendering directly into the texture.
##
## This controls some low-level choices made about the texture object itself.
## For instance, compressed textures are disallowed when this flag is set
## true.
##
## Normally, a user should not need to set this flag directly; it is set
## automatically by the low-level display code when a texture is bound to a
## framebuffer.

proc get_default_sampler*(this: Texture): SamplerState {.importcpp: "#->get_default_sampler()".} ## \
## This returns the default sampler state for this texture, containing the
## wrap and filter properties specified on the texture level; it may still be
## overridden by a sampler state specified at a higher level.

proc set_default_sampler*(this: Texture, sampler: SamplerState) {.importcpp: "#->set_default_sampler(#)".} ## \
## This sets the default sampler state for this texture, containing the wrap
## and filter properties specified on the texture level; it may still be
## overridden by a sampler state specified at a higher level.  This
## encompasses the settings for get_wrap_u, get_minfilter,
## get_anisotropic_degree, etc.
##
## This makes a copy of the SamplerState object, so future modifications of
## the same SamplerState will have no effect on this texture unless you call
## set_default_sampler again.

proc uses_mipmaps*(this: Texture): bool {.importcpp: "#->uses_mipmaps()".} ## \
## Returns true if the minfilter settings on this texture indicate the use of
## mipmapping, false otherwise.

proc get_expected_num_mipmap_levels*(this: Texture): int {.importcpp: "#->get_expected_num_mipmap_levels()".} ## \
## Returns the number of mipmap levels that should be defined for this
## texture, given the texture's size.
##
## Note that this returns a number appropriate for mipmapping, even if the
## texture does not currently have mipmapping enabled.

proc get_expected_mipmap_x_size*(this: Texture, n: int): int {.importcpp: "#->get_expected_mipmap_x_size(#)".} ## \
## Returns the x_size that the nth mipmap level should have, based on the
## texture's size.

proc get_expected_mipmap_y_size*(this: Texture, n: int): int {.importcpp: "#->get_expected_mipmap_y_size(#)".} ## \
## Returns the y_size that the nth mipmap level should have, based on the
## texture's size.

proc get_expected_mipmap_z_size*(this: Texture, n: int): int {.importcpp: "#->get_expected_mipmap_z_size(#)".} ## \
## Returns the z_size that the nth mipmap level should have, based on the
## texture's size.

proc get_expected_mipmap_num_pages*(this: Texture, n: int): int {.importcpp: "#->get_expected_mipmap_num_pages(#)".} ## \
## Returns the total number of pages that the nth mipmap level should have,
## based on the texture's size.  This is usually the same as
## get_expected_mipmap_z_size(), except for a multiview texture, in which case
## it is get_expected_mipmap_z_size() * get_num_views().

proc has_ram_image*(this: Texture): bool {.importcpp: "#->has_ram_image()".} ## \
## Returns true if the Texture has its image contents available in main RAM,
## false if it exists only in texture memory or in the prepared GSG context.
##
## Note that this has nothing to do with whether get_ram_image() will fail or
## not.  Even if has_ram_image() returns false, get_ram_image() may still
## return a valid RAM image, because get_ram_image() will automatically load
## the texture from disk if necessary.  The only thing has_ram_image() tells
## you is whether the texture is available right now without hitting the disk
## first.
##
## Note also that if an application uses only one GSG, it may appear that
## has_ram_image() returns true if the texture has not yet been loaded by the
## GSG, but this correlation is not true in general and should not be depended
## on.  Specifically, if an application ever uses multiple GSG's in its
## lifetime (for instance, by opening more than one window, or by closing its
## window and opening another one later), then has_ram_image() may well return
## false on textures that have never been loaded on the current GSG.

proc has_uncompressed_ram_image*(this: Texture): bool {.importcpp: "#->has_uncompressed_ram_image()".} ## \
## Returns true if the Texture has its image contents available in main RAM
## and is uncompressed, false otherwise.  See has_ram_image().

proc might_have_ram_image*(this: Texture): bool {.importcpp: "#->might_have_ram_image()".} ## \
## Returns true if the texture's image contents are currently available in
## main RAM, or there is reason to believe it can be loaded on demand.  That
## is, this function returns a "best guess" as to whether get_ram_image() will
## succeed without actually calling it first.

proc get_ram_image_size*(this: Texture): clonglong {.importcpp: "#->get_ram_image_size()".} ## \
## Returns the total number of bytes used by the in-memory image, across all
## pages and views, or 0 if there is no in-memory image.

proc get_ram_view_size*(this: Texture): clonglong {.importcpp: "#->get_ram_view_size()".} ## \
## Returns the number of bytes used by the in-memory image per view, or 0 if
## there is no in-memory image.  Since each view is a stack of z_size pages,
## this is get_z_size() * get_ram_page_size().

proc get_ram_page_size*(this: Texture): clonglong {.importcpp: "#->get_ram_page_size()".} ## \
## Returns the number of bytes used by the in-memory image per page, or 0 if
## there is no in-memory image.
##
## For a non-compressed texture, this is the same as
## get_expected_ram_page_size().  For a compressed texture, this may be a
## smaller value.  (We do assume that all pages will be the same size on a
## compressed texture).

proc get_expected_ram_image_size*(this: Texture): clonglong {.importcpp: "#->get_expected_ram_image_size()".} ## \
## Returns the number of bytes that *ought* to be used by the in-memory image,
## based on the texture parameters.

proc get_expected_ram_page_size*(this: Texture): clonglong {.importcpp: "#->get_expected_ram_page_size()".} ## \
## Returns the number of bytes that should be used per each Z page of the 3-d
## texture.  For a 2-d or 1-d texture, this is the same as
## get_expected_ram_image_size().

proc clear_ram_image*(this: Texture) {.importcpp: "#->clear_ram_image()".} ## \
## Discards the current system-RAM image.

proc set_keep_ram_image*(this: Texture, keep_ram_image: bool) {.importcpp: "#->set_keep_ram_image(#)".} ## \
## Sets the flag that indicates whether this Texture is eligible to have its
## main RAM copy of the texture memory dumped when the texture is prepared for
## rendering.
##
## This will be false for most textures, which can reload their images if
## needed by rereading the input file.  However, textures that were generated
## dynamically and cannot be easily reloaded will want to set this flag to
## true, so that the texture will always keep its image copy around.

proc get_keep_ram_image*(this: Texture): bool {.importcpp: "#->get_keep_ram_image()".} ## \
## Returns the flag that indicates whether this Texture is eligible to have
## its main RAM copy of the texture memory dumped when the texture is prepared
## for rendering.  See set_keep_ram_image().

proc is_cacheable*(this: Texture): bool {.importcpp: "#->is_cacheable()".} ## \
## Returns true if there is enough information in this Texture object to write
## it to the bam cache successfully, false otherwise.  For most textures, this
## is the same as has_ram_image().

proc compress_ram_image*(this: Texture): bool {.importcpp: "#->compress_ram_image()".} ## \
## Attempts to compress the texture's RAM image internally, to a format
## supported by the indicated GSG.  In order for this to work, the squish
## library must have been compiled into Panda.
##
## If compression is CM_on, then an appropriate compression method that is
## supported by the indicated GSG is automatically chosen.  If the GSG pointer
## is NULL, any of the standard DXT1/3/5 compression methods will be used,
## regardless of whether it is supported.
##
## If compression is any specific compression method, that method is used
## regardless of whether the GSG supports it.
##
## quality_level determines the speed/quality tradeoff of the compression.  If
## it is QL_default, the texture's own quality_level parameter is used.
##
## Returns true if successful, false otherwise.

proc uncompress_ram_image*(this: Texture): bool {.importcpp: "#->uncompress_ram_image()".} ## \
## Attempts to uncompress the texture's RAM image internally.  In order for
## this to work, the squish library must have been compiled into Panda, and
## the ram image must be compressed in a format supported by squish.
##
## Returns true if successful, false otherwise.

proc get_num_ram_mipmap_images*(this: Texture): int {.importcpp: "#->get_num_ram_mipmap_images()".} ## \
## Returns the maximum number of mipmap level images available in system
## memory.  The actual number may be less than this (that is, there might be
## gaps in the sequence); use has_ram_mipmap_image() to verify each level.
##
## Also see get_num_loadable_ram_mipmap_images().

proc has_ram_mipmap_image*(this: Texture, n: int): bool {.importcpp: "#->has_ram_mipmap_image(#)".} ## \
## Returns true if the Texture has the nth mipmap level available in system
## memory, false otherwise.  If the texture's minfilter mode requires
## mipmapping (see uses_mipmaps()), and all the texture's mipmap levels are
## not available when the texture is rendered, they will be generated
## automatically.

proc get_num_loadable_ram_mipmap_images*(this: Texture): int {.importcpp: "#->get_num_loadable_ram_mipmap_images()".} ## \
## Returns the number of contiguous mipmap levels that exist in RAM, up until
## the first gap in the sequence.  It is guaranteed that at least mipmap
## levels [0, get_num_ram_mipmap_images()) exist.
##
## The number returned will never exceed the number of required mipmap images
## based on the size of the texture and its filter mode.
##
## This method is different from get_num_ram_mipmap_images() in that it
## returns only the number of mipmap levels that can actually be usefully
## loaded, regardless of the actual number that may be stored.

proc has_all_ram_mipmap_images*(this: Texture): bool {.importcpp: "#->has_all_ram_mipmap_images()".} ## \
## Returns true if all expected mipmap levels have been defined and exist in
## the system RAM, or false if even one mipmap level is missing.

proc get_ram_mipmap_image_size*(this: Texture, n: int): clonglong {.importcpp: "#->get_ram_mipmap_image_size(#)".} ## \
## Returns the number of bytes used by the in-memory image for mipmap level n,
## or 0 if there is no in-memory image for this mipmap level.

proc get_ram_mipmap_view_size*(this: Texture, n: int): clonglong {.importcpp: "#->get_ram_mipmap_view_size(#)".} ## \
## Returns the number of bytes used by the in-memory image per view for mipmap
## level n, or 0 if there is no in-memory image for this mipmap level.
##
## A "view" is a collection of z_size pages for each mipmap level.  Most
## textures have only one view, except for multiview or stereo textures.
##
## For a non-compressed texture, this is the same as
## get_expected_ram_mipmap_view_size().  For a compressed texture, this may be
## a smaller value.  (We do assume that all pages will be the same size on a
## compressed texture).

proc get_ram_mipmap_page_size*(this: Texture, n: int): clonglong {.importcpp: "#->get_ram_mipmap_page_size(#)".} ## \
## Returns the number of bytes used by the in-memory image per page for mipmap
## level n, or 0 if there is no in-memory image for this mipmap level.
##
## For a non-compressed texture, this is the same as
## get_expected_ram_mipmap_page_size().  For a compressed texture, this may be
## a smaller value.  (We do assume that all pages will be the same size on a
## compressed texture).

proc get_expected_ram_mipmap_image_size*(this: Texture, n: int): clonglong {.importcpp: "#->get_expected_ram_mipmap_image_size(#)".} ## \
## Returns the number of bytes that *ought* to be used by the in-memory image
## for mipmap level n, based on the texture parameters.

proc get_expected_ram_mipmap_view_size*(this: Texture, n: int): clonglong {.importcpp: "#->get_expected_ram_mipmap_view_size(#)".} ## \
## Returns the number of bytes that *ought* to be used by each view of the in-
## memory image for mipmap level n, based on the texture parameters.  For a
## normal, non-multiview texture, this is the same as
## get_expected_ram_mipmap_image_size(n).

proc get_expected_ram_mipmap_page_size*(this: Texture, n: int): clonglong {.importcpp: "#->get_expected_ram_mipmap_page_size(#)".} ## \
## Returns the number of bytes that should be used per each Z page of the 3-d
## texture, for mipmap level n.  For a 2-d or 1-d texture, this is the same as
## get_expected_ram_mipmap_view_size(n).

proc get_ram_mipmap_pointer*(this: Texture, n: int) {.importcpp: "#->get_ram_mipmap_pointer(#)".} ## \
## Similiar to get_ram_mipmap_image(), however, in this case the void pointer
## for the given ram image is returned.  This will be NULL unless it has been
## explicitly set.

proc set_ram_mipmap_pointer_from_int*(this: Texture, pointer: clonglong, n: int, page_size: int) {.importcpp: "#->set_ram_mipmap_pointer_from_int(#, #, #)".} ## \
## Accepts a raw pointer cast as an int, which is then passed to
## set_ram_mipmap_pointer(); see the documentation for that method.
##
## This variant is particularly useful to set an external pointer from a
## language like Python, which doesn't support void pointers directly.

proc clear_ram_mipmap_image*(this: Texture, n: int) {.importcpp: "#->clear_ram_mipmap_image(#)".} ## \
## Discards the current system-RAM image for the nth mipmap level.

proc clear_ram_mipmap_images*(this: Texture) {.importcpp: "#->clear_ram_mipmap_images()".} ## \
## Discards the current system-RAM image for all mipmap levels, except level 0
## (the base image).

proc generate_ram_mipmap_images*(this: Texture) {.importcpp: "#->generate_ram_mipmap_images()".} ## \
## Automatically fills in the n mipmap levels of the Texture, based on the
## texture's source image.  This requires the texture's uncompressed ram image
## to be available in system memory.  If it is not already, it will be fetched
## if possible.
##
## This call is not normally necessary, since the mipmap levels will be
## generated automatically if needed.  But there may be certain cases in which
## you would like to call this explicitly.

proc get_simple_x_size*(this: Texture): int {.importcpp: "#->get_simple_x_size()".} ## \
## Returns the width of the "simple" image in texels.

proc get_simple_y_size*(this: Texture): int {.importcpp: "#->get_simple_y_size()".} ## \
## Returns the height of the "simple" image in texels.

proc has_simple_ram_image*(this: Texture): bool {.importcpp: "#->has_simple_ram_image()".} ## \
## Returns true if the Texture has a "simple" image available in main RAM.

proc get_simple_ram_image_size*(this: Texture): clonglong {.importcpp: "#->get_simple_ram_image_size()".} ## \
## Returns the number of bytes used by the "simple" image, or 0 if there is no
## simple image.

proc generate_simple_ram_image*(this: Texture) {.importcpp: "#->generate_simple_ram_image()".} ## \
## Computes the "simple" ram image by loading the main RAM image, if it is not
## already available, and reducing it to 16x16 or smaller.  This may be an
## expensive operation.

proc clear_simple_ram_image*(this: Texture) {.importcpp: "#->clear_simple_ram_image()".} ## \
## Discards the current "simple" image.

proc peek*(this: Texture): TexturePeeker {.importcpp: "#->peek()".} ## \
## Returns a TexturePeeker object that can be used to examine the individual
## texels stored within this Texture by (u, v) coordinate.
##
## If the texture has a ram image resident, that image is used.  If it does
## not have a full ram image but does have a simple_ram_image resident, that
## image is used instead.  If neither image is resident the full image is
## reloaded.
##
## Returns NULL if the texture cannot find an image to load, or the texture
## format is incompatible.

proc get_properties_modified*(this: Texture): UpdateSeq {.importcpp: "#->get_properties_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the texture properties (unrelated to the image) are modified.

proc get_image_modified*(this: Texture): UpdateSeq {.importcpp: "#->get_image_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the texture image data (including mipmap levels) are modified.

proc get_simple_image_modified*(this: Texture): UpdateSeq {.importcpp: "#->get_simple_image_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the texture's "simple" image data is modified.

proc has_auto_texture_scale*(this: Texture): bool {.importcpp: "#->has_auto_texture_scale()".} ## \
## Returns true if set_auto_texture_scale() has been set to something other
## than ATS_unspecified for this particular texture.

proc get_auto_texture_scale*(this: Texture): AutoTextureScale {.importcpp: "#->get_auto_texture_scale()".} ## \
## Returns the power-of-2 texture-scaling mode that will be applied to this
## particular texture when it is next loaded from disk.  See
## set_textures_power_2().

proc set_auto_texture_scale*(this: Texture, scale: AutoTextureScale) {.importcpp: "#->set_auto_texture_scale(#)".} ## \
## Specifies the power-of-2 texture-scaling mode that will be applied to this
## particular texture when it is next loaded from disk.  See
## set_textures_power_2().

proc prepare*(this: Texture, prepared_objects: PreparedGraphicsObjects): AsyncFuture {.importcpp: "#->prepare(#)".} ## \
## Indicates that the texture should be enqueued to be prepared in the
## indicated prepared_objects at the beginning of the next frame.  This will
## ensure the texture is already loaded into texture memory if it is expected
## to be rendered soon.
##
## Use this function instead of prepare_now() to preload textures from a user
## interface standpoint.

proc is_prepared*(this: Texture, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->is_prepared(#)".} ## \
## Returns true if the texture has already been prepared or enqueued for
## preparation on the indicated GSG, false otherwise.

proc was_image_modified*(this: Texture, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->was_image_modified(#)".} ## \
## Returns true if the texture needs to be re-loaded onto the indicated GSG,
## either because its image data is out-of-date, or because it's not fully
## prepared now.

proc get_data_size_bytes*(this: Texture, prepared_objects: PreparedGraphicsObjects): clonglong {.importcpp: "#->get_data_size_bytes(#)".} ## \
## Returns the number of bytes which the texture is reported to consume within
## graphics memory, for the indicated GSG.  This may return a nonzero value
## even if the texture is not currently resident; you should also check
## get_resident() if you want to know how much space the texture is actually
## consuming right now.

proc get_active*(this: Texture, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->get_active(#)".} ## \
## Returns true if this Texture was rendered in the most recent frame within
## the indicated GSG.

proc get_resident*(this: Texture, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->get_resident(#)".} ## \
## Returns true if this Texture is reported to be resident within graphics
## memory for the indicated GSG.

proc release*(this: Texture, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->release(#)".} ## \
## Frees the texture context only on the indicated object, if it exists there.
## Returns true if it was released, false if it had not been prepared.

proc release_all*(this: Texture): int {.importcpp: "#->release_all()".} ## \
## Frees the context allocated on all objects for which the texture has been
## declared.  Returns the number of contexts which have been freed.

proc estimate_texture_memory*(this: Texture): clonglong {.importcpp: "#->estimate_texture_memory()".} ## \
## Estimates the amount of texture memory that will be consumed by loading
## this texture.  This returns a value that is not specific to any particular
## graphics card or driver; it tries to make a reasonable assumption about how
## a driver will load the texture.  It does not account for texture
## compression or anything fancy.  This is mainly useful for debugging and
## reporting purposes.
##
## Returns a value in bytes.

proc set_aux_data*(this: Texture, key: string, aux_data: TypedReferenceCount) {.importcpp: "#->set_aux_data(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Records an arbitrary object in the Texture, associated with a specified
## key.  The object may later be retrieved by calling get_aux_data() with the
## same key.
##
## These data objects are not recorded to a bam or txo file.

proc clear_aux_data*(this: Texture, key: string) {.importcpp: "#->clear_aux_data(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes a record previously recorded via set_aux_data().

proc get_aux_data*(this: Texture, key: string): TypedReferenceCount {.importcpp: "#->get_aux_data(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a record previously recorded via set_aux_data().  Returns NULL if
## there was no record associated with the indicated key.

proc set_textures_power_2*(_: typedesc[Texture], scale: AutoTextureScale) {.importcpp: "Texture::set_textures_power_2(#)", header: "texture.h".} ## \
## Set this flag to ATS_none, ATS_up, ATS_down, or ATS_pad to control the
## scaling of textures in general, if a particular texture does not override
## this.  See also set_auto_texture_scale() for the per-texture override.

proc get_textures_power_2*(_: typedesc[Texture]): AutoTextureScale {.importcpp: "Texture::get_textures_power_2()", header: "texture.h".} ## \
## This flag returns ATS_none, ATS_up, or ATS_down and controls the scaling of
## textures in general.  It is initialized from the config variable of the
## same name, but it can be subsequently adjusted.  See also
## get_auto_texture_scale().

proc has_textures_power_2*(_: typedesc[Texture]): bool {.importcpp: "Texture::has_textures_power_2()", header: "texture.h".} ## \
## If true, then get_textures_power_2 has been set using set_textures_power_2.
## If false, then get_textures_power_2 simply returns the config variable of
## the same name.

proc get_pad_x_size*(this: Texture): int {.importcpp: "#->get_pad_x_size()".} ## \
## Returns size of the pad region.  See set_pad_size.

proc get_pad_y_size*(this: Texture): int {.importcpp: "#->get_pad_y_size()".} ## \
## Returns size of the pad region.  See set_pad_size.

proc get_pad_z_size*(this: Texture): int {.importcpp: "#->get_pad_z_size()".} ## \
## Returns size of the pad region.  See set_pad_size.

proc get_tex_scale*(this: Texture): LVecBase2 {.importcpp: "#->get_tex_scale()".} ## \
## Returns a scale pair that is suitable for applying to geometry via
## NodePath::set_tex_scale(), which will convert texture coordinates on the
## geometry from the range 0..1 into the appropriate range to render the video
## part of the texture.
##
## This is necessary only if a padding size has been set via set_pad_size()
## (or implicitly via something like "textures-power-2 pad" in the config.prc
## file).  In this case, this is a convenient way to generate UV's that
## reflect the built-in padding size.

proc set_pad_size*(this: Texture, x: int, y: int, z: int) {.importcpp: "#->set_pad_size(#, #, #)".} ## \
## Sets the size of the pad region.
##
## Sometimes, when a video card demands power-of-two textures, it is necessary
## to create a big texture and then only use a portion of it.  The pad region
## indicates which portion of the texture is not really in use.  All
## operations use the texture as a whole, including the pad region, unless
## they explicitly state that they use only the non-pad region.
##
## Changing the texture's size clears the pad region.

proc set_pad_size*(this: Texture, x: int, y: int) {.importcpp: "#->set_pad_size(#, #)".} ## \
## Sets the size of the pad region.
##
## Sometimes, when a video card demands power-of-two textures, it is necessary
## to create a big texture and then only use a portion of it.  The pad region
## indicates which portion of the texture is not really in use.  All
## operations use the texture as a whole, including the pad region, unless
## they explicitly state that they use only the non-pad region.
##
## Changing the texture's size clears the pad region.

proc set_pad_size*(this: Texture, x: int) {.importcpp: "#->set_pad_size(#)".} ## \
## Sets the size of the pad region.
##
## Sometimes, when a video card demands power-of-two textures, it is necessary
## to create a big texture and then only use a portion of it.  The pad region
## indicates which portion of the texture is not really in use.  All
## operations use the texture as a whole, including the pad region, unless
## they explicitly state that they use only the non-pad region.
##
## Changing the texture's size clears the pad region.

proc set_pad_size*(this: Texture) {.importcpp: "#->set_pad_size()".} ## \
## Sets the size of the pad region.
##
## Sometimes, when a video card demands power-of-two textures, it is necessary
## to create a big texture and then only use a portion of it.  The pad region
## indicates which portion of the texture is not really in use.  All
## operations use the texture as a whole, including the pad region, unless
## they explicitly state that they use only the non-pad region.
##
## Changing the texture's size clears the pad region.

proc set_size_padded*(this: Texture, x: int, y: int, z: int) {.importcpp: "#->set_size_padded(#, #, #)".} ## \
## Changes the size of the texture, padding if necessary, and setting the pad
## region as well.

proc set_size_padded*(this: Texture, x: int, y: int) {.importcpp: "#->set_size_padded(#, #)".} ## \
## Changes the size of the texture, padding if necessary, and setting the pad
## region as well.

proc set_size_padded*(this: Texture, x: int) {.importcpp: "#->set_size_padded(#)".} ## \
## Changes the size of the texture, padding if necessary, and setting the pad
## region as well.

proc set_size_padded*(this: Texture) {.importcpp: "#->set_size_padded()".} ## \
## Changes the size of the texture, padding if necessary, and setting the pad
## region as well.

proc get_orig_file_x_size*(this: Texture): int {.importcpp: "#->get_orig_file_x_size()".} ## \
## Returns the X size of the original disk image that this Texture was loaded
## from (if it came from a disk file), before any automatic rescaling by
## Panda.

proc get_orig_file_y_size*(this: Texture): int {.importcpp: "#->get_orig_file_y_size()".} ## \
## Returns the Y size of the original disk image that this Texture was loaded
## from (if it came from a disk file), before any automatic rescaling by
## Panda.

proc get_orig_file_z_size*(this: Texture): int {.importcpp: "#->get_orig_file_z_size()".} ## \
## Returns the Z size of the original disk image that this Texture was loaded
## from (if it came from a disk file), before any automatic rescaling by
## Panda.

proc set_orig_file_size*(this: Texture, x: int, y: int, z: int) {.importcpp: "#->set_orig_file_size(#, #, #)".} ## \
## Specifies the size of the texture as it exists in its original disk file,
## before any Panda scaling.

proc set_orig_file_size*(this: Texture, x: int, y: int) {.importcpp: "#->set_orig_file_size(#, #)".} ## \
## Specifies the size of the texture as it exists in its original disk file,
## before any Panda scaling.

proc set_loaded_from_image*(this: Texture, flag: bool) {.importcpp: "#->set_loaded_from_image(#)".} ## \
## Sets the flag that indicates the texture has been loaded from a disk file
## or PNMImage.  You should also ensure the filename has been set correctly.
## When this flag is true, the texture may be automatically reloaded when its
## ram image needs to be replaced.

proc set_loaded_from_image*(this: Texture) {.importcpp: "#->set_loaded_from_image()".} ## \
## Sets the flag that indicates the texture has been loaded from a disk file
## or PNMImage.  You should also ensure the filename has been set correctly.
## When this flag is true, the texture may be automatically reloaded when its
## ram image needs to be replaced.

proc get_loaded_from_image*(this: Texture): bool {.importcpp: "#->get_loaded_from_image()".} ## \
## Returns the flag that indicates the texture has been loaded from a disk
## file or PNMImage.  See set_loaded_from_image().

proc set_loaded_from_txo*(this: Texture, flag: bool) {.importcpp: "#->set_loaded_from_txo(#)".} ## \
## Sets the flag that indicates the texture has been loaded from a txo file.
## You probably shouldn't be setting this directly; it is set automatically
## when a Texture is loaded.

proc set_loaded_from_txo*(this: Texture) {.importcpp: "#->set_loaded_from_txo()".} ## \
## Sets the flag that indicates the texture has been loaded from a txo file.
## You probably shouldn't be setting this directly; it is set automatically
## when a Texture is loaded.

proc get_loaded_from_txo*(this: Texture): bool {.importcpp: "#->get_loaded_from_txo()".} ## \
## Returns the flag that indicates the texture has been loaded from a txo
## file.

proc get_match_framebuffer_format*(this: Texture): bool {.importcpp: "#->get_match_framebuffer_format()".} ## \
## Returns true if the special flag was set that indicates to the GSG that the
## Texture's format should be chosen to exactly match the framebuffer's
## format, presumably because the application intends to copy image data from
## the framebuffer into the Texture (or vice-versa).

proc set_match_framebuffer_format*(this: Texture, flag: bool) {.importcpp: "#->set_match_framebuffer_format(#)".} ## \
## Sets the special flag that, if true, indicates to the GSG that the
## Texture's format should be chosen to exactly match the framebuffer's
## format, presumably because the application intends to copy image data from
## the framebuffer into the Texture (or vice-versa).
##
## This sets only the graphics card's idea of the texture format; it is not
## related to the system-memory format.

proc get_post_load_store_cache*(this: Texture): bool {.importcpp: "#->get_post_load_store_cache()".} ## \
## Returns the setting of the post_load_store_cache flag.  See
## set_post_load_store_cache().

proc set_post_load_store_cache*(this: Texture, flag: bool) {.importcpp: "#->set_post_load_store_cache(#)".} ## \
## Sets the post_load_store_cache flag.  When this is set, the next time the
## texture is loaded on a GSG, it will automatically extract its RAM image
## from the GSG and save it to the global BamCache.
##
## This is used to store compressed RAM images in the BamCache.  This flag
## should not be set explicitly; it is set automatically by the TexturePool
## when model-cache-compressed-textures is set true.

proc prepare_now*(this: Texture, view: int, prepared_objects: PreparedGraphicsObjects, gsg: GraphicsStateGuardianBase): TextureContext {.importcpp: "#->prepare_now(#, #, #)".} ## \
## Creates a context for the texture on the particular GSG, if it does not
## already exist.  Returns the new (or old) TextureContext.  This assumes that
## the GraphicsStateGuardian is the currently active rendering context and
## that it is ready to accept new textures.  If this is not necessarily the
## case, you should use prepare() instead.
##
## Normally, this is not called directly except by the GraphicsStateGuardian;
## a texture does not need to be explicitly prepared by the user before it may
## be rendered.

proc up_to_power_2*(_: typedesc[Texture], value: int): int {.importcpp: "Texture::up_to_power_2(#)", header: "texture.h".} ## \
## Returns the smallest power of 2 greater than or equal to value.

proc down_to_power_2*(_: typedesc[Texture], value: int): int {.importcpp: "Texture::down_to_power_2(#)", header: "texture.h".} ## \
## Returns the largest power of 2 less than or equal to value.

proc consider_rescale*(this: Texture, pnmimage: PNMImage) {.importcpp: "#->consider_rescale(#)".} ## \
## Asks the PNMImage to change its scale when it reads the image, according to
## the whims of the Config.prc file.
##
## For most efficient results, this method should be called after
## pnmimage.read_header() has been called, but before pnmimage.read().  This
## method may also be called after pnmimage.read(), i.e.  when the pnmimage is
## already loaded; in this case it will rescale the image on the spot.  Also
## see rescale_texture().

proc consider_rescale*(_: typedesc[Texture], pnmimage: PNMImage, name: string, auto_texture_scale: AutoTextureScale) {.importcpp: "Texture::consider_rescale(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Asks the PNMImage to change its scale when it reads the image, according to
## the whims of the Config.prc file.
##
## For most efficient results, this method should be called after
## pnmimage.read_header() has been called, but before pnmimage.read().  This
## method may also be called after pnmimage.read(), i.e.  when the pnmimage is
## already loaded; in this case it will rescale the image on the spot.  Also
## see rescale_texture().

proc consider_rescale*(_: typedesc[Texture], pnmimage: PNMImage, name: string) {.importcpp: "Texture::consider_rescale(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Asks the PNMImage to change its scale when it reads the image, according to
## the whims of the Config.prc file.
##
## For most efficient results, this method should be called after
## pnmimage.read_header() has been called, but before pnmimage.read().  This
## method may also be called after pnmimage.read(), i.e.  when the pnmimage is
## already loaded; in this case it will rescale the image on the spot.  Also
## see rescale_texture().

proc rescale_texture*(this: Texture): bool {.importcpp: "#->rescale_texture()".} ## \
## This method is similar to consider_rescale(), but instead of scaling a
## separate PNMImage, it will ask the Texture to rescale its own internal
## image to a power of 2, according to the config file requirements.  This may
## be useful after loading a Texture image by hand, instead of reading it from
## a disk file.  Returns true if the texture is changed, false if it was not.

proc get_class_type*(_: typedesc[Texture]): TypeHandle {.importcpp: "Texture::get_class_type()", header: "texture.h".}

proc load*(_: typedesc[Shader], file: Filename): Shader {.importcpp: "Shader::load(#)", header: "shader.h".} ## \
## Loads the shader with the given filename.

proc make*(_: typedesc[Shader], body: string): Shader {.importcpp: "Shader::make(nimStringToStdString(#))", header: "shader.h".} ## \
## Loads the shader, using the string as shader body.

proc get_filename*(this: Shader): Filename {.importcpp: "#->get_filename()".} ## \
## Return the Shader's filename for the given shader type.

proc get_text*(this: Shader): string {.importcpp: "nimStringFromStdString(#->get_text())", header: stringConversionCode.} ## \
## Return the Shader's text for the given shader type.

proc get_error_flag*(this: Shader): bool {.importcpp: "#->get_error_flag()".} ## \
## Returns true if the shader contains a compile-time error.  This doesn't
## tell you whether or not the shader is supported on the current video card.

proc has_fullpath*(this: Shader): bool {.importcpp: "#->has_fullpath()".} ## \
## Returns true if the fullpath has been set and is available.  See
## set_fullpath().

proc get_fullpath*(this: Shader): Filename {.importcpp: "#->get_fullpath()".} ## \
## Returns the fullpath that has been set.  This is the full path to the file
## as it was found along the model-path.

proc get_cache_compiled_shader*(this: Shader): bool {.importcpp: "#->get_cache_compiled_shader()".} ## \
## Returns the setting of the cache_compiled_shader flag.  See
## set_cache_compiled_shader().

proc set_cache_compiled_shader*(this: Shader, flag: bool) {.importcpp: "#->set_cache_compiled_shader(#)".} ## \
## Sets the cache_compiled_shader flag.  When this is set, the next time the
## Shader is loaded on a GSG, it will automatically extract the compiled
## shader from the GSG and save it to the global BamCache.
##
## This is used to store compiled shaders in the BamCache.  This flag should
## not be set explicitly; it is set automatically by the ShaderPool when
## model-cache-compiled-shaders is set true.

proc prepare*(this: Shader, prepared_objects: PreparedGraphicsObjects): AsyncFuture {.importcpp: "#->prepare(#)".} ## \
## Indicates that the shader should be enqueued to be prepared in the
## indicated prepared_objects at the beginning of the next frame.  This will
## ensure the texture is already loaded into texture memory if it is expected
## to be rendered soon.
##
## Use this function instead of prepare_now() to preload textures from a user
## interface standpoint.

proc is_prepared*(this: Shader, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->is_prepared(#)".} ## \
## Returns true if the shader has already been prepared or enqueued for
## preparation on the indicated GSG, false otherwise.

proc release*(this: Shader, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->release(#)".} ## \
## Frees the texture context only on the indicated object, if it exists there.
## Returns true if it was released, false if it had not been prepared.

proc release_all*(this: Shader): int {.importcpp: "#->release_all()".} ## \
## Frees the context allocated on all objects for which the texture has been
## declared.  Returns the number of contexts which have been freed.

proc prepare_now*(this: Shader, prepared_objects: PreparedGraphicsObjects, gsg: GraphicsStateGuardianBase): ShaderContext {.importcpp: "#->prepare_now(#, #)".} ## \
## Creates a context for the shader on the particular GSG, if it does not
## already exist.  Returns the new (or old) ShaderContext.  This assumes that
## the GraphicsStateGuardian is the currently active rendering context and
## that it is ready to accept new textures.  If this is not necessarily the
## case, you should use prepare() instead.
##
## Normally, this is not called directly except by the GraphicsStateGuardian;
## a shader does not need to be explicitly prepared by the user before it may
## be rendered.

proc get_class_type*(_: typedesc[Shader]): TypeHandle {.importcpp: "Shader::get_class_type()", header: "shader.h".}

proc newShader*(param0: Shader): Shader {.importcpp: "new Shader(#)".}

converter upcast_to_TypedWritableReferenceCount*(this: ShaderBuffer): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcast_to_Namable*(this: ShaderBuffer): Namable {.importcpp: "((Namable *)(#.p()))".}

converter upcast_to_GeomEnums*(this: ShaderBuffer): GeomEnums {.importcpp: "((GeomEnums *)(#.p()))".}

proc newShaderBuffer*(param0: ShaderBuffer): ShaderBuffer {.importcpp: "new ShaderBuffer(#)".}

proc prepare*(this: ShaderBuffer, prepared_objects: PreparedGraphicsObjects) {.importcpp: "#->prepare(#)".} ## \
## Indicates that the data should be enqueued to be prepared in the indicated
## prepared_objects at the beginning of the next frame.  This will ensure the
## data is already loaded into the GSG if it is expected to be rendered soon.
##
## Use this function instead of prepare_now() to preload datas from a user
## interface standpoint.

proc is_prepared*(this: ShaderBuffer, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->is_prepared(#)".} ## \
## Returns true if the data has already been prepared or enqueued for
## preparation on the indicated GSG, false otherwise.

proc prepare_now*(this: ShaderBuffer, prepared_objects: PreparedGraphicsObjects, gsg: GraphicsStateGuardianBase): BufferContext {.importcpp: "#->prepare_now(#, #)".} ## \
## Creates a context for the data on the particular GSG, if it does not
## already exist.  Returns the new (or old) BufferContext.  This assumes
## that the GraphicsStateGuardian is the currently active rendering context
## and that it is ready to accept new datas.  If this is not necessarily the
## case, you should use prepare() instead.
##
## Normally, this is not called directly except by the GraphicsStateGuardian;
## a data does not need to be explicitly prepared by the user before it may be
## rendered.

proc release*(this: ShaderBuffer, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->release(#)".} ## \
## Frees the data context only on the indicated object, if it exists there.
## Returns true if it was released, false if it had not been prepared.

proc release_all*(this: ShaderBuffer): int {.importcpp: "#->release_all()".} ## \
## Frees the context allocated on all objects for which the data has been
## declared.  Returns the number of contexts which have been freed.

proc get_class_type*(_: typedesc[ShaderBuffer]): TypeHandle {.importcpp: "ShaderBuffer::get_class_type()", header: "shaderBuffer.h".}

proc get_name*(this: PreparedGraphicsObjects): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the name of the PreparedGraphicsObjects structure.  This is an
## arbitrary name that serves mainly to uniquify the context for PStats
## reporting.

proc set_graphics_memory_limit*(this: PreparedGraphicsObjects, limit: clonglong) {.importcpp: "#->set_graphics_memory_limit(#)".} ## \
## Sets an artificial cap on graphics memory that will be imposed on this GSG.
##
## This limits the total amount of graphics memory, including texture memory
## and vertex buffer memory, that will be consumed by the GSG, regardless of
## whether the hardware claims to provide more graphics memory than this.  It
## is useful to put a ceiling on graphics memory consumed, since some drivers
## seem to allow the application to consume more memory than the hardware can
## realistically support.

proc get_graphics_memory_limit*(this: PreparedGraphicsObjects): clonglong {.importcpp: "#->get_graphics_memory_limit()".} ## \
## Returns the artificial cap on graphics memory that will be imposed on this
## GSG.  See set_graphics_memory_limit().

proc show_graphics_memory_lru*(this: PreparedGraphicsObjects, `out`: ostream) {.importcpp: "#->show_graphics_memory_lru(#)".} ## \
## Writes to the indicated ostream a report of how the various textures and
## vertex buffers are allocated in the LRU.

proc show_residency_trackers*(this: PreparedGraphicsObjects, `out`: ostream) {.importcpp: "#->show_residency_trackers(#)".} ## \
## Writes to the indicated ostream a report of how the various textures and
## vertex buffers are allocated in the LRU.

proc release_all*(this: PreparedGraphicsObjects) {.importcpp: "#->release_all()".} ## \
## Releases all prepared objects of all kinds at once.

proc get_num_queued*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_queued()".} ## \
## Returns the number of objects of any kind that have been enqueued to be
## prepared on this GSG.

proc get_num_prepared*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_prepared()".} ## \
## Returns the number of objects of any kind that have already been prepared
## on this GSG.

proc enqueue_texture*(this: PreparedGraphicsObjects, tex: Texture) {.importcpp: "#->enqueue_texture(#)".} ## \
## Indicates that a texture would like to be put on the list to be prepared
## when the GSG is next ready to do this (presumably at the next frame).

proc is_texture_queued*(this: PreparedGraphicsObjects, tex: Texture): bool {.importcpp: "#->is_texture_queued(#)".} ## \
## Returns true if the texture has been queued on this GSG, false otherwise.

proc dequeue_texture*(this: PreparedGraphicsObjects, tex: Texture): bool {.importcpp: "#->dequeue_texture(#)".} ## \
## Removes a texture from the queued list of textures to be prepared.
## Normally it is not necessary to call this, unless you change your mind
## about preparing it at the last minute, since the texture will automatically
## be dequeued and prepared at the next frame.
##
## The return value is true if the texture is successfully dequeued, false if
## it had not been queued.

proc is_texture_prepared*(this: PreparedGraphicsObjects, tex: Texture): bool {.importcpp: "#->is_texture_prepared(#)".} ## \
## Returns true if the texture has been prepared on this GSG, false otherwise.

proc release_texture*(this: PreparedGraphicsObjects, tex: Texture) {.importcpp: "#->release_texture(#)".} ## \
## Releases a texture if it has already been prepared, or removes it from the
## preparation queue.

proc release_texture*(this: PreparedGraphicsObjects, tc: TextureContext) {.importcpp: "#->release_texture(#)".} ## \
## Indicates that a texture context, created by a previous call to
## prepare_texture(), is no longer needed.  The driver resources will not be
## freed until some GSG calls update(), indicating it is at a stage where it
## is ready to release textures--this prevents conflicts from threading or
## multiple GSG's sharing textures (we have no way of knowing which graphics
## context is currently active, or what state it's in, at the time
## release_texture is called).

proc release_all_textures*(this: PreparedGraphicsObjects): int {.importcpp: "#->release_all_textures()".} ## \
## Releases all textures at once.  This will force them to be reloaded into
## texture memory for all GSG's that share this object.  Returns the number of
## textures released.

proc get_num_queued_textures*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_queued_textures()".} ## \
## Returns the number of textures that have been enqueued to be prepared on
## this GSG.

proc get_num_prepared_textures*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_prepared_textures()".} ## \
## Returns the number of textures that have already been prepared on this GSG.

proc prepare_texture_now*(this: PreparedGraphicsObjects, tex: Texture, view: int, gsg: GraphicsStateGuardianBase): TextureContext {.importcpp: "#->prepare_texture_now(#, #, #)".} ## \
## Immediately creates a new TextureContext for the indicated texture and
## returns it.  This assumes that the GraphicsStateGuardian is the currently
## active rendering context and that it is ready to accept new textures.  If
## this is not necessarily the case, you should use enqueue_texture() instead.
##
## Normally, this function is not called directly.  Call
## Texture::prepare_now() instead.
##
## The TextureContext contains all of the pertinent information needed by the
## GSG to keep track of this one particular texture, and will exist as long as
## the texture is ready to be rendered.
##
## When either the Texture or the PreparedGraphicsObjects object destructs,
## the TextureContext will be deleted.

proc enqueue_sampler*(this: PreparedGraphicsObjects, sampler: SamplerState) {.importcpp: "#->enqueue_sampler(#)".} ## \
## Indicates that a sampler would like to be put on the list to be prepared
## when the GSG is next ready to do this (presumably at the next frame).

proc is_sampler_queued*(this: PreparedGraphicsObjects, sampler: SamplerState): bool {.importcpp: "#->is_sampler_queued(#)".} ## \
## Returns true if the sampler has been queued on this GSG, false otherwise.

proc dequeue_sampler*(this: PreparedGraphicsObjects, sampler: SamplerState): bool {.importcpp: "#->dequeue_sampler(#)".} ## \
## Removes a sampler from the queued list of samplers to be prepared.
## Normally it is not necessary to call this, unless you change your mind
## about preparing it at the last minute, since the sampler will automatically
## be dequeued and prepared at the next frame.
##
## The return value is true if the sampler is successfully dequeued, false if
## it had not been queued.

proc is_sampler_prepared*(this: PreparedGraphicsObjects, sampler: SamplerState): bool {.importcpp: "#->is_sampler_prepared(#)".} ## \
## Returns true if the sampler has been prepared on this GSG, false otherwise.

proc release_sampler*(this: PreparedGraphicsObjects, sampler: SamplerState) {.importcpp: "#->release_sampler(#)".} ## \
## Releases a sampler if it has already been prepared, or removes it from the
## preparation queue.

proc release_all_samplers*(this: PreparedGraphicsObjects): int {.importcpp: "#->release_all_samplers()".} ## \
## Releases all samplers at once.  This will force them to be reloaded for all
## GSG's that share this object.  Returns the number of samplers released.

proc get_num_queued_samplers*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_queued_samplers()".} ## \
## Returns the number of samplers that have been enqueued to be prepared on
## this GSG.

proc get_num_prepared_samplers*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_prepared_samplers()".} ## \
## Returns the number of samplers that have already been prepared on this GSG.

proc enqueue_geom*(this: PreparedGraphicsObjects, geom: Geom) {.importcpp: "#->enqueue_geom(#)".} ## \
## Indicates that a geom would like to be put on the list to be prepared when
## the GSG is next ready to do this (presumably at the next frame).

proc is_geom_queued*(this: PreparedGraphicsObjects, geom: Geom): bool {.importcpp: "#->is_geom_queued(#)".} ## \
## Returns true if the geom has been queued on this GSG, false otherwise.

proc dequeue_geom*(this: PreparedGraphicsObjects, geom: Geom): bool {.importcpp: "#->dequeue_geom(#)".} ## \
## Removes a geom from the queued list of geoms to be prepared.  Normally it
## is not necessary to call this, unless you change your mind about preparing
## it at the last minute, since the geom will automatically be dequeued and
## prepared at the next frame.
##
## The return value is true if the geom is successfully dequeued, false if it
## had not been queued.

proc is_geom_prepared*(this: PreparedGraphicsObjects, geom: Geom): bool {.importcpp: "#->is_geom_prepared(#)".} ## \
## Returns true if the vertex buffer has been prepared on this GSG, false
## otherwise.

proc release_geom*(this: PreparedGraphicsObjects, gc: GeomContext) {.importcpp: "#->release_geom(#)".} ## \
## Indicates that a geom context, created by a previous call to
## prepare_geom(), is no longer needed.  The driver resources will not be
## freed until some GSG calls update(), indicating it is at a stage where it
## is ready to release geoms--this prevents conflicts from threading or
## multiple GSG's sharing geoms (we have no way of knowing which graphics
## context is currently active, or what state it's in, at the time
## release_geom is called).

proc release_all_geoms*(this: PreparedGraphicsObjects): int {.importcpp: "#->release_all_geoms()".} ## \
## Releases all geoms at once.  This will force them to be reloaded into geom
## memory for all GSG's that share this object.  Returns the number of geoms
## released.

proc get_num_queued_geoms*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_queued_geoms()".} ## \
## Returns the number of geoms that have been enqueued to be prepared on this
## GSG.

proc get_num_prepared_geoms*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_prepared_geoms()".} ## \
## Returns the number of geoms that have already been prepared on this GSG.

proc prepare_geom_now*(this: PreparedGraphicsObjects, geom: Geom, gsg: GraphicsStateGuardianBase): GeomContext {.importcpp: "#->prepare_geom_now(#, #)".} ## \
## Immediately creates a new GeomContext for the indicated geom and returns
## it.  This assumes that the GraphicsStateGuardian is the currently active
## rendering context and that it is ready to accept new geoms.  If this is not
## necessarily the case, you should use enqueue_geom() instead.
##
## Normally, this function is not called directly.  Call Geom::prepare_now()
## instead.
##
## The GeomContext contains all of the pertinent information needed by the GSG
## to keep track of this one particular geom, and will exist as long as the
## geom is ready to be rendered.
##
## When either the Geom or the PreparedGraphicsObjects object destructs, the
## GeomContext will be deleted.

proc enqueue_shader*(this: PreparedGraphicsObjects, shader: Shader) {.importcpp: "#->enqueue_shader(#)".} ## \
## Indicates that a shader would like to be put on the list to be prepared
## when the GSG is next ready to do this (presumably at the next frame).

proc is_shader_queued*(this: PreparedGraphicsObjects, shader: Shader): bool {.importcpp: "#->is_shader_queued(#)".} ## \
## Returns true if the shader has been queued on this GSG, false otherwise.

proc dequeue_shader*(this: PreparedGraphicsObjects, shader: Shader): bool {.importcpp: "#->dequeue_shader(#)".} ## \
## Removes a shader from the queued list of shaders to be prepared.  Normally
## it is not necessary to call this, unless you change your mind about
## preparing it at the last minute, since the shader will automatically be
## dequeued and prepared at the next frame.
##
## The return value is true if the shader is successfully dequeued, false if
## it had not been queued.

proc is_shader_prepared*(this: PreparedGraphicsObjects, shader: Shader): bool {.importcpp: "#->is_shader_prepared(#)".} ## \
## Returns true if the shader has been prepared on this GSG, false otherwise.

proc release_shader*(this: PreparedGraphicsObjects, sc: ShaderContext) {.importcpp: "#->release_shader(#)".} ## \
## Indicates that a shader context, created by a previous call to
## prepare_shader(), is no longer needed.  The driver resources will not be
## freed until some GSG calls update(), indicating it is at a stage where it
## is ready to release shaders--this prevents conflicts from threading or
## multiple GSG's sharing shaders (we have no way of knowing which graphics
## context is currently active, or what state it's in, at the time
## release_shader is called).

proc release_all_shaders*(this: PreparedGraphicsObjects): int {.importcpp: "#->release_all_shaders()".} ## \
## Releases all shaders at once.  This will force them to be reloaded into
## shader memory for all GSG's that share this object.  Returns the number of
## shaders released.

proc get_num_queued_shaders*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_queued_shaders()".} ## \
## Returns the number of shaders that have been enqueued to be prepared on
## this GSG.

proc get_num_prepared_shaders*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_prepared_shaders()".} ## \
## Returns the number of shaders that have already been prepared on this GSG.

proc prepare_shader_now*(this: PreparedGraphicsObjects, shader: Shader, gsg: GraphicsStateGuardianBase): ShaderContext {.importcpp: "#->prepare_shader_now(#, #)".} ## \
## Immediately creates a new ShaderContext for the indicated shader and
## returns it.  This assumes that the GraphicsStateGuardian is the currently
## active rendering context and that it is ready to accept new shaders.  If
## this is not necessarily the case, you should use enqueue_shader() instead.
##
## Normally, this function is not called directly.  Call Shader::prepare_now()
## instead.
##
## The ShaderContext contains all of the pertinent information needed by the
## GSG to keep track of this one particular shader, and will exist as long as
## the shader is ready to be rendered.
##
## When either the Shader or the PreparedGraphicsObjects object destructs, the
## ShaderContext will be deleted.

proc enqueue_vertex_buffer*(this: PreparedGraphicsObjects, data: GeomVertexArrayData) {.importcpp: "#->enqueue_vertex_buffer(#)".} ## \
## Indicates that a buffer would like to be put on the list to be prepared
## when the GSG is next ready to do this (presumably at the next frame).

proc is_vertex_buffer_queued*(this: PreparedGraphicsObjects, data: GeomVertexArrayData): bool {.importcpp: "#->is_vertex_buffer_queued(#)".} ## \
## Returns true if the vertex buffer has been queued on this GSG, false
## otherwise.

proc dequeue_vertex_buffer*(this: PreparedGraphicsObjects, data: GeomVertexArrayData): bool {.importcpp: "#->dequeue_vertex_buffer(#)".} ## \
## Removes a buffer from the queued list of data arrays to be prepared.
## Normally it is not necessary to call this, unless you change your mind
## about preparing it at the last minute, since the data will automatically be
## dequeued and prepared at the next frame.
##
## The return value is true if the buffer is successfully dequeued, false if
## it had not been queued.

proc is_vertex_buffer_prepared*(this: PreparedGraphicsObjects, data: GeomVertexArrayData): bool {.importcpp: "#->is_vertex_buffer_prepared(#)".} ## \
## Returns true if the vertex buffer has been prepared on this GSG, false
## otherwise.

proc release_vertex_buffer*(this: PreparedGraphicsObjects, vbc: VertexBufferContext) {.importcpp: "#->release_vertex_buffer(#)".} ## \
## Indicates that a data context, created by a previous call to
## prepare_vertex_buffer(), is no longer needed.  The driver resources will
## not be freed until some GSG calls update(), indicating it is at a stage
## where it is ready to release datas--this prevents conflicts from threading
## or multiple GSG's sharing datas (we have no way of knowing which graphics
## context is currently active, or what state it's in, at the time
## release_vertex_buffer is called).

proc release_all_vertex_buffers*(this: PreparedGraphicsObjects): int {.importcpp: "#->release_all_vertex_buffers()".} ## \
## Releases all datas at once.  This will force them to be reloaded into data
## memory for all GSG's that share this object.  Returns the number of datas
## released.

proc get_num_queued_vertex_buffers*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_queued_vertex_buffers()".} ## \
## Returns the number of vertex buffers that have been enqueued to be prepared
## on this GSG.

proc get_num_prepared_vertex_buffers*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_prepared_vertex_buffers()".} ## \
## Returns the number of vertex buffers that have already been prepared on
## this GSG.

proc prepare_vertex_buffer_now*(this: PreparedGraphicsObjects, data: GeomVertexArrayData, gsg: GraphicsStateGuardianBase): VertexBufferContext {.importcpp: "#->prepare_vertex_buffer_now(#, #)".} ## \
## Immediately creates a new VertexBufferContext for the indicated data and
## returns it.  This assumes that the GraphicsStateGuardian is the currently
## active rendering context and that it is ready to accept new datas.  If this
## is not necessarily the case, you should use enqueue_vertex_buffer()
## instead.
##
## Normally, this function is not called directly.  Call Data::prepare_now()
## instead.
##
## The VertexBufferContext contains all of the pertinent information needed by
## the GSG to keep track of this one particular data, and will exist as long
## as the data is ready to be rendered.
##
## When either the Data or the PreparedGraphicsObjects object destructs, the
## VertexBufferContext will be deleted.

proc enqueue_index_buffer*(this: PreparedGraphicsObjects, data: GeomPrimitive) {.importcpp: "#->enqueue_index_buffer(#)".} ## \
## Indicates that a buffer would like to be put on the list to be prepared
## when the GSG is next ready to do this (presumably at the next frame).

proc is_index_buffer_queued*(this: PreparedGraphicsObjects, data: GeomPrimitive): bool {.importcpp: "#->is_index_buffer_queued(#)".} ## \
## Returns true if the index buffer has been queued on this GSG, false
## otherwise.

proc dequeue_index_buffer*(this: PreparedGraphicsObjects, data: GeomPrimitive): bool {.importcpp: "#->dequeue_index_buffer(#)".} ## \
## Removes a buffer from the queued list of data arrays to be prepared.
## Normally it is not necessary to call this, unless you change your mind
## about preparing it at the last minute, since the data will automatically be
## dequeued and prepared at the next frame.
##
## The return value is true if the buffer is successfully dequeued, false if
## it had not been queued.

proc is_index_buffer_prepared*(this: PreparedGraphicsObjects, data: GeomPrimitive): bool {.importcpp: "#->is_index_buffer_prepared(#)".} ## \
## Returns true if the index buffer has been prepared on this GSG, false
## otherwise.

proc release_index_buffer*(this: PreparedGraphicsObjects, ibc: IndexBufferContext) {.importcpp: "#->release_index_buffer(#)".} ## \
## Indicates that a data context, created by a previous call to
## prepare_index_buffer(), is no longer needed.  The driver resources will not
## be freed until some GSG calls update(), indicating it is at a stage where
## it is ready to release datas--this prevents conflicts from threading or
## multiple GSG's sharing datas (we have no way of knowing which graphics
## context is currently active, or what state it's in, at the time
## release_index_buffer is called).

proc release_all_index_buffers*(this: PreparedGraphicsObjects): int {.importcpp: "#->release_all_index_buffers()".} ## \
## Releases all datas at once.  This will force them to be reloaded into data
## memory for all GSG's that share this object.  Returns the number of datas
## released.

proc get_num_queued_index_buffers*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_queued_index_buffers()".} ## \
## Returns the number of index buffers that have been enqueued to be prepared
## on this GSG.

proc get_num_prepared_index_buffers*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_prepared_index_buffers()".} ## \
## Returns the number of index buffers that have already been prepared on this
## GSG.

proc prepare_index_buffer_now*(this: PreparedGraphicsObjects, data: GeomPrimitive, gsg: GraphicsStateGuardianBase): IndexBufferContext {.importcpp: "#->prepare_index_buffer_now(#, #)".} ## \
## Immediately creates a new IndexBufferContext for the indicated data and
## returns it.  This assumes that the GraphicsStateGuardian is the currently
## active rendering context and that it is ready to accept new datas.  If this
## is not necessarily the case, you should use enqueue_index_buffer() instead.
##
## Normally, this function is not called directly.  Call Data::prepare_now()
## instead.
##
## The IndexBufferContext contains all of the pertinent information needed by
## the GSG to keep track of this one particular data, and will exist as long
## as the data is ready to be rendered.
##
## When either the Data or the PreparedGraphicsObjects object destructs, the
## IndexBufferContext will be deleted.

proc enqueue_shader_buffer*(this: PreparedGraphicsObjects, data: ShaderBuffer) {.importcpp: "#->enqueue_shader_buffer(#)".} ## \
## Indicates that a buffer would like to be put on the list to be prepared
## when the GSG is next ready to do this (presumably at the next frame).

proc is_shader_buffer_queued*(this: PreparedGraphicsObjects, data: ShaderBuffer): bool {.importcpp: "#->is_shader_buffer_queued(#)".} ## \
## Returns true if the index buffer has been queued on this GSG, false
## otherwise.

proc dequeue_shader_buffer*(this: PreparedGraphicsObjects, data: ShaderBuffer): bool {.importcpp: "#->dequeue_shader_buffer(#)".} ## \
## Removes a buffer from the queued list of data arrays to be prepared.
## Normally it is not necessary to call this, unless you change your mind
## about preparing it at the last minute, since the data will automatically be
## dequeued and prepared at the next frame.
##
## The return value is true if the buffer is successfully dequeued, false if
## it had not been queued.

proc is_shader_buffer_prepared*(this: PreparedGraphicsObjects, data: ShaderBuffer): bool {.importcpp: "#->is_shader_buffer_prepared(#)".} ## \
## Returns true if the index buffer has been prepared on this GSG, false
## otherwise.

proc release_shader_buffer*(this: PreparedGraphicsObjects, bc: BufferContext) {.importcpp: "#->release_shader_buffer(#)".} ## \
## Indicates that a data context, created by a previous call to
## prepare_shader_buffer(), is no longer needed.  The driver resources will not
## be freed until some GSG calls update(), indicating it is at a stage where
## it is ready to release datas--this prevents conflicts from threading or
## multiple GSG's sharing datas (we have no way of knowing which graphics
## context is currently active, or what state it's in, at the time
## release_shader_buffer is called).

proc release_all_shader_buffers*(this: PreparedGraphicsObjects): int {.importcpp: "#->release_all_shader_buffers()".} ## \
## Releases all datas at once.  This will force them to be reloaded into data
## memory for all GSG's that share this object.  Returns the number of datas
## released.

proc get_num_queued_shader_buffers*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_queued_shader_buffers()".} ## \
## Returns the number of index buffers that have been enqueued to be prepared
## on this GSG.

proc get_num_prepared_shader_buffers*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_prepared_shader_buffers()".} ## \
## Returns the number of index buffers that have already been prepared on this
## GSG.

proc prepare_shader_buffer_now*(this: PreparedGraphicsObjects, data: ShaderBuffer, gsg: GraphicsStateGuardianBase): BufferContext {.importcpp: "#->prepare_shader_buffer_now(#, #)".} ## \
## Immediately creates a new BufferContext for the indicated data and
## returns it.  This assumes that the GraphicsStateGuardian is the currently
## active rendering context and that it is ready to accept new datas.  If this
## is not necessarily the case, you should use enqueue_shader_buffer() instead.
##
## Normally, this function is not called directly.  Call Data::prepare_now()
## instead.
##
## The BufferContext contains all of the pertinent information needed by
## the GSG to keep track of this one particular data, and will exist as long
## as the data is ready to be rendered.
##
## When either the Data or the PreparedGraphicsObjects object destructs, the
## BufferContext will be deleted.

converter upcast_to_BufferContext*(this: IndexBufferContext): BufferContext {.importcpp: "#.upcast_to_BufferContext()".}

converter upcast_to_AdaptiveLruPage*(this: IndexBufferContext): AdaptiveLruPage {.importcpp: "#.upcast_to_AdaptiveLruPage()".}

proc get_data*(this: IndexBufferContext): GeomPrimitive {.importcpp: "#.get_data()".} ## \
## Returns the pointer to the client-side array data object.

proc get_class_type*(_: typedesc[IndexBufferContext]): TypeHandle {.importcpp: "IndexBufferContext::get_class_type()", header: "indexBufferContext.h".}

proc make_copy*(this: Lens): Lens {.importcpp: "#->make_copy()".}

proc extrude*(this: Lens, point2d: LPoint2, near_point: LPoint3, far_point: LPoint3): bool {.importcpp: "#->extrude(#, #, #)".} ## \
## Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is
## the center of the lens and (-1,-1) is the lower-left corner, compute the
## corresponding vector in space that maps to this point, if such a vector can
## be determined.  The vector is returned by indicating the points on the near
## plane and far plane that both map to the indicated 2-d point.
##
## Returns true if the vector is defined, or false otherwise.

proc extrude*(this: Lens, point2d: LPoint3, near_point: LPoint3, far_point: LPoint3): bool {.importcpp: "#->extrude(#, #, #)".} ## \
## Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is
## the center of the lens and (-1,-1) is the lower-left corner, compute the
## corresponding vector in space that maps to this point, if such a vector can
## be determined.  The vector is returned by indicating the points on the near
## plane and far plane that both map to the indicated 2-d point.
##
## The z coordinate of the 2-d point is ignored.
##
## Returns true if the vector is defined, or false otherwise.

proc extrude_depth*(this: Lens, point2d: LPoint3, point3d: LPoint3): bool {.importcpp: "#->extrude_depth(#, #)".} ## \
## Uses the depth component of the 3-d result from project() to compute the
## original point in 3-d space corresponding to a particular point on the
## lens.  This exactly reverses project(), assuming the point does fall
## legitimately within the lens.

proc extrude_vec*(this: Lens, point2d: LPoint2, vec3d: LVector3): bool {.importcpp: "#->extrude_vec(#, #)".} ## \
## Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is
## the center of the lens and (-1,-1) is the lower-left corner, compute the
## vector that corresponds to the view direction.  This will be parallel to
## the normal on the surface (the far plane) corresponding to the lens shape
## at this point.
##
## See the comment block on Lens::extrude_vec_impl() for a more in-depth
## comment on the meaning of this vector.
##
## Returns true if the vector is defined, or false otherwise.

proc extrude_vec*(this: Lens, point2d: LPoint3, vec3d: LVector3): bool {.importcpp: "#->extrude_vec(#, #)".} ## \
## Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is
## the center of the lens and (-1,-1) is the lower-left corner, compute the
## vector that corresponds to the view direction.  This will be parallel to
## the normal on the surface (the far plane) corresponding to the lens shape
## at this point.
##
## See the comment block on Lens::extrude_vec_impl() for a more in-depth
## comment on the meaning of this vector.
##
## The z coordinate of the 2-d point is ignored.
##
## Returns true if the vector is defined, or false otherwise.

proc project*(this: Lens, point3d: LPoint3, point2d: LPoint2): bool {.importcpp: "#->project(#, #)".} ## \
## Given a 3-d point in space, determine the 2-d point this maps to, in the
## range (-1,1) in both dimensions, where (0,0) is the center of the lens and
## (-1,-1) is the lower-left corner.
##
## Returns true if the 3-d point is in front of the lens and within the
## viewing frustum (in which case point2d is filled in), or false otherwise
## (in which case point2d will be filled in with something, which may or may
## not be meaningful).

proc project*(this: Lens, point3d: LPoint3, point2d: LPoint3): bool {.importcpp: "#->project(#, #)".} ## \
## Given a 3-d point in space, determine the 2-d point this maps to, in the
## range (-1,1) in both dimensions, where (0,0) is the center of the lens and
## (-1,-1) is the lower-left corner.
##
## The z coordinate will also be set to a value in the range (-1, 1), where 1
## represents a point on the near plane, and -1 represents a point on the far
## plane.
##
## Returns true if the 3-d point is in front of the lens and within the
## viewing frustum (in which case point2d is filled in), or false otherwise
## (in which case point2d will be filled in with something, which may or may
## not be meaningful).

proc set_change_event*(this: Lens, event: string) {.importcpp: "#->set_change_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the name of the event that will be generated whenever any properties
## of the Lens have changed.  If this is not set for a particular lens, no
## event will be generated.
##
## The event is thrown with one parameter, the lens itself.  This can be used
## to automatically track changes to camera fov, etc.  in the application.

proc get_change_event*(this: Lens): string {.importcpp: "nimStringFromStdString(#->get_change_event())", header: stringConversionCode.} ## \
## Returns the name of the event that will be generated whenever any
## properties of this particular Lens have changed.

proc set_coordinate_system*(this: Lens, cs: CoordinateSystem) {.importcpp: "#->set_coordinate_system(#)".} ## \
## Specifies the coordinate system that all 3-d computations are performed
## within for this Lens.  Normally, this is CS_default.

proc get_coordinate_system*(this: Lens): CoordinateSystem {.importcpp: "#->get_coordinate_system()".} ## \
## Returns the coordinate system that all 3-d computations are performed
## within for this Lens.  Normally, this is CS_default.

proc clear*(this: Lens) {.importcpp: "#->clear()".} ## \
## Resets all lens parameters to their initial default settings.

proc set_film_size*(this: Lens, film_size: LVecBase2) {.importcpp: "#->set_film_size(#)".} ## \
## Sets the size and shape of the "film" within the lens.  This both
## establishes the units used by calls like set_focal_length(), and
## establishes the aspect ratio of the frame.
##
## In a physical camera, the field of view of a lens is determined by the
## lens' focal length and by the size of the film area exposed by the lens.
## For instance, a 35mm camera exposes a rectangle on the film about 24mm x
## 36mm, which means a 50mm lens gives about a 40-degree horizontal field of
## view.
##
## In the virtual camera, you may set the film size to any units here, and
## specify a focal length in the same units to simulate the same effect.  Or,
## you may ignore this parameter, and specify the field of view and aspect
## ratio of the lens directly.

proc set_film_size*(this: Lens, width: float32) {.importcpp: "#->set_film_size(#)".} ## \
## Sets the horizontal size of the film without changing its shape.  The
## aspect ratio remains unchanged; this computes the vertical size of the film
## to automatically maintain the aspect ratio.

proc set_film_size*(this: Lens, width: float32, height: float32) {.importcpp: "#->set_film_size(#, #)".} ## \
## Sets the size and shape of the "film" within the lens.  This both
## establishes the units used by calls like set_focal_length(), and
## establishes the aspect ratio of the frame.
##
## In a physical camera, the field of view of a lens is determined by the
## lens' focal length and by the size of the film area exposed by the lens.
## For instance, a 35mm camera exposes a rectangle on the film about 24mm x
## 36mm, which means a 50mm lens gives about a 40-degree horizontal field of
## view.
##
## In the virtual camera, you may set the film size to any units here, and
## specify a focal length in the same units to simulate the same effect.  Or,
## you may ignore this parameter, and specify the field of view and aspect
## ratio of the lens directly.

proc get_film_size*(this: Lens): LVecBase2 {.importcpp: "#->get_film_size()".} ## \
## Returns the horizontal and vertical film size of the virtual film.  See
## set_film_size().

proc set_film_offset*(this: Lens, film_offset: LVecBase2) {.importcpp: "#->set_film_offset(#)".} ## \
## Sets the horizontal and vertical offset amounts of this Lens.  These are
## both in the same units specified in set_film_size().
##
## This can be used to establish an off-axis lens.

proc set_film_offset*(this: Lens, x: float32, y: float32) {.importcpp: "#->set_film_offset(#, #)".} ## \
## Sets the horizontal and vertical offset amounts of this Lens.  These are
## both in the same units specified in set_film_size().
##
## This can be used to establish an off-axis lens.

proc get_film_offset*(this: Lens): LVector2 {.importcpp: "#->get_film_offset()".} ## \
## Returns the horizontal and vertical offset amounts of this Lens.  See
## set_film_offset().

proc set_focal_length*(this: Lens, focal_length: float32) {.importcpp: "#->set_focal_length(#)".} ## \
## Sets the focal length of the lens.  This may adjust the field-of-view
## correspondingly, and is an alternate way to specify field of view.
##
## For certain kinds of lenses (e.g.  OrthographicLens), the focal length has
## no meaning.

proc get_focal_length*(this: Lens): float32 {.importcpp: "#->get_focal_length()".} ## \
## Returns the focal length of the lens.  This may have been set explicitly by
## a previous call to set_focal_length(), or it may be computed based on the
## lens' fov and film_size.  For certain kinds of lenses, the focal length has
## no meaning.

proc set_min_fov*(this: Lens, min_fov: float32) {.importcpp: "#->set_min_fov(#)".} ## \
## Sets the field of view of the smallest dimension of the window.  If the
## window is wider than it is tall, this specifies the vertical field of view;
## if it is taller than it is wide, this specifies the horizontal field of
## view.
##
## In many cases, this is preferable to setting either the horizontal or
## vertical field of view explicitly.  Setting this parameter means that
## pulling the window wider will widen the field of view, which is usually
## what you expect to happen.

proc set_fov*(this: Lens, fov: LVecBase2) {.importcpp: "#->set_fov(#)".} ## \
## Sets the field of view of the lens in both dimensions.  This establishes
## both the field of view and the aspect ratio of the lens.  This is one way
## to specify the field of view of a lens; set_focal_length() is another way.
##
## For certain kinds of lenses (like OrthographicLens), the field of view has
## no meaning.

proc set_fov*(this: Lens, fov: float32) {.importcpp: "#->set_fov(#)".} ## \
## Sets the horizontal field of view of the lens without changing the aspect
## ratio.  The vertical field of view is adjusted to maintain the same aspect
## ratio.

proc set_fov*(this: Lens, hfov: float32, vfov: float32) {.importcpp: "#->set_fov(#, #)".} ## \
## Sets the field of view of the lens in both dimensions.  This establishes
## both the field of view and the aspect ratio of the lens.  This is one way
## to specify the field of view of a lens; set_focal_length() is another way.
##
## For certain kinds of lenses (like OrthoLens), the field of view has no
## meaning.

proc get_fov*(this: Lens): LVecBase2 {.importcpp: "#->get_fov()".} ## \
## Returns the horizontal and vertical film size of the virtual film.  See
## set_fov().

proc get_hfov*(this: Lens): float32 {.importcpp: "#->get_hfov()".} ## \
## Returns the horizontal component of fov only.  See get_fov().

proc get_vfov*(this: Lens): float32 {.importcpp: "#->get_vfov()".} ## \
## Returns the vertical component of fov only.  See get_fov().

proc get_min_fov*(this: Lens): float32 {.importcpp: "#->get_min_fov()".} ## \
## Returns the field of view of the narrowest dimension of the window.  See
## set_min_fov().

proc set_aspect_ratio*(this: Lens, aspect_ratio: float32) {.importcpp: "#->set_aspect_ratio(#)".} ## \
## Sets the aspect ratio of the lens.  This is the ratio of the height to the
## width of the generated image.  Setting this overrides the two-parameter fov
## or film size setting.

proc get_aspect_ratio*(this: Lens): float32 {.importcpp: "#->get_aspect_ratio()".} ## \
## Returns the aspect ratio of the Lens.  This is determined based on the
## indicated film size; see set_film_size().

proc set_near*(this: Lens, near_distance: float32) {.importcpp: "#->set_near(#)".} ## \
## Defines the position of the near plane (or cylinder, sphere, whatever).
## Points closer to the lens than this may not be rendered.

proc get_near*(this: Lens): float32 {.importcpp: "#->get_near()".} ## \
## Returns the position of the near plane (or cylinder, sphere, whatever).

proc set_far*(this: Lens, far_distance: float32) {.importcpp: "#->set_far(#)".} ## \
## Defines the position of the far plane (or cylinder, sphere, whatever).
## Points farther from the lens than this may not be rendered.

proc get_far*(this: Lens): float32 {.importcpp: "#->get_far()".} ## \
## Returns the position of the far plane (or cylinder, sphere, whatever).

proc set_near_far*(this: Lens, near_distance: float32, far_distance: float32) {.importcpp: "#->set_near_far(#, #)".} ## \
## Simultaneously changes the near and far planes.

proc get_default_near*(_: typedesc[Lens]): float32 {.importcpp: "Lens::get_default_near()", header: "lens.h".} ## \
## Returns the default near plane distance that will be assigned to each
## newly-created lens.  This is read from the Config.prc file.

proc get_default_far*(_: typedesc[Lens]): float32 {.importcpp: "Lens::get_default_far()", header: "lens.h".} ## \
## Returns the default far plane distance that will be assigned to each newly-
## created lens.  This is read from the Config.prc file.

proc set_view_hpr*(this: Lens, view_hpr: LVecBase3) {.importcpp: "#->set_view_hpr(#)".} ## \
## Sets the direction in which the lens is facing.  Normally, this is down the
## forward axis (usually the Y axis), but it may be rotated.  This is only one
## way of specifying the rotation; you may also specify an explicit vector in
## which to look, or you may give a complete transformation matrix.

proc set_view_hpr*(this: Lens, h: float32, p: float32, r: float32) {.importcpp: "#->set_view_hpr(#, #, #)".} ## \
## Sets the direction in which the lens is facing.  Normally, this is down the
## forward axis (usually the Y axis), but it may be rotated.  This is only one
## way of specifying the rotation; you may also specify an explicit vector in
## which to look, or you may give a complete transformation matrix.

proc get_view_hpr*(this: Lens): LVecBase3 {.importcpp: "#->get_view_hpr()".} ## \
## Returns the direction in which the lens is facing.

proc set_view_vector*(this: Lens, view_vector: LVector3, up_vector: LVector3) {.importcpp: "#->set_view_vector(#, #)".} ## \
## Specifies the direction in which the lens is facing by giving an axis to
## look along, and a perpendicular (or at least non-parallel) up axis.
##
## See also set_view_hpr().

proc set_view_vector*(this: Lens, x: float32, y: float32, z: float32, i: float32, j: float32, k: float32) {.importcpp: "#->set_view_vector(#, #, #, #, #, #)".} ## \
## Specifies the direction in which the lens is facing by giving an axis to
## look along, and a perpendicular (or at least non-parallel) up axis.
##
## See also set_view_hpr().

proc get_view_vector*(this: Lens): LVector3 {.importcpp: "#->get_view_vector()".} ## \
## Returns the axis along which the lens is facing.

proc get_up_vector*(this: Lens): LVector3 {.importcpp: "#->get_up_vector()".} ## \
## Returns the axis perpendicular to the camera's view vector that indicates
## the "up" direction.

proc get_nodal_point*(this: Lens): LPoint3 {.importcpp: "#->get_nodal_point()".} ## \
## Returns the center point of the lens: the point from which the lens is
## viewing.

proc set_interocular_distance*(this: Lens, interocular_distance: float32) {.importcpp: "#->set_interocular_distance(#)".} ## \
## Sets the distance between the left and right eyes of a stereo camera.  This
## distance is used to apply a stereo effect when the lens is rendered on a
## stereo display region.  It only has an effect on a PerspectiveLens.
##
## The left eye and the right eye are each offset along the X axis by half of
## this distance, so that this parameter specifies the total distance between
## them.
##
## Also see set_convergence_distance(), which relates.

proc get_interocular_distance*(this: Lens): float32 {.importcpp: "#->get_interocular_distance()".} ## \
## See set_interocular_distance().

proc set_convergence_distance*(this: Lens, convergence_distance: float32) {.importcpp: "#->set_convergence_distance(#)".} ## \
## Sets the distance between between the camera plane and the point in the
## distance that the left and right eyes are both looking at.  This distance
## is used to apply a stereo effect when the lens is rendered on a stereo
## display region.  It only has an effect on a PerspectiveLens.
##
## This parameter must be greater than 0, but may be as large as you like.  It
## controls the distance at which the two stereo images will appear to
## converge, which is a normal property of stereo vision.  Normally this
## should be set to the distance from the camera to the area of interest in
## your scene.  Anything beyond this distance will appear to go into the
## screen, and anything closer will appear to come out of the screen.  If you
## want to simulate parallel stereo, set this to infinity.
##
## Note that this creates an off-axis frustum, which means that the lenses are
## still pointing in the same direction, which is usually more desirable than
## the more naive toe-in approach, where the two lenses are simply tilted
## toward each other.
##
## Prior to Panda3D 1.9.0, the convergence was being calculated incorrectly.
## It has since been corrected.  To restore the legacy behavior you can set
## the stereo-lens-old-convergence variable to true.
##
## Also see set_interocular_distance(), which relates.

proc get_convergence_distance*(this: Lens): float32 {.importcpp: "#->get_convergence_distance()".} ## \
## See set_convergence_distance().

proc set_view_mat*(this: Lens, view_mat: LMatrix4) {.importcpp: "#->set_view_mat(#)".} ## \
## Sets an arbitrary transformation on the lens.  This replaces the individual
## transformation components like set_view_hpr().
##
## Setting a transformation here will have a slightly different effect than
## putting one on the LensNode that contains this lens.  In particular,
## lighting and other effects computations will still be performed on the lens
## in its untransformed (facing forward) position, but the actual projection
## matrix will be transformed by this matrix.

proc get_view_mat*(this: Lens): LMatrix4 {.importcpp: "#->get_view_mat()".} ## \
## Returns the direction in which the lens is facing.

proc clear_view_mat*(this: Lens) {.importcpp: "#->clear_view_mat()".} ## \
## Resets the lens transform to identity.

proc set_keystone*(this: Lens, keystone: LVecBase2) {.importcpp: "#->set_keystone(#)".} ## \
## Indicates the ratio of keystone correction to perform on the lens, in each
## of three axes.  This will build a special non-affine scale factor into the
## projection matrix that will compensate for keystoning of a projected image;
## this can be used to compensate for a projector that for physical reasons
## cannot be aimed directly at its screen.
##
## The default value is taken from the default-keystone Config variable.  0, 0
## indicates no keystone correction; specify a small value (usually in the
## range -1 .. 1) in either the x or y position to generate a keystone
## correction in that axis.

proc get_keystone*(this: Lens): LVecBase2 {.importcpp: "#->get_keystone()".} ## \
## Returns the keystone correction specified for the lens.

proc clear_keystone*(this: Lens) {.importcpp: "#->clear_keystone()".} ## \
## Disables the lens keystone correction.

proc set_custom_film_mat*(this: Lens, custom_film_mat: LMatrix4) {.importcpp: "#->set_custom_film_mat(#)".} ## \
## Specifies a custom matrix to transform the points on the film after they
## have been converted into nominal film space (-1 .. 1 in U and V).  This can
## be used to introduce arbitrary scales, rotations, or other linear
## transforms to the media plane.  This is normally a 2-d matrix, but a full
## 4x4 matrix may be specified.  This is applied on top of any film size, lens
## shift, and/or keystone correction.

proc get_custom_film_mat*(this: Lens): LMatrix4 {.importcpp: "#->get_custom_film_mat()".} ## \
## Returns the custom_film_mat specified for the lens.

proc clear_custom_film_mat*(this: Lens) {.importcpp: "#->clear_custom_film_mat()".} ## \
## Disables the lens custom_film_mat correction.

proc set_frustum_from_corners*(this: Lens, ul: LVecBase3, ur: LVecBase3, ll: LVecBase3, lr: LVecBase3, flags: int) {.importcpp: "#->set_frustum_from_corners(#, #, #, #, #)".} ## \
## Sets up the lens to use the frustum defined by the four indicated points.
## This is most useful for a PerspectiveLens, but it may be called for other
## kinds of lenses as well.
##
## The frustum will be rooted at the origin (or by whatever translation might
## have been specified in a previous call to set_view_mat).
##
## It is legal for the four points not to be arranged in a rectangle; if this
## is the case, the frustum will be fitted as tightly as possible to cover all
## four points.
##
## The flags parameter contains the union of one or more of the following bits
## to control the behavior of this function:
##
## FC_roll - If this is included, the camera may be rotated so that its up
## vector is perpendicular to the top line.  Otherwise, the standard up vector
## is used.
##
## FC_camera_plane - This allows the camera plane to be adjusted to be as
## nearly perpendicular to the center of the frustum as possible.  Without
## this bit, the orientation camera plane is defined by position of the four
## points (which should all be coplanar).  With this bit, the camera plane is
## arbitrary, and may be chosen so that the four points do not themselves lie
## in the camera plane (but the points will still be within the frustum).
##
## FC_off_axis - This allows the resulting frustum to be off-axis to get the
## tightest possible fit.  Without this bit, the viewing axis will be centered
## within the frustum, but there may be more wasted space along the edges.
##
## FC_aspect_ratio - This allows the frustum to be scaled non-proportionately
## in the vertical and horizontal dimensions, if necessary, to get a tighter
## fit.  Without this bit, the current aspect ratio will be preserved.
##
## FC_shear - This allows the frustum to be sheared, if necessary, to get the
## tightest possible fit.  This may result in a parallelogram-based frustum,
## which will give a slanted appearance to the rendered image.  Without this
## bit, the frustum will be rectangle-based.
##
## In general, if 0 is passed in as the value for flags, the generated frustum
## will be a loose fit but sane; if -1 is passed in, it will be a tighter fit
## and possibly screwy.

proc recompute_all*(this: Lens) {.importcpp: "#->recompute_all()".} ## \
## Forces all internal parameters of the Lens to be recomputed.  Normally,
## this should never need to be called; it is provided only to assist in
## debugging.

proc is_linear*(this: Lens): bool {.importcpp: "#->is_linear()".} ## \
## Returns true if the lens represents a linear projection (e.g.
## PerspectiveLens, OrthographicLens), and therefore there is a valid matrix
## returned by get_projection_mat(), or false otherwise.

proc is_perspective*(this: Lens): bool {.importcpp: "#->is_perspective()".} ## \
## Returns true if the lens represents a perspective projection (i.e.  it is a
## PerspectiveLens), false otherwise.

proc is_orthographic*(this: Lens): bool {.importcpp: "#->is_orthographic()".} ## \
## Returns true if the lens represents a orthographic projection (i.e.  it is
## a OrthographicLens), false otherwise.

proc make_geometry*(this: Lens): Geom {.importcpp: "#->make_geometry()".} ## \
## Allocates and returns a new Geom that can be rendered to show a visible
## representation of the frustum used for this kind of lens, if it makes sense
## to do so.  If a visible representation cannot be created, returns NULL.

proc make_bounds*(this: Lens): BoundingVolume {.importcpp: "#->make_bounds()".} ## \
## Allocates and returns a new BoundingVolume that encloses the frustum used
## for this kind of lens, if possible.  If a suitable bounding volume cannot
## be created, returns NULL.

proc get_projection_mat*(this: Lens): LMatrix4 {.importcpp: "#->get_projection_mat()".} ## \
## Returns the complete transformation matrix from a 3-d point in space to a
## point on the film, if such a matrix exists, or the identity matrix if the
## lens is nonlinear.

proc get_projection_mat_inv*(this: Lens): LMatrix4 {.importcpp: "#->get_projection_mat_inv()".} ## \
## Returns the matrix that transforms from a 2-d point on the film to a 3-d
## vector in space, if such a matrix exists.

proc get_film_mat*(this: Lens): LMatrix4 {.importcpp: "#->get_film_mat()".} ## \
## Returns the matrix that transforms from a point behind the lens to a point
## on the film.

proc get_film_mat_inv*(this: Lens): LMatrix4 {.importcpp: "#->get_film_mat_inv()".} ## \
## Returns the matrix that transforms from a point on the film to a point
## behind the lens.

proc get_lens_mat*(this: Lens): LMatrix4 {.importcpp: "#->get_lens_mat()".} ## \
## Returns the matrix that transforms from a point in front of the lens to a
## point in space.

proc get_lens_mat_inv*(this: Lens): LMatrix4 {.importcpp: "#->get_lens_mat_inv()".} ## \
## Returns the matrix that transforms from a point in space to a point in
## front of the lens.

proc output*(this: Lens, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: Lens, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: Lens, `out`: ostream) {.importcpp: "#->write(#)".}

proc get_last_change*(this: Lens): UpdateSeq {.importcpp: "#->get_last_change()".} ## \
## Returns the UpdateSeq that is incremented whenever the lens properties are
## changed.  As long as this number remains the same, you may assume the lens
## properties are unchanged.

proc get_class_type*(_: typedesc[Lens]): TypeHandle {.importcpp: "Lens::get_class_type()", header: "lens.h".}

converter upcast_to_TypedWritableReferenceCount*(this: Material): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcast_to_Namable*(this: Material): Namable {.importcpp: "((Namable *)(#.p()))".}

proc newMaterial*(copy: Material): Material {.importcpp: "new Material(#)".}

proc newMaterial*(name: string): Material {.importcpp: "new Material(nimStringToStdString(#))", header: stringConversionCode.}

proc newMaterial*(): Material {.importcpp: "new Material()".}

proc get_default*(_: typedesc[Material]): Material {.importcpp: "Material::get_default()", header: "material.h".} ## \
## Returns the default material.

proc has_base_color*(this: Material): bool {.importcpp: "#->has_base_color()".} ## \
## Returns true if the base color has been explicitly set for this material,
## false otherwise.

proc get_base_color*(this: Material): LColor {.importcpp: "#->get_base_color()".} ## \
## Returns the base_color color setting, if it has been set.  If neither the
## base color nor the metallic have been set, this returns the diffuse color.

proc set_base_color*(this: Material, color: LColor) {.importcpp: "#->set_base_color(#)".} ## \
## Specifies the base color of the material.  In conjunction with
## set_metallic, this is an alternate way to specify the color of a material.
## For dielectrics, this will determine the value of the diffuse color, and
## for metals, this will determine the value of the specular color.
##
## Setting this will clear an explicit specular, diffuse or ambient color
## assignment.
##
## If this is not set, the object color will be used.

proc clear_base_color*(this: Material) {.importcpp: "#->clear_base_color()".} ## \
## Removes the explicit base_color color from the material.

proc has_ambient*(this: Material): bool {.importcpp: "#->has_ambient()".} ## \
## Returns true if the ambient color has been explicitly set for this
## material, false otherwise.

proc get_ambient*(this: Material): LColor {.importcpp: "#->get_ambient()".} ## \
## Returns the ambient color setting, if it has been set.  Returns (0,0,0,0)
## if the ambient color has not been set.

proc set_ambient*(this: Material, color: LColor) {.importcpp: "#->set_ambient(#)".} ## \
## Specifies the ambient color setting of the material.  This will be the
## multiplied by any ambient lights in effect on the material to set its base
## color.
##
## This is the color of the object as it appears in the absence of direct
## light.
##
## If this is not set, the object color will be used.

proc clear_ambient*(this: Material) {.importcpp: "#->clear_ambient()".} ## \
## Removes the explicit ambient color from the material.

proc has_diffuse*(this: Material): bool {.importcpp: "#->has_diffuse()".} ## \
## Returns true if the diffuse color has been explicitly set for this
## material, false otherwise.

proc get_diffuse*(this: Material): LColor {.importcpp: "#->get_diffuse()".} ## \
## Returns the diffuse color setting, if it has been set.  Returns (1,1,1,1)
## if the diffuse color has not been set.

proc set_diffuse*(this: Material, color: LColor) {.importcpp: "#->set_diffuse(#)".} ## \
## Specifies the diffuse color setting of the material.  This will be
## multiplied by any lights in effect on the material to get the color in the
## parts of the object illuminated by the lights.
##
## This is the primary color of an object; the color of the object as it
## appears in direct light, in the absence of highlights.
##
## If this is not set, the object color will be used.

proc clear_diffuse*(this: Material) {.importcpp: "#->clear_diffuse()".} ## \
## Removes the explicit diffuse color from the material.

proc has_specular*(this: Material): bool {.importcpp: "#->has_specular()".} ## \
## Returns true if the specular color has been explicitly set for this
## material, false otherwise.

proc get_specular*(this: Material): LColor {.importcpp: "#->get_specular()".} ## \
## Returns the specular color setting, if it has been set.  Returns (0,0,0,0)
## if the specular color has not been set.

proc set_specular*(this: Material, color: LColor) {.importcpp: "#->set_specular(#)".} ## \
## Specifies the specular color setting of the material.  This will be
## multiplied by any lights in effect on the material to compute the color of
## specular highlights on the object.
##
## This is the highlight color of an object: the color of small highlight
## reflections.
##
## If this is not set, the specular color is taken from the index of
## refraction, which is 1 by default (meaning no specular reflections are
## generated).

proc clear_specular*(this: Material) {.importcpp: "#->clear_specular()".} ## \
## Removes the explicit specular color from the material.

proc has_emission*(this: Material): bool {.importcpp: "#->has_emission()".} ## \
## Returns true if the emission color has been explicitly set for this
## material, false otherwise.

proc get_emission*(this: Material): LColor {.importcpp: "#->get_emission()".} ## \
## Returns the emission color setting, if it has been set.  Returns (0,0,0,0)
## if the emission color has not been set.

proc set_emission*(this: Material, color: LColor) {.importcpp: "#->set_emission(#)".} ## \
## Specifies the emission color setting of the material.  This is the color of
## the object as it appears in the absence of any light whatsover, including
## ambient light.  It is as if the object is glowing by this color (although
## of course it will not illuminate neighboring objects).
##
## If this is not set, the object will not glow by its own light and will only
## appear visible in the presence of one or more lights.

proc clear_emission*(this: Material) {.importcpp: "#->clear_emission()".} ## \
## Removes the explicit emission color from the material.

proc get_shininess*(this: Material): float32 {.importcpp: "#->get_shininess()".} ## \
## Returns the shininess exponent of the material.

proc set_shininess*(this: Material, shininess: float32) {.importcpp: "#->set_shininess(#)".} ## \
## Sets the shininess exponent of the material.  This controls the size of the
## specular highlight spot.  In general, larger number produce a smaller
## specular highlight, which makes the object appear shinier.  Smaller numbers
## produce a larger highlight, which makes the object appear less shiny.
##
## This is usually in the range 0..128.
##
## Setting a shininess value removes any previous roughness assignment.

proc has_roughness*(this: Material): bool {.importcpp: "#->has_roughness()".} ## \
## Returns true if the roughness has been explicitly set for this material,
## false otherwise.

proc get_roughness*(this: Material): float32 {.importcpp: "#->get_roughness()".} ## \
## Returns the roughness previously specified by set_roughness.  If none was
## previously set, this value is computed from the shininess value.

proc set_roughness*(this: Material, roughness: float32) {.importcpp: "#->set_roughness(#)".} ## \
## Sets the roughness exponent of the material, where 0 is completely shiny
## (infinite shininess), and 1 is a completely dull object (0 shininess).
## This is a different, more perceptually intuitive way of controlling the
## size of the specular spot, and more commonly used in physically-based
## rendering.
##
## Setting a roughness recalculates the shininess value.

proc has_metallic*(this: Material): bool {.importcpp: "#->has_metallic()".} ## \
## Returns true if the metallic has been explicitly set for this material,
## false otherwise.

proc get_metallic*(this: Material): float32 {.importcpp: "#->get_metallic()".} ## \
## Returns the metallic setting, if it has been set.  Returns 0 if it has not
## been set.

proc set_metallic*(this: Material, metallic: float32) {.importcpp: "#->set_metallic(#)".} ## \
## Sets the metallic setting of the material, which is is used for physically-
## based rendering models.  This is usually 0 for dielectric materials and 1
## for metals.  It really does not make sense to set this to a value other
## than 0 or 1, but it is nonetheless a float for compatibility with tools
## that allow setting this to values other than 0 or 1.

proc clear_metallic*(this: Material) {.importcpp: "#->clear_metallic()".} ## \
## Removes the explicit metallic setting from the material.

proc has_refractive_index*(this: Material): bool {.importcpp: "#->has_refractive_index()".} ## \
## Returns true if a refractive index has explicitly been specified for this
## material.

proc get_refractive_index*(this: Material): float32 {.importcpp: "#->get_refractive_index()".} ## \
## Returns the index of refraction, or 1 if none has been set for this
## material.

proc set_refractive_index*(this: Material, refractive_index: float32) {.importcpp: "#->set_refractive_index(#)".} ## \
## Sets the index of refraction of the material, which is used to determine
## the specular color in absence of an explicit specular color assignment.
## This is usually 1.5 for dielectric materials.  It is not very useful for
## metals, since they cannot be described as easily with a single number.
##
## Should be 1 or higher.  The default is 1.

proc get_local*(this: Material): bool {.importcpp: "#->get_local()".} ## \
## Returns the local viewer flag.  Set set_local().

proc set_local*(this: Material, local: bool) {.importcpp: "#->set_local(#)".} ## \
## Sets the local viewer flag.  Set this true to enable camera-relative
## specular highlights, or false to use orthogonal specular highlights.  The
## default value is true.  Applications that use orthogonal projection should
## specify false.

proc get_twoside*(this: Material): bool {.importcpp: "#->get_twoside()".} ## \
## Returns the state of the two-sided lighting flag.  See set_twoside().

proc set_twoside*(this: Material, twoside: bool) {.importcpp: "#->set_twoside(#)".} ## \
## Set this true to enable two-sided lighting.  When two-sided lighting is on,
## both sides of a polygon will be lit by this material.  The default is for
## two-sided lighting to be off, in which case only the front surface is lit.

proc `==`*(this: Material, other: Material): bool {.importcpp: "#->operator ==(#)".}

proc `!=`*(this: Material, other: Material): bool {.importcpp: "#->operator !=(#)".}

proc `<`*(this: Material, other: Material): bool {.importcpp: "#->operator <(#)".}

proc compare_to*(this: Material, other: Material): int {.importcpp: "#->compare_to(#)".} ## \
## Returns a number less than zero if this material sorts before the other
## one, greater than zero if it sorts after, or zero if they are equivalent.
## The sorting order is arbitrary and largely meaningless, except to
## differentiate different materials.

proc output*(this: Material, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: Material, `out`: ostream, indent: int) {.importcpp: "#->write(#, #)".}

proc is_attrib_locked*(this: Material): bool {.importcpp: "#->is_attrib_locked()".} ## \
## @deprecated This no longer has any meaning in 1.10.

proc set_attrib_lock*(this: Material) {.importcpp: "#->set_attrib_lock()".} ## \
## @deprecated This no longer has any meaning in 1.10.

proc get_class_type*(_: typedesc[Material]): TypeHandle {.importcpp: "Material::get_class_type()", header: "material.h".}

proc get_material*(_: typedesc[MaterialPool], temp: Material): Material {.importcpp: "MaterialPool::get_material(#)", header: "materialPool.h".} ## \
## Returns a Material pointer that represents the same material described by
## temp, except that it is a shared pointer.
##
## Each call to get_material() passing an equivalent Material pointer will
## return the same shared pointer.
##
## If you modify the shared pointer, it will automatically disassociate it
## from the pool.
##
## Also, the return value may be a different pointer than that passed in, or
## it may be the same pointer.  In either case, the passed in pointer has now
## been sacrificed to the greater good and should not be used again (like any
## other PointerTo, it will be freed when the last reference count is
## removed).

proc release_material*(_: typedesc[MaterialPool], temp: Material) {.importcpp: "MaterialPool::release_material(#)", header: "materialPool.h".} ## \
## Removes the indicated material from the pool.

proc release_all_materials*(_: typedesc[MaterialPool]) {.importcpp: "MaterialPool::release_all_materials()", header: "materialPool.h".} ## \
## Releases all materials in the pool and restores the pool to the empty
## state.

proc garbage_collect*(_: typedesc[MaterialPool]): int {.importcpp: "MaterialPool::garbage_collect()", header: "materialPool.h".} ## \
## Releases only those materials in the pool that have a reference count of
## exactly 1; i.e.  only those materials that are not being used outside of
## the pool.  Returns the number of materials released.

proc list_contents*(_: typedesc[MaterialPool], `out`: ostream) {.importcpp: "MaterialPool::list_contents(#)", header: "materialPool.h".} ## \
## Lists the contents of the material pool to the indicated output stream.

proc write*(_: typedesc[MaterialPool], `out`: ostream) {.importcpp: "MaterialPool::write(#)", header: "materialPool.h".} ## \
## Lists the contents of the material pool to the indicated output stream.

proc newMatrixLens*(): MatrixLens {.importcpp: "new MatrixLens()".}

proc set_user_mat*(this: MatrixLens, user_mat: LMatrix4) {.importcpp: "#->set_user_mat(#)".} ## \
## Explicitly specifies the projection matrix.  This matrix should convert X
## and Y to the range [-film_size/2, film_size/2], where (-fs/2,-fs/2) is the
## lower left corner of the screen and (fs/2, fs/2) is the upper right.  Z
## should go to the range [-1, 1], where -1 is the near plane and 1 is the far
## plane.  Note that this is a left-handed Y-up coordinate system.
##
## The default film_size for a MatrixLens is 2, so the default range is [-1,
## 1] for both X and Y.  This is consistent with the GL conventions for
## projection matrices.

proc get_user_mat*(this: MatrixLens): LMatrix4 {.importcpp: "#->get_user_mat()".} ## \
## Returns the explicit projection matrix as set by the user.  This does not
## include transforms on the lens or film (e.g.  a film offset or view hpr).

proc set_left_eye_mat*(this: MatrixLens, user_mat: LMatrix4) {.importcpp: "#->set_left_eye_mat(#)".} ## \
## Sets a custom projection matrix for the left eye.  This is only used if the
## lens is attached to a stereo camera, in which case the left eye matrix will
## be used to draw the scene in the left eye (but the center matrix--the
## user_mat--will still be used to cull the scene).
##
## This matrix should not be too different from the center matrix (set by
## set_user_mat()) or culling errors may become obvious.

proc clear_left_eye_mat*(this: MatrixLens) {.importcpp: "#->clear_left_eye_mat()".} ## \
## Removes the custom projection matrix set for the left eye, and uses the
## center matrix (set by set_user_mat) instead.

proc has_left_eye_mat*(this: MatrixLens): bool {.importcpp: "#->has_left_eye_mat()".} ## \
## Returns true if the camera has a custom projection matrix set for the left
## eye, or false if the center matrix (set by set_user_mat) will be used for
## the left eye.

proc get_left_eye_mat*(this: MatrixLens): LMatrix4 {.importcpp: "#->get_left_eye_mat()".} ## \
## Returns the custom projection matrix for the left eye, if any, or the
## center matrix if there is no custom matrix set for the left eye.

proc set_right_eye_mat*(this: MatrixLens, user_mat: LMatrix4) {.importcpp: "#->set_right_eye_mat(#)".} ## \
## Sets a custom projection matrix for the right eye.  This is only used if
## the lens is attached to a stereo camera, in which case the right eye matrix
## will be used to draw the scene in the right eye (but the center matrix--the
## user_mat--will still be used to cull the scene).
##
## This matrix should not be too different from the center matrix (set by
## set_user_mat()) or culling errors may become obvious.

proc clear_right_eye_mat*(this: MatrixLens) {.importcpp: "#->clear_right_eye_mat()".} ## \
## Removes the custom projection matrix set for the right eye, and uses the
## center matrix (set by set_user_mat) instead.

proc has_right_eye_mat*(this: MatrixLens): bool {.importcpp: "#->has_right_eye_mat()".} ## \
## Returns true if the camera has a custom projection matrix set for the right
## eye, or false if the center matrix (set by set_user_mat) will be used for
## the right eye.

proc get_right_eye_mat*(this: MatrixLens): LMatrix4 {.importcpp: "#->get_right_eye_mat()".} ## \
## Returns the custom projection matrix for the right eye, if any, or the
## center matrix if there is no custom matrix set for the right eye.

proc get_class_type*(_: typedesc[MatrixLens]): TypeHandle {.importcpp: "MatrixLens::get_class_type()", header: "matrixLens.h".}

proc newOrthographicLens*(): OrthographicLens {.importcpp: "new OrthographicLens()".}

proc get_class_type*(_: typedesc[OrthographicLens]): TypeHandle {.importcpp: "OrthographicLens::get_class_type()", header: "orthographicLens.h".}

proc newParamTextureSampler*(tex: Texture, sampler: SamplerState): ParamTextureSampler {.importcpp: "new ParamTextureSampler(#, #)".} ## \
## Creates a new ParamTextureSampler storing the given texture and sampler
## objects.

proc get_texture*(this: ParamTextureSampler): Texture {.importcpp: "#->get_texture()".} ## \
## Retrieves the texture stored in the parameter.

proc get_sampler*(this: ParamTextureSampler): SamplerState {.importcpp: "#->get_sampler()".} ## \
## Retrieves the sampler state stored in the parameter.

proc get_class_type*(_: typedesc[ParamTextureSampler]): TypeHandle {.importcpp: "ParamTextureSampler::get_class_type()", header: "paramTextureSampler.h".}

proc newParamTextureImage*(tex: Texture, read: bool, write: bool, z: int, n: int): ParamTextureImage {.importcpp: "new ParamTextureImage(#, #, #, #, #)".} ## \
## Creates a new ParamTextureImage storing the given texture and image binding
## parameters.

proc newParamTextureImage*(tex: Texture, read: bool, write: bool, z: int): ParamTextureImage {.importcpp: "new ParamTextureImage(#, #, #, #)".} ## \
## Creates a new ParamTextureImage storing the given texture and image binding
## parameters.

proc newParamTextureImage*(tex: Texture, read: bool, write: bool): ParamTextureImage {.importcpp: "new ParamTextureImage(#, #, #)".} ## \
## Creates a new ParamTextureImage storing the given texture and image binding
## parameters.

proc get_texture*(this: ParamTextureImage): Texture {.importcpp: "#->get_texture()".} ## \
## Retrieves the texture stored in the parameter.

proc has_read_access*(this: ParamTextureImage): bool {.importcpp: "#->has_read_access()".} ## \
## Returns true if this image should be bound with read access enabled.

proc has_write_access*(this: ParamTextureImage): bool {.importcpp: "#->has_write_access()".} ## \
## Returns true if this image should be bound with write access enabled.

proc get_bind_layered*(this: ParamTextureImage): bool {.importcpp: "#->get_bind_layered()".} ## \
## Returns true if all layers of this image should be bound simultaneously.

proc get_bind_level*(this: ParamTextureImage): int {.importcpp: "#->get_bind_level()".} ## \
## Returns the image level that should be bound.

proc get_bind_layer*(this: ParamTextureImage): int {.importcpp: "#->get_bind_layer()".} ## \
## Returns the image layer that should be bound.  This is undefined if
## get_bind_layered() returns false.

proc get_class_type*(_: typedesc[ParamTextureImage]): TypeHandle {.importcpp: "ParamTextureImage::get_class_type()", header: "paramTextureImage.h".}

proc newPerspectiveLens*(): PerspectiveLens {.importcpp: "new PerspectiveLens()".}

proc newPerspectiveLens*(hfov: float32, vfov: float32): PerspectiveLens {.importcpp: "new PerspectiveLens(#, #)".}

proc get_class_type*(_: typedesc[PerspectiveLens]): TypeHandle {.importcpp: "PerspectiveLens::get_class_type()", header: "perspectiveLens.h".}

proc newTextureReloadRequest*(param0: TextureReloadRequest): TextureReloadRequest {.importcpp: "new TextureReloadRequest(#)".}

proc newTextureReloadRequest*(name: string, pgo: PreparedGraphicsObjects, texture: Texture, allow_compressed: bool): TextureReloadRequest {.importcpp: "new TextureReloadRequest(nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Create a new TextureReloadRequest, and add it to the loader via
## load_async(), to begin an asynchronous load.

proc get_prepared_graphics_objects*(this: TextureReloadRequest): PreparedGraphicsObjects {.importcpp: "#->get_prepared_graphics_objects()".} ## \
## Returns the PreparedGraphicsObjects object associated with this
## asynchronous TextureReloadRequest.

proc get_texture*(this: TextureReloadRequest): Texture {.importcpp: "#->get_texture()".} ## \
## Returns the Texture object associated with this asynchronous
## TextureReloadRequest.

proc get_allow_compressed*(this: TextureReloadRequest): bool {.importcpp: "#->get_allow_compressed()".} ## \
## Returns the "allow compressed" flag associated with this asynchronous
## TextureReloadRequest.

proc is_ready*(this: TextureReloadRequest): bool {.importcpp: "#->is_ready()".} ## \
## Returns true if this request has completed, false if it is still pending.
## Equivalent to `req.done() and not req.cancelled()`.
## @see done()

proc get_class_type*(_: typedesc[TextureReloadRequest]): TypeHandle {.importcpp: "TextureReloadRequest::get_class_type()", header: "textureReloadRequest.h".}

converter upcast_to_BufferContext*(this: TextureContext): BufferContext {.importcpp: "#.upcast_to_BufferContext()".}

converter upcast_to_AdaptiveLruPage*(this: TextureContext): AdaptiveLruPage {.importcpp: "#.upcast_to_AdaptiveLruPage()".}

proc get_texture*(this: TextureContext): Texture {.importcpp: "#.get_texture()".} ## \
## Returns the pointer to the associated Texture object.

proc get_view*(this: TextureContext): int {.importcpp: "#.get_view()".} ## \
## Returns the specific view of a multiview texture this context represents.
## In the usual case, with a non-multiview texture, this will be 0.

proc get_native_id*(this: TextureContext): clonglong {.importcpp: "#.get_native_id()".} ## \
## Returns an implementation-defined handle or pointer that can be used
## to interface directly with the underlying API.
## Returns 0 if the underlying implementation does not support this.

proc get_native_buffer_id*(this: TextureContext): clonglong {.importcpp: "#.get_native_buffer_id()".} ## \
## Similar to get_native_id, but some implementations use a separate
## identifier for the buffer object associated with buffer textures.
## Returns 0 if the underlying implementation does not support this, or
## if this is not a buffer texture.

proc was_modified*(this: TextureContext): bool {.importcpp: "#.was_modified()".} ## \
## Returns true if the texture properties or image have been modified since
## the last time mark_loaded() was called.

proc was_properties_modified*(this: TextureContext): bool {.importcpp: "#.was_properties_modified()".} ## \
## Returns true if the texture properties (unrelated to the image) have been
## modified since the last time mark_loaded() was called.

proc was_image_modified*(this: TextureContext): bool {.importcpp: "#.was_image_modified()".} ## \
## Returns true if the texture image has been modified since the last time
## mark_loaded() was called.

proc was_simple_image_modified*(this: TextureContext): bool {.importcpp: "#.was_simple_image_modified()".} ## \
## Returns true if the texture's "simple" image has been modified since the
## last time mark_simple_loaded() was called.

proc get_properties_modified*(this: TextureContext): UpdateSeq {.importcpp: "#.get_properties_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the texture properties (unrelated to the image) are modified.

proc get_image_modified*(this: TextureContext): UpdateSeq {.importcpp: "#.get_image_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the texture image data (including mipmap levels) are modified.

proc get_simple_image_modified*(this: TextureContext): UpdateSeq {.importcpp: "#.get_simple_image_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the texture's "simple" image data is modified.

proc get_class_type*(_: typedesc[TextureContext]): TypeHandle {.importcpp: "TextureContext::get_class_type()", header: "textureContext.h".}

proc get_shader*(this: ShaderContext): Shader {.importcpp: "#.get_shader()".}

proc get_class_type*(_: typedesc[ShaderContext]): TypeHandle {.importcpp: "ShaderContext::get_class_type()", header: "shaderContext.h".}

proc newUserVertexSlider*(name: InternalName): UserVertexSlider {.importcpp: "new UserVertexSlider(#)".}

proc newUserVertexSlider*(name: string): UserVertexSlider {.importcpp: "new UserVertexSlider(nimStringToStdString(#))", header: stringConversionCode.}

proc set_slider*(this: UserVertexSlider, slider: float32) {.importcpp: "#->set_slider(#)".} ## \
## Stores the indicated slider value.

proc get_class_type*(_: typedesc[UserVertexSlider]): TypeHandle {.importcpp: "UserVertexSlider::get_class_type()", header: "userVertexSlider.h".}

proc newUserVertexTransform*(name: string): UserVertexTransform {.importcpp: "new UserVertexTransform(nimStringToStdString(#))", header: stringConversionCode.}

proc get_name*(this: UserVertexTransform): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the name passed to the constructor.  Completely arbitrary.

proc set_matrix*(this: UserVertexTransform, matrix: LMatrix4) {.importcpp: "#->set_matrix(#)".} ## \
## Stores the indicated matrix.

proc get_class_type*(_: typedesc[UserVertexTransform]): TypeHandle {.importcpp: "UserVertexTransform::get_class_type()", header: "userVertexTransform.h".}

converter upcast_to_Texture*(this: VideoTexture): Texture {.importcpp: "(PT(Texture)(#))".}

converter upcast_to_AnimInterface*(this: VideoTexture): AnimInterface {.importcpp: "((AnimInterface *)(#.p()))".}

proc get_keep_ram_image*(this: VideoTexture): bool {.importcpp: "#->get_keep_ram_image()".} ## \
## Returns the flag that indicates whether this Texture is eligible to have
## its main RAM copy of the texture memory dumped when the texture is prepared
## for rendering.  See set_keep_ram_image().

proc get_video_width*(this: VideoTexture): int {.importcpp: "#->get_video_width()".} ## \
## Returns the width in texels of the source video stream.  This is not
## necessarily the width of the actual texture, since the texture may have
## been expanded to raise it to a power of 2.

proc get_video_height*(this: VideoTexture): int {.importcpp: "#->get_video_height()".} ## \
## Returns the height in texels of the source video stream.  This is not
## necessarily the height of the actual texture, since the texture may have
## been expanded to raise it to a power of 2.

proc get_class_type*(_: typedesc[VideoTexture]): TypeHandle {.importcpp: "VideoTexture::get_class_type()", header: "videoTexture.h".}

converter upcast_to_BufferContext*(this: VertexBufferContext): BufferContext {.importcpp: "#.upcast_to_BufferContext()".}

converter upcast_to_AdaptiveLruPage*(this: VertexBufferContext): AdaptiveLruPage {.importcpp: "#.upcast_to_AdaptiveLruPage()".}

proc get_data*(this: VertexBufferContext): GeomVertexArrayData {.importcpp: "#.get_data()".} ## \
## Returns the pointer to the client-side array data object.

proc changed_size*(this: VertexBufferContext, reader: GeomVertexArrayDataHandle): bool {.importcpp: "#.changed_size(#)".} ## \
## Returns true if the data has changed size since the last time mark_loaded()
## was called.

proc changed_usage_hint*(this: VertexBufferContext, reader: GeomVertexArrayDataHandle): bool {.importcpp: "#.changed_usage_hint(#)".} ## \
## Returns true if the data has changed its usage hint since the last time
## mark_loaded() was called.

proc was_modified*(this: VertexBufferContext, reader: GeomVertexArrayDataHandle): bool {.importcpp: "#.was_modified(#)".} ## \
## Returns true if the data has been modified since the last time
## mark_loaded() was called.

proc get_class_type*(_: typedesc[VertexBufferContext]): TypeHandle {.importcpp: "VertexBufferContext::get_class_type()", header: "vertexBufferContext.h".}

proc initTextureCollection*(): TextureCollection {.importcpp: "TextureCollection()".}

proc initTextureCollection*(copy: TextureCollection): TextureCollection {.importcpp: "TextureCollection(#)".}

proc add_texture*(this: TextureCollection, texture: Texture) {.importcpp: "#.add_texture(#)".} ## \
## Adds a new Texture to the collection.

proc remove_texture*(this: TextureCollection, texture: Texture): bool {.importcpp: "#.remove_texture(#)".} ## \
## Removes the indicated Texture from the collection.  Returns true if the
## texture was removed, false if it was not a member of the collection.

proc add_textures_from*(this: TextureCollection, other: TextureCollection) {.importcpp: "#.add_textures_from(#)".} ## \
## Adds all the Textures indicated in the other collection to this texture.
## The other textures are simply appended to the end of the textures in this
## list; duplicates are not automatically removed.

proc remove_textures_from*(this: TextureCollection, other: TextureCollection) {.importcpp: "#.remove_textures_from(#)".} ## \
## Removes from this collection all of the Textures listed in the other
## collection.

proc remove_duplicate_textures*(this: TextureCollection) {.importcpp: "#.remove_duplicate_textures()".} ## \
## Removes any duplicate entries of the same Textures on this collection.  If
## a Texture appears multiple times, the first appearance is retained;
## subsequent appearances are removed.

proc has_texture*(this: TextureCollection, texture: Texture): bool {.importcpp: "#.has_texture(#)".} ## \
## Returns true if the indicated Texture appears in this collection, false
## otherwise.

proc clear*(this: TextureCollection) {.importcpp: "#.clear()".} ## \
## Removes all Textures from the collection.

proc reserve*(this: TextureCollection, num: clonglong) {.importcpp: "#.reserve(#)".} ## \
## This is a hint to Panda to allocate enough memory to hold the given number
## of NodePaths, if you know ahead of time how many you will be adding.

proc find_texture*(this: TextureCollection, name: string): Texture {.importcpp: "#.find_texture(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the texture in the collection with the indicated name, if any, or
## NULL if no texture has that name.

proc get_num_textures*(this: TextureCollection): int {.importcpp: "#.get_num_textures()".} ## \
## Returns the number of Textures in the collection.

proc get_texture*(this: TextureCollection, index: int): Texture {.importcpp: "#.get_texture(#)".} ## \
## Returns the nth Texture in the collection.

proc `[]`*(this: TextureCollection, index: int): Texture {.importcpp: "#.operator [](#)".} ## \
## Returns the nth Texture in the collection.  This is the same as
## get_texture(), but it may be a more convenient way to access it.

proc size*(this: TextureCollection): int {.importcpp: "#.size()".} ## \
## Returns the number of textures in the collection.  This is the same thing
## as get_num_textures().

proc `+=`*(this: TextureCollection, other: TextureCollection): TextureCollection {.importcpp: "#.operator +=(#)".}

proc `+`*(this: TextureCollection, other: TextureCollection): TextureCollection {.importcpp: "#.operator +(#)".}

proc append*(this: TextureCollection, texture: Texture) {.importcpp: "#.append(#)".} ## \
## Adds a new Texture to the collection.  This method duplicates the
## add_texture() method; it is provided to satisfy Python's naming convention.

proc extend*(this: TextureCollection, other: TextureCollection) {.importcpp: "#.extend(#)".} ## \
## Appends the other list onto the end of this one.  This method duplicates
## the += operator; it is provided to satisfy Python's naming convention.

proc output*(this: TextureCollection, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes a brief one-line description of the TextureCollection to the
## indicated output stream.

proc write*(this: TextureCollection, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes a complete multi-line description of the TextureCollection to the
## indicated output stream.

proc write*(this: TextureCollection, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a complete multi-line description of the TextureCollection to the
## indicated output stream.

proc has_texture*(_: typedesc[TexturePool], filename: Filename): bool {.importcpp: "TexturePool::has_texture(#)", header: "texturePool.h".} ## \
## Returns true if the texture has ever been loaded, false otherwise.

proc verify_texture*(_: typedesc[TexturePool], filename: Filename): bool {.importcpp: "TexturePool::verify_texture(#)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns true to indicate success, or false to indicate failure.
## If this returns true, it is guaranteed that a subsequent call to
## load_texture() with the same texture name will return a valid Texture
## pointer.

proc get_texture*(_: typedesc[TexturePool], filename: Filename, alpha_filename: Filename, primary_file_num_channels: int, alpha_file_channel: int, read_mipmaps: bool): Texture {.importcpp: "TexturePool::get_texture(#, #, #, #, #)", header: "texturePool.h".} ## \
## Returns the texture that has already been previously loaded, or NULL
## otherwise.

proc get_texture*(_: typedesc[TexturePool], filename: Filename, alpha_filename: Filename, primary_file_num_channels: int, alpha_file_channel: int): Texture {.importcpp: "TexturePool::get_texture(#, #, #, #)", header: "texturePool.h".} ## \
## Returns the texture that has already been previously loaded, or NULL
## otherwise.

proc get_texture*(_: typedesc[TexturePool], filename: Filename, alpha_filename: Filename, primary_file_num_channels: int): Texture {.importcpp: "TexturePool::get_texture(#, #, #)", header: "texturePool.h".} ## \
## Returns the texture that has already been previously loaded, or NULL
## otherwise.

proc get_texture*(_: typedesc[TexturePool], filename: Filename, alpha_filename: Filename): Texture {.importcpp: "TexturePool::get_texture(#, #)", header: "texturePool.h".} ## \
## Returns the texture that has already been previously loaded, or NULL
## otherwise.

proc get_texture*(_: typedesc[TexturePool], filename: Filename, primary_file_num_channels: int, read_mipmaps: bool): Texture {.importcpp: "TexturePool::get_texture(#, #, #)", header: "texturePool.h".} ## \
## Returns the texture that has already been previously loaded, or NULL
## otherwise.

proc get_texture*(_: typedesc[TexturePool], filename: Filename, primary_file_num_channels: int): Texture {.importcpp: "TexturePool::get_texture(#, #)", header: "texturePool.h".} ## \
## Returns the texture that has already been previously loaded, or NULL
## otherwise.

proc get_texture*(_: typedesc[TexturePool], filename: Filename): Texture {.importcpp: "TexturePool::get_texture(#)", header: "texturePool.h".} ## \
## Returns the texture that has already been previously loaded, or NULL
## otherwise.

proc load_texture*(_: typedesc[TexturePool], filename: Filename, alpha_filename: Filename, primary_file_num_channels: int, alpha_file_channel: int, read_mipmaps: bool, options: LoaderOptions): Texture {.importcpp: "TexturePool::load_texture(#, #, #, #, #, #)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns the new texture.  If a texture with the same filename
## was previously loaded, returns that one instead.  If the texture file
## cannot be found, returns NULL.
##
## If read_mipmaps is true, both filenames should contain a hash mark ('#'),
## which will be filled in with the mipmap level number; and the texture will
## be defined with a series of images, two for each mipmap level.

proc load_texture*(_: typedesc[TexturePool], filename: Filename, alpha_filename: Filename, primary_file_num_channels: int, alpha_file_channel: int, read_mipmaps: bool): Texture {.importcpp: "TexturePool::load_texture(#, #, #, #, #)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns the new texture.  If a texture with the same filename
## was previously loaded, returns that one instead.  If the texture file
## cannot be found, returns NULL.
##
## If read_mipmaps is true, both filenames should contain a hash mark ('#'),
## which will be filled in with the mipmap level number; and the texture will
## be defined with a series of images, two for each mipmap level.

proc load_texture*(_: typedesc[TexturePool], filename: Filename, alpha_filename: Filename, primary_file_num_channels: int, alpha_file_channel: int): Texture {.importcpp: "TexturePool::load_texture(#, #, #, #)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns the new texture.  If a texture with the same filename
## was previously loaded, returns that one instead.  If the texture file
## cannot be found, returns NULL.
##
## If read_mipmaps is true, both filenames should contain a hash mark ('#'),
## which will be filled in with the mipmap level number; and the texture will
## be defined with a series of images, two for each mipmap level.

proc load_texture*(_: typedesc[TexturePool], filename: Filename, alpha_filename: Filename, primary_file_num_channels: int): Texture {.importcpp: "TexturePool::load_texture(#, #, #)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns the new texture.  If a texture with the same filename
## was previously loaded, returns that one instead.  If the texture file
## cannot be found, returns NULL.
##
## If read_mipmaps is true, both filenames should contain a hash mark ('#'),
## which will be filled in with the mipmap level number; and the texture will
## be defined with a series of images, two for each mipmap level.

proc load_texture*(_: typedesc[TexturePool], filename: Filename, alpha_filename: Filename): Texture {.importcpp: "TexturePool::load_texture(#, #)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns the new texture.  If a texture with the same filename
## was previously loaded, returns that one instead.  If the texture file
## cannot be found, returns NULL.
##
## If read_mipmaps is true, both filenames should contain a hash mark ('#'),
## which will be filled in with the mipmap level number; and the texture will
## be defined with a series of images, two for each mipmap level.

proc load_texture*(_: typedesc[TexturePool], filename: Filename, primary_file_num_channels: int, read_mipmaps: bool, options: LoaderOptions): Texture {.importcpp: "TexturePool::load_texture(#, #, #, #)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns the new texture.  If a texture with the same filename
## was previously loaded, returns that one instead.  If the texture file
## cannot be found, returns NULL.
##
## If read_mipmaps is true, the filename should contain a hash mark ('#'),
## which will be filled in with the mipmap level number; and the texture will
## be defined with a series of images, one for each mipmap level.

proc load_texture*(_: typedesc[TexturePool], filename: Filename, primary_file_num_channels: int, read_mipmaps: bool): Texture {.importcpp: "TexturePool::load_texture(#, #, #)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns the new texture.  If a texture with the same filename
## was previously loaded, returns that one instead.  If the texture file
## cannot be found, returns NULL.
##
## If read_mipmaps is true, the filename should contain a hash mark ('#'),
## which will be filled in with the mipmap level number; and the texture will
## be defined with a series of images, one for each mipmap level.

proc load_texture*(_: typedesc[TexturePool], filename: Filename, primary_file_num_channels: int): Texture {.importcpp: "TexturePool::load_texture(#, #)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns the new texture.  If a texture with the same filename
## was previously loaded, returns that one instead.  If the texture file
## cannot be found, returns NULL.
##
## If read_mipmaps is true, the filename should contain a hash mark ('#'),
## which will be filled in with the mipmap level number; and the texture will
## be defined with a series of images, one for each mipmap level.

proc load_texture*(_: typedesc[TexturePool], filename: Filename): Texture {.importcpp: "TexturePool::load_texture(#)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns the new texture.  If a texture with the same filename
## was previously loaded, returns that one instead.  If the texture file
## cannot be found, returns NULL.
##
## If read_mipmaps is true, the filename should contain a hash mark ('#'),
## which will be filled in with the mipmap level number; and the texture will
## be defined with a series of images, one for each mipmap level.

proc load_3d_texture*(_: typedesc[TexturePool], filename_pattern: Filename, read_mipmaps: bool, options: LoaderOptions): Texture {.importcpp: "TexturePool::load_3d_texture(#, #, #)", header: "texturePool.h".} ## \
## Loads a 3-D texture that is specified with a series of n pages, all
## numbered in sequence, and beginning with index 0.  The filename should
## include a sequence of one or more hash characters ("#") which will be
## filled in with the index number of each level.
##
## If read_mipmaps is true, the filename should contain an additional hash
## mark.  The first hash mark will be filled in with the mipmap level number,
## and the second with the index number of each 3-d level.

proc load_3d_texture*(_: typedesc[TexturePool], filename_pattern: Filename, read_mipmaps: bool): Texture {.importcpp: "TexturePool::load_3d_texture(#, #)", header: "texturePool.h".} ## \
## Loads a 3-D texture that is specified with a series of n pages, all
## numbered in sequence, and beginning with index 0.  The filename should
## include a sequence of one or more hash characters ("#") which will be
## filled in with the index number of each level.
##
## If read_mipmaps is true, the filename should contain an additional hash
## mark.  The first hash mark will be filled in with the mipmap level number,
## and the second with the index number of each 3-d level.

proc load_3d_texture*(_: typedesc[TexturePool], filename_pattern: Filename): Texture {.importcpp: "TexturePool::load_3d_texture(#)", header: "texturePool.h".} ## \
## Loads a 3-D texture that is specified with a series of n pages, all
## numbered in sequence, and beginning with index 0.  The filename should
## include a sequence of one or more hash characters ("#") which will be
## filled in with the index number of each level.
##
## If read_mipmaps is true, the filename should contain an additional hash
## mark.  The first hash mark will be filled in with the mipmap level number,
## and the second with the index number of each 3-d level.

proc load_2d_texture_array*(_: typedesc[TexturePool], filename_pattern: Filename, read_mipmaps: bool, options: LoaderOptions): Texture {.importcpp: "TexturePool::load_2d_texture_array(#, #, #)", header: "texturePool.h".} ## \
## Loads a 2-D texture array that is specified with a series of n pages, all
## numbered in sequence, and beginning with index 0.  The filename should
## include a sequence of one or more hash characters ("#") which will be
## filled in with the index number of each level.
##
## If read_mipmaps is true, the filename should contain an additional hash
## mark.  The first hash mark will be filled in with the mipmap level number,
## and the second with the index number of each 2-d level.

proc load_2d_texture_array*(_: typedesc[TexturePool], filename_pattern: Filename, read_mipmaps: bool): Texture {.importcpp: "TexturePool::load_2d_texture_array(#, #)", header: "texturePool.h".} ## \
## Loads a 2-D texture array that is specified with a series of n pages, all
## numbered in sequence, and beginning with index 0.  The filename should
## include a sequence of one or more hash characters ("#") which will be
## filled in with the index number of each level.
##
## If read_mipmaps is true, the filename should contain an additional hash
## mark.  The first hash mark will be filled in with the mipmap level number,
## and the second with the index number of each 2-d level.

proc load_2d_texture_array*(_: typedesc[TexturePool], filename_pattern: Filename): Texture {.importcpp: "TexturePool::load_2d_texture_array(#)", header: "texturePool.h".} ## \
## Loads a 2-D texture array that is specified with a series of n pages, all
## numbered in sequence, and beginning with index 0.  The filename should
## include a sequence of one or more hash characters ("#") which will be
## filled in with the index number of each level.
##
## If read_mipmaps is true, the filename should contain an additional hash
## mark.  The first hash mark will be filled in with the mipmap level number,
## and the second with the index number of each 2-d level.

proc load_cube_map*(_: typedesc[TexturePool], filename_pattern: Filename, read_mipmaps: bool, options: LoaderOptions): Texture {.importcpp: "TexturePool::load_cube_map(#, #, #)", header: "texturePool.h".} ## \
## Loads a cube map texture that is specified with a series of 6 pages,
## numbered 0 through 5.  The filename should include a sequence of one or
## more hash characters ("#") which will be filled in with the index number of
## each pagee.
##
## If read_mipmaps is true, the filename should contain an additional hash
## mark.  The first hash mark will be filled in with the mipmap level number,
## and the second with the face number, 0 through 5.

proc load_cube_map*(_: typedesc[TexturePool], filename_pattern: Filename, read_mipmaps: bool): Texture {.importcpp: "TexturePool::load_cube_map(#, #)", header: "texturePool.h".} ## \
## Loads a cube map texture that is specified with a series of 6 pages,
## numbered 0 through 5.  The filename should include a sequence of one or
## more hash characters ("#") which will be filled in with the index number of
## each pagee.
##
## If read_mipmaps is true, the filename should contain an additional hash
## mark.  The first hash mark will be filled in with the mipmap level number,
## and the second with the face number, 0 through 5.

proc load_cube_map*(_: typedesc[TexturePool], filename_pattern: Filename): Texture {.importcpp: "TexturePool::load_cube_map(#)", header: "texturePool.h".} ## \
## Loads a cube map texture that is specified with a series of 6 pages,
## numbered 0 through 5.  The filename should include a sequence of one or
## more hash characters ("#") which will be filled in with the index number of
## each pagee.
##
## If read_mipmaps is true, the filename should contain an additional hash
## mark.  The first hash mark will be filled in with the mipmap level number,
## and the second with the face number, 0 through 5.

proc get_normalization_cube_map*(_: typedesc[TexturePool], size: int): Texture {.importcpp: "TexturePool::get_normalization_cube_map(#)", header: "texturePool.h".} ## \
## Returns a standard Texture object that has been created with
## Texture::generate_normalization_cube_map().  This Texture may be shared by
## any application code requiring a normalization cube map.  It will be at
## least as large as the specified size, though it may be larger.

proc get_alpha_scale_map*(_: typedesc[TexturePool]): Texture {.importcpp: "TexturePool::get_alpha_scale_map()", header: "texturePool.h".} ## \
## Returns a standard Texture object that has been created with
## Texture::generate_alpha_scale_map().
##
## This Texture object is used internally by Panda to apply an alpha scale to
## an object (instead of munging its vertices) when
## gsg->get_alpha_scale_via_texture() returns true.

proc add_texture*(_: typedesc[TexturePool], texture: Texture) {.importcpp: "TexturePool::add_texture(#)", header: "texturePool.h".} ## \
## Adds the indicated already-loaded texture to the pool.  The texture must
## have a filename set for its name.  The texture will always replace any
## previously-loaded texture in the pool that had the same filename.

proc release_texture*(_: typedesc[TexturePool], texture: Texture) {.importcpp: "TexturePool::release_texture(#)", header: "texturePool.h".} ## \
## Removes the indicated texture from the pool, indicating it will never be
## loaded again; the texture may then be freed.  If this function is never
## called, a reference count will be maintained on every texture every loaded,
## and textures will never be freed.
##
## The texture's name should not have been changed during its lifetime, or
## this function may fail to locate it in the pool.

proc release_all_textures*(_: typedesc[TexturePool]) {.importcpp: "TexturePool::release_all_textures()", header: "texturePool.h".} ## \
## Releases all textures in the pool and restores the pool to the empty state.

proc rehash*(_: typedesc[TexturePool]) {.importcpp: "TexturePool::rehash()", header: "texturePool.h".} ## \
## Should be called when the model-path changes, to blow away the cache of
## texture pathnames found along the model-path.

proc garbage_collect*(_: typedesc[TexturePool]): int {.importcpp: "TexturePool::garbage_collect()", header: "texturePool.h".} ## \
## Releases only those textures in the pool that have a reference count of
## exactly 1; i.e.  only those textures that are not being used outside of the
## pool.  Returns the number of textures released.

proc list_contents*(_: typedesc[TexturePool]) {.importcpp: "TexturePool::list_contents()", header: "texturePool.h".} ## \
## Lists the contents of the texture pool to cout

proc list_contents*(_: typedesc[TexturePool], `out`: ostream) {.importcpp: "TexturePool::list_contents(#)", header: "texturePool.h".} ## \
## Lists the contents of the texture pool to the indicated output stream.

proc find_texture*(_: typedesc[TexturePool], name: string): Texture {.importcpp: "TexturePool::find_texture(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the first texture found in the pool that matches the indicated name
## (which may contain wildcards).  Returns the texture if it is found, or NULL
## if it is not.

proc find_all_textures*(_: typedesc[TexturePool], name: string): TextureCollection {.importcpp: "TexturePool::find_all_textures(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the set of all textures found in the pool that match the indicated
## name (which may contain wildcards).

proc find_all_textures*(_: typedesc[TexturePool]): TextureCollection {.importcpp: "TexturePool::find_all_textures()", header: "texturePool.h".} ## \
## Returns the set of all textures found in the pool that match the indicated
## name (which may contain wildcards).

proc set_fake_texture_image*(_: typedesc[TexturePool], filename: Filename) {.importcpp: "TexturePool::set_fake_texture_image(#)", header: "texturePool.h".} ## \
## Sets a bogus filename that will be loaded in lieu of any textures requested
## from this point on.

proc clear_fake_texture_image*(_: typedesc[TexturePool]) {.importcpp: "TexturePool::clear_fake_texture_image()", header: "texturePool.h".} ## \
## Restores normal behavior of loading the textures actually requested.

proc has_fake_texture_image*(_: typedesc[TexturePool]): bool {.importcpp: "TexturePool::has_fake_texture_image()", header: "texturePool.h".} ## \
## Returns true if fake_texture_image mode has been enabled, false if we are
## in the normal mode.

proc get_fake_texture_image*(_: typedesc[TexturePool]): Filename {.importcpp: "TexturePool::get_fake_texture_image()", header: "texturePool.h".} ## \
## Returns the filename that was specified with a previous call to
## set_fake_texture_image().

proc make_texture*(_: typedesc[TexturePool], extension: string): Texture {.importcpp: "TexturePool::make_texture(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates a new Texture object of the appropriate type for the indicated
## filename extension, according to the types that have been registered via
## register_texture_type().

proc write*(_: typedesc[TexturePool], `out`: ostream) {.importcpp: "TexturePool::write(#)", header: "texturePool.h".} ## \
## Lists the contents of the texture pool to the indicated output stream.  For
## debugging.

proc get_x_size*(this: TexturePeeker): int {.importcpp: "#->get_x_size()".} ## \
## Returns the width of the texture image that is contributing to the
## TexturePeeker's information.  This may be either the Texture's full width,
## or its simple ram image's width.

proc get_y_size*(this: TexturePeeker): int {.importcpp: "#->get_y_size()".} ## \
## Returns the height of the texture image that is contributing to the
## TexturePeeker's information.  This may be either the Texture's full height,
## or its simple ram image's height.

proc get_z_size*(this: TexturePeeker): int {.importcpp: "#->get_z_size()".} ## \
## Returns the depth of the texture image that is contributing to the
## TexturePeeker's information.

proc has_pixel*(this: TexturePeeker, x: int, y: int): bool {.importcpp: "#->has_pixel(#, #)".} ## \
## Returns whether a given coordinate is inside of the texture dimensions.

proc has_pixel*(this: TexturePeeker, x: int, y: int, z: int): bool {.importcpp: "#->has_pixel(#, #, #)".} ## \
## Returns whether a given coordinate is inside of the texture dimensions.

proc lookup*(this: TexturePeeker, color: LColor, u: float32, v: float32) {.importcpp: "#->lookup(#, #, #)".} ## \
## Fills "color" with the RGBA color of the texel at point (u, v).
##
## The texel color is determined via nearest-point sampling (no filtering of
## adjacent pixels), regardless of the filter type associated with the
## texture.  u, v, and w will wrap around regardless of the texture's wrap
## mode.

proc lookup*(this: TexturePeeker, color: LColor, u: float32, v: float32, w: float32) {.importcpp: "#->lookup(#, #, #, #)".} ## \
## Fills "color" with the RGBA color of the texel at point (u, v, w).
##
## The texel color is determined via nearest-point sampling (no filtering of
## adjacent pixels), regardless of the filter type associated with the
## texture.  u, v, and w will wrap around regardless of the texture's wrap
## mode.

proc fetch_pixel*(this: TexturePeeker, color: LColor, x: int, y: int) {.importcpp: "#->fetch_pixel(#, #, #)".} ## \
## Works like TexturePeeker::lookup(), but instead of uv-coordinates, integer
## coordinates are used.

proc fetch_pixel*(this: TexturePeeker, color: LColor, x: int, y: int, z: int) {.importcpp: "#->fetch_pixel(#, #, #, #)".} ## \
## Works like TexturePeeker::lookup(), but instead of uv-coordinates, integer
## coordinates are used.

proc lookup_bilinear*(this: TexturePeeker, color: LColor, u: float32, v: float32): bool {.importcpp: "#->lookup_bilinear(#, #, #)".} ## \
## Performs a bilinear lookup to retrieve the color value stored at the uv
## coordinate (u, v).
##
## In case the point is outside of the uv range, color is set to zero,
## and false is returned.  Otherwise true is returned.

proc filter_rect*(this: TexturePeeker, color: LColor, min_u: float32, min_v: float32, max_u: float32, max_v: float32) {.importcpp: "#->filter_rect(#, #, #, #, #)".} ## \
## Fills "color" with the average RGBA color of the texels within the
## rectangle defined by the specified coordinate range.
##
## The texel color is linearly filtered over the entire region.  u, v, and w
## must be in the range [0, 1].

proc filter_rect*(this: TexturePeeker, color: LColor, min_u: float32, min_v: float32, min_w: float32, max_u: float32, max_v: float32, max_w: float32) {.importcpp: "#->filter_rect(#, #, #, #, #, #, #)".} ## \
## Fills "color" with the average RGBA color of the texels within the
## rectangle defined by the specified coordinate range.
##
## The texel color is linearly filtered over the entire region.  u, v, and w
## must be in the range [0, 1].

proc newTexturePeeker*(param0: TexturePeeker): TexturePeeker {.importcpp: "new TexturePeeker(#)".}

proc get_stage*(_: typedesc[TextureStagePool], temp: TextureStage): TextureStage {.importcpp: "TextureStagePool::get_stage(#)", header: "textureStagePool.h".} ## \
## Returns a TextureStage pointer that represents the same TextureStage
## described by temp, except that it is a shared pointer.
##
## Each call to get_stage() passing an equivalent TextureStage pointer will
## return the same shared pointer.
##
## If you modify the shared pointer, it will automatically disassociate it
## from the pool.
##
## Also, the return value may be a different pointer than that passed in, or
## it may be the same pointer.  In either case, the passed in pointer has now
## been sacrificed to the greater good and should not be used again (like any
## other PointerTo, it will be freed when the last reference count is
## removed).

proc release_stage*(_: typedesc[TextureStagePool], temp: TextureStage) {.importcpp: "TextureStagePool::release_stage(#)", header: "textureStagePool.h".} ## \
## Removes the indicated TextureStage from the pool.

proc release_all_stages*(_: typedesc[TextureStagePool]) {.importcpp: "TextureStagePool::release_all_stages()", header: "textureStagePool.h".} ## \
## Releases all TextureStages in the pool and restores the pool to the empty
## state.

proc garbage_collect*(_: typedesc[TextureStagePool]): int {.importcpp: "TextureStagePool::garbage_collect()", header: "textureStagePool.h".} ## \
## Releases only those TextureStages in the pool that have a reference count
## of exactly 1; i.e.  only those TextureStages that are not being used
## outside of the pool.  Returns the number of TextureStages released.

proc list_contents*(_: typedesc[TextureStagePool], `out`: ostream) {.importcpp: "TextureStagePool::list_contents(#)", header: "textureStagePool.h".} ## \
## Lists the contents of the TextureStage pool to the indicated output stream.

proc write*(_: typedesc[TextureStagePool], `out`: ostream) {.importcpp: "TextureStagePool::write(#)", header: "textureStagePool.h".} ## \
## Lists the contents of the TextureStage pool to the indicated output stream.

proc set_sort*(this: GraphicsOutputBase, sort: int) {.importcpp: "#->set_sort(#)".}

proc get_texture*(this: GraphicsOutputBase, i: int): Texture {.importcpp: "#->get_texture(#)".}

proc get_texture*(this: GraphicsOutputBase): Texture {.importcpp: "#->get_texture()".}

proc get_class_type*(_: typedesc[GraphicsOutputBase]): TypeHandle {.importcpp: "GraphicsOutputBase::get_class_type()", header: "graphicsOutputBase.h".}

proc get_incomplete_render*(this: GraphicsStateGuardianBase): bool {.importcpp: "#->get_incomplete_render()".}

proc get_effective_incomplete_render*(this: GraphicsStateGuardianBase): bool {.importcpp: "#->get_effective_incomplete_render()".}

proc prefers_triangle_strips*(this: GraphicsStateGuardianBase): bool {.importcpp: "#->prefers_triangle_strips()".}

proc get_max_vertices_per_array*(this: GraphicsStateGuardianBase): int {.importcpp: "#->get_max_vertices_per_array()".}

proc get_max_vertices_per_primitive*(this: GraphicsStateGuardianBase): int {.importcpp: "#->get_max_vertices_per_primitive()".}

proc get_max_texture_dimension*(this: GraphicsStateGuardianBase): int {.importcpp: "#->get_max_texture_dimension()".}

proc get_supports_compressed_texture_format*(this: GraphicsStateGuardianBase, compression_mode: int): bool {.importcpp: "#->get_supports_compressed_texture_format(#)".}

proc get_supports_multisample*(this: GraphicsStateGuardianBase): bool {.importcpp: "#->get_supports_multisample()".}

proc get_supported_geom_rendering*(this: GraphicsStateGuardianBase): int {.importcpp: "#->get_supported_geom_rendering()".}

proc get_supports_shadow_filter*(this: GraphicsStateGuardianBase): bool {.importcpp: "#->get_supports_shadow_filter()".}

proc get_supports_texture_srgb*(this: GraphicsStateGuardianBase): bool {.importcpp: "#->get_supports_texture_srgb()".}

proc get_supports_hlsl*(this: GraphicsStateGuardianBase): bool {.importcpp: "#->get_supports_hlsl()".}

proc get_default_gsg*(_: typedesc[GraphicsStateGuardianBase]): GraphicsStateGuardianBase {.importcpp: "GraphicsStateGuardianBase::get_default_gsg()", header: "graphicsStateGuardianBase.h".} ## \
## Returns a pointer to the "default" GSG.  This is typically the first GSG
## created in an application; in a single-window application, it will be the
## only GSG. This GSG is used to determine default optimization choices for
## loaded geometry.
##
## The return value may be NULL if a GSG has not been created.

proc set_default_gsg*(_: typedesc[GraphicsStateGuardianBase], default_gsg: GraphicsStateGuardianBase) {.importcpp: "GraphicsStateGuardianBase::set_default_gsg(#)", header: "graphicsStateGuardianBase.h".} ## \
## Specifies a particular GSG to use as the "default" GSG.  See
## get_default_gsg().

proc get_num_gsgs*(_: typedesc[GraphicsStateGuardianBase]): clonglong {.importcpp: "GraphicsStateGuardianBase::get_num_gsgs()", header: "graphicsStateGuardianBase.h".} ## \
## Returns the total number of GSG's in the universe.

proc get_gsg*(_: typedesc[GraphicsStateGuardianBase], n: clonglong): GraphicsStateGuardianBase {.importcpp: "GraphicsStateGuardianBase::get_gsg(#)", header: "graphicsStateGuardianBase.h".} ## \
## Returns the nth GSG in the universe.  GSG's automatically add themselves
## and remove themselves from this list as they are created and destroyed.

proc get_class_type*(_: typedesc[GraphicsStateGuardianBase]): TypeHandle {.importcpp: "GraphicsStateGuardianBase::get_class_type()", header: "graphicsStateGuardianBase.h".}

proc initMathNumbers*(): MathNumbers {.importcpp: "MathNumbers()".}

proc initMathNumbers*(param0: MathNumbers): MathNumbers {.importcpp: "MathNumbers(#)".}

proc deg_2_rad*(f: float64): float64 {.importcpp: "deg_2_rad(#)".}

proc deg_2_rad*(f: float32): float32 {.importcpp: "deg_2_rad(#)".}

proc rad_2_deg*(f: float64): float64 {.importcpp: "rad_2_deg(#)".}

proc rad_2_deg*(f: float32): float32 {.importcpp: "rad_2_deg(#)".}

proc initLVecBase2f*(): LVecBase2f {.importcpp: "LVecBase2f()".}

proc initLVecBase2f*(param0: LVecBase2f): LVecBase2f {.importcpp: "LVecBase2f(#)".}

proc initLVecBase2f*(fill_value: float32): LVecBase2f {.importcpp: "LVecBase2f(#)".}

proc initLVecBase2f*(x: float32, y: float32): LVecBase2f {.importcpp: "LVecBase2f(#, #)".}

proc zero*(_: typedesc[LVecBase2f]): LVecBase2f {.importcpp: "LVecBase2f::zero()", header: "lvecBase2.h".} ## \
## Returns a zero-length vector.

proc unit_x*(_: typedesc[LVecBase2f]): LVecBase2f {.importcpp: "LVecBase2f::unit_x()", header: "lvecBase2.h".} ## \
## Returns a unit X vector.

proc unit_y*(_: typedesc[LVecBase2f]): LVecBase2f {.importcpp: "LVecBase2f::unit_y()", header: "lvecBase2.h".} ## \
## Returns a unit Y vector.

proc `[]`*(this: LVecBase2f, i: int, assign_val: float32) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[LVecBase2f]): int {.importcpp: "LVecBase2f::size()", header: "lvecBase2.h".}

proc is_nan*(this: LVecBase2f): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the vector is not-a-number, false
## otherwise.

proc get_cell*(this: LVecBase2f, i: int): float32 {.importcpp: "#.get_cell(#)".}

proc set_cell*(this: LVecBase2f, i: int, value: float32) {.importcpp: "#.set_cell(#, #)".}

proc get_x*(this: LVecBase2f): float32 {.importcpp: "#.get_x()".}

proc get_y*(this: LVecBase2f): float32 {.importcpp: "#.get_y()".}

proc set_x*(this: LVecBase2f, value: float32) {.importcpp: "#.set_x(#)".}

proc set_y*(this: LVecBase2f, value: float32) {.importcpp: "#.set_y(#)".}

proc add_to_cell*(this: LVecBase2f, i: int, value: float32) {.importcpp: "#.add_to_cell(#, #)".} ## \
## These next functions add to an existing value.  i.e.
## foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
## scripting languages:

proc add_x*(this: LVecBase2f, value: float32) {.importcpp: "#.add_x(#)".}

proc add_y*(this: LVecBase2f, value: float32) {.importcpp: "#.add_y(#)".}

proc get_data*(this: LVecBase2f) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the two data elements in the vector.
## The next element occupies the next position consecutively in memory.

proc get_num_components*(_: typedesc[LVecBase2f]): int {.importcpp: "LVecBase2f::get_num_components()", header: "lvecBase2.h".}

proc fill*(this: LVecBase2f, fill_value: float32) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: LVecBase2f, x: float32, y: float32) {.importcpp: "#.set(#, #)".}

proc dot*(this: LVecBase2f, other: LVecBase2f): float32 {.importcpp: "#.dot(#)".}

proc length_squared*(this: LVecBase2f): float32 {.importcpp: "#.length_squared()".} ## \
## Returns the square of the vector's length, cheap and easy.

proc length*(this: LVecBase2f): float32 {.importcpp: "#.length()".} ## \
## Returns the length of the vector, by the Pythagorean theorem.

proc normalize*(this: LVecBase2f): bool {.importcpp: "#.normalize()".} ## \
## Normalizes the vector in place.  Returns true if the vector was normalized,
## false if it was a zero-length vector.

proc normalized*(this: LVecBase2f): LVecBase2f {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVecBase2f, onto: LVecBase2f): LVecBase2f {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc `<`*(this: LVecBase2f, other: LVecBase2f): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LVecBase2f, other: LVecBase2f): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LVecBase2f, other: LVecBase2f): bool {.importcpp: "#.operator !=(#)".}

proc compare_to*(this: LVecBase2f, other: LVecBase2f): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compare_to*(this: LVecBase2f, other: LVecBase2f, threshold: float32): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts vectors lexicographically, componentwise.  Returns a number less than
## 0 if this vector sorts before the other one, greater than zero if it sorts
## after, 0 if they are equivalent (within the indicated tolerance).

proc get_hash*(this: LVecBase2f): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc get_hash*(this: LVecBase2f, threshold: float32): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc add_hash*(this: LVecBase2f, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc add_hash*(this: LVecBase2f, hash: clonglong, threshold: float32): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc `-`*(this: LVecBase2f): LVecBase2f {.importcpp: "#.operator -()".}

proc `+`*(this: LVecBase2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVecBase2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVecBase2f, scalar: float32): LVecBase2f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVecBase2f, scalar: float32): LVecBase2f {.importcpp: "#.operator /(#)".}

proc `+=`*(this: LVecBase2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: LVecBase2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: LVecBase2f, scalar: float32): LVecBase2f {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: LVecBase2f, scalar: float32): LVecBase2f {.importcpp: "#.operator /=(#)".}

proc componentwise_mult*(this: LVecBase2f, other: LVecBase2f) {.importcpp: "#.componentwise_mult(#)".}

proc fmax*(this: LVecBase2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.fmax(#)".}

proc fmin*(this: LVecBase2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.fmin(#)".}

proc almost_equal*(this: LVecBase2f, other: LVecBase2f): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two vectors are memberwise equal within a default tolerance
## based on the numeric type.

proc almost_equal*(this: LVecBase2f, other: LVecBase2f, threshold: float32): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two vectors are memberwise equal within a specified
## tolerance.

proc output*(this: LVecBase2f, `out`: ostream) {.importcpp: "#.output(#)".}

proc write_datagram_fixed*(this: LVecBase2f, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the vector to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the vector, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc read_datagram_fixed*(this: LVecBase2f, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the vector from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc write_datagram*(this: LVecBase2f, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the vector to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc read_datagram*(this: LVecBase2f, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the vector from the Datagram using get_stdfloat().

proc get_class_type*(_: typedesc[LVecBase2f]): TypeHandle {.importcpp: "LVecBase2f::get_class_type()", header: "lvecBase2.h".}

proc initLVecBase2d*(): LVecBase2d {.importcpp: "LVecBase2d()".}

proc initLVecBase2d*(param0: LVecBase2d): LVecBase2d {.importcpp: "LVecBase2d(#)".}

proc initLVecBase2d*(fill_value: float64): LVecBase2d {.importcpp: "LVecBase2d(#)".}

proc initLVecBase2d*(x: float64, y: float64): LVecBase2d {.importcpp: "LVecBase2d(#, #)".}

proc zero*(_: typedesc[LVecBase2d]): LVecBase2d {.importcpp: "LVecBase2d::zero()", header: "lvecBase2.h".} ## \
## Returns a zero-length vector.

proc unit_x*(_: typedesc[LVecBase2d]): LVecBase2d {.importcpp: "LVecBase2d::unit_x()", header: "lvecBase2.h".} ## \
## Returns a unit X vector.

proc unit_y*(_: typedesc[LVecBase2d]): LVecBase2d {.importcpp: "LVecBase2d::unit_y()", header: "lvecBase2.h".} ## \
## Returns a unit Y vector.

proc `[]`*(this: LVecBase2d, i: int, assign_val: float64) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[LVecBase2d]): int {.importcpp: "LVecBase2d::size()", header: "lvecBase2.h".}

proc is_nan*(this: LVecBase2d): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the vector is not-a-number, false
## otherwise.

proc get_cell*(this: LVecBase2d, i: int): float64 {.importcpp: "#.get_cell(#)".}

proc set_cell*(this: LVecBase2d, i: int, value: float64) {.importcpp: "#.set_cell(#, #)".}

proc get_x*(this: LVecBase2d): float64 {.importcpp: "#.get_x()".}

proc get_y*(this: LVecBase2d): float64 {.importcpp: "#.get_y()".}

proc set_x*(this: LVecBase2d, value: float64) {.importcpp: "#.set_x(#)".}

proc set_y*(this: LVecBase2d, value: float64) {.importcpp: "#.set_y(#)".}

proc add_to_cell*(this: LVecBase2d, i: int, value: float64) {.importcpp: "#.add_to_cell(#, #)".} ## \
## These next functions add to an existing value.  i.e.
## foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
## scripting languages:

proc add_x*(this: LVecBase2d, value: float64) {.importcpp: "#.add_x(#)".}

proc add_y*(this: LVecBase2d, value: float64) {.importcpp: "#.add_y(#)".}

proc get_data*(this: LVecBase2d) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the two data elements in the vector.
## The next element occupies the next position consecutively in memory.

proc get_num_components*(_: typedesc[LVecBase2d]): int {.importcpp: "LVecBase2d::get_num_components()", header: "lvecBase2.h".}

proc fill*(this: LVecBase2d, fill_value: float64) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: LVecBase2d, x: float64, y: float64) {.importcpp: "#.set(#, #)".}

proc dot*(this: LVecBase2d, other: LVecBase2d): float64 {.importcpp: "#.dot(#)".}

proc length_squared*(this: LVecBase2d): float64 {.importcpp: "#.length_squared()".} ## \
## Returns the square of the vector's length, cheap and easy.

proc length*(this: LVecBase2d): float64 {.importcpp: "#.length()".} ## \
## Returns the length of the vector, by the Pythagorean theorem.

proc normalize*(this: LVecBase2d): bool {.importcpp: "#.normalize()".} ## \
## Normalizes the vector in place.  Returns true if the vector was normalized,
## false if it was a zero-length vector.

proc normalized*(this: LVecBase2d): LVecBase2d {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVecBase2d, onto: LVecBase2d): LVecBase2d {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc `<`*(this: LVecBase2d, other: LVecBase2d): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LVecBase2d, other: LVecBase2d): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LVecBase2d, other: LVecBase2d): bool {.importcpp: "#.operator !=(#)".}

proc compare_to*(this: LVecBase2d, other: LVecBase2d): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compare_to*(this: LVecBase2d, other: LVecBase2d, threshold: float64): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts vectors lexicographically, componentwise.  Returns a number less than
## 0 if this vector sorts before the other one, greater than zero if it sorts
## after, 0 if they are equivalent (within the indicated tolerance).

proc get_hash*(this: LVecBase2d): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc get_hash*(this: LVecBase2d, threshold: float64): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc add_hash*(this: LVecBase2d, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc add_hash*(this: LVecBase2d, hash: clonglong, threshold: float64): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc `-`*(this: LVecBase2d): LVecBase2d {.importcpp: "#.operator -()".}

proc `+`*(this: LVecBase2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVecBase2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVecBase2d, scalar: float64): LVecBase2d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVecBase2d, scalar: float64): LVecBase2d {.importcpp: "#.operator /(#)".}

proc `+=`*(this: LVecBase2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: LVecBase2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: LVecBase2d, scalar: float64): LVecBase2d {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: LVecBase2d, scalar: float64): LVecBase2d {.importcpp: "#.operator /=(#)".}

proc componentwise_mult*(this: LVecBase2d, other: LVecBase2d) {.importcpp: "#.componentwise_mult(#)".}

proc fmax*(this: LVecBase2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.fmax(#)".}

proc fmin*(this: LVecBase2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.fmin(#)".}

proc almost_equal*(this: LVecBase2d, other: LVecBase2d): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two vectors are memberwise equal within a default tolerance
## based on the numeric type.

proc almost_equal*(this: LVecBase2d, other: LVecBase2d, threshold: float64): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two vectors are memberwise equal within a specified
## tolerance.

proc output*(this: LVecBase2d, `out`: ostream) {.importcpp: "#.output(#)".}

proc write_datagram_fixed*(this: LVecBase2d, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the vector to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the vector, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc read_datagram_fixed*(this: LVecBase2d, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the vector from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc write_datagram*(this: LVecBase2d, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the vector to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc read_datagram*(this: LVecBase2d, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the vector from the Datagram using get_stdfloat().

proc get_class_type*(_: typedesc[LVecBase2d]): TypeHandle {.importcpp: "LVecBase2d::get_class_type()", header: "lvecBase2.h".}

proc initLVecBase2i*(): LVecBase2i {.importcpp: "LVecBase2i()".}

proc initLVecBase2i*(param0: LVecBase2i): LVecBase2i {.importcpp: "LVecBase2i(#)".}

proc initLVecBase2i*(fill_value: int): LVecBase2i {.importcpp: "LVecBase2i(#)".}

proc initLVecBase2i*(x: int, y: int): LVecBase2i {.importcpp: "LVecBase2i(#, #)".}

proc zero*(_: typedesc[LVecBase2i]): LVecBase2i {.importcpp: "LVecBase2i::zero()", header: "lvecBase2.h".} ## \
## Returns a zero-length vector.

proc unit_x*(_: typedesc[LVecBase2i]): LVecBase2i {.importcpp: "LVecBase2i::unit_x()", header: "lvecBase2.h".} ## \
## Returns a unit X vector.

proc unit_y*(_: typedesc[LVecBase2i]): LVecBase2i {.importcpp: "LVecBase2i::unit_y()", header: "lvecBase2.h".} ## \
## Returns a unit Y vector.

proc `[]`*(this: LVecBase2i, i: int, assign_val: int) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[LVecBase2i]): int {.importcpp: "LVecBase2i::size()", header: "lvecBase2.h".}

proc is_nan*(this: LVecBase2i): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the vector is not-a-number, false
## otherwise.

proc get_cell*(this: LVecBase2i, i: int): int {.importcpp: "#.get_cell(#)".}

proc set_cell*(this: LVecBase2i, i: int, value: int) {.importcpp: "#.set_cell(#, #)".}

proc get_x*(this: LVecBase2i): int {.importcpp: "#.get_x()".}

proc get_y*(this: LVecBase2i): int {.importcpp: "#.get_y()".}

proc set_x*(this: LVecBase2i, value: int) {.importcpp: "#.set_x(#)".}

proc set_y*(this: LVecBase2i, value: int) {.importcpp: "#.set_y(#)".}

proc add_to_cell*(this: LVecBase2i, i: int, value: int) {.importcpp: "#.add_to_cell(#, #)".} ## \
## These next functions add to an existing value.  i.e.
## foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
## scripting languages:

proc add_x*(this: LVecBase2i, value: int) {.importcpp: "#.add_x(#)".}

proc add_y*(this: LVecBase2i, value: int) {.importcpp: "#.add_y(#)".}

proc get_data*(this: LVecBase2i) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the two data elements in the vector.
## The next element occupies the next position consecutively in memory.

proc get_num_components*(_: typedesc[LVecBase2i]): int {.importcpp: "LVecBase2i::get_num_components()", header: "lvecBase2.h".}

proc fill*(this: LVecBase2i, fill_value: int) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: LVecBase2i, x: int, y: int) {.importcpp: "#.set(#, #)".}

proc dot*(this: LVecBase2i, other: LVecBase2i): int {.importcpp: "#.dot(#)".}

proc length_squared*(this: LVecBase2i): int {.importcpp: "#.length_squared()".} ## \
## Returns the square of the vector's length, cheap and easy.

proc `<`*(this: LVecBase2i, other: LVecBase2i): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LVecBase2i, other: LVecBase2i): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LVecBase2i, other: LVecBase2i): bool {.importcpp: "#.operator !=(#)".}

proc compare_to*(this: LVecBase2i, other: LVecBase2i): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc get_hash*(this: LVecBase2i): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc add_hash*(this: LVecBase2i, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc `-`*(this: LVecBase2i): LVecBase2i {.importcpp: "#.operator -()".}

proc `+`*(this: LVecBase2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVecBase2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVecBase2i, scalar: int): LVecBase2i {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVecBase2i, scalar: int): LVecBase2i {.importcpp: "#.operator /(#)".}

proc `+=`*(this: LVecBase2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: LVecBase2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: LVecBase2i, scalar: int): LVecBase2i {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: LVecBase2i, scalar: int): LVecBase2i {.importcpp: "#.operator /=(#)".}

proc componentwise_mult*(this: LVecBase2i, other: LVecBase2i) {.importcpp: "#.componentwise_mult(#)".}

proc fmax*(this: LVecBase2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.fmax(#)".}

proc fmin*(this: LVecBase2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.fmin(#)".}

proc almost_equal*(this: LVecBase2i, other: LVecBase2i): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two vectors are memberwise equal within a default tolerance
## based on the numeric type.

proc almost_equal*(this: LVecBase2i, other: LVecBase2i, threshold: int): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two vectors are memberwise equal within a specified
## tolerance.

proc output*(this: LVecBase2i, `out`: ostream) {.importcpp: "#.output(#)".}

proc write_datagram_fixed*(this: LVecBase2i, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the vector to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the vector, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc read_datagram_fixed*(this: LVecBase2i, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the vector from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc write_datagram*(this: LVecBase2i, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the vector to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc read_datagram*(this: LVecBase2i, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the vector from the Datagram using get_stdfloat().

proc get_class_type*(_: typedesc[LVecBase2i]): TypeHandle {.importcpp: "LVecBase2i::get_class_type()", header: "lvecBase2.h".}

proc initLVector2f*(): LVector2f {.importcpp: "LVector2f()".}

proc initLVector2f*(copy: LVecBase2f): LVector2f {.importcpp: "LVector2f(#)".} ## \
## Constructs a new LVector2 from a LVecBase2

proc initLVector2f*(param0: LVector2f): LVector2f {.importcpp: "LVector2f(#)".}

proc initLVector2f*(fill_value: float32): LVector2f {.importcpp: "LVector2f(#)".} ## \
## Constructs a new LVector2 with all components set to the fill value.

proc initLVector2f*(x: float32, y: float32): LVector2f {.importcpp: "LVector2f(#, #)".}

proc zero*(_: typedesc[LVector2f]): LVector2f {.importcpp: "LVector2f::zero()", header: "lvector2.h".} ## \
## Returns a zero-length vector.

proc unit_x*(_: typedesc[LVector2f]): LVector2f {.importcpp: "LVector2f::unit_x()", header: "lvector2.h".} ## \
## Returns a unit X vector.

proc unit_y*(_: typedesc[LVector2f]): LVector2f {.importcpp: "LVector2f::unit_y()", header: "lvector2.h".} ## \
## Returns a unit Y vector.

proc `-`*(this: LVector2f): LVector2f {.importcpp: "#.operator -()".}

proc `+`*(this: LVector2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.operator +(#)".}

proc `+`*(this: LVector2f, other: LVector2f): LVector2f {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVector2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.operator -(#)".}

proc `-`*(this: LVector2f, other: LVector2f): LVector2f {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVector2f, scalar: float32): LVector2f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVector2f, scalar: float32): LVector2f {.importcpp: "#.operator /(#)".}

proc normalized*(this: LVector2f): LVector2f {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVector2f, onto: LVecBase2f): LVector2f {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc signed_angle_rad*(this: LVector2f, other: LVector2f): float32 {.importcpp: "#.signed_angle_rad(#)".} ## \
## returns the signed angled between two vectors.  normalization is NOT
## necessary

proc signed_angle_deg*(this: LVector2f, other: LVector2f): float32 {.importcpp: "#.signed_angle_deg(#)".} ## \
## returns the signed angled between two vectors.  normalization is NOT
## necessary

proc get_class_type*(_: typedesc[LVector2f]): TypeHandle {.importcpp: "LVector2f::get_class_type()", header: "lvector2.h".}

proc initLVector2d*(): LVector2d {.importcpp: "LVector2d()".}

proc initLVector2d*(copy: LVecBase2d): LVector2d {.importcpp: "LVector2d(#)".} ## \
## Constructs a new LVector2 from a LVecBase2

proc initLVector2d*(param0: LVector2d): LVector2d {.importcpp: "LVector2d(#)".}

proc initLVector2d*(fill_value: float64): LVector2d {.importcpp: "LVector2d(#)".} ## \
## Constructs a new LVector2 with all components set to the fill value.

proc initLVector2d*(x: float64, y: float64): LVector2d {.importcpp: "LVector2d(#, #)".}

proc zero*(_: typedesc[LVector2d]): LVector2d {.importcpp: "LVector2d::zero()", header: "lvector2.h".} ## \
## Returns a zero-length vector.

proc unit_x*(_: typedesc[LVector2d]): LVector2d {.importcpp: "LVector2d::unit_x()", header: "lvector2.h".} ## \
## Returns a unit X vector.

proc unit_y*(_: typedesc[LVector2d]): LVector2d {.importcpp: "LVector2d::unit_y()", header: "lvector2.h".} ## \
## Returns a unit Y vector.

proc `-`*(this: LVector2d): LVector2d {.importcpp: "#.operator -()".}

proc `+`*(this: LVector2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.operator +(#)".}

proc `+`*(this: LVector2d, other: LVector2d): LVector2d {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVector2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.operator -(#)".}

proc `-`*(this: LVector2d, other: LVector2d): LVector2d {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVector2d, scalar: float64): LVector2d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVector2d, scalar: float64): LVector2d {.importcpp: "#.operator /(#)".}

proc normalized*(this: LVector2d): LVector2d {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVector2d, onto: LVecBase2d): LVector2d {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc signed_angle_rad*(this: LVector2d, other: LVector2d): float64 {.importcpp: "#.signed_angle_rad(#)".} ## \
## returns the signed angled between two vectors.  normalization is NOT
## necessary

proc signed_angle_deg*(this: LVector2d, other: LVector2d): float64 {.importcpp: "#.signed_angle_deg(#)".} ## \
## returns the signed angled between two vectors.  normalization is NOT
## necessary

proc get_class_type*(_: typedesc[LVector2d]): TypeHandle {.importcpp: "LVector2d::get_class_type()", header: "lvector2.h".}

proc initLVector2i*(): LVector2i {.importcpp: "LVector2i()".}

proc initLVector2i*(copy: LVecBase2i): LVector2i {.importcpp: "LVector2i(#)".} ## \
## Constructs a new LVector2 from a LVecBase2

proc initLVector2i*(param0: LVector2i): LVector2i {.importcpp: "LVector2i(#)".}

proc initLVector2i*(fill_value: int): LVector2i {.importcpp: "LVector2i(#)".} ## \
## Constructs a new LVector2 with all components set to the fill value.

proc initLVector2i*(x: int, y: int): LVector2i {.importcpp: "LVector2i(#, #)".}

proc zero*(_: typedesc[LVector2i]): LVector2i {.importcpp: "LVector2i::zero()", header: "lvector2.h".} ## \
## Returns a zero-length vector.

proc unit_x*(_: typedesc[LVector2i]): LVector2i {.importcpp: "LVector2i::unit_x()", header: "lvector2.h".} ## \
## Returns a unit X vector.

proc unit_y*(_: typedesc[LVector2i]): LVector2i {.importcpp: "LVector2i::unit_y()", header: "lvector2.h".} ## \
## Returns a unit Y vector.

proc `-`*(this: LVector2i): LVector2i {.importcpp: "#.operator -()".}

proc `+`*(this: LVector2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.operator +(#)".}

proc `+`*(this: LVector2i, other: LVector2i): LVector2i {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVector2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.operator -(#)".}

proc `-`*(this: LVector2i, other: LVector2i): LVector2i {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVector2i, scalar: int): LVector2i {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVector2i, scalar: int): LVector2i {.importcpp: "#.operator /(#)".}

proc get_class_type*(_: typedesc[LVector2i]): TypeHandle {.importcpp: "LVector2i::get_class_type()", header: "lvector2.h".}

proc initLPoint2f*(): LPoint2f {.importcpp: "LPoint2f()".}

proc initLPoint2f*(param0: LPoint2f): LPoint2f {.importcpp: "LPoint2f(#)".}

proc initLPoint2f*(copy: LVecBase2f): LPoint2f {.importcpp: "LPoint2f(#)".} ## \
## Constructs a new LPoint2 from a LVecBase2

proc initLPoint2f*(fill_value: float32): LPoint2f {.importcpp: "LPoint2f(#)".} ## \
## Constructs a new LPoint2 all components set to the fill value.

proc initLPoint2f*(x: float32, y: float32): LPoint2f {.importcpp: "LPoint2f(#, #)".} ## \
## Constructs a new LPoint2 with the given components

proc zero*(_: typedesc[LPoint2f]): LPoint2f {.importcpp: "LPoint2f::zero()", header: "lpoint2.h".} ## \
## Returns a zero-length point.

proc unit_x*(_: typedesc[LPoint2f]): LPoint2f {.importcpp: "LPoint2f::unit_x()", header: "lpoint2.h".} ## \
## Returns a unit X point.

proc unit_y*(_: typedesc[LPoint2f]): LPoint2f {.importcpp: "LPoint2f::unit_y()", header: "lpoint2.h".} ## \
## Returns a unit Y point.

proc `-`*(this: LPoint2f): LPoint2f {.importcpp: "#.operator -()".}

proc `+`*(this: LPoint2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.operator +(#)".}

proc `+`*(this: LPoint2f, other: LVector2f): LPoint2f {.importcpp: "#.operator +(#)".}

proc `-`*(this: LPoint2f, other: LPoint2f): LVector2f {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint2f, other: LVector2f): LPoint2f {.importcpp: "#.operator -(#)".}

proc `*`*(this: LPoint2f, scalar: float32): LPoint2f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LPoint2f, scalar: float32): LPoint2f {.importcpp: "#.operator /(#)".}

proc normalized*(this: LPoint2f): LPoint2f {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LPoint2f, onto: LVecBase2f): LPoint2f {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc get_class_type*(_: typedesc[LPoint2f]): TypeHandle {.importcpp: "LPoint2f::get_class_type()", header: "lpoint2.h".}

proc initLPoint2d*(): LPoint2d {.importcpp: "LPoint2d()".}

proc initLPoint2d*(param0: LPoint2d): LPoint2d {.importcpp: "LPoint2d(#)".}

proc initLPoint2d*(copy: LVecBase2d): LPoint2d {.importcpp: "LPoint2d(#)".} ## \
## Constructs a new LPoint2 from a LVecBase2

proc initLPoint2d*(fill_value: float64): LPoint2d {.importcpp: "LPoint2d(#)".} ## \
## Constructs a new LPoint2 all components set to the fill value.

proc initLPoint2d*(x: float64, y: float64): LPoint2d {.importcpp: "LPoint2d(#, #)".} ## \
## Constructs a new LPoint2 with the given components

proc zero*(_: typedesc[LPoint2d]): LPoint2d {.importcpp: "LPoint2d::zero()", header: "lpoint2.h".} ## \
## Returns a zero-length point.

proc unit_x*(_: typedesc[LPoint2d]): LPoint2d {.importcpp: "LPoint2d::unit_x()", header: "lpoint2.h".} ## \
## Returns a unit X point.

proc unit_y*(_: typedesc[LPoint2d]): LPoint2d {.importcpp: "LPoint2d::unit_y()", header: "lpoint2.h".} ## \
## Returns a unit Y point.

proc `-`*(this: LPoint2d): LPoint2d {.importcpp: "#.operator -()".}

proc `+`*(this: LPoint2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.operator +(#)".}

proc `+`*(this: LPoint2d, other: LVector2d): LPoint2d {.importcpp: "#.operator +(#)".}

proc `-`*(this: LPoint2d, other: LPoint2d): LVector2d {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint2d, other: LVector2d): LPoint2d {.importcpp: "#.operator -(#)".}

proc `*`*(this: LPoint2d, scalar: float64): LPoint2d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LPoint2d, scalar: float64): LPoint2d {.importcpp: "#.operator /(#)".}

proc normalized*(this: LPoint2d): LPoint2d {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LPoint2d, onto: LVecBase2d): LPoint2d {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc get_class_type*(_: typedesc[LPoint2d]): TypeHandle {.importcpp: "LPoint2d::get_class_type()", header: "lpoint2.h".}

proc initLPoint2i*(): LPoint2i {.importcpp: "LPoint2i()".}

proc initLPoint2i*(param0: LPoint2i): LPoint2i {.importcpp: "LPoint2i(#)".}

proc initLPoint2i*(copy: LVecBase2i): LPoint2i {.importcpp: "LPoint2i(#)".} ## \
## Constructs a new LPoint2 from a LVecBase2

proc initLPoint2i*(fill_value: int): LPoint2i {.importcpp: "LPoint2i(#)".} ## \
## Constructs a new LPoint2 all components set to the fill value.

proc initLPoint2i*(x: int, y: int): LPoint2i {.importcpp: "LPoint2i(#, #)".} ## \
## Constructs a new LPoint2 with the given components

proc zero*(_: typedesc[LPoint2i]): LPoint2i {.importcpp: "LPoint2i::zero()", header: "lpoint2.h".} ## \
## Returns a zero-length point.

proc unit_x*(_: typedesc[LPoint2i]): LPoint2i {.importcpp: "LPoint2i::unit_x()", header: "lpoint2.h".} ## \
## Returns a unit X point.

proc unit_y*(_: typedesc[LPoint2i]): LPoint2i {.importcpp: "LPoint2i::unit_y()", header: "lpoint2.h".} ## \
## Returns a unit Y point.

proc `-`*(this: LPoint2i): LPoint2i {.importcpp: "#.operator -()".}

proc `+`*(this: LPoint2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.operator +(#)".}

proc `+`*(this: LPoint2i, other: LVector2i): LPoint2i {.importcpp: "#.operator +(#)".}

proc `-`*(this: LPoint2i, other: LPoint2i): LVector2i {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint2i, other: LVector2i): LPoint2i {.importcpp: "#.operator -(#)".}

proc `*`*(this: LPoint2i, scalar: int): LPoint2i {.importcpp: "#.operator *(#)".}

proc `/`*(this: LPoint2i, scalar: int): LPoint2i {.importcpp: "#.operator /(#)".}

proc get_class_type*(_: typedesc[LPoint2i]): TypeHandle {.importcpp: "LPoint2i::get_class_type()", header: "lpoint2.h".}

proc initLVecBase3f*(): LVecBase3f {.importcpp: "LVecBase3f()".}

proc initLVecBase3f*(copy: LVecBase2f, z: float32): LVecBase3f {.importcpp: "LVecBase3f(#, #)".}

proc initLVecBase3f*(param0: LVecBase3f): LVecBase3f {.importcpp: "LVecBase3f(#)".}

proc initLVecBase3f*(fill_value: float32): LVecBase3f {.importcpp: "LVecBase3f(#)".}

proc initLVecBase3f*(x: float32, y: float32, z: float32): LVecBase3f {.importcpp: "LVecBase3f(#, #, #)".}

proc zero*(_: typedesc[LVecBase3f]): LVecBase3f {.importcpp: "LVecBase3f::zero()", header: "lvecBase3.h".} ## \
## Returns a zero-length vector.

proc unit_x*(_: typedesc[LVecBase3f]): LVecBase3f {.importcpp: "LVecBase3f::unit_x()", header: "lvecBase3.h".} ## \
## Returns a unit X vector.

proc unit_y*(_: typedesc[LVecBase3f]): LVecBase3f {.importcpp: "LVecBase3f::unit_y()", header: "lvecBase3.h".} ## \
## Returns a unit Y vector.

proc unit_z*(_: typedesc[LVecBase3f]): LVecBase3f {.importcpp: "LVecBase3f::unit_z()", header: "lvecBase3.h".} ## \
## Returns a unit Z vector.

proc `[]`*(this: LVecBase3f, i: int, assign_val: float32) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[LVecBase3f]): int {.importcpp: "LVecBase3f::size()", header: "lvecBase3.h".}

proc is_nan*(this: LVecBase3f): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the vector is not-a-number, false
## otherwise.

proc get_cell*(this: LVecBase3f, i: int): float32 {.importcpp: "#.get_cell(#)".}

proc get_x*(this: LVecBase3f): float32 {.importcpp: "#.get_x()".}

proc get_y*(this: LVecBase3f): float32 {.importcpp: "#.get_y()".}

proc get_z*(this: LVecBase3f): float32 {.importcpp: "#.get_z()".}

proc set_cell*(this: LVecBase3f, i: int, value: float32) {.importcpp: "#.set_cell(#, #)".}

proc set_x*(this: LVecBase3f, value: float32) {.importcpp: "#.set_x(#)".}

proc set_y*(this: LVecBase3f, value: float32) {.importcpp: "#.set_y(#)".}

proc set_z*(this: LVecBase3f, value: float32) {.importcpp: "#.set_z(#)".}

proc get_xy*(this: LVecBase3f): LVecBase2f {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

proc get_xz*(this: LVecBase3f): LVecBase2f {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

proc get_yz*(this: LVecBase3f): LVecBase2f {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

proc add_to_cell*(this: LVecBase3f, i: int, value: float32) {.importcpp: "#.add_to_cell(#, #)".} ## \
## These next functions add to an existing value.  i.e.
## foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
## scripting languages:

proc add_x*(this: LVecBase3f, value: float32) {.importcpp: "#.add_x(#)".}

proc add_y*(this: LVecBase3f, value: float32) {.importcpp: "#.add_y(#)".}

proc add_z*(this: LVecBase3f, value: float32) {.importcpp: "#.add_z(#)".}

proc get_data*(this: LVecBase3f) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the three data elements in the vector.
## The remaining elements occupy the next positions consecutively in memory.

proc get_num_components*(_: typedesc[LVecBase3f]): int {.importcpp: "LVecBase3f::get_num_components()", header: "lvecBase3.h".}

proc fill*(this: LVecBase3f, fill_value: float32) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: LVecBase3f, x: float32, y: float32, z: float32) {.importcpp: "#.set(#, #, #)".}

proc dot*(this: LVecBase3f, other: LVecBase3f): float32 {.importcpp: "#.dot(#)".}

proc length_squared*(this: LVecBase3f): float32 {.importcpp: "#.length_squared()".} ## \
## Returns the square of the vector's length, cheap and easy.

proc length*(this: LVecBase3f): float32 {.importcpp: "#.length()".} ## \
## Returns the length of the vector, by the Pythagorean theorem.

proc normalize*(this: LVecBase3f): bool {.importcpp: "#.normalize()".} ## \
## Normalizes the vector in place.  Returns true if the vector was normalized,
## false if it was a zero-length vector.

proc normalized*(this: LVecBase3f): LVecBase3f {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVecBase3f, onto: LVecBase3f): LVecBase3f {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc cross*(this: LVecBase3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.cross(#)".}

proc `<`*(this: LVecBase3f, other: LVecBase3f): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LVecBase3f, other: LVecBase3f): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LVecBase3f, other: LVecBase3f): bool {.importcpp: "#.operator !=(#)".}

proc get_standardized_hpr*(this: LVecBase3f): LVecBase3f {.importcpp: "#.get_standardized_hpr()".} ## \
## Try to un-spin the hpr to a standard form.  Like all standards, someone
## decides between many arbitrary possible standards.  This function assumes
## that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
## same.  Another example is -90 and 270. Each element will be in the range
## -180.0 to 179.99999. The original usage of this function is for human
## readable output.
##
## It doesn't work so well for asserting that foo_hpr is roughly equal to
## bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
## get_standardized_rotation, LQuaternion::is_same_direction

proc compare_to*(this: LVecBase3f, other: LVecBase3f): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compare_to*(this: LVecBase3f, other: LVecBase3f, threshold: float32): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts vectors lexicographically, componentwise.  Returns a number less than
## 0 if this vector sorts before the other one, greater than zero if it sorts
## after, 0 if they are equivalent (within the indicated tolerance).

proc get_hash*(this: LVecBase3f): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc get_hash*(this: LVecBase3f, threshold: float32): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc add_hash*(this: LVecBase3f, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc add_hash*(this: LVecBase3f, hash: clonglong, threshold: float32): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc `-`*(this: LVecBase3f): LVecBase3f {.importcpp: "#.operator -()".}

proc `+`*(this: LVecBase3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVecBase3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVecBase3f, scalar: float32): LVecBase3f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVecBase3f, scalar: float32): LVecBase3f {.importcpp: "#.operator /(#)".}

proc `+=`*(this: LVecBase3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: LVecBase3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: LVecBase3f, scalar: float32): LVecBase3f {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: LVecBase3f, scalar: float32): LVecBase3f {.importcpp: "#.operator /=(#)".}

proc componentwise_mult*(this: LVecBase3f, other: LVecBase3f) {.importcpp: "#.componentwise_mult(#)".}

proc fmax*(this: LVecBase3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.fmax(#)".}

proc fmin*(this: LVecBase3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.fmin(#)".}

proc cross_into*(this: LVecBase3f, other: LVecBase3f) {.importcpp: "#.cross_into(#)".}

proc almost_equal*(this: LVecBase3f, other: LVecBase3f): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two vectors are memberwise equal within a default tolerance
## based on the numeric type.

proc almost_equal*(this: LVecBase3f, other: LVecBase3f, threshold: float32): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two vectors are memberwise equal within a specified
## tolerance.

proc output*(this: LVecBase3f, `out`: ostream) {.importcpp: "#.output(#)".}

proc write_datagram_fixed*(this: LVecBase3f, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the vector to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the vector, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc read_datagram_fixed*(this: LVecBase3f, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the vector from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc write_datagram*(this: LVecBase3f, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the vector to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc read_datagram*(this: LVecBase3f, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the vector from the Datagram using get_stdfloat().

proc get_class_type*(_: typedesc[LVecBase3f]): TypeHandle {.importcpp: "LVecBase3f::get_class_type()", header: "lvecBase3.h".}

proc initLVecBase3d*(): LVecBase3d {.importcpp: "LVecBase3d()".}

proc initLVecBase3d*(copy: LVecBase2d, z: float64): LVecBase3d {.importcpp: "LVecBase3d(#, #)".}

proc initLVecBase3d*(param0: LVecBase3d): LVecBase3d {.importcpp: "LVecBase3d(#)".}

proc initLVecBase3d*(fill_value: float64): LVecBase3d {.importcpp: "LVecBase3d(#)".}

proc initLVecBase3d*(x: float64, y: float64, z: float64): LVecBase3d {.importcpp: "LVecBase3d(#, #, #)".}

proc zero*(_: typedesc[LVecBase3d]): LVecBase3d {.importcpp: "LVecBase3d::zero()", header: "lvecBase3.h".} ## \
## Returns a zero-length vector.

proc unit_x*(_: typedesc[LVecBase3d]): LVecBase3d {.importcpp: "LVecBase3d::unit_x()", header: "lvecBase3.h".} ## \
## Returns a unit X vector.

proc unit_y*(_: typedesc[LVecBase3d]): LVecBase3d {.importcpp: "LVecBase3d::unit_y()", header: "lvecBase3.h".} ## \
## Returns a unit Y vector.

proc unit_z*(_: typedesc[LVecBase3d]): LVecBase3d {.importcpp: "LVecBase3d::unit_z()", header: "lvecBase3.h".} ## \
## Returns a unit Z vector.

proc `[]`*(this: LVecBase3d, i: int, assign_val: float64) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[LVecBase3d]): int {.importcpp: "LVecBase3d::size()", header: "lvecBase3.h".}

proc is_nan*(this: LVecBase3d): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the vector is not-a-number, false
## otherwise.

proc get_cell*(this: LVecBase3d, i: int): float64 {.importcpp: "#.get_cell(#)".}

proc get_x*(this: LVecBase3d): float64 {.importcpp: "#.get_x()".}

proc get_y*(this: LVecBase3d): float64 {.importcpp: "#.get_y()".}

proc get_z*(this: LVecBase3d): float64 {.importcpp: "#.get_z()".}

proc set_cell*(this: LVecBase3d, i: int, value: float64) {.importcpp: "#.set_cell(#, #)".}

proc set_x*(this: LVecBase3d, value: float64) {.importcpp: "#.set_x(#)".}

proc set_y*(this: LVecBase3d, value: float64) {.importcpp: "#.set_y(#)".}

proc set_z*(this: LVecBase3d, value: float64) {.importcpp: "#.set_z(#)".}

proc get_xy*(this: LVecBase3d): LVecBase2d {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

proc get_xz*(this: LVecBase3d): LVecBase2d {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

proc get_yz*(this: LVecBase3d): LVecBase2d {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

proc add_to_cell*(this: LVecBase3d, i: int, value: float64) {.importcpp: "#.add_to_cell(#, #)".} ## \
## These next functions add to an existing value.  i.e.
## foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
## scripting languages:

proc add_x*(this: LVecBase3d, value: float64) {.importcpp: "#.add_x(#)".}

proc add_y*(this: LVecBase3d, value: float64) {.importcpp: "#.add_y(#)".}

proc add_z*(this: LVecBase3d, value: float64) {.importcpp: "#.add_z(#)".}

proc get_data*(this: LVecBase3d) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the three data elements in the vector.
## The remaining elements occupy the next positions consecutively in memory.

proc get_num_components*(_: typedesc[LVecBase3d]): int {.importcpp: "LVecBase3d::get_num_components()", header: "lvecBase3.h".}

proc fill*(this: LVecBase3d, fill_value: float64) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: LVecBase3d, x: float64, y: float64, z: float64) {.importcpp: "#.set(#, #, #)".}

proc dot*(this: LVecBase3d, other: LVecBase3d): float64 {.importcpp: "#.dot(#)".}

proc length_squared*(this: LVecBase3d): float64 {.importcpp: "#.length_squared()".} ## \
## Returns the square of the vector's length, cheap and easy.

proc length*(this: LVecBase3d): float64 {.importcpp: "#.length()".} ## \
## Returns the length of the vector, by the Pythagorean theorem.

proc normalize*(this: LVecBase3d): bool {.importcpp: "#.normalize()".} ## \
## Normalizes the vector in place.  Returns true if the vector was normalized,
## false if it was a zero-length vector.

proc normalized*(this: LVecBase3d): LVecBase3d {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVecBase3d, onto: LVecBase3d): LVecBase3d {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc cross*(this: LVecBase3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.cross(#)".}

proc `<`*(this: LVecBase3d, other: LVecBase3d): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LVecBase3d, other: LVecBase3d): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LVecBase3d, other: LVecBase3d): bool {.importcpp: "#.operator !=(#)".}

proc get_standardized_hpr*(this: LVecBase3d): LVecBase3d {.importcpp: "#.get_standardized_hpr()".} ## \
## Try to un-spin the hpr to a standard form.  Like all standards, someone
## decides between many arbitrary possible standards.  This function assumes
## that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
## same.  Another example is -90 and 270. Each element will be in the range
## -180.0 to 179.99999. The original usage of this function is for human
## readable output.
##
## It doesn't work so well for asserting that foo_hpr is roughly equal to
## bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
## get_standardized_rotation, LQuaternion::is_same_direction

proc compare_to*(this: LVecBase3d, other: LVecBase3d): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compare_to*(this: LVecBase3d, other: LVecBase3d, threshold: float64): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts vectors lexicographically, componentwise.  Returns a number less than
## 0 if this vector sorts before the other one, greater than zero if it sorts
## after, 0 if they are equivalent (within the indicated tolerance).

proc get_hash*(this: LVecBase3d): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc get_hash*(this: LVecBase3d, threshold: float64): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc add_hash*(this: LVecBase3d, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc add_hash*(this: LVecBase3d, hash: clonglong, threshold: float64): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc `-`*(this: LVecBase3d): LVecBase3d {.importcpp: "#.operator -()".}

proc `+`*(this: LVecBase3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVecBase3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVecBase3d, scalar: float64): LVecBase3d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVecBase3d, scalar: float64): LVecBase3d {.importcpp: "#.operator /(#)".}

proc `+=`*(this: LVecBase3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: LVecBase3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: LVecBase3d, scalar: float64): LVecBase3d {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: LVecBase3d, scalar: float64): LVecBase3d {.importcpp: "#.operator /=(#)".}

proc componentwise_mult*(this: LVecBase3d, other: LVecBase3d) {.importcpp: "#.componentwise_mult(#)".}

proc fmax*(this: LVecBase3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.fmax(#)".}

proc fmin*(this: LVecBase3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.fmin(#)".}

proc cross_into*(this: LVecBase3d, other: LVecBase3d) {.importcpp: "#.cross_into(#)".}

proc almost_equal*(this: LVecBase3d, other: LVecBase3d): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two vectors are memberwise equal within a default tolerance
## based on the numeric type.

proc almost_equal*(this: LVecBase3d, other: LVecBase3d, threshold: float64): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two vectors are memberwise equal within a specified
## tolerance.

proc output*(this: LVecBase3d, `out`: ostream) {.importcpp: "#.output(#)".}

proc write_datagram_fixed*(this: LVecBase3d, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the vector to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the vector, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc read_datagram_fixed*(this: LVecBase3d, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the vector from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc write_datagram*(this: LVecBase3d, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the vector to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc read_datagram*(this: LVecBase3d, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the vector from the Datagram using get_stdfloat().

proc get_class_type*(_: typedesc[LVecBase3d]): TypeHandle {.importcpp: "LVecBase3d::get_class_type()", header: "lvecBase3.h".}

proc initLVecBase3i*(): LVecBase3i {.importcpp: "LVecBase3i()".}

proc initLVecBase3i*(copy: LVecBase2i, z: int): LVecBase3i {.importcpp: "LVecBase3i(#, #)".}

proc initLVecBase3i*(param0: LVecBase3i): LVecBase3i {.importcpp: "LVecBase3i(#)".}

proc initLVecBase3i*(fill_value: int): LVecBase3i {.importcpp: "LVecBase3i(#)".}

proc initLVecBase3i*(x: int, y: int, z: int): LVecBase3i {.importcpp: "LVecBase3i(#, #, #)".}

proc zero*(_: typedesc[LVecBase3i]): LVecBase3i {.importcpp: "LVecBase3i::zero()", header: "lvecBase3.h".} ## \
## Returns a zero-length vector.

proc unit_x*(_: typedesc[LVecBase3i]): LVecBase3i {.importcpp: "LVecBase3i::unit_x()", header: "lvecBase3.h".} ## \
## Returns a unit X vector.

proc unit_y*(_: typedesc[LVecBase3i]): LVecBase3i {.importcpp: "LVecBase3i::unit_y()", header: "lvecBase3.h".} ## \
## Returns a unit Y vector.

proc unit_z*(_: typedesc[LVecBase3i]): LVecBase3i {.importcpp: "LVecBase3i::unit_z()", header: "lvecBase3.h".} ## \
## Returns a unit Z vector.

proc `[]`*(this: LVecBase3i, i: int, assign_val: int) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[LVecBase3i]): int {.importcpp: "LVecBase3i::size()", header: "lvecBase3.h".}

proc is_nan*(this: LVecBase3i): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the vector is not-a-number, false
## otherwise.

proc get_cell*(this: LVecBase3i, i: int): int {.importcpp: "#.get_cell(#)".}

proc get_x*(this: LVecBase3i): int {.importcpp: "#.get_x()".}

proc get_y*(this: LVecBase3i): int {.importcpp: "#.get_y()".}

proc get_z*(this: LVecBase3i): int {.importcpp: "#.get_z()".}

proc set_cell*(this: LVecBase3i, i: int, value: int) {.importcpp: "#.set_cell(#, #)".}

proc set_x*(this: LVecBase3i, value: int) {.importcpp: "#.set_x(#)".}

proc set_y*(this: LVecBase3i, value: int) {.importcpp: "#.set_y(#)".}

proc set_z*(this: LVecBase3i, value: int) {.importcpp: "#.set_z(#)".}

proc get_xy*(this: LVecBase3i): LVecBase2i {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

proc get_xz*(this: LVecBase3i): LVecBase2i {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

proc get_yz*(this: LVecBase3i): LVecBase2i {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

proc add_to_cell*(this: LVecBase3i, i: int, value: int) {.importcpp: "#.add_to_cell(#, #)".} ## \
## These next functions add to an existing value.  i.e.
## foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
## scripting languages:

proc add_x*(this: LVecBase3i, value: int) {.importcpp: "#.add_x(#)".}

proc add_y*(this: LVecBase3i, value: int) {.importcpp: "#.add_y(#)".}

proc add_z*(this: LVecBase3i, value: int) {.importcpp: "#.add_z(#)".}

proc get_data*(this: LVecBase3i) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the three data elements in the vector.
## The remaining elements occupy the next positions consecutively in memory.

proc get_num_components*(_: typedesc[LVecBase3i]): int {.importcpp: "LVecBase3i::get_num_components()", header: "lvecBase3.h".}

proc fill*(this: LVecBase3i, fill_value: int) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: LVecBase3i, x: int, y: int, z: int) {.importcpp: "#.set(#, #, #)".}

proc dot*(this: LVecBase3i, other: LVecBase3i): int {.importcpp: "#.dot(#)".}

proc length_squared*(this: LVecBase3i): int {.importcpp: "#.length_squared()".} ## \
## Returns the square of the vector's length, cheap and easy.

proc cross*(this: LVecBase3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.cross(#)".}

proc `<`*(this: LVecBase3i, other: LVecBase3i): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LVecBase3i, other: LVecBase3i): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LVecBase3i, other: LVecBase3i): bool {.importcpp: "#.operator !=(#)".}

proc compare_to*(this: LVecBase3i, other: LVecBase3i): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc get_hash*(this: LVecBase3i): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc add_hash*(this: LVecBase3i, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc `-`*(this: LVecBase3i): LVecBase3i {.importcpp: "#.operator -()".}

proc `+`*(this: LVecBase3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVecBase3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVecBase3i, scalar: int): LVecBase3i {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVecBase3i, scalar: int): LVecBase3i {.importcpp: "#.operator /(#)".}

proc `+=`*(this: LVecBase3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: LVecBase3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: LVecBase3i, scalar: int): LVecBase3i {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: LVecBase3i, scalar: int): LVecBase3i {.importcpp: "#.operator /=(#)".}

proc componentwise_mult*(this: LVecBase3i, other: LVecBase3i) {.importcpp: "#.componentwise_mult(#)".}

proc fmax*(this: LVecBase3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.fmax(#)".}

proc fmin*(this: LVecBase3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.fmin(#)".}

proc cross_into*(this: LVecBase3i, other: LVecBase3i) {.importcpp: "#.cross_into(#)".}

proc almost_equal*(this: LVecBase3i, other: LVecBase3i): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two vectors are memberwise equal within a default tolerance
## based on the numeric type.

proc almost_equal*(this: LVecBase3i, other: LVecBase3i, threshold: int): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two vectors are memberwise equal within a specified
## tolerance.

proc output*(this: LVecBase3i, `out`: ostream) {.importcpp: "#.output(#)".}

proc write_datagram_fixed*(this: LVecBase3i, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the vector to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the vector, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc read_datagram_fixed*(this: LVecBase3i, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the vector from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc write_datagram*(this: LVecBase3i, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the vector to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc read_datagram*(this: LVecBase3i, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the vector from the Datagram using get_stdfloat().

proc get_class_type*(_: typedesc[LVecBase3i]): TypeHandle {.importcpp: "LVecBase3i::get_class_type()", header: "lvecBase3.h".}

proc get_default_coordinate_system*(): CoordinateSystem {.importcpp: "get_default_coordinate_system()".}

proc parse_coordinate_system_string*(str: string): CoordinateSystem {.importcpp: "parse_coordinate_system_string(nimStringToStdString(#))", header: stringConversionCode.}

proc format_coordinate_system*(cs: CoordinateSystem): string {.importcpp: "nimStringFromStdString(format_coordinate_system(#))", header: stringConversionCode.}

proc is_right_handed*(cs: CoordinateSystem): bool {.importcpp: "is_right_handed(#)".}

proc is_right_handed*(): bool {.importcpp: "is_right_handed()".}

proc initLVector3f*(): LVector3f {.importcpp: "LVector3f()".}

proc initLVector3f*(copy: LVecBase2f, z: float32): LVector3f {.importcpp: "LVector3f(#, #)".}

proc initLVector3f*(copy: LVecBase3f): LVector3f {.importcpp: "LVector3f(#)".}

proc initLVector3f*(param0: LVector3f): LVector3f {.importcpp: "LVector3f(#)".}

proc initLVector3f*(fill_value: float32): LVector3f {.importcpp: "LVector3f(#)".}

proc initLVector3f*(x: float32, y: float32, z: float32): LVector3f {.importcpp: "LVector3f(#, #, #)".}

proc zero*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::zero()", header: "lvector3.h".} ## \
## Returns a zero-length vector.

proc unit_x*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::unit_x()", header: "lvector3.h".} ## \
## Returns a unit X vector.

proc unit_y*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::unit_y()", header: "lvector3.h".} ## \
## Returns a unit Y vector.

proc unit_z*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::unit_z()", header: "lvector3.h".} ## \
## Returns a unit Z vector.

proc get_xy*(this: LVector3f): LVector2f {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

proc get_xz*(this: LVector3f): LVector2f {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

proc get_yz*(this: LVector3f): LVector2f {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

proc `-`*(this: LVector3f): LVector3f {.importcpp: "#.operator -()".}

proc `+`*(this: LVector3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.operator +(#)".}

proc `+`*(this: LVector3f, other: LVector3f): LVector3f {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVector3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.operator -(#)".}

proc `-`*(this: LVector3f, other: LVector3f): LVector3f {.importcpp: "#.operator -(#)".}

proc cross*(this: LVector3f, other: LVecBase3f): LVector3f {.importcpp: "#.cross(#)".}

proc normalized*(this: LVector3f): LVector3f {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVector3f, onto: LVecBase3f): LVector3f {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc angle_rad*(this: LVector3f, other: LVector3f): float32 {.importcpp: "#.angle_rad(#)".} ## \
## Returns the unsigned angle between this vector and the other one, expressed
## in radians.  Both vectors should be initially normalized.

proc angle_deg*(this: LVector3f, other: LVector3f): float32 {.importcpp: "#.angle_deg(#)".} ## \
## Returns the angle between this vector and the other one, expressed in
## degrees.  Both vectors should be initially normalized.

proc signed_angle_rad*(this: LVector3f, other: LVector3f, `ref`: LVector3f): float32 {.importcpp: "#.signed_angle_rad(#, #)".} ## \
## returns the signed angle between two vectors.  The angle is positive if the
## rotation from this vector to other is clockwise when looking in the
## direction of the ref vector.
##
## Vectors (except the ref vector) should be initially normalized.

proc signed_angle_deg*(this: LVector3f, other: LVector3f, `ref`: LVector3f): float32 {.importcpp: "#.signed_angle_deg(#, #)".} ## \
## Returns the signed angle between two vectors.  The angle is positive if the
## rotation from this vector to other is clockwise when looking in the
## direction of the ref vector.
##
## Vectors (except the ref vector) should be initially normalized.

proc relative_angle_rad*(this: LVector3f, other: LVector3f): float32 {.importcpp: "#.relative_angle_rad(#)".} ## \
## @deprecated Do not use.

proc relative_angle_deg*(this: LVector3f, other: LVector3f): float32 {.importcpp: "#.relative_angle_deg(#)".} ## \
## @deprecated Do not use.

proc `*`*(this: LVector3f, scalar: float32): LVector3f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVector3f, scalar: float32): LVector3f {.importcpp: "#.operator /(#)".}

proc up*(_: typedesc[LVector3f], cs: CoordinateSystem): LVector3f {.importcpp: "LVector3f::up(#)", header: "lvector3.h".} ## \
## Returns the up vector for the given coordinate system.

proc up*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::up()", header: "lvector3.h".} ## \
## Returns the up vector for the given coordinate system.

proc right*(_: typedesc[LVector3f], cs: CoordinateSystem): LVector3f {.importcpp: "LVector3f::right(#)", header: "lvector3.h".} ## \
## Returns the right vector for the given coordinate system.

proc right*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::right()", header: "lvector3.h".} ## \
## Returns the right vector for the given coordinate system.

proc forward*(_: typedesc[LVector3f], cs: CoordinateSystem): LVector3f {.importcpp: "LVector3f::forward(#)", header: "lvector3.h".} ## \
## Returns the forward vector for the given coordinate system.

proc forward*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::forward()", header: "lvector3.h".} ## \
## Returns the forward vector for the given coordinate system.

proc down*(_: typedesc[LVector3f], cs: CoordinateSystem): LVector3f {.importcpp: "LVector3f::down(#)", header: "lvector3.h".} ## \
## Returns the down vector for the given coordinate system.

proc down*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::down()", header: "lvector3.h".} ## \
## Returns the down vector for the given coordinate system.

proc left*(_: typedesc[LVector3f], cs: CoordinateSystem): LVector3f {.importcpp: "LVector3f::left(#)", header: "lvector3.h".} ## \
## Returns the left vector for the given coordinate system.

proc left*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::left()", header: "lvector3.h".} ## \
## Returns the left vector for the given coordinate system.

proc back*(_: typedesc[LVector3f], cs: CoordinateSystem): LVector3f {.importcpp: "LVector3f::back(#)", header: "lvector3.h".} ## \
## Returns the back vector for the given coordinate system.

proc back*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::back()", header: "lvector3.h".} ## \
## Returns the back vector for the given coordinate system.

proc rfu*(_: typedesc[LVector3f], right: float32, fwd: float32, up: float32, cs: CoordinateSystem): LVector3f {.importcpp: "LVector3f::rfu(#, #, #, #)", header: "lvector3.h".} ## \
## Returns a vector that is described by its right, forward, and up
## components, in whatever way the coordinate system represents that vector.

proc rfu*(_: typedesc[LVector3f], right: float32, fwd: float32, up: float32): LVector3f {.importcpp: "LVector3f::rfu(#, #, #)", header: "lvector3.h".} ## \
## Returns a vector that is described by its right, forward, and up
## components, in whatever way the coordinate system represents that vector.

proc get_class_type*(_: typedesc[LVector3f]): TypeHandle {.importcpp: "LVector3f::get_class_type()", header: "lvector3.h".}

proc initLVector3d*(): LVector3d {.importcpp: "LVector3d()".}

proc initLVector3d*(copy: LVecBase2d, z: float64): LVector3d {.importcpp: "LVector3d(#, #)".}

proc initLVector3d*(copy: LVecBase3d): LVector3d {.importcpp: "LVector3d(#)".}

proc initLVector3d*(param0: LVector3d): LVector3d {.importcpp: "LVector3d(#)".}

proc initLVector3d*(fill_value: float64): LVector3d {.importcpp: "LVector3d(#)".}

proc initLVector3d*(x: float64, y: float64, z: float64): LVector3d {.importcpp: "LVector3d(#, #, #)".}

proc zero*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::zero()", header: "lvector3.h".} ## \
## Returns a zero-length vector.

proc unit_x*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::unit_x()", header: "lvector3.h".} ## \
## Returns a unit X vector.

proc unit_y*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::unit_y()", header: "lvector3.h".} ## \
## Returns a unit Y vector.

proc unit_z*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::unit_z()", header: "lvector3.h".} ## \
## Returns a unit Z vector.

proc get_xy*(this: LVector3d): LVector2d {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

proc get_xz*(this: LVector3d): LVector2d {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

proc get_yz*(this: LVector3d): LVector2d {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

proc `-`*(this: LVector3d): LVector3d {.importcpp: "#.operator -()".}

proc `+`*(this: LVector3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.operator +(#)".}

proc `+`*(this: LVector3d, other: LVector3d): LVector3d {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVector3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.operator -(#)".}

proc `-`*(this: LVector3d, other: LVector3d): LVector3d {.importcpp: "#.operator -(#)".}

proc cross*(this: LVector3d, other: LVecBase3d): LVector3d {.importcpp: "#.cross(#)".}

proc normalized*(this: LVector3d): LVector3d {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVector3d, onto: LVecBase3d): LVector3d {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc angle_rad*(this: LVector3d, other: LVector3d): float64 {.importcpp: "#.angle_rad(#)".} ## \
## Returns the unsigned angle between this vector and the other one, expressed
## in radians.  Both vectors should be initially normalized.

proc angle_deg*(this: LVector3d, other: LVector3d): float64 {.importcpp: "#.angle_deg(#)".} ## \
## Returns the angle between this vector and the other one, expressed in
## degrees.  Both vectors should be initially normalized.

proc signed_angle_rad*(this: LVector3d, other: LVector3d, `ref`: LVector3d): float64 {.importcpp: "#.signed_angle_rad(#, #)".} ## \
## returns the signed angle between two vectors.  The angle is positive if the
## rotation from this vector to other is clockwise when looking in the
## direction of the ref vector.
##
## Vectors (except the ref vector) should be initially normalized.

proc signed_angle_deg*(this: LVector3d, other: LVector3d, `ref`: LVector3d): float64 {.importcpp: "#.signed_angle_deg(#, #)".} ## \
## Returns the signed angle between two vectors.  The angle is positive if the
## rotation from this vector to other is clockwise when looking in the
## direction of the ref vector.
##
## Vectors (except the ref vector) should be initially normalized.

proc relative_angle_rad*(this: LVector3d, other: LVector3d): float64 {.importcpp: "#.relative_angle_rad(#)".} ## \
## @deprecated Do not use.

proc relative_angle_deg*(this: LVector3d, other: LVector3d): float64 {.importcpp: "#.relative_angle_deg(#)".} ## \
## @deprecated Do not use.

proc `*`*(this: LVector3d, scalar: float64): LVector3d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVector3d, scalar: float64): LVector3d {.importcpp: "#.operator /(#)".}

proc up*(_: typedesc[LVector3d], cs: CoordinateSystem): LVector3d {.importcpp: "LVector3d::up(#)", header: "lvector3.h".} ## \
## Returns the up vector for the given coordinate system.

proc up*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::up()", header: "lvector3.h".} ## \
## Returns the up vector for the given coordinate system.

proc right*(_: typedesc[LVector3d], cs: CoordinateSystem): LVector3d {.importcpp: "LVector3d::right(#)", header: "lvector3.h".} ## \
## Returns the right vector for the given coordinate system.

proc right*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::right()", header: "lvector3.h".} ## \
## Returns the right vector for the given coordinate system.

proc forward*(_: typedesc[LVector3d], cs: CoordinateSystem): LVector3d {.importcpp: "LVector3d::forward(#)", header: "lvector3.h".} ## \
## Returns the forward vector for the given coordinate system.

proc forward*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::forward()", header: "lvector3.h".} ## \
## Returns the forward vector for the given coordinate system.

proc down*(_: typedesc[LVector3d], cs: CoordinateSystem): LVector3d {.importcpp: "LVector3d::down(#)", header: "lvector3.h".} ## \
## Returns the down vector for the given coordinate system.

proc down*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::down()", header: "lvector3.h".} ## \
## Returns the down vector for the given coordinate system.

proc left*(_: typedesc[LVector3d], cs: CoordinateSystem): LVector3d {.importcpp: "LVector3d::left(#)", header: "lvector3.h".} ## \
## Returns the left vector for the given coordinate system.

proc left*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::left()", header: "lvector3.h".} ## \
## Returns the left vector for the given coordinate system.

proc back*(_: typedesc[LVector3d], cs: CoordinateSystem): LVector3d {.importcpp: "LVector3d::back(#)", header: "lvector3.h".} ## \
## Returns the back vector for the given coordinate system.

proc back*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::back()", header: "lvector3.h".} ## \
## Returns the back vector for the given coordinate system.

proc rfu*(_: typedesc[LVector3d], right: float64, fwd: float64, up: float64, cs: CoordinateSystem): LVector3d {.importcpp: "LVector3d::rfu(#, #, #, #)", header: "lvector3.h".} ## \
## Returns a vector that is described by its right, forward, and up
## components, in whatever way the coordinate system represents that vector.

proc rfu*(_: typedesc[LVector3d], right: float64, fwd: float64, up: float64): LVector3d {.importcpp: "LVector3d::rfu(#, #, #)", header: "lvector3.h".} ## \
## Returns a vector that is described by its right, forward, and up
## components, in whatever way the coordinate system represents that vector.

proc get_class_type*(_: typedesc[LVector3d]): TypeHandle {.importcpp: "LVector3d::get_class_type()", header: "lvector3.h".}

proc initLVector3i*(): LVector3i {.importcpp: "LVector3i()".}

proc initLVector3i*(copy: LVecBase2i, z: int): LVector3i {.importcpp: "LVector3i(#, #)".}

proc initLVector3i*(copy: LVecBase3i): LVector3i {.importcpp: "LVector3i(#)".}

proc initLVector3i*(param0: LVector3i): LVector3i {.importcpp: "LVector3i(#)".}

proc initLVector3i*(fill_value: int): LVector3i {.importcpp: "LVector3i(#)".}

proc initLVector3i*(x: int, y: int, z: int): LVector3i {.importcpp: "LVector3i(#, #, #)".}

proc zero*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::zero()", header: "lvector3.h".} ## \
## Returns a zero-length vector.

proc unit_x*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::unit_x()", header: "lvector3.h".} ## \
## Returns a unit X vector.

proc unit_y*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::unit_y()", header: "lvector3.h".} ## \
## Returns a unit Y vector.

proc unit_z*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::unit_z()", header: "lvector3.h".} ## \
## Returns a unit Z vector.

proc get_xy*(this: LVector3i): LVector2i {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

proc get_xz*(this: LVector3i): LVector2i {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

proc get_yz*(this: LVector3i): LVector2i {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

proc `-`*(this: LVector3i): LVector3i {.importcpp: "#.operator -()".}

proc `+`*(this: LVector3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.operator +(#)".}

proc `+`*(this: LVector3i, other: LVector3i): LVector3i {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVector3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.operator -(#)".}

proc `-`*(this: LVector3i, other: LVector3i): LVector3i {.importcpp: "#.operator -(#)".}

proc cross*(this: LVector3i, other: LVecBase3i): LVector3i {.importcpp: "#.cross(#)".}

proc `*`*(this: LVector3i, scalar: int): LVector3i {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVector3i, scalar: int): LVector3i {.importcpp: "#.operator /(#)".}

proc up*(_: typedesc[LVector3i], cs: CoordinateSystem): LVector3i {.importcpp: "LVector3i::up(#)", header: "lvector3.h".} ## \
## Returns the up vector for the given coordinate system.

proc up*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::up()", header: "lvector3.h".} ## \
## Returns the up vector for the given coordinate system.

proc right*(_: typedesc[LVector3i], cs: CoordinateSystem): LVector3i {.importcpp: "LVector3i::right(#)", header: "lvector3.h".} ## \
## Returns the right vector for the given coordinate system.

proc right*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::right()", header: "lvector3.h".} ## \
## Returns the right vector for the given coordinate system.

proc forward*(_: typedesc[LVector3i], cs: CoordinateSystem): LVector3i {.importcpp: "LVector3i::forward(#)", header: "lvector3.h".} ## \
## Returns the forward vector for the given coordinate system.

proc forward*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::forward()", header: "lvector3.h".} ## \
## Returns the forward vector for the given coordinate system.

proc down*(_: typedesc[LVector3i], cs: CoordinateSystem): LVector3i {.importcpp: "LVector3i::down(#)", header: "lvector3.h".} ## \
## Returns the down vector for the given coordinate system.

proc down*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::down()", header: "lvector3.h".} ## \
## Returns the down vector for the given coordinate system.

proc left*(_: typedesc[LVector3i], cs: CoordinateSystem): LVector3i {.importcpp: "LVector3i::left(#)", header: "lvector3.h".} ## \
## Returns the left vector for the given coordinate system.

proc left*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::left()", header: "lvector3.h".} ## \
## Returns the left vector for the given coordinate system.

proc back*(_: typedesc[LVector3i], cs: CoordinateSystem): LVector3i {.importcpp: "LVector3i::back(#)", header: "lvector3.h".} ## \
## Returns the back vector for the given coordinate system.

proc back*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::back()", header: "lvector3.h".} ## \
## Returns the back vector for the given coordinate system.

proc rfu*(_: typedesc[LVector3i], right: int, fwd: int, up: int, cs: CoordinateSystem): LVector3i {.importcpp: "LVector3i::rfu(#, #, #, #)", header: "lvector3.h".} ## \
## Returns a vector that is described by its right, forward, and up
## components, in whatever way the coordinate system represents that vector.

proc rfu*(_: typedesc[LVector3i], right: int, fwd: int, up: int): LVector3i {.importcpp: "LVector3i::rfu(#, #, #)", header: "lvector3.h".} ## \
## Returns a vector that is described by its right, forward, and up
## components, in whatever way the coordinate system represents that vector.

proc get_class_type*(_: typedesc[LVector3i]): TypeHandle {.importcpp: "LVector3i::get_class_type()", header: "lvector3.h".}

proc initLPoint3f*(): LPoint3f {.importcpp: "LPoint3f()".}

proc initLPoint3f*(param0: LPoint3f): LPoint3f {.importcpp: "LPoint3f(#)".}

proc initLPoint3f*(copy: LVecBase2f, z: float32): LPoint3f {.importcpp: "LPoint3f(#, #)".}

proc initLPoint3f*(copy: LVecBase3f): LPoint3f {.importcpp: "LPoint3f(#)".}

proc initLPoint3f*(fill_value: float32): LPoint3f {.importcpp: "LPoint3f(#)".}

proc initLPoint3f*(x: float32, y: float32, z: float32): LPoint3f {.importcpp: "LPoint3f(#, #, #)".}

proc zero*(_: typedesc[LPoint3f]): LPoint3f {.importcpp: "LPoint3f::zero()", header: "lpoint3.h".} ## \
## Returns a zero-length point.

proc unit_x*(_: typedesc[LPoint3f]): LPoint3f {.importcpp: "LPoint3f::unit_x()", header: "lpoint3.h".} ## \
## Returns a unit X point.

proc unit_y*(_: typedesc[LPoint3f]): LPoint3f {.importcpp: "LPoint3f::unit_y()", header: "lpoint3.h".} ## \
## Returns a unit Y point.

proc unit_z*(_: typedesc[LPoint3f]): LPoint3f {.importcpp: "LPoint3f::unit_z()", header: "lpoint3.h".} ## \
## Returns a unit Z point.

proc get_xy*(this: LPoint3f): LPoint2f {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

proc get_xz*(this: LPoint3f): LPoint2f {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

proc get_yz*(this: LPoint3f): LPoint2f {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

proc `-`*(this: LPoint3f): LPoint3f {.importcpp: "#.operator -()".}

proc `+`*(this: LPoint3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.operator +(#)".}

proc `+`*(this: LPoint3f, other: LVector3f): LPoint3f {.importcpp: "#.operator +(#)".}

proc `-`*(this: LPoint3f, other: LPoint3f): LVector3f {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint3f, other: LVector3f): LPoint3f {.importcpp: "#.operator -(#)".}

proc cross*(this: LPoint3f, other: LVecBase3f): LPoint3f {.importcpp: "#.cross(#)".}

proc normalized*(this: LPoint3f): LPoint3f {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LPoint3f, onto: LVecBase3f): LPoint3f {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc `*`*(this: LPoint3f, scalar: float32): LPoint3f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LPoint3f, scalar: float32): LPoint3f {.importcpp: "#.operator /(#)".}

proc origin*(_: typedesc[LPoint3f], cs: CoordinateSystem): LPoint3f {.importcpp: "LPoint3f::origin(#)", header: "lpoint3.h".} ## \
## Returns the origin of the indicated coordinate system.  This is always 0,
## 0, 0 with all of our existing coordinate systems; it's hard to imagine it
## ever being different.

proc origin*(_: typedesc[LPoint3f]): LPoint3f {.importcpp: "LPoint3f::origin()", header: "lpoint3.h".} ## \
## Returns the origin of the indicated coordinate system.  This is always 0,
## 0, 0 with all of our existing coordinate systems; it's hard to imagine it
## ever being different.

proc rfu*(_: typedesc[LPoint3f], right: float32, fwd: float32, up: float32, cs: CoordinateSystem): LPoint3f {.importcpp: "LPoint3f::rfu(#, #, #, #)", header: "lpoint3.h".} ## \
## Returns a point described by right, forward, up displacements from the
## origin, wherever that maps to in the given coordinate system.

proc rfu*(_: typedesc[LPoint3f], right: float32, fwd: float32, up: float32): LPoint3f {.importcpp: "LPoint3f::rfu(#, #, #)", header: "lpoint3.h".} ## \
## Returns a point described by right, forward, up displacements from the
## origin, wherever that maps to in the given coordinate system.

proc get_class_type*(_: typedesc[LPoint3f]): TypeHandle {.importcpp: "LPoint3f::get_class_type()", header: "lpoint3.h".}

proc initLPoint3d*(): LPoint3d {.importcpp: "LPoint3d()".}

proc initLPoint3d*(param0: LPoint3d): LPoint3d {.importcpp: "LPoint3d(#)".}

proc initLPoint3d*(copy: LVecBase2d, z: float64): LPoint3d {.importcpp: "LPoint3d(#, #)".}

proc initLPoint3d*(copy: LVecBase3d): LPoint3d {.importcpp: "LPoint3d(#)".}

proc initLPoint3d*(fill_value: float64): LPoint3d {.importcpp: "LPoint3d(#)".}

proc initLPoint3d*(x: float64, y: float64, z: float64): LPoint3d {.importcpp: "LPoint3d(#, #, #)".}

proc zero*(_: typedesc[LPoint3d]): LPoint3d {.importcpp: "LPoint3d::zero()", header: "lpoint3.h".} ## \
## Returns a zero-length point.

proc unit_x*(_: typedesc[LPoint3d]): LPoint3d {.importcpp: "LPoint3d::unit_x()", header: "lpoint3.h".} ## \
## Returns a unit X point.

proc unit_y*(_: typedesc[LPoint3d]): LPoint3d {.importcpp: "LPoint3d::unit_y()", header: "lpoint3.h".} ## \
## Returns a unit Y point.

proc unit_z*(_: typedesc[LPoint3d]): LPoint3d {.importcpp: "LPoint3d::unit_z()", header: "lpoint3.h".} ## \
## Returns a unit Z point.

proc get_xy*(this: LPoint3d): LPoint2d {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

proc get_xz*(this: LPoint3d): LPoint2d {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

proc get_yz*(this: LPoint3d): LPoint2d {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

proc `-`*(this: LPoint3d): LPoint3d {.importcpp: "#.operator -()".}

proc `+`*(this: LPoint3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.operator +(#)".}

proc `+`*(this: LPoint3d, other: LVector3d): LPoint3d {.importcpp: "#.operator +(#)".}

proc `-`*(this: LPoint3d, other: LPoint3d): LVector3d {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint3d, other: LVector3d): LPoint3d {.importcpp: "#.operator -(#)".}

proc cross*(this: LPoint3d, other: LVecBase3d): LPoint3d {.importcpp: "#.cross(#)".}

proc normalized*(this: LPoint3d): LPoint3d {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LPoint3d, onto: LVecBase3d): LPoint3d {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc `*`*(this: LPoint3d, scalar: float64): LPoint3d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LPoint3d, scalar: float64): LPoint3d {.importcpp: "#.operator /(#)".}

proc origin*(_: typedesc[LPoint3d], cs: CoordinateSystem): LPoint3d {.importcpp: "LPoint3d::origin(#)", header: "lpoint3.h".} ## \
## Returns the origin of the indicated coordinate system.  This is always 0,
## 0, 0 with all of our existing coordinate systems; it's hard to imagine it
## ever being different.

proc origin*(_: typedesc[LPoint3d]): LPoint3d {.importcpp: "LPoint3d::origin()", header: "lpoint3.h".} ## \
## Returns the origin of the indicated coordinate system.  This is always 0,
## 0, 0 with all of our existing coordinate systems; it's hard to imagine it
## ever being different.

proc rfu*(_: typedesc[LPoint3d], right: float64, fwd: float64, up: float64, cs: CoordinateSystem): LPoint3d {.importcpp: "LPoint3d::rfu(#, #, #, #)", header: "lpoint3.h".} ## \
## Returns a point described by right, forward, up displacements from the
## origin, wherever that maps to in the given coordinate system.

proc rfu*(_: typedesc[LPoint3d], right: float64, fwd: float64, up: float64): LPoint3d {.importcpp: "LPoint3d::rfu(#, #, #)", header: "lpoint3.h".} ## \
## Returns a point described by right, forward, up displacements from the
## origin, wherever that maps to in the given coordinate system.

proc get_class_type*(_: typedesc[LPoint3d]): TypeHandle {.importcpp: "LPoint3d::get_class_type()", header: "lpoint3.h".}

proc initLPoint3i*(): LPoint3i {.importcpp: "LPoint3i()".}

proc initLPoint3i*(param0: LPoint3i): LPoint3i {.importcpp: "LPoint3i(#)".}

proc initLPoint3i*(copy: LVecBase2i, z: int): LPoint3i {.importcpp: "LPoint3i(#, #)".}

proc initLPoint3i*(copy: LVecBase3i): LPoint3i {.importcpp: "LPoint3i(#)".}

proc initLPoint3i*(fill_value: int): LPoint3i {.importcpp: "LPoint3i(#)".}

proc initLPoint3i*(x: int, y: int, z: int): LPoint3i {.importcpp: "LPoint3i(#, #, #)".}

proc zero*(_: typedesc[LPoint3i]): LPoint3i {.importcpp: "LPoint3i::zero()", header: "lpoint3.h".} ## \
## Returns a zero-length point.

proc unit_x*(_: typedesc[LPoint3i]): LPoint3i {.importcpp: "LPoint3i::unit_x()", header: "lpoint3.h".} ## \
## Returns a unit X point.

proc unit_y*(_: typedesc[LPoint3i]): LPoint3i {.importcpp: "LPoint3i::unit_y()", header: "lpoint3.h".} ## \
## Returns a unit Y point.

proc unit_z*(_: typedesc[LPoint3i]): LPoint3i {.importcpp: "LPoint3i::unit_z()", header: "lpoint3.h".} ## \
## Returns a unit Z point.

proc get_xy*(this: LPoint3i): LPoint2i {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

proc get_xz*(this: LPoint3i): LPoint2i {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

proc get_yz*(this: LPoint3i): LPoint2i {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

proc `-`*(this: LPoint3i): LPoint3i {.importcpp: "#.operator -()".}

proc `+`*(this: LPoint3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.operator +(#)".}

proc `+`*(this: LPoint3i, other: LVector3i): LPoint3i {.importcpp: "#.operator +(#)".}

proc `-`*(this: LPoint3i, other: LPoint3i): LVector3i {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint3i, other: LVector3i): LPoint3i {.importcpp: "#.operator -(#)".}

proc cross*(this: LPoint3i, other: LVecBase3i): LPoint3i {.importcpp: "#.cross(#)".}

proc `*`*(this: LPoint3i, scalar: int): LPoint3i {.importcpp: "#.operator *(#)".}

proc `/`*(this: LPoint3i, scalar: int): LPoint3i {.importcpp: "#.operator /(#)".}

proc origin*(_: typedesc[LPoint3i], cs: CoordinateSystem): LPoint3i {.importcpp: "LPoint3i::origin(#)", header: "lpoint3.h".} ## \
## Returns the origin of the indicated coordinate system.  This is always 0,
## 0, 0 with all of our existing coordinate systems; it's hard to imagine it
## ever being different.

proc origin*(_: typedesc[LPoint3i]): LPoint3i {.importcpp: "LPoint3i::origin()", header: "lpoint3.h".} ## \
## Returns the origin of the indicated coordinate system.  This is always 0,
## 0, 0 with all of our existing coordinate systems; it's hard to imagine it
## ever being different.

proc rfu*(_: typedesc[LPoint3i], right: int, fwd: int, up: int, cs: CoordinateSystem): LPoint3i {.importcpp: "LPoint3i::rfu(#, #, #, #)", header: "lpoint3.h".} ## \
## Returns a point described by right, forward, up displacements from the
## origin, wherever that maps to in the given coordinate system.

proc rfu*(_: typedesc[LPoint3i], right: int, fwd: int, up: int): LPoint3i {.importcpp: "LPoint3i::rfu(#, #, #)", header: "lpoint3.h".} ## \
## Returns a point described by right, forward, up displacements from the
## origin, wherever that maps to in the given coordinate system.

proc get_class_type*(_: typedesc[LPoint3i]): TypeHandle {.importcpp: "LPoint3i::get_class_type()", header: "lpoint3.h".}

proc initLVecBase4f*(): LVecBase4f {.importcpp: "LVecBase4f()".}

proc initLVecBase4f*(point: LPoint3f): LVecBase4f {.importcpp: "LVecBase4f(#)".} ## \
## Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.

proc initLVecBase4f*(copy: LVecBase3f, w: float32): LVecBase4f {.importcpp: "LVecBase4f(#, #)".}

proc initLVecBase4f*(param0: LVecBase4f): LVecBase4f {.importcpp: "LVecBase4f(#)".}

proc initLVecBase4f*(vector: LVector3f): LVecBase4f {.importcpp: "LVecBase4f(#)".} ## \
## Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.

proc initLVecBase4f*(copy: UnalignedLVecBase4f): LVecBase4f {.importcpp: "LVecBase4f(#)".}

proc initLVecBase4f*(fill_value: float32): LVecBase4f {.importcpp: "LVecBase4f(#)".}

proc initLVecBase4f*(x: float32, y: float32, z: float32, w: float32): LVecBase4f {.importcpp: "LVecBase4f(#, #, #, #)".}

proc zero*(_: typedesc[LVecBase4f]): LVecBase4f {.importcpp: "LVecBase4f::zero()", header: "lvecBase4.h".} ## \
## Returns a zero-length vector.

proc unit_x*(_: typedesc[LVecBase4f]): LVecBase4f {.importcpp: "LVecBase4f::unit_x()", header: "lvecBase4.h".} ## \
## Returns a unit X vector.

proc unit_y*(_: typedesc[LVecBase4f]): LVecBase4f {.importcpp: "LVecBase4f::unit_y()", header: "lvecBase4.h".} ## \
## Returns a unit Y vector.

proc unit_z*(_: typedesc[LVecBase4f]): LVecBase4f {.importcpp: "LVecBase4f::unit_z()", header: "lvecBase4.h".} ## \
## Returns a unit Z vector.

proc unit_w*(_: typedesc[LVecBase4f]): LVecBase4f {.importcpp: "LVecBase4f::unit_w()", header: "lvecBase4.h".} ## \
## Returns a unit W vector.

proc `[]`*(this: LVecBase4f, i: int, assign_val: float32) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[LVecBase4f]): int {.importcpp: "LVecBase4f::size()", header: "lvecBase4.h".}

proc is_nan*(this: LVecBase4f): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the vector is not-a-number, false
## otherwise.

proc get_cell*(this: LVecBase4f, i: int): float32 {.importcpp: "#.get_cell(#)".}

proc set_cell*(this: LVecBase4f, i: int, value: float32) {.importcpp: "#.set_cell(#, #)".}

proc get_x*(this: LVecBase4f): float32 {.importcpp: "#.get_x()".}

proc get_y*(this: LVecBase4f): float32 {.importcpp: "#.get_y()".}

proc get_z*(this: LVecBase4f): float32 {.importcpp: "#.get_z()".}

proc get_w*(this: LVecBase4f): float32 {.importcpp: "#.get_w()".}

proc get_xyz*(this: LVecBase4f): LVecBase3f {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

proc get_xy*(this: LVecBase4f): LVecBase2f {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

proc set_x*(this: LVecBase4f, value: float32) {.importcpp: "#.set_x(#)".}

proc set_y*(this: LVecBase4f, value: float32) {.importcpp: "#.set_y(#)".}

proc set_z*(this: LVecBase4f, value: float32) {.importcpp: "#.set_z(#)".}

proc set_w*(this: LVecBase4f, value: float32) {.importcpp: "#.set_w(#)".}

proc add_to_cell*(this: LVecBase4f, i: int, value: float32) {.importcpp: "#.add_to_cell(#, #)".} ## \
## These next functions add to an existing value.  i.e.
## foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
## scripting languages:

proc add_x*(this: LVecBase4f, value: float32) {.importcpp: "#.add_x(#)".}

proc add_y*(this: LVecBase4f, value: float32) {.importcpp: "#.add_y(#)".}

proc add_z*(this: LVecBase4f, value: float32) {.importcpp: "#.add_z(#)".}

proc add_w*(this: LVecBase4f, value: float32) {.importcpp: "#.add_w(#)".}

proc get_data*(this: LVecBase4f) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the four data elements in the vector.
## The remaining elements occupy the next positions consecutively in memory.

proc get_num_components*(_: typedesc[LVecBase4f]): int {.importcpp: "LVecBase4f::get_num_components()", header: "lvecBase4.h".}

proc fill*(this: LVecBase4f, fill_value: float32) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: LVecBase4f, x: float32, y: float32, z: float32, w: float32) {.importcpp: "#.set(#, #, #, #)".}

proc dot*(this: LVecBase4f, other: LVecBase4f): float32 {.importcpp: "#.dot(#)".}

proc length_squared*(this: LVecBase4f): float32 {.importcpp: "#.length_squared()".} ## \
## Returns the square of the vector's length, cheap and easy.

proc length*(this: LVecBase4f): float32 {.importcpp: "#.length()".} ## \
## Returns the length of the vector, by the Pythagorean theorem.

proc normalize*(this: LVecBase4f): bool {.importcpp: "#.normalize()".} ## \
## Normalizes the vector in place.  Returns true if the vector was normalized,
## false if it was a zero-length vector.

proc normalized*(this: LVecBase4f): LVecBase4f {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVecBase4f, onto: LVecBase4f): LVecBase4f {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc `<`*(this: LVecBase4f, other: LVecBase4f): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LVecBase4f, other: LVecBase4f): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LVecBase4f, other: LVecBase4f): bool {.importcpp: "#.operator !=(#)".}

proc compare_to*(this: LVecBase4f, other: LVecBase4f): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compare_to*(this: LVecBase4f, other: LVecBase4f, threshold: float32): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts vectors lexicographically, componentwise.  Returns a number less than
## 0 if this vector sorts before the other one, greater than zero if it sorts
## after, 0 if they are equivalent (within the indicated tolerance).

proc get_hash*(this: LVecBase4f): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc get_hash*(this: LVecBase4f, threshold: float32): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc add_hash*(this: LVecBase4f, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc add_hash*(this: LVecBase4f, hash: clonglong, threshold: float32): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc `-`*(this: LVecBase4f): LVecBase4f {.importcpp: "#.operator -()".}

proc `+`*(this: LVecBase4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVecBase4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVecBase4f, scalar: float32): LVecBase4f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVecBase4f, scalar: float32): LVecBase4f {.importcpp: "#.operator /(#)".}

proc `+=`*(this: LVecBase4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: LVecBase4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: LVecBase4f, scalar: float32): LVecBase4f {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: LVecBase4f, scalar: float32): LVecBase4f {.importcpp: "#.operator /=(#)".}

proc componentwise_mult*(this: LVecBase4f, other: LVecBase4f) {.importcpp: "#.componentwise_mult(#)".}

proc fmax*(this: LVecBase4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.fmax(#)".}

proc fmin*(this: LVecBase4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.fmin(#)".}

proc almost_equal*(this: LVecBase4f, other: LVecBase4f): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two vectors are memberwise equal within a default tolerance
## based on the numeric type.

proc almost_equal*(this: LVecBase4f, other: LVecBase4f, threshold: float32): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two vectors are memberwise equal within a specified
## tolerance.

proc output*(this: LVecBase4f, `out`: ostream) {.importcpp: "#.output(#)".}

proc write_datagram_fixed*(this: LVecBase4f, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the vector to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the vector, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc read_datagram_fixed*(this: LVecBase4f, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the vector from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc write_datagram*(this: LVecBase4f, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the vector to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc read_datagram*(this: LVecBase4f, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the vector from the Datagram using get_stdfloat().

proc get_class_type*(_: typedesc[LVecBase4f]): TypeHandle {.importcpp: "LVecBase4f::get_class_type()", header: "lvecBase4.h".}

proc initUnalignedLVecBase4f*(): UnalignedLVecBase4f {.importcpp: "UnalignedLVecBase4f()".}

proc initUnalignedLVecBase4f*(copy: LVecBase4f): UnalignedLVecBase4f {.importcpp: "UnalignedLVecBase4f(#)".}

proc initUnalignedLVecBase4f*(param0: UnalignedLVecBase4f): UnalignedLVecBase4f {.importcpp: "UnalignedLVecBase4f(#)".}

proc initUnalignedLVecBase4f*(fill_value: float32): UnalignedLVecBase4f {.importcpp: "UnalignedLVecBase4f(#)".}

proc initUnalignedLVecBase4f*(x: float32, y: float32, z: float32, w: float32): UnalignedLVecBase4f {.importcpp: "UnalignedLVecBase4f(#, #, #, #)".}

proc fill*(this: UnalignedLVecBase4f, fill_value: float32) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: UnalignedLVecBase4f, x: float32, y: float32, z: float32, w: float32) {.importcpp: "#.set(#, #, #, #)".}

proc `[]`*(this: UnalignedLVecBase4f, i: int, assign_val: float32) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[UnalignedLVecBase4f]): int {.importcpp: "UnalignedLVecBase4f::size()", header: "unalignedLVecBase4f.h".}

proc get_data*(this: UnalignedLVecBase4f) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the three data elements in the vector.
## The remaining elements occupy the next positions consecutively in memory.

proc get_num_components*(_: typedesc[UnalignedLVecBase4f]): int {.importcpp: "UnalignedLVecBase4f::get_num_components()", header: "unalignedLVecBase4f.h".}

proc `==`*(this: UnalignedLVecBase4f, other: UnalignedLVecBase4f): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: UnalignedLVecBase4f, other: UnalignedLVecBase4f): bool {.importcpp: "#.operator !=(#)".}

proc get_class_type*(_: typedesc[UnalignedLVecBase4f]): TypeHandle {.importcpp: "UnalignedLVecBase4f::get_class_type()", header: "unalignedLVecBase4f.h".}

proc initLVecBase4d*(): LVecBase4d {.importcpp: "LVecBase4d()".}

proc initLVecBase4d*(point: LPoint3d): LVecBase4d {.importcpp: "LVecBase4d(#)".} ## \
## Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.

proc initLVecBase4d*(copy: LVecBase3d, w: float64): LVecBase4d {.importcpp: "LVecBase4d(#, #)".}

proc initLVecBase4d*(param0: LVecBase4d): LVecBase4d {.importcpp: "LVecBase4d(#)".}

proc initLVecBase4d*(vector: LVector3d): LVecBase4d {.importcpp: "LVecBase4d(#)".} ## \
## Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.

proc initLVecBase4d*(copy: UnalignedLVecBase4d): LVecBase4d {.importcpp: "LVecBase4d(#)".}

proc initLVecBase4d*(fill_value: float64): LVecBase4d {.importcpp: "LVecBase4d(#)".}

proc initLVecBase4d*(x: float64, y: float64, z: float64, w: float64): LVecBase4d {.importcpp: "LVecBase4d(#, #, #, #)".}

proc zero*(_: typedesc[LVecBase4d]): LVecBase4d {.importcpp: "LVecBase4d::zero()", header: "lvecBase4.h".} ## \
## Returns a zero-length vector.

proc unit_x*(_: typedesc[LVecBase4d]): LVecBase4d {.importcpp: "LVecBase4d::unit_x()", header: "lvecBase4.h".} ## \
## Returns a unit X vector.

proc unit_y*(_: typedesc[LVecBase4d]): LVecBase4d {.importcpp: "LVecBase4d::unit_y()", header: "lvecBase4.h".} ## \
## Returns a unit Y vector.

proc unit_z*(_: typedesc[LVecBase4d]): LVecBase4d {.importcpp: "LVecBase4d::unit_z()", header: "lvecBase4.h".} ## \
## Returns a unit Z vector.

proc unit_w*(_: typedesc[LVecBase4d]): LVecBase4d {.importcpp: "LVecBase4d::unit_w()", header: "lvecBase4.h".} ## \
## Returns a unit W vector.

proc `[]`*(this: LVecBase4d, i: int, assign_val: float64) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[LVecBase4d]): int {.importcpp: "LVecBase4d::size()", header: "lvecBase4.h".}

proc is_nan*(this: LVecBase4d): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the vector is not-a-number, false
## otherwise.

proc get_cell*(this: LVecBase4d, i: int): float64 {.importcpp: "#.get_cell(#)".}

proc set_cell*(this: LVecBase4d, i: int, value: float64) {.importcpp: "#.set_cell(#, #)".}

proc get_x*(this: LVecBase4d): float64 {.importcpp: "#.get_x()".}

proc get_y*(this: LVecBase4d): float64 {.importcpp: "#.get_y()".}

proc get_z*(this: LVecBase4d): float64 {.importcpp: "#.get_z()".}

proc get_w*(this: LVecBase4d): float64 {.importcpp: "#.get_w()".}

proc get_xyz*(this: LVecBase4d): LVecBase3d {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

proc get_xy*(this: LVecBase4d): LVecBase2d {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

proc set_x*(this: LVecBase4d, value: float64) {.importcpp: "#.set_x(#)".}

proc set_y*(this: LVecBase4d, value: float64) {.importcpp: "#.set_y(#)".}

proc set_z*(this: LVecBase4d, value: float64) {.importcpp: "#.set_z(#)".}

proc set_w*(this: LVecBase4d, value: float64) {.importcpp: "#.set_w(#)".}

proc add_to_cell*(this: LVecBase4d, i: int, value: float64) {.importcpp: "#.add_to_cell(#, #)".} ## \
## These next functions add to an existing value.  i.e.
## foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
## scripting languages:

proc add_x*(this: LVecBase4d, value: float64) {.importcpp: "#.add_x(#)".}

proc add_y*(this: LVecBase4d, value: float64) {.importcpp: "#.add_y(#)".}

proc add_z*(this: LVecBase4d, value: float64) {.importcpp: "#.add_z(#)".}

proc add_w*(this: LVecBase4d, value: float64) {.importcpp: "#.add_w(#)".}

proc get_data*(this: LVecBase4d) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the four data elements in the vector.
## The remaining elements occupy the next positions consecutively in memory.

proc get_num_components*(_: typedesc[LVecBase4d]): int {.importcpp: "LVecBase4d::get_num_components()", header: "lvecBase4.h".}

proc fill*(this: LVecBase4d, fill_value: float64) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: LVecBase4d, x: float64, y: float64, z: float64, w: float64) {.importcpp: "#.set(#, #, #, #)".}

proc dot*(this: LVecBase4d, other: LVecBase4d): float64 {.importcpp: "#.dot(#)".}

proc length_squared*(this: LVecBase4d): float64 {.importcpp: "#.length_squared()".} ## \
## Returns the square of the vector's length, cheap and easy.

proc length*(this: LVecBase4d): float64 {.importcpp: "#.length()".} ## \
## Returns the length of the vector, by the Pythagorean theorem.

proc normalize*(this: LVecBase4d): bool {.importcpp: "#.normalize()".} ## \
## Normalizes the vector in place.  Returns true if the vector was normalized,
## false if it was a zero-length vector.

proc normalized*(this: LVecBase4d): LVecBase4d {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVecBase4d, onto: LVecBase4d): LVecBase4d {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc `<`*(this: LVecBase4d, other: LVecBase4d): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LVecBase4d, other: LVecBase4d): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LVecBase4d, other: LVecBase4d): bool {.importcpp: "#.operator !=(#)".}

proc compare_to*(this: LVecBase4d, other: LVecBase4d): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compare_to*(this: LVecBase4d, other: LVecBase4d, threshold: float64): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts vectors lexicographically, componentwise.  Returns a number less than
## 0 if this vector sorts before the other one, greater than zero if it sorts
## after, 0 if they are equivalent (within the indicated tolerance).

proc get_hash*(this: LVecBase4d): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc get_hash*(this: LVecBase4d, threshold: float64): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc add_hash*(this: LVecBase4d, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc add_hash*(this: LVecBase4d, hash: clonglong, threshold: float64): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc `-`*(this: LVecBase4d): LVecBase4d {.importcpp: "#.operator -()".}

proc `+`*(this: LVecBase4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVecBase4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVecBase4d, scalar: float64): LVecBase4d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVecBase4d, scalar: float64): LVecBase4d {.importcpp: "#.operator /(#)".}

proc `+=`*(this: LVecBase4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: LVecBase4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: LVecBase4d, scalar: float64): LVecBase4d {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: LVecBase4d, scalar: float64): LVecBase4d {.importcpp: "#.operator /=(#)".}

proc componentwise_mult*(this: LVecBase4d, other: LVecBase4d) {.importcpp: "#.componentwise_mult(#)".}

proc fmax*(this: LVecBase4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.fmax(#)".}

proc fmin*(this: LVecBase4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.fmin(#)".}

proc almost_equal*(this: LVecBase4d, other: LVecBase4d): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two vectors are memberwise equal within a default tolerance
## based on the numeric type.

proc almost_equal*(this: LVecBase4d, other: LVecBase4d, threshold: float64): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two vectors are memberwise equal within a specified
## tolerance.

proc output*(this: LVecBase4d, `out`: ostream) {.importcpp: "#.output(#)".}

proc write_datagram_fixed*(this: LVecBase4d, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the vector to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the vector, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc read_datagram_fixed*(this: LVecBase4d, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the vector from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc write_datagram*(this: LVecBase4d, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the vector to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc read_datagram*(this: LVecBase4d, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the vector from the Datagram using get_stdfloat().

proc get_class_type*(_: typedesc[LVecBase4d]): TypeHandle {.importcpp: "LVecBase4d::get_class_type()", header: "lvecBase4.h".}

proc initUnalignedLVecBase4d*(): UnalignedLVecBase4d {.importcpp: "UnalignedLVecBase4d()".}

proc initUnalignedLVecBase4d*(copy: LVecBase4d): UnalignedLVecBase4d {.importcpp: "UnalignedLVecBase4d(#)".}

proc initUnalignedLVecBase4d*(param0: UnalignedLVecBase4d): UnalignedLVecBase4d {.importcpp: "UnalignedLVecBase4d(#)".}

proc initUnalignedLVecBase4d*(fill_value: float64): UnalignedLVecBase4d {.importcpp: "UnalignedLVecBase4d(#)".}

proc initUnalignedLVecBase4d*(x: float64, y: float64, z: float64, w: float64): UnalignedLVecBase4d {.importcpp: "UnalignedLVecBase4d(#, #, #, #)".}

proc fill*(this: UnalignedLVecBase4d, fill_value: float64) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: UnalignedLVecBase4d, x: float64, y: float64, z: float64, w: float64) {.importcpp: "#.set(#, #, #, #)".}

proc `[]`*(this: UnalignedLVecBase4d, i: int, assign_val: float64) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[UnalignedLVecBase4d]): int {.importcpp: "UnalignedLVecBase4d::size()", header: "unalignedLVecBase4d.h".}

proc get_data*(this: UnalignedLVecBase4d) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the three data elements in the vector.
## The remaining elements occupy the next positions consecutively in memory.

proc get_num_components*(_: typedesc[UnalignedLVecBase4d]): int {.importcpp: "UnalignedLVecBase4d::get_num_components()", header: "unalignedLVecBase4d.h".}

proc `==`*(this: UnalignedLVecBase4d, other: UnalignedLVecBase4d): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: UnalignedLVecBase4d, other: UnalignedLVecBase4d): bool {.importcpp: "#.operator !=(#)".}

proc get_class_type*(_: typedesc[UnalignedLVecBase4d]): TypeHandle {.importcpp: "UnalignedLVecBase4d::get_class_type()", header: "unalignedLVecBase4d.h".}

proc initLVecBase4i*(): LVecBase4i {.importcpp: "LVecBase4i()".}

proc initLVecBase4i*(point: LPoint3i): LVecBase4i {.importcpp: "LVecBase4i(#)".} ## \
## Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.

proc initLVecBase4i*(copy: LVecBase3i, w: int): LVecBase4i {.importcpp: "LVecBase4i(#, #)".}

proc initLVecBase4i*(param0: LVecBase4i): LVecBase4i {.importcpp: "LVecBase4i(#)".}

proc initLVecBase4i*(vector: LVector3i): LVecBase4i {.importcpp: "LVecBase4i(#)".} ## \
## Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.

proc initLVecBase4i*(copy: UnalignedLVecBase4i): LVecBase4i {.importcpp: "LVecBase4i(#)".}

proc initLVecBase4i*(fill_value: int): LVecBase4i {.importcpp: "LVecBase4i(#)".}

proc initLVecBase4i*(x: int, y: int, z: int, w: int): LVecBase4i {.importcpp: "LVecBase4i(#, #, #, #)".}

proc zero*(_: typedesc[LVecBase4i]): LVecBase4i {.importcpp: "LVecBase4i::zero()", header: "lvecBase4.h".} ## \
## Returns a zero-length vector.

proc unit_x*(_: typedesc[LVecBase4i]): LVecBase4i {.importcpp: "LVecBase4i::unit_x()", header: "lvecBase4.h".} ## \
## Returns a unit X vector.

proc unit_y*(_: typedesc[LVecBase4i]): LVecBase4i {.importcpp: "LVecBase4i::unit_y()", header: "lvecBase4.h".} ## \
## Returns a unit Y vector.

proc unit_z*(_: typedesc[LVecBase4i]): LVecBase4i {.importcpp: "LVecBase4i::unit_z()", header: "lvecBase4.h".} ## \
## Returns a unit Z vector.

proc unit_w*(_: typedesc[LVecBase4i]): LVecBase4i {.importcpp: "LVecBase4i::unit_w()", header: "lvecBase4.h".} ## \
## Returns a unit W vector.

proc `[]`*(this: LVecBase4i, i: int, assign_val: int) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[LVecBase4i]): int {.importcpp: "LVecBase4i::size()", header: "lvecBase4.h".}

proc is_nan*(this: LVecBase4i): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the vector is not-a-number, false
## otherwise.

proc get_cell*(this: LVecBase4i, i: int): int {.importcpp: "#.get_cell(#)".}

proc set_cell*(this: LVecBase4i, i: int, value: int) {.importcpp: "#.set_cell(#, #)".}

proc get_x*(this: LVecBase4i): int {.importcpp: "#.get_x()".}

proc get_y*(this: LVecBase4i): int {.importcpp: "#.get_y()".}

proc get_z*(this: LVecBase4i): int {.importcpp: "#.get_z()".}

proc get_w*(this: LVecBase4i): int {.importcpp: "#.get_w()".}

proc get_xyz*(this: LVecBase4i): LVecBase3i {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

proc get_xy*(this: LVecBase4i): LVecBase2i {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

proc set_x*(this: LVecBase4i, value: int) {.importcpp: "#.set_x(#)".}

proc set_y*(this: LVecBase4i, value: int) {.importcpp: "#.set_y(#)".}

proc set_z*(this: LVecBase4i, value: int) {.importcpp: "#.set_z(#)".}

proc set_w*(this: LVecBase4i, value: int) {.importcpp: "#.set_w(#)".}

proc add_to_cell*(this: LVecBase4i, i: int, value: int) {.importcpp: "#.add_to_cell(#, #)".} ## \
## These next functions add to an existing value.  i.e.
## foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
## scripting languages:

proc add_x*(this: LVecBase4i, value: int) {.importcpp: "#.add_x(#)".}

proc add_y*(this: LVecBase4i, value: int) {.importcpp: "#.add_y(#)".}

proc add_z*(this: LVecBase4i, value: int) {.importcpp: "#.add_z(#)".}

proc add_w*(this: LVecBase4i, value: int) {.importcpp: "#.add_w(#)".}

proc get_data*(this: LVecBase4i) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the four data elements in the vector.
## The remaining elements occupy the next positions consecutively in memory.

proc get_num_components*(_: typedesc[LVecBase4i]): int {.importcpp: "LVecBase4i::get_num_components()", header: "lvecBase4.h".}

proc fill*(this: LVecBase4i, fill_value: int) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: LVecBase4i, x: int, y: int, z: int, w: int) {.importcpp: "#.set(#, #, #, #)".}

proc dot*(this: LVecBase4i, other: LVecBase4i): int {.importcpp: "#.dot(#)".}

proc length_squared*(this: LVecBase4i): int {.importcpp: "#.length_squared()".} ## \
## Returns the square of the vector's length, cheap and easy.

proc `<`*(this: LVecBase4i, other: LVecBase4i): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LVecBase4i, other: LVecBase4i): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LVecBase4i, other: LVecBase4i): bool {.importcpp: "#.operator !=(#)".}

proc compare_to*(this: LVecBase4i, other: LVecBase4i): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc get_hash*(this: LVecBase4i): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc add_hash*(this: LVecBase4i, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc `-`*(this: LVecBase4i): LVecBase4i {.importcpp: "#.operator -()".}

proc `+`*(this: LVecBase4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVecBase4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVecBase4i, scalar: int): LVecBase4i {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVecBase4i, scalar: int): LVecBase4i {.importcpp: "#.operator /(#)".}

proc `+=`*(this: LVecBase4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: LVecBase4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: LVecBase4i, scalar: int): LVecBase4i {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: LVecBase4i, scalar: int): LVecBase4i {.importcpp: "#.operator /=(#)".}

proc componentwise_mult*(this: LVecBase4i, other: LVecBase4i) {.importcpp: "#.componentwise_mult(#)".}

proc fmax*(this: LVecBase4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.fmax(#)".}

proc fmin*(this: LVecBase4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.fmin(#)".}

proc almost_equal*(this: LVecBase4i, other: LVecBase4i): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two vectors are memberwise equal within a default tolerance
## based on the numeric type.

proc almost_equal*(this: LVecBase4i, other: LVecBase4i, threshold: int): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two vectors are memberwise equal within a specified
## tolerance.

proc output*(this: LVecBase4i, `out`: ostream) {.importcpp: "#.output(#)".}

proc write_datagram_fixed*(this: LVecBase4i, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the vector to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the vector, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc read_datagram_fixed*(this: LVecBase4i, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the vector from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc write_datagram*(this: LVecBase4i, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the vector to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc read_datagram*(this: LVecBase4i, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the vector from the Datagram using get_stdfloat().

proc get_class_type*(_: typedesc[LVecBase4i]): TypeHandle {.importcpp: "LVecBase4i::get_class_type()", header: "lvecBase4.h".}

proc initUnalignedLVecBase4i*(): UnalignedLVecBase4i {.importcpp: "UnalignedLVecBase4i()".}

proc initUnalignedLVecBase4i*(copy: LVecBase4i): UnalignedLVecBase4i {.importcpp: "UnalignedLVecBase4i(#)".}

proc initUnalignedLVecBase4i*(param0: UnalignedLVecBase4i): UnalignedLVecBase4i {.importcpp: "UnalignedLVecBase4i(#)".}

proc initUnalignedLVecBase4i*(fill_value: int): UnalignedLVecBase4i {.importcpp: "UnalignedLVecBase4i(#)".}

proc initUnalignedLVecBase4i*(x: int, y: int, z: int, w: int): UnalignedLVecBase4i {.importcpp: "UnalignedLVecBase4i(#, #, #, #)".}

proc fill*(this: UnalignedLVecBase4i, fill_value: int) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: UnalignedLVecBase4i, x: int, y: int, z: int, w: int) {.importcpp: "#.set(#, #, #, #)".}

proc `[]`*(this: UnalignedLVecBase4i, i: int, assign_val: int) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[UnalignedLVecBase4i]): int {.importcpp: "UnalignedLVecBase4i::size()", header: "unalignedLVecBase4i.h".}

proc get_data*(this: UnalignedLVecBase4i) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the three data elements in the vector.
## The remaining elements occupy the next positions consecutively in memory.

proc get_num_components*(_: typedesc[UnalignedLVecBase4i]): int {.importcpp: "UnalignedLVecBase4i::get_num_components()", header: "unalignedLVecBase4i.h".}

proc `==`*(this: UnalignedLVecBase4i, other: UnalignedLVecBase4i): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: UnalignedLVecBase4i, other: UnalignedLVecBase4i): bool {.importcpp: "#.operator !=(#)".}

proc get_class_type*(_: typedesc[UnalignedLVecBase4i]): TypeHandle {.importcpp: "UnalignedLVecBase4i::get_class_type()", header: "unalignedLVecBase4i.h".}

proc initLVector4f*(): LVector4f {.importcpp: "LVector4f()".}

proc initLVector4f*(copy: LVecBase3f, w: float32): LVector4f {.importcpp: "LVector4f(#, #)".}

proc initLVector4f*(copy: LVecBase4f): LVector4f {.importcpp: "LVector4f(#)".}

proc initLVector4f*(param0: LVector4f): LVector4f {.importcpp: "LVector4f(#)".}

proc initLVector4f*(fill_value: float32): LVector4f {.importcpp: "LVector4f(#)".}

proc initLVector4f*(x: float32, y: float32, z: float32, w: float32): LVector4f {.importcpp: "LVector4f(#, #, #, #)".}

proc zero*(_: typedesc[LVector4f]): LVector4f {.importcpp: "LVector4f::zero()", header: "lvector4.h".} ## \
## Returns a zero-length vector.

proc unit_x*(_: typedesc[LVector4f]): LVector4f {.importcpp: "LVector4f::unit_x()", header: "lvector4.h".} ## \
## Returns a unit X vector.

proc unit_y*(_: typedesc[LVector4f]): LVector4f {.importcpp: "LVector4f::unit_y()", header: "lvector4.h".} ## \
## Returns a unit Y vector.

proc unit_z*(_: typedesc[LVector4f]): LVector4f {.importcpp: "LVector4f::unit_z()", header: "lvector4.h".} ## \
## Returns a unit Z vector.

proc unit_w*(_: typedesc[LVector4f]): LVector4f {.importcpp: "LVector4f::unit_w()", header: "lvector4.h".} ## \
## Returns a unit W vector.

proc get_xyz*(this: LVector4f): LVector3f {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

proc get_xy*(this: LVector4f): LVector2f {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

proc `-`*(this: LVector4f): LVector4f {.importcpp: "#.operator -()".}

proc `+`*(this: LVector4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.operator +(#)".}

proc `+`*(this: LVector4f, other: LVector4f): LVector4f {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVector4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.operator -(#)".}

proc `-`*(this: LVector4f, other: LVector4f): LVector4f {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVector4f, scalar: float32): LVector4f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVector4f, scalar: float32): LVector4f {.importcpp: "#.operator /(#)".}

proc normalized*(this: LVector4f): LVector4f {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVector4f, onto: LVecBase4f): LVector4f {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc get_class_type*(_: typedesc[LVector4f]): TypeHandle {.importcpp: "LVector4f::get_class_type()", header: "lvector4.h".}

proc initLVector4d*(): LVector4d {.importcpp: "LVector4d()".}

proc initLVector4d*(copy: LVecBase3d, w: float64): LVector4d {.importcpp: "LVector4d(#, #)".}

proc initLVector4d*(copy: LVecBase4d): LVector4d {.importcpp: "LVector4d(#)".}

proc initLVector4d*(param0: LVector4d): LVector4d {.importcpp: "LVector4d(#)".}

proc initLVector4d*(fill_value: float64): LVector4d {.importcpp: "LVector4d(#)".}

proc initLVector4d*(x: float64, y: float64, z: float64, w: float64): LVector4d {.importcpp: "LVector4d(#, #, #, #)".}

proc zero*(_: typedesc[LVector4d]): LVector4d {.importcpp: "LVector4d::zero()", header: "lvector4.h".} ## \
## Returns a zero-length vector.

proc unit_x*(_: typedesc[LVector4d]): LVector4d {.importcpp: "LVector4d::unit_x()", header: "lvector4.h".} ## \
## Returns a unit X vector.

proc unit_y*(_: typedesc[LVector4d]): LVector4d {.importcpp: "LVector4d::unit_y()", header: "lvector4.h".} ## \
## Returns a unit Y vector.

proc unit_z*(_: typedesc[LVector4d]): LVector4d {.importcpp: "LVector4d::unit_z()", header: "lvector4.h".} ## \
## Returns a unit Z vector.

proc unit_w*(_: typedesc[LVector4d]): LVector4d {.importcpp: "LVector4d::unit_w()", header: "lvector4.h".} ## \
## Returns a unit W vector.

proc get_xyz*(this: LVector4d): LVector3d {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

proc get_xy*(this: LVector4d): LVector2d {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

proc `-`*(this: LVector4d): LVector4d {.importcpp: "#.operator -()".}

proc `+`*(this: LVector4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.operator +(#)".}

proc `+`*(this: LVector4d, other: LVector4d): LVector4d {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVector4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.operator -(#)".}

proc `-`*(this: LVector4d, other: LVector4d): LVector4d {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVector4d, scalar: float64): LVector4d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVector4d, scalar: float64): LVector4d {.importcpp: "#.operator /(#)".}

proc normalized*(this: LVector4d): LVector4d {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVector4d, onto: LVecBase4d): LVector4d {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc get_class_type*(_: typedesc[LVector4d]): TypeHandle {.importcpp: "LVector4d::get_class_type()", header: "lvector4.h".}

proc initLVector4i*(): LVector4i {.importcpp: "LVector4i()".}

proc initLVector4i*(copy: LVecBase3i, w: int): LVector4i {.importcpp: "LVector4i(#, #)".}

proc initLVector4i*(copy: LVecBase4i): LVector4i {.importcpp: "LVector4i(#)".}

proc initLVector4i*(param0: LVector4i): LVector4i {.importcpp: "LVector4i(#)".}

proc initLVector4i*(fill_value: int): LVector4i {.importcpp: "LVector4i(#)".}

proc initLVector4i*(x: int, y: int, z: int, w: int): LVector4i {.importcpp: "LVector4i(#, #, #, #)".}

proc zero*(_: typedesc[LVector4i]): LVector4i {.importcpp: "LVector4i::zero()", header: "lvector4.h".} ## \
## Returns a zero-length vector.

proc unit_x*(_: typedesc[LVector4i]): LVector4i {.importcpp: "LVector4i::unit_x()", header: "lvector4.h".} ## \
## Returns a unit X vector.

proc unit_y*(_: typedesc[LVector4i]): LVector4i {.importcpp: "LVector4i::unit_y()", header: "lvector4.h".} ## \
## Returns a unit Y vector.

proc unit_z*(_: typedesc[LVector4i]): LVector4i {.importcpp: "LVector4i::unit_z()", header: "lvector4.h".} ## \
## Returns a unit Z vector.

proc unit_w*(_: typedesc[LVector4i]): LVector4i {.importcpp: "LVector4i::unit_w()", header: "lvector4.h".} ## \
## Returns a unit W vector.

proc get_xyz*(this: LVector4i): LVector3i {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

proc get_xy*(this: LVector4i): LVector2i {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

proc `-`*(this: LVector4i): LVector4i {.importcpp: "#.operator -()".}

proc `+`*(this: LVector4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.operator +(#)".}

proc `+`*(this: LVector4i, other: LVector4i): LVector4i {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVector4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.operator -(#)".}

proc `-`*(this: LVector4i, other: LVector4i): LVector4i {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVector4i, scalar: int): LVector4i {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVector4i, scalar: int): LVector4i {.importcpp: "#.operator /(#)".}

proc get_class_type*(_: typedesc[LVector4i]): TypeHandle {.importcpp: "LVector4i::get_class_type()", header: "lvector4.h".}

proc initLPoint4f*(): LPoint4f {.importcpp: "LPoint4f()".}

proc initLPoint4f*(param0: LPoint4f): LPoint4f {.importcpp: "LPoint4f(#)".}

proc initLPoint4f*(copy: LVecBase3f, w: float32): LPoint4f {.importcpp: "LPoint4f(#, #)".}

proc initLPoint4f*(copy: LVecBase4f): LPoint4f {.importcpp: "LPoint4f(#)".}

proc initLPoint4f*(fill_value: float32): LPoint4f {.importcpp: "LPoint4f(#)".}

proc initLPoint4f*(x: float32, y: float32, z: float32, w: float32): LPoint4f {.importcpp: "LPoint4f(#, #, #, #)".}

proc zero*(_: typedesc[LPoint4f]): LPoint4f {.importcpp: "LPoint4f::zero()", header: "lpoint4.h".} ## \
## Returns a zero-length point.

proc unit_x*(_: typedesc[LPoint4f]): LPoint4f {.importcpp: "LPoint4f::unit_x()", header: "lpoint4.h".} ## \
## Returns a unit X point.

proc unit_y*(_: typedesc[LPoint4f]): LPoint4f {.importcpp: "LPoint4f::unit_y()", header: "lpoint4.h".} ## \
## Returns a unit Y point.

proc unit_z*(_: typedesc[LPoint4f]): LPoint4f {.importcpp: "LPoint4f::unit_z()", header: "lpoint4.h".} ## \
## Returns a unit Z point.

proc unit_w*(_: typedesc[LPoint4f]): LPoint4f {.importcpp: "LPoint4f::unit_w()", header: "lpoint4.h".} ## \
## Returns a unit W point.

proc get_xyz*(this: LPoint4f): LPoint3f {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

proc get_xy*(this: LPoint4f): LPoint2f {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

proc `-`*(this: LPoint4f): LPoint4f {.importcpp: "#.operator -()".}

proc `+`*(this: LPoint4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.operator +(#)".}

proc `+`*(this: LPoint4f, other: LVector4f): LPoint4f {.importcpp: "#.operator +(#)".}

proc `-`*(this: LPoint4f, other: LPoint4f): LVector4f {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint4f, other: LVector4f): LPoint4f {.importcpp: "#.operator -(#)".}

proc `*`*(this: LPoint4f, scalar: float32): LPoint4f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LPoint4f, scalar: float32): LPoint4f {.importcpp: "#.operator /(#)".}

proc normalized*(this: LPoint4f): LPoint4f {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LPoint4f, onto: LVecBase4f): LPoint4f {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc get_class_type*(_: typedesc[LPoint4f]): TypeHandle {.importcpp: "LPoint4f::get_class_type()", header: "lpoint4.h".}

proc initLPoint4d*(): LPoint4d {.importcpp: "LPoint4d()".}

proc initLPoint4d*(param0: LPoint4d): LPoint4d {.importcpp: "LPoint4d(#)".}

proc initLPoint4d*(copy: LVecBase3d, w: float64): LPoint4d {.importcpp: "LPoint4d(#, #)".}

proc initLPoint4d*(copy: LVecBase4d): LPoint4d {.importcpp: "LPoint4d(#)".}

proc initLPoint4d*(fill_value: float64): LPoint4d {.importcpp: "LPoint4d(#)".}

proc initLPoint4d*(x: float64, y: float64, z: float64, w: float64): LPoint4d {.importcpp: "LPoint4d(#, #, #, #)".}

proc zero*(_: typedesc[LPoint4d]): LPoint4d {.importcpp: "LPoint4d::zero()", header: "lpoint4.h".} ## \
## Returns a zero-length point.

proc unit_x*(_: typedesc[LPoint4d]): LPoint4d {.importcpp: "LPoint4d::unit_x()", header: "lpoint4.h".} ## \
## Returns a unit X point.

proc unit_y*(_: typedesc[LPoint4d]): LPoint4d {.importcpp: "LPoint4d::unit_y()", header: "lpoint4.h".} ## \
## Returns a unit Y point.

proc unit_z*(_: typedesc[LPoint4d]): LPoint4d {.importcpp: "LPoint4d::unit_z()", header: "lpoint4.h".} ## \
## Returns a unit Z point.

proc unit_w*(_: typedesc[LPoint4d]): LPoint4d {.importcpp: "LPoint4d::unit_w()", header: "lpoint4.h".} ## \
## Returns a unit W point.

proc get_xyz*(this: LPoint4d): LPoint3d {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

proc get_xy*(this: LPoint4d): LPoint2d {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

proc `-`*(this: LPoint4d): LPoint4d {.importcpp: "#.operator -()".}

proc `+`*(this: LPoint4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.operator +(#)".}

proc `+`*(this: LPoint4d, other: LVector4d): LPoint4d {.importcpp: "#.operator +(#)".}

proc `-`*(this: LPoint4d, other: LPoint4d): LVector4d {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint4d, other: LVector4d): LPoint4d {.importcpp: "#.operator -(#)".}

proc `*`*(this: LPoint4d, scalar: float64): LPoint4d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LPoint4d, scalar: float64): LPoint4d {.importcpp: "#.operator /(#)".}

proc normalized*(this: LPoint4d): LPoint4d {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LPoint4d, onto: LVecBase4d): LPoint4d {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc get_class_type*(_: typedesc[LPoint4d]): TypeHandle {.importcpp: "LPoint4d::get_class_type()", header: "lpoint4.h".}

proc initLPoint4i*(): LPoint4i {.importcpp: "LPoint4i()".}

proc initLPoint4i*(param0: LPoint4i): LPoint4i {.importcpp: "LPoint4i(#)".}

proc initLPoint4i*(copy: LVecBase3i, w: int): LPoint4i {.importcpp: "LPoint4i(#, #)".}

proc initLPoint4i*(copy: LVecBase4i): LPoint4i {.importcpp: "LPoint4i(#)".}

proc initLPoint4i*(fill_value: int): LPoint4i {.importcpp: "LPoint4i(#)".}

proc initLPoint4i*(x: int, y: int, z: int, w: int): LPoint4i {.importcpp: "LPoint4i(#, #, #, #)".}

proc zero*(_: typedesc[LPoint4i]): LPoint4i {.importcpp: "LPoint4i::zero()", header: "lpoint4.h".} ## \
## Returns a zero-length point.

proc unit_x*(_: typedesc[LPoint4i]): LPoint4i {.importcpp: "LPoint4i::unit_x()", header: "lpoint4.h".} ## \
## Returns a unit X point.

proc unit_y*(_: typedesc[LPoint4i]): LPoint4i {.importcpp: "LPoint4i::unit_y()", header: "lpoint4.h".} ## \
## Returns a unit Y point.

proc unit_z*(_: typedesc[LPoint4i]): LPoint4i {.importcpp: "LPoint4i::unit_z()", header: "lpoint4.h".} ## \
## Returns a unit Z point.

proc unit_w*(_: typedesc[LPoint4i]): LPoint4i {.importcpp: "LPoint4i::unit_w()", header: "lpoint4.h".} ## \
## Returns a unit W point.

proc get_xyz*(this: LPoint4i): LPoint3i {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

proc get_xy*(this: LPoint4i): LPoint2i {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

proc `-`*(this: LPoint4i): LPoint4i {.importcpp: "#.operator -()".}

proc `+`*(this: LPoint4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.operator +(#)".}

proc `+`*(this: LPoint4i, other: LVector4i): LPoint4i {.importcpp: "#.operator +(#)".}

proc `-`*(this: LPoint4i, other: LPoint4i): LVector4i {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint4i, other: LVector4i): LPoint4i {.importcpp: "#.operator -(#)".}

proc `*`*(this: LPoint4i, scalar: int): LPoint4i {.importcpp: "#.operator *(#)".}

proc `/`*(this: LPoint4i, scalar: int): LPoint4i {.importcpp: "#.operator /(#)".}

proc get_class_type*(_: typedesc[LPoint4i]): TypeHandle {.importcpp: "LPoint4i::get_class_type()", header: "lpoint4.h".}

proc initLMatrix3f*(): LMatrix3f {.importcpp: "LMatrix3f()".}

proc initLMatrix3f*(other: LMatrix3f): LMatrix3f {.importcpp: "LMatrix3f(#)".}

proc initLMatrix3f*(param0: LVecBase3f, param1: LVecBase3f, param2: LVecBase3f): LMatrix3f {.importcpp: "LMatrix3f(#, #, #)".} ## \
## Constructs the matrix from three individual rows.

proc initLMatrix3f*(param0: float32, param1: float32, param2: float32, param3: float32, param4: float32, param5: float32, param6: float32, param7: float32, param8: float32): LMatrix3f {.importcpp: "LMatrix3f(#, #, #, #, #, #, #, #, #)".}

proc fill*(this: LMatrix3f, fill_value: float32) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the matrix to the indicated fill_value.  This is of
## questionable value, but is sometimes useful when initializing to zero.

proc set*(this: LMatrix3f, e00: float32, e01: float32, e02: float32, e10: float32, e11: float32, e12: float32, e20: float32, e21: float32, e22: float32) {.importcpp: "#.set(#, #, #, #, #, #, #, #, #)".}

proc size*(_: typedesc[LMatrix3f]): int {.importcpp: "LMatrix3f::size()", header: "lmatrix3.h".} ## \
## Returns 3: the number of rows of a LMatrix3.

proc set_row*(this: LMatrix3f, row: int, v: LVecBase2f) {.importcpp: "#.set_row(#, #)".} ## \
## Replaces the indicated row of the matrix from a two-component vector,
## ignoring the last column.

proc set_row*(this: LMatrix3f, row: int, v: LVecBase3f) {.importcpp: "#.set_row(#, #)".} ## \
## Replaces the indicated row of the matrix from a three-component vector.

proc set_col*(this: LMatrix3f, col: int, v: LVecBase2f) {.importcpp: "#.set_col(#, #)".} ## \
## Replaces the indicated column of the matrix from a two-component vector,
## ignoring the last row.

proc set_col*(this: LMatrix3f, col: int, v: LVecBase3f) {.importcpp: "#.set_col(#, #)".} ## \
## Replaces the indicated column of the matrix from a three-component vector.

proc get_row*(this: LMatrix3f, result_vec: LVecBase3f, row: int) {.importcpp: "#.get_row(#, #)".} ## \
## Stores the indicated row of the matrix as a three-component vector.

proc get_row*(this: LMatrix3f, row: int): LVecBase3f {.importcpp: "#.get_row(#)".} ## \
## Returns the indicated row of the matrix as a three-component vector.

proc get_col*(this: LMatrix3f, col: int): LVecBase3f {.importcpp: "#.get_col(#)".} ## \
## Returns the indicated column of the matrix as a three-component vector.

proc get_row2*(this: LMatrix3f, row: int): LVecBase2f {.importcpp: "#.get_row2(#)".} ## \
## Returns the indicated row of the matrix as a two-component vector, ignoring
## the last column.

proc get_col2*(this: LMatrix3f, col: int): LVecBase2f {.importcpp: "#.get_col2(#)".} ## \
## Returns the indicated column of the matrix as a two-component vector,
## ignoring the last row.

proc is_nan*(this: LMatrix3f): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the matrix is not-a-number, false
## otherwise.

proc is_identity*(this: LMatrix3f): bool {.importcpp: "#.is_identity()".} ## \
## Returns true if this is (close enough to) the identity matrix, false
## otherwise.

proc get_cell*(this: LMatrix3f, row: int, col: int): float32 {.importcpp: "#.get_cell(#, #)".} ## \
## Returns a particular element of the matrix.

proc set_cell*(this: LMatrix3f, row: int, col: int, value: float32) {.importcpp: "#.set_cell(#, #, #)".} ## \
## Changes a particular element of the matrix.

proc get_data*(this: LMatrix3f) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the nine data elements in the matrix.
## The remaining elements occupy the next eight positions in row-major order.

proc get_num_components*(this: LMatrix3f): int {.importcpp: "#.get_num_components()".} ## \
## Returns the number of elements in the matrix, nine.

proc `<`*(this: LMatrix3f, other: LMatrix3f): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LMatrix3f, other: LMatrix3f): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LMatrix3f, other: LMatrix3f): bool {.importcpp: "#.operator !=(#)".}

proc compare_to*(this: LMatrix3f, other: LMatrix3f): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compare_to*(this: LMatrix3f, other: LMatrix3f, threshold: float32): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts matrices lexicographically, componentwise.  Returns a number less
## than 0 if this matrix sorts before the other one, greater than zero if it
## sorts after, 0 if they are equivalent (within the indicated tolerance).

proc get_hash*(this: LMatrix3f): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc get_hash*(this: LMatrix3f, threshold: float32): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc add_hash*(this: LMatrix3f, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc add_hash*(this: LMatrix3f, hash: clonglong, threshold: float32): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc xform*(this: LMatrix3f, v: LVecBase3f): LVecBase3f {.importcpp: "#.xform(#)".} ## \
## 3-component vector or point times matrix.

proc xform_point*(this: LMatrix3f, v: LVecBase2f): LVecBase2f {.importcpp: "#.xform_point(#)".} ## \
## The matrix transforms a 2-component point (including translation component)
## and returns the result.  This assumes the matrix is an affine transform.

proc xform_vec*(this: LMatrix3f, v: LVecBase2f): LVecBase2f {.importcpp: "#.xform_vec(#)".} ## \
## The matrix transforms a 2-component vector (without translation component)
## and returns the result.  This assumes the matrix is an affine transform.

proc xform_vec*(this: LMatrix3f, v: LVecBase3f): LVecBase3f {.importcpp: "#.xform_vec(#)".} ## \
## The matrix transforms a 3-component vector and returns the result.  This
## assumes the matrix is an orthonormal transform.
##
## In practice, this is the same computation as xform().

proc xform_vec_general*(this: LMatrix3f, v: LVecBase3f): LVecBase3f {.importcpp: "#.xform_vec_general(#)".} ## \
## The matrix transforms a 3-component vector (without translation component)
## and returns the result, as a fully general operation.

proc xform_in_place*(this: LMatrix3f, v: LVecBase3f) {.importcpp: "#.xform_in_place(#)".} ## \
## 3-component vector or point times matrix.

proc xform_point_in_place*(this: LMatrix3f, v: LVecBase2f) {.importcpp: "#.xform_point_in_place(#)".} ## \
## The matrix transforms a 2-component point (including translation
## component).  This assumes the matrix is an affine transform.

proc xform_vec_in_place*(this: LMatrix3f, v: LVecBase2f) {.importcpp: "#.xform_vec_in_place(#)".} ## \
## The matrix transforms a 2-component vector (without translation component).
## This assumes the matrix is an affine transform.

proc xform_vec_in_place*(this: LMatrix3f, v: LVecBase3f) {.importcpp: "#.xform_vec_in_place(#)".} ## \
## The matrix transforms a 3-component vector.  This assumes the matrix is an
## orthonormal transform.
##
## In practice, this is the same computation as xform().

proc xform_vec_general_in_place*(this: LMatrix3f, v: LVecBase3f) {.importcpp: "#.xform_vec_general_in_place(#)".} ## \
## The matrix transforms a 3-component vector (without translation component),
## as a fully general operation.

proc multiply*(this: LMatrix3f, other1: LMatrix3f, other2: LMatrix3f) {.importcpp: "#.multiply(#, #)".} ## \
## this = other1 * other2

proc `*`*(this: LMatrix3f, other: LMatrix3f): LMatrix3f {.importcpp: "#.operator *(#)".}

proc `*`*(this: LMatrix3f, scalar: float32): LMatrix3f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LMatrix3f, scalar: float32): LMatrix3f {.importcpp: "#.operator /(#)".}

proc `+=`*(this: LMatrix3f, other: LMatrix3f): LMatrix3f {.importcpp: "#.operator +=(#)".} ## \
## Performs a memberwise addition between two matrices.

proc `-=`*(this: LMatrix3f, other: LMatrix3f): LMatrix3f {.importcpp: "#.operator -=(#)".} ## \
## Performs a memberwise subtraction between two matrices.

proc `*=`*(this: LMatrix3f, other: LMatrix3f): LMatrix3f {.importcpp: "#.operator *=(#)".}

proc `*=`*(this: LMatrix3f, scalar: float32): LMatrix3f {.importcpp: "#.operator *=(#)".} ## \
## Performs a memberwise scale.

proc `/=`*(this: LMatrix3f, scalar: float32): LMatrix3f {.importcpp: "#.operator /=(#)".} ## \
## Performs a memberwise scale.

proc componentwise_mult*(this: LMatrix3f, other: LMatrix3f) {.importcpp: "#.componentwise_mult(#)".}

proc determinant*(this: LMatrix3f): float32 {.importcpp: "#.determinant()".} ## \
## Returns the determinant of the matrix.

proc transpose_from*(this: LMatrix3f, other: LMatrix3f) {.importcpp: "#.transpose_from(#)".}

proc transpose_in_place*(this: LMatrix3f) {.importcpp: "#.transpose_in_place()".}

proc invert_from*(this: LMatrix3f, other: LMatrix3f): bool {.importcpp: "#.invert_from(#)".} ## \
## Computes the inverse of the other matrix, and stores the result in this
## matrix.  This is a fully general operation and makes no assumptions about
## the type of transform represented by the matrix.
##
## The other matrix must be a different object than this matrix.  However, if
## you need to invert a matrix in place, see invert_in_place.
##
## The return value is true if the matrix was successfully inverted, false if
## there was a singularity.

proc invert_in_place*(this: LMatrix3f): bool {.importcpp: "#.invert_in_place()".} ## \
## Inverts the current matrix.  Returns true if the inverse is successful,
## false if the matrix was singular.

proc invert_transpose_from*(this: LMatrix3f, other: LMatrix3f): bool {.importcpp: "#.invert_transpose_from(#)".} ## \
## Simultaneously computes the inverse of the indicated matrix, and then the
## transpose of that inverse.

proc invert_transpose_from*(this: LMatrix3f, other: LMatrix4f): bool {.importcpp: "#.invert_transpose_from(#)".} ## \
## Simultaneously computes the inverse of the indicated matrix, and then the
## transpose of that inverse.

proc ident_mat*(_: typedesc[LMatrix3f]): LMatrix3f {.importcpp: "LMatrix3f::ident_mat()", header: "lmatrix3.h".} ## \
## Returns an identity matrix.
##
## This function definition must appear first, since some inline functions
## below take advantage of it.

proc set_translate_mat*(this: LMatrix3f, trans: LVecBase2f) {.importcpp: "#.set_translate_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated translation.

proc set_rotate_mat*(this: LMatrix3f, angle: float32) {.importcpp: "#.set_rotate_mat(#)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise.

proc set_rotate_mat*(this: LMatrix3f, angle: float32, axis: LVecBase3f, cs: CoordinateSystem) {.importcpp: "#.set_rotate_mat(#, #, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc set_rotate_mat*(this: LMatrix3f, angle: float32, axis: LVecBase3f) {.importcpp: "#.set_rotate_mat(#, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc set_scale_mat*(this: LMatrix3f, scale: LVecBase2f) {.importcpp: "#.set_scale_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated scale in each of the two
## axes.

proc set_scale_mat*(this: LMatrix3f, scale: LVecBase3f) {.importcpp: "#.set_scale_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated scale in each of the
## three axes.

proc translate_mat*(_: typedesc[LMatrix3f], trans: LVecBase2f): LMatrix3f {.importcpp: "LMatrix3f::translate_mat(#)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated translation.

proc translate_mat*(_: typedesc[LMatrix3f], tx: float32, ty: float32): LMatrix3f {.importcpp: "LMatrix3f::translate_mat(#, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated translation.

proc rotate_mat*(_: typedesc[LMatrix3f], angle: float32): LMatrix3f {.importcpp: "LMatrix3f::rotate_mat(#)", header: "lmatrix3.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise.

proc rotate_mat*(_: typedesc[LMatrix3f], angle: float32, axis: LVecBase3f, cs: CoordinateSystem): LMatrix3f {.importcpp: "LMatrix3f::rotate_mat(#, #, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc rotate_mat*(_: typedesc[LMatrix3f], angle: float32, axis: LVecBase3f): LMatrix3f {.importcpp: "LMatrix3f::rotate_mat(#, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc scale_mat*(_: typedesc[LMatrix3f], scale: LVecBase2f): LMatrix3f {.importcpp: "LMatrix3f::scale_mat(#)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated scale in each of the two axes.

proc scale_mat*(_: typedesc[LMatrix3f], scale: LVecBase3f): LMatrix3f {.importcpp: "LMatrix3f::scale_mat(#)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated scale in each of the three
## axes.

proc scale_mat*(_: typedesc[LMatrix3f], sx: float32, sy: float32): LMatrix3f {.importcpp: "LMatrix3f::scale_mat(#, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated scale in each of the two axes.

proc scale_mat*(_: typedesc[LMatrix3f], sx: float32, sy: float32, sz: float32): LMatrix3f {.importcpp: "LMatrix3f::scale_mat(#, #, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated scale in each of the three
## axes.

proc set_rotate_mat_normaxis*(this: LMatrix3f, angle: float32, axis: LVecBase3f, cs: CoordinateSystem) {.importcpp: "#.set_rotate_mat_normaxis(#, #, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## normalized.

proc set_rotate_mat_normaxis*(this: LMatrix3f, angle: float32, axis: LVecBase3f) {.importcpp: "#.set_rotate_mat_normaxis(#, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## normalized.

proc rotate_mat_normaxis*(_: typedesc[LMatrix3f], angle: float32, axis: LVecBase3f, cs: CoordinateSystem): LMatrix3f {.importcpp: "LMatrix3f::rotate_mat_normaxis(#, #, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## normalized.

proc rotate_mat_normaxis*(_: typedesc[LMatrix3f], angle: float32, axis: LVecBase3f): LMatrix3f {.importcpp: "LMatrix3f::rotate_mat_normaxis(#, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## normalized.

proc set_shear_mat*(this: LMatrix3f, shear: LVecBase3f, cs: CoordinateSystem) {.importcpp: "#.set_shear_mat(#, #)".} ## \
## Fills mat with a matrix that applies the indicated shear in each of the
## three planes.

proc set_shear_mat*(this: LMatrix3f, shear: LVecBase3f) {.importcpp: "#.set_shear_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated shear in each of the
## three planes.

proc shear_mat*(_: typedesc[LMatrix3f], shear: LVecBase3f, cs: CoordinateSystem): LMatrix3f {.importcpp: "LMatrix3f::shear_mat(#, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shear_mat*(_: typedesc[LMatrix3f], shear: LVecBase3f): LMatrix3f {.importcpp: "LMatrix3f::shear_mat(#)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shear_mat*(_: typedesc[LMatrix3f], shxy: float32, shxz: float32, shyz: float32, cs: CoordinateSystem): LMatrix3f {.importcpp: "LMatrix3f::shear_mat(#, #, #, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shear_mat*(_: typedesc[LMatrix3f], shxy: float32, shxz: float32, shyz: float32): LMatrix3f {.importcpp: "LMatrix3f::shear_mat(#, #, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc set_scale_shear_mat*(this: LMatrix3f, scale: LVecBase3f, shear: LVecBase3f, cs: CoordinateSystem) {.importcpp: "#.set_scale_shear_mat(#, #, #)".} ## \
## Fills mat with a matrix that applies the indicated scale and shear.

proc set_scale_shear_mat*(this: LMatrix3f, scale: LVecBase3f, shear: LVecBase3f) {.importcpp: "#.set_scale_shear_mat(#, #)".} ## \
## Fills mat with a matrix that applies the indicated scale and shear.

proc scale_shear_mat*(_: typedesc[LMatrix3f], scale: LVecBase3f, shear: LVecBase3f, cs: CoordinateSystem): LMatrix3f {.importcpp: "LMatrix3f::scale_shear_mat(#, #, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scale_shear_mat*(_: typedesc[LMatrix3f], scale: LVecBase3f, shear: LVecBase3f): LMatrix3f {.importcpp: "LMatrix3f::scale_shear_mat(#, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scale_shear_mat*(_: typedesc[LMatrix3f], sx: float32, sy: float32, sz: float32, shxy: float32, shxz: float32, shyz: float32, cs: CoordinateSystem): LMatrix3f {.importcpp: "LMatrix3f::scale_shear_mat(#, #, #, #, #, #, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scale_shear_mat*(_: typedesc[LMatrix3f], sx: float32, sy: float32, sz: float32, shxy: float32, shxz: float32, shyz: float32): LMatrix3f {.importcpp: "LMatrix3f::scale_shear_mat(#, #, #, #, #, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc convert_mat*(_: typedesc[LMatrix3f], `from`: CoordinateSystem, to: CoordinateSystem): LMatrix3f {.importcpp: "LMatrix3f::convert_mat(#, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that transforms from the indicated coordinate system to
## the indicated coordinate system.

proc almost_equal*(this: LMatrix3f, other: LMatrix3f): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two matrices are memberwise equal within a default
## tolerance based on the numeric type.

proc almost_equal*(this: LMatrix3f, other: LMatrix3f, threshold: float32): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two matrices are memberwise equal within a specified
## tolerance.

proc output*(this: LMatrix3f, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: LMatrix3f, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: LMatrix3f, `out`: ostream) {.importcpp: "#.write(#)".}

proc write_datagram_fixed*(this: LMatrix3f, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the matrix to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the matrix, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc read_datagram_fixed*(this: LMatrix3f, scan: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the matrix from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc write_datagram*(this: LMatrix3f, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the matrix to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the matrix using the standard width
## setting, especially when you are writing a bam file.

proc read_datagram*(this: LMatrix3f, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the matrix from the Datagram using get_stdfloat().

proc get_class_type*(_: typedesc[LMatrix3f]): TypeHandle {.importcpp: "LMatrix3f::get_class_type()", header: "lmatrix3.h".}

proc transpose*(a: LMatrix3d): LMatrix3d {.importcpp: "transpose(#)".}

proc transpose*(a: LMatrix3f): LMatrix3f {.importcpp: "transpose(#)".}

proc transpose*(a: LMatrix4d): LMatrix4d {.importcpp: "transpose(#)".}

proc transpose*(a: LMatrix4f): LMatrix4f {.importcpp: "transpose(#)".}

proc invert*(a: LMatrix3d): LMatrix3d {.importcpp: "invert(#)".}

proc invert*(a: LMatrix3f): LMatrix3f {.importcpp: "invert(#)".}

proc invert*(a: LMatrix4d): LMatrix4d {.importcpp: "invert(#)".}

proc invert*(a: LMatrix4f): LMatrix4f {.importcpp: "invert(#)".}

proc invert*(a: LQuaterniond): LQuaterniond {.importcpp: "invert(#)".}

proc invert*(a: LQuaternionf): LQuaternionf {.importcpp: "invert(#)".}

proc initLMatrix4f*(): LMatrix4f {.importcpp: "LMatrix4f()".}

proc initLMatrix4f*(upper3: LMatrix3f): LMatrix4f {.importcpp: "LMatrix4f(#)".} ## \
## Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
## translation component.

proc initLMatrix4f*(upper3: LMatrix3f, trans: LVecBase3f): LMatrix4f {.importcpp: "LMatrix4f(#, #)".}

proc initLMatrix4f*(other: LMatrix4f): LMatrix4f {.importcpp: "LMatrix4f(#)".}

proc initLMatrix4f*(param0: LVecBase4f, param1: LVecBase4f, param2: LVecBase4f, param3: LVecBase4f): LMatrix4f {.importcpp: "LMatrix4f(#, #, #, #)".} ## \
## Constructs the matrix from four individual rows.

proc initLMatrix4f*(other: UnalignedLMatrix4f): LMatrix4f {.importcpp: "LMatrix4f(#)".}

proc initLMatrix4f*(param0: float32, param1: float32, param2: float32, param3: float32, param4: float32, param5: float32, param6: float32, param7: float32, param8: float32, param9: float32, param10: float32, param11: float32, param12: float32, param13: float32, param14: float32, param15: float32): LMatrix4f {.importcpp: "LMatrix4f(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".}

proc fill*(this: LMatrix4f, fill_value: float32) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the matrix to the indicated fill_value.  This is of
## questionable value, but is sometimes useful when initializing to zero.

proc set*(this: LMatrix4f, e00: float32, e01: float32, e02: float32, e03: float32, e10: float32, e11: float32, e12: float32, e13: float32, e20: float32, e21: float32, e22: float32, e23: float32, e30: float32, e31: float32, e32: float32, e33: float32) {.importcpp: "#.set(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".}

proc set_upper_3*(this: LMatrix4f, upper3: LMatrix3f) {.importcpp: "#.set_upper_3(#)".} ## \
## Get and set the upper 3x3 rotation matrix.

proc get_upper_3*(this: LMatrix4f): LMatrix3f {.importcpp: "#.get_upper_3()".} ## \
## Retrieves the upper 3x3 submatrix.

proc size*(_: typedesc[LMatrix4f]): int {.importcpp: "LMatrix4f::size()", header: "lmatrix4.h".} ## \
## Returns 4: the number of rows of a LMatrix4.

proc set_row*(this: LMatrix4f, row: int, v: LVecBase3f) {.importcpp: "#.set_row(#, #)".} ## \
## Replaces the indicated row of the matrix with the indicated 3-component
## vector, ignoring the last column.

proc set_row*(this: LMatrix4f, row: int, v: LVecBase4f) {.importcpp: "#.set_row(#, #)".} ## \
## Replaces the indicated row of the matrix.

proc set_col*(this: LMatrix4f, col: int, v: LVecBase3f) {.importcpp: "#.set_col(#, #)".} ## \
## Replaces the indicated column of the matrix with the indicated 3-component
## vector, ignoring the last row.

proc set_col*(this: LMatrix4f, col: int, v: LVecBase4f) {.importcpp: "#.set_col(#, #)".} ## \
## Replaces the indicated column of the matrix.

proc get_row*(this: LMatrix4f, result_vec: LVecBase4f, row: int) {.importcpp: "#.get_row(#, #)".} ## \
## Stores the indicated row of the matrix as a 4-component vector.

proc get_row*(this: LMatrix4f, row: int): LVecBase4f {.importcpp: "#.get_row(#)".} ## \
## Retrieves the indicated row of the matrix as a 4-component vector.

proc get_col*(this: LMatrix4f, col: int): LVecBase4f {.importcpp: "#.get_col(#)".} ## \
## Retrieves the indicated column of the matrix as a 4-component vector.

proc get_row3*(this: LMatrix4f, result_vec: LVecBase3f, row: int) {.importcpp: "#.get_row3(#, #)".} ## \
## Stores the row column of the matrix as a 3-component vector, ignoring the
## last column.

proc get_row3*(this: LMatrix4f, row: int): LVecBase3f {.importcpp: "#.get_row3(#)".} ## \
## Retrieves the row column of the matrix as a 3-component vector, ignoring
## the last column.

proc get_col3*(this: LMatrix4f, col: int): LVecBase3f {.importcpp: "#.get_col3(#)".} ## \
## Retrieves the indicated column of the matrix as a 3-component vector,
## ignoring the last row.

proc is_nan*(this: LMatrix4f): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the matrix is not-a-number, false
## otherwise.

proc is_identity*(this: LMatrix4f): bool {.importcpp: "#.is_identity()".} ## \
## Returns true if this is (close enough to) the identity matrix, false
## otherwise.

proc get_cell*(this: LMatrix4f, row: int, col: int): float32 {.importcpp: "#.get_cell(#, #)".} ## \
## Returns a particular element of the matrix.

proc set_cell*(this: LMatrix4f, row: int, col: int, value: float32) {.importcpp: "#.set_cell(#, #, #)".} ## \
## Changes a particular element of the matrix.

proc get_data*(this: LMatrix4f) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the nine data elements in the matrix.
## The remaining elements occupy the next eight positions in row-major order.

proc get_num_components*(this: LMatrix4f): int {.importcpp: "#.get_num_components()".} ## \
## Returns the number of elements in the matrix, 16.

proc begin*(this: LMatrix4f) {.importcpp: "#.begin()".} ## \
## Returns an iterator that may be used to traverse the elements of the
## matrix, STL-style.

proc `<`*(this: LMatrix4f, other: LMatrix4f): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LMatrix4f, other: LMatrix4f): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LMatrix4f, other: LMatrix4f): bool {.importcpp: "#.operator !=(#)".}

proc compare_to*(this: LMatrix4f, other: LMatrix4f): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compare_to*(this: LMatrix4f, other: LMatrix4f, threshold: float32): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts matrices lexicographically, componentwise.  Returns a number less
## than 0 if this matrix sorts before the other one, greater than zero if it
## sorts after, 0 if they are equivalent (within the indicated tolerance).

proc get_hash*(this: LMatrix4f): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc get_hash*(this: LMatrix4f, threshold: float32): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc add_hash*(this: LMatrix4f, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc add_hash*(this: LMatrix4f, hash: clonglong, threshold: float32): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc xform*(this: LMatrix4f, v: LVecBase4f): LVecBase4f {.importcpp: "#.xform(#)".} ## \
## 4-component vector or point times matrix.  This is a fully general
## operation.

proc xform_point*(this: LMatrix4f, v: LVecBase3f): LVecBase3f {.importcpp: "#.xform_point(#)".} ## \
## The matrix transforms a 3-component point (including translation component)
## and returns the result.  This assumes the matrix is an affine transform.

proc xform_point_general*(this: LMatrix4f, v: LVecBase3f): LVecBase3f {.importcpp: "#.xform_point_general(#)".} ## \
## The matrix transforms a 3-component point (including translation component)
## and returns the result, as a fully general operation.

proc xform_vec*(this: LMatrix4f, v: LVecBase3f): LVecBase3f {.importcpp: "#.xform_vec(#)".} ## \
## The matrix transforms a 3-component vector (without translation component)
## and returns the result.  This assumes the matrix is an orthonormal
## transform.

proc xform_vec_general*(this: LMatrix4f, v: LVecBase3f): LVecBase3f {.importcpp: "#.xform_vec_general(#)".} ## \
## The matrix transforms a 3-component vector (without translation component)
## and returns the result, as a fully general operation.

proc xform_in_place*(this: LMatrix4f, v: LVecBase4f) {.importcpp: "#.xform_in_place(#)".} ## \
## 4-component vector or point times matrix.  This is a fully general
## operation.

proc xform_point_in_place*(this: LMatrix4f, v: LVecBase3f) {.importcpp: "#.xform_point_in_place(#)".} ## \
## The matrix transforms a 3-component point (including translation
## component).  This assumes the matrix is an affine transform.

proc xform_point_general_in_place*(this: LMatrix4f, v: LVecBase3f) {.importcpp: "#.xform_point_general_in_place(#)".} ## \
## The matrix transforms a 3-component point (including translation
## component), as a fully general operation.

proc xform_vec_in_place*(this: LMatrix4f, v: LVecBase3f) {.importcpp: "#.xform_vec_in_place(#)".} ## \
## The matrix transforms a 3-component vector (without translation component).
## This assumes the matrix is an orthonormal transform.

proc xform_vec_general_in_place*(this: LMatrix4f, v: LVecBase3f) {.importcpp: "#.xform_vec_general_in_place(#)".} ## \
## The matrix transforms a 3-component vector (without translation component),
## as a fully general operation.

proc multiply*(this: LMatrix4f, other1: LMatrix4f, other2: LMatrix4f) {.importcpp: "#.multiply(#, #)".} ## \
## this = other1 * other2

proc `*`*(this: LMatrix4f, other: LMatrix4f): LMatrix4f {.importcpp: "#.operator *(#)".}

proc `*`*(this: LMatrix4f, scalar: float32): LMatrix4f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LMatrix4f, scalar: float32): LMatrix4f {.importcpp: "#.operator /(#)".}

proc `+=`*(this: LMatrix4f, other: LMatrix4f): LMatrix4f {.importcpp: "#.operator +=(#)".} ## \
## Performs a memberwise addition between two matrices.

proc `-=`*(this: LMatrix4f, other: LMatrix4f): LMatrix4f {.importcpp: "#.operator -=(#)".} ## \
## Performs a memberwise subtraction between two matrices.

proc `*=`*(this: LMatrix4f, other: LMatrix4f): LMatrix4f {.importcpp: "#.operator *=(#)".}

proc `*=`*(this: LMatrix4f, scalar: float32): LMatrix4f {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: LMatrix4f, scalar: float32): LMatrix4f {.importcpp: "#.operator /=(#)".}

proc componentwise_mult*(this: LMatrix4f, other: LMatrix4f) {.importcpp: "#.componentwise_mult(#)".}

proc transpose_from*(this: LMatrix4f, other: LMatrix4f) {.importcpp: "#.transpose_from(#)".}

proc transpose_in_place*(this: LMatrix4f) {.importcpp: "#.transpose_in_place()".}

proc invert_from*(this: LMatrix4f, other: LMatrix4f): bool {.importcpp: "#.invert_from(#)".} ## \
## Computes the inverse of the other matrix, and stores the result in this
## matrix.  This is a fully general operation and makes no assumptions about
## the type of transform represented by the matrix.
##
## The other matrix must be a different object than this matrix.  However, if
## you need to invert a matrix in place, see invert_in_place.
##
## The return value is true if the matrix was successfully inverted, false if
## the was a singularity.

proc invert_affine_from*(this: LMatrix4f, other: LMatrix4f): bool {.importcpp: "#.invert_affine_from(#)".} ## \
## bugbug: we could optimize this for rotationscaletranslation matrices
## (transpose upper 3x3 and take negative of translation component)

proc invert_in_place*(this: LMatrix4f): bool {.importcpp: "#.invert_in_place()".} ## \
## Inverts the current matrix.  Returns true if the inverse is successful,
## false if the matrix was singular.

proc accumulate*(this: LMatrix4f, other: LMatrix4f, weight: float32) {.importcpp: "#.accumulate(#, #)".} ## \
## Computes `(*this) += other * weight`.

proc ident_mat*(_: typedesc[LMatrix4f]): LMatrix4f {.importcpp: "LMatrix4f::ident_mat()", header: "lmatrix4.h".} ## \
## Returns an identity matrix.
##
## This function definition must appear first, since some inline functions
## below take advantage of it.

proc ones_mat*(_: typedesc[LMatrix4f]): LMatrix4f {.importcpp: "LMatrix4f::ones_mat()", header: "lmatrix4.h".} ## \
## Returns an matrix filled with ones.

proc zeros_mat*(_: typedesc[LMatrix4f]): LMatrix4f {.importcpp: "LMatrix4f::zeros_mat()", header: "lmatrix4.h".} ## \
## Returns an matrix filled with zeros.

proc set_translate_mat*(this: LMatrix4f, trans: LVecBase3f) {.importcpp: "#.set_translate_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated translation.

proc set_rotate_mat*(this: LMatrix4f, angle: float32, axis: LVecBase3f, cs: CoordinateSystem) {.importcpp: "#.set_rotate_mat(#, #, #)".} ## \
## Sets mat to a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc set_rotate_mat*(this: LMatrix4f, angle: float32, axis: LVecBase3f) {.importcpp: "#.set_rotate_mat(#, #)".} ## \
## Sets mat to a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc set_rotate_mat_normaxis*(this: LMatrix4f, angle: float32, axis: LVecBase3f, cs: CoordinateSystem) {.importcpp: "#.set_rotate_mat_normaxis(#, #, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## prenormalized.

proc set_rotate_mat_normaxis*(this: LMatrix4f, angle: float32, axis: LVecBase3f) {.importcpp: "#.set_rotate_mat_normaxis(#, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## prenormalized.

proc set_scale_mat*(this: LMatrix4f, scale: LVecBase3f) {.importcpp: "#.set_scale_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated scale in each of the
## three axes.

proc set_shear_mat*(this: LMatrix4f, shear: LVecBase3f, cs: CoordinateSystem) {.importcpp: "#.set_shear_mat(#, #)".} ## \
## Fills mat with a matrix that applies the indicated shear in each of the
## three planes.

proc set_shear_mat*(this: LMatrix4f, shear: LVecBase3f) {.importcpp: "#.set_shear_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated shear in each of the
## three planes.

proc set_scale_shear_mat*(this: LMatrix4f, scale: LVecBase3f, shear: LVecBase3f, cs: CoordinateSystem) {.importcpp: "#.set_scale_shear_mat(#, #, #)".} ## \
## Fills mat with a matrix that applies the indicated scale and shear.

proc set_scale_shear_mat*(this: LMatrix4f, scale: LVecBase3f, shear: LVecBase3f) {.importcpp: "#.set_scale_shear_mat(#, #)".} ## \
## Fills mat with a matrix that applies the indicated scale and shear.

proc translate_mat*(_: typedesc[LMatrix4f], trans: LVecBase3f): LMatrix4f {.importcpp: "LMatrix4f::translate_mat(#)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated translation.

proc translate_mat*(_: typedesc[LMatrix4f], tx: float32, ty: float32, tz: float32): LMatrix4f {.importcpp: "LMatrix4f::translate_mat(#, #, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated translation.

proc rotate_mat*(_: typedesc[LMatrix4f], angle: float32, axis: LVecBase3f, cs: CoordinateSystem): LMatrix4f {.importcpp: "LMatrix4f::rotate_mat(#, #, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc rotate_mat*(_: typedesc[LMatrix4f], angle: float32, axis: LVecBase3f): LMatrix4f {.importcpp: "LMatrix4f::rotate_mat(#, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc rotate_mat_normaxis*(_: typedesc[LMatrix4f], angle: float32, axis: LVecBase3f, cs: CoordinateSystem): LMatrix4f {.importcpp: "LMatrix4f::rotate_mat_normaxis(#, #, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## prenormalized.

proc rotate_mat_normaxis*(_: typedesc[LMatrix4f], angle: float32, axis: LVecBase3f): LMatrix4f {.importcpp: "LMatrix4f::rotate_mat_normaxis(#, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## prenormalized.

proc scale_mat*(_: typedesc[LMatrix4f], scale: LVecBase3f): LMatrix4f {.importcpp: "LMatrix4f::scale_mat(#)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated scale in each of the three
## axes.

proc scale_mat*(_: typedesc[LMatrix4f], scale: float32): LMatrix4f {.importcpp: "LMatrix4f::scale_mat(#)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated uniform scale.

proc scale_mat*(_: typedesc[LMatrix4f], sx: float32, sy: float32, sz: float32): LMatrix4f {.importcpp: "LMatrix4f::scale_mat(#, #, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated scale in each of the three
## axes.

proc shear_mat*(_: typedesc[LMatrix4f], shear: LVecBase3f, cs: CoordinateSystem): LMatrix4f {.importcpp: "LMatrix4f::shear_mat(#, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shear_mat*(_: typedesc[LMatrix4f], shear: LVecBase3f): LMatrix4f {.importcpp: "LMatrix4f::shear_mat(#)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shear_mat*(_: typedesc[LMatrix4f], shxy: float32, shxz: float32, shyz: float32, cs: CoordinateSystem): LMatrix4f {.importcpp: "LMatrix4f::shear_mat(#, #, #, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shear_mat*(_: typedesc[LMatrix4f], shxy: float32, shxz: float32, shyz: float32): LMatrix4f {.importcpp: "LMatrix4f::shear_mat(#, #, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc scale_shear_mat*(_: typedesc[LMatrix4f], scale: LVecBase3f, shear: LVecBase3f, cs: CoordinateSystem): LMatrix4f {.importcpp: "LMatrix4f::scale_shear_mat(#, #, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scale_shear_mat*(_: typedesc[LMatrix4f], scale: LVecBase3f, shear: LVecBase3f): LMatrix4f {.importcpp: "LMatrix4f::scale_shear_mat(#, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scale_shear_mat*(_: typedesc[LMatrix4f], sx: float32, sy: float32, sz: float32, shxy: float32, shxz: float32, shyz: float32, cs: CoordinateSystem): LMatrix4f {.importcpp: "LMatrix4f::scale_shear_mat(#, #, #, #, #, #, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scale_shear_mat*(_: typedesc[LMatrix4f], sx: float32, sy: float32, sz: float32, shxy: float32, shxz: float32, shyz: float32): LMatrix4f {.importcpp: "LMatrix4f::scale_shear_mat(#, #, #, #, #, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc y_to_z_up_mat*(_: typedesc[LMatrix4f]): LMatrix4f {.importcpp: "LMatrix4f::y_to_z_up_mat()", header: "lmatrix4.h".} ## \
## Returns a matrix that transforms from the Y-up coordinate system to the
## Z-up coordinate system.

proc z_to_y_up_mat*(_: typedesc[LMatrix4f]): LMatrix4f {.importcpp: "LMatrix4f::z_to_y_up_mat()", header: "lmatrix4.h".} ## \
## Returns a matrix that transforms from the Y-up coordinate system to the
## Z-up coordinate system.

proc convert_mat*(_: typedesc[LMatrix4f], `from`: CoordinateSystem, to: CoordinateSystem): LMatrix4f {.importcpp: "LMatrix4f::convert_mat(#, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that transforms from the indicated coordinate system to
## the indicated coordinate system.

proc almost_equal*(this: LMatrix4f, other: LMatrix4f): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two matrices are memberwise equal within a default
## tolerance based on the numeric type.

proc almost_equal*(this: LMatrix4f, other: LMatrix4f, threshold: float32): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two matrices are memberwise equal within a specified
## tolerance.  This is faster than the equivalence operator as this doesn't
## have to guarantee that it is transitive.

proc output*(this: LMatrix4f, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: LMatrix4f, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: LMatrix4f, `out`: ostream) {.importcpp: "#.write(#)".}

proc write_datagram_fixed*(this: LMatrix4f, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the matrix to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the matrix, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc read_datagram_fixed*(this: LMatrix4f, scan: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the matrix from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc write_datagram*(this: LMatrix4f, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the matrix to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the matrix using the standard width
## setting, especially when you are writing a bam file.

proc read_datagram*(this: LMatrix4f, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the matrix from the Datagram using get_stdfloat().

proc get_class_type*(_: typedesc[LMatrix4f]): TypeHandle {.importcpp: "LMatrix4f::get_class_type()", header: "lmatrix4.h".}

proc initUnalignedLMatrix4f*(): UnalignedLMatrix4f {.importcpp: "UnalignedLMatrix4f()".}

proc initUnalignedLMatrix4f*(copy: LMatrix4f): UnalignedLMatrix4f {.importcpp: "UnalignedLMatrix4f(#)".}

proc initUnalignedLMatrix4f*(copy: UnalignedLMatrix4f): UnalignedLMatrix4f {.importcpp: "UnalignedLMatrix4f(#)".}

proc initUnalignedLMatrix4f*(e00: float32, e01: float32, e02: float32, e03: float32, e10: float32, e11: float32, e12: float32, e13: float32, e20: float32, e21: float32, e22: float32, e23: float32, e30: float32, e31: float32, e32: float32, e33: float32): UnalignedLMatrix4f {.importcpp: "UnalignedLMatrix4f(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".}

proc set*(this: UnalignedLMatrix4f, e00: float32, e01: float32, e02: float32, e03: float32, e10: float32, e11: float32, e12: float32, e13: float32, e20: float32, e21: float32, e22: float32, e23: float32, e30: float32, e31: float32, e32: float32, e33: float32) {.importcpp: "#.set(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".}

proc get_data*(this: UnalignedLMatrix4f) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the nine data elements in the matrix.
## The remaining elements occupy the next eight positions in row-major order.

proc get_num_components*(this: UnalignedLMatrix4f): int {.importcpp: "#.get_num_components()".} ## \
## Returns the number of elements in the matrix, sixteen.

proc `==`*(this: UnalignedLMatrix4f, other: UnalignedLMatrix4f): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: UnalignedLMatrix4f, other: UnalignedLMatrix4f): bool {.importcpp: "#.operator !=(#)".}

proc get_class_type*(_: typedesc[UnalignedLMatrix4f]): TypeHandle {.importcpp: "UnalignedLMatrix4f::get_class_type()", header: "unalignedLMatrix4f.h".}

proc initLMatrix3d*(): LMatrix3d {.importcpp: "LMatrix3d()".}

proc initLMatrix3d*(other: LMatrix3d): LMatrix3d {.importcpp: "LMatrix3d(#)".}

proc initLMatrix3d*(param0: LVecBase3d, param1: LVecBase3d, param2: LVecBase3d): LMatrix3d {.importcpp: "LMatrix3d(#, #, #)".} ## \
## Constructs the matrix from three individual rows.

proc initLMatrix3d*(param0: float64, param1: float64, param2: float64, param3: float64, param4: float64, param5: float64, param6: float64, param7: float64, param8: float64): LMatrix3d {.importcpp: "LMatrix3d(#, #, #, #, #, #, #, #, #)".}

proc fill*(this: LMatrix3d, fill_value: float64) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the matrix to the indicated fill_value.  This is of
## questionable value, but is sometimes useful when initializing to zero.

proc set*(this: LMatrix3d, e00: float64, e01: float64, e02: float64, e10: float64, e11: float64, e12: float64, e20: float64, e21: float64, e22: float64) {.importcpp: "#.set(#, #, #, #, #, #, #, #, #)".}

proc size*(_: typedesc[LMatrix3d]): int {.importcpp: "LMatrix3d::size()", header: "lmatrix3.h".} ## \
## Returns 3: the number of rows of a LMatrix3.

proc set_row*(this: LMatrix3d, row: int, v: LVecBase2d) {.importcpp: "#.set_row(#, #)".} ## \
## Replaces the indicated row of the matrix from a two-component vector,
## ignoring the last column.

proc set_row*(this: LMatrix3d, row: int, v: LVecBase3d) {.importcpp: "#.set_row(#, #)".} ## \
## Replaces the indicated row of the matrix from a three-component vector.

proc set_col*(this: LMatrix3d, col: int, v: LVecBase2d) {.importcpp: "#.set_col(#, #)".} ## \
## Replaces the indicated column of the matrix from a two-component vector,
## ignoring the last row.

proc set_col*(this: LMatrix3d, col: int, v: LVecBase3d) {.importcpp: "#.set_col(#, #)".} ## \
## Replaces the indicated column of the matrix from a three-component vector.

proc get_row*(this: LMatrix3d, result_vec: LVecBase3d, row: int) {.importcpp: "#.get_row(#, #)".} ## \
## Stores the indicated row of the matrix as a three-component vector.

proc get_row*(this: LMatrix3d, row: int): LVecBase3d {.importcpp: "#.get_row(#)".} ## \
## Returns the indicated row of the matrix as a three-component vector.

proc get_col*(this: LMatrix3d, col: int): LVecBase3d {.importcpp: "#.get_col(#)".} ## \
## Returns the indicated column of the matrix as a three-component vector.

proc get_row2*(this: LMatrix3d, row: int): LVecBase2d {.importcpp: "#.get_row2(#)".} ## \
## Returns the indicated row of the matrix as a two-component vector, ignoring
## the last column.

proc get_col2*(this: LMatrix3d, col: int): LVecBase2d {.importcpp: "#.get_col2(#)".} ## \
## Returns the indicated column of the matrix as a two-component vector,
## ignoring the last row.

proc is_nan*(this: LMatrix3d): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the matrix is not-a-number, false
## otherwise.

proc is_identity*(this: LMatrix3d): bool {.importcpp: "#.is_identity()".} ## \
## Returns true if this is (close enough to) the identity matrix, false
## otherwise.

proc get_cell*(this: LMatrix3d, row: int, col: int): float64 {.importcpp: "#.get_cell(#, #)".} ## \
## Returns a particular element of the matrix.

proc set_cell*(this: LMatrix3d, row: int, col: int, value: float64) {.importcpp: "#.set_cell(#, #, #)".} ## \
## Changes a particular element of the matrix.

proc get_data*(this: LMatrix3d) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the nine data elements in the matrix.
## The remaining elements occupy the next eight positions in row-major order.

proc get_num_components*(this: LMatrix3d): int {.importcpp: "#.get_num_components()".} ## \
## Returns the number of elements in the matrix, nine.

proc `<`*(this: LMatrix3d, other: LMatrix3d): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LMatrix3d, other: LMatrix3d): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LMatrix3d, other: LMatrix3d): bool {.importcpp: "#.operator !=(#)".}

proc compare_to*(this: LMatrix3d, other: LMatrix3d): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compare_to*(this: LMatrix3d, other: LMatrix3d, threshold: float64): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts matrices lexicographically, componentwise.  Returns a number less
## than 0 if this matrix sorts before the other one, greater than zero if it
## sorts after, 0 if they are equivalent (within the indicated tolerance).

proc get_hash*(this: LMatrix3d): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc get_hash*(this: LMatrix3d, threshold: float64): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc add_hash*(this: LMatrix3d, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc add_hash*(this: LMatrix3d, hash: clonglong, threshold: float64): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc xform*(this: LMatrix3d, v: LVecBase3d): LVecBase3d {.importcpp: "#.xform(#)".} ## \
## 3-component vector or point times matrix.

proc xform_point*(this: LMatrix3d, v: LVecBase2d): LVecBase2d {.importcpp: "#.xform_point(#)".} ## \
## The matrix transforms a 2-component point (including translation component)
## and returns the result.  This assumes the matrix is an affine transform.

proc xform_vec*(this: LMatrix3d, v: LVecBase2d): LVecBase2d {.importcpp: "#.xform_vec(#)".} ## \
## The matrix transforms a 2-component vector (without translation component)
## and returns the result.  This assumes the matrix is an affine transform.

proc xform_vec*(this: LMatrix3d, v: LVecBase3d): LVecBase3d {.importcpp: "#.xform_vec(#)".} ## \
## The matrix transforms a 3-component vector and returns the result.  This
## assumes the matrix is an orthonormal transform.
##
## In practice, this is the same computation as xform().

proc xform_vec_general*(this: LMatrix3d, v: LVecBase3d): LVecBase3d {.importcpp: "#.xform_vec_general(#)".} ## \
## The matrix transforms a 3-component vector (without translation component)
## and returns the result, as a fully general operation.

proc xform_in_place*(this: LMatrix3d, v: LVecBase3d) {.importcpp: "#.xform_in_place(#)".} ## \
## 3-component vector or point times matrix.

proc xform_point_in_place*(this: LMatrix3d, v: LVecBase2d) {.importcpp: "#.xform_point_in_place(#)".} ## \
## The matrix transforms a 2-component point (including translation
## component).  This assumes the matrix is an affine transform.

proc xform_vec_in_place*(this: LMatrix3d, v: LVecBase2d) {.importcpp: "#.xform_vec_in_place(#)".} ## \
## The matrix transforms a 2-component vector (without translation component).
## This assumes the matrix is an affine transform.

proc xform_vec_in_place*(this: LMatrix3d, v: LVecBase3d) {.importcpp: "#.xform_vec_in_place(#)".} ## \
## The matrix transforms a 3-component vector.  This assumes the matrix is an
## orthonormal transform.
##
## In practice, this is the same computation as xform().

proc xform_vec_general_in_place*(this: LMatrix3d, v: LVecBase3d) {.importcpp: "#.xform_vec_general_in_place(#)".} ## \
## The matrix transforms a 3-component vector (without translation component),
## as a fully general operation.

proc multiply*(this: LMatrix3d, other1: LMatrix3d, other2: LMatrix3d) {.importcpp: "#.multiply(#, #)".} ## \
## this = other1 * other2

proc `*`*(this: LMatrix3d, other: LMatrix3d): LMatrix3d {.importcpp: "#.operator *(#)".}

proc `*`*(this: LMatrix3d, scalar: float64): LMatrix3d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LMatrix3d, scalar: float64): LMatrix3d {.importcpp: "#.operator /(#)".}

proc `+=`*(this: LMatrix3d, other: LMatrix3d): LMatrix3d {.importcpp: "#.operator +=(#)".} ## \
## Performs a memberwise addition between two matrices.

proc `-=`*(this: LMatrix3d, other: LMatrix3d): LMatrix3d {.importcpp: "#.operator -=(#)".} ## \
## Performs a memberwise subtraction between two matrices.

proc `*=`*(this: LMatrix3d, other: LMatrix3d): LMatrix3d {.importcpp: "#.operator *=(#)".}

proc `*=`*(this: LMatrix3d, scalar: float64): LMatrix3d {.importcpp: "#.operator *=(#)".} ## \
## Performs a memberwise scale.

proc `/=`*(this: LMatrix3d, scalar: float64): LMatrix3d {.importcpp: "#.operator /=(#)".} ## \
## Performs a memberwise scale.

proc componentwise_mult*(this: LMatrix3d, other: LMatrix3d) {.importcpp: "#.componentwise_mult(#)".}

proc determinant*(this: LMatrix3d): float64 {.importcpp: "#.determinant()".} ## \
## Returns the determinant of the matrix.

proc transpose_from*(this: LMatrix3d, other: LMatrix3d) {.importcpp: "#.transpose_from(#)".}

proc transpose_in_place*(this: LMatrix3d) {.importcpp: "#.transpose_in_place()".}

proc invert_from*(this: LMatrix3d, other: LMatrix3d): bool {.importcpp: "#.invert_from(#)".} ## \
## Computes the inverse of the other matrix, and stores the result in this
## matrix.  This is a fully general operation and makes no assumptions about
## the type of transform represented by the matrix.
##
## The other matrix must be a different object than this matrix.  However, if
## you need to invert a matrix in place, see invert_in_place.
##
## The return value is true if the matrix was successfully inverted, false if
## there was a singularity.

proc invert_in_place*(this: LMatrix3d): bool {.importcpp: "#.invert_in_place()".} ## \
## Inverts the current matrix.  Returns true if the inverse is successful,
## false if the matrix was singular.

proc invert_transpose_from*(this: LMatrix3d, other: LMatrix3d): bool {.importcpp: "#.invert_transpose_from(#)".} ## \
## Simultaneously computes the inverse of the indicated matrix, and then the
## transpose of that inverse.

proc invert_transpose_from*(this: LMatrix3d, other: LMatrix4d): bool {.importcpp: "#.invert_transpose_from(#)".} ## \
## Simultaneously computes the inverse of the indicated matrix, and then the
## transpose of that inverse.

proc ident_mat*(_: typedesc[LMatrix3d]): LMatrix3d {.importcpp: "LMatrix3d::ident_mat()", header: "lmatrix3.h".} ## \
## Returns an identity matrix.
##
## This function definition must appear first, since some inline functions
## below take advantage of it.

proc set_translate_mat*(this: LMatrix3d, trans: LVecBase2d) {.importcpp: "#.set_translate_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated translation.

proc set_rotate_mat*(this: LMatrix3d, angle: float64) {.importcpp: "#.set_rotate_mat(#)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise.

proc set_rotate_mat*(this: LMatrix3d, angle: float64, axis: LVecBase3d, cs: CoordinateSystem) {.importcpp: "#.set_rotate_mat(#, #, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc set_rotate_mat*(this: LMatrix3d, angle: float64, axis: LVecBase3d) {.importcpp: "#.set_rotate_mat(#, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc set_scale_mat*(this: LMatrix3d, scale: LVecBase2d) {.importcpp: "#.set_scale_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated scale in each of the two
## axes.

proc set_scale_mat*(this: LMatrix3d, scale: LVecBase3d) {.importcpp: "#.set_scale_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated scale in each of the
## three axes.

proc translate_mat*(_: typedesc[LMatrix3d], trans: LVecBase2d): LMatrix3d {.importcpp: "LMatrix3d::translate_mat(#)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated translation.

proc translate_mat*(_: typedesc[LMatrix3d], tx: float64, ty: float64): LMatrix3d {.importcpp: "LMatrix3d::translate_mat(#, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated translation.

proc rotate_mat*(_: typedesc[LMatrix3d], angle: float64): LMatrix3d {.importcpp: "LMatrix3d::rotate_mat(#)", header: "lmatrix3.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise.

proc rotate_mat*(_: typedesc[LMatrix3d], angle: float64, axis: LVecBase3d, cs: CoordinateSystem): LMatrix3d {.importcpp: "LMatrix3d::rotate_mat(#, #, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc rotate_mat*(_: typedesc[LMatrix3d], angle: float64, axis: LVecBase3d): LMatrix3d {.importcpp: "LMatrix3d::rotate_mat(#, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc scale_mat*(_: typedesc[LMatrix3d], scale: LVecBase2d): LMatrix3d {.importcpp: "LMatrix3d::scale_mat(#)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated scale in each of the two axes.

proc scale_mat*(_: typedesc[LMatrix3d], scale: LVecBase3d): LMatrix3d {.importcpp: "LMatrix3d::scale_mat(#)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated scale in each of the three
## axes.

proc scale_mat*(_: typedesc[LMatrix3d], sx: float64, sy: float64): LMatrix3d {.importcpp: "LMatrix3d::scale_mat(#, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated scale in each of the two axes.

proc scale_mat*(_: typedesc[LMatrix3d], sx: float64, sy: float64, sz: float64): LMatrix3d {.importcpp: "LMatrix3d::scale_mat(#, #, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated scale in each of the three
## axes.

proc set_rotate_mat_normaxis*(this: LMatrix3d, angle: float64, axis: LVecBase3d, cs: CoordinateSystem) {.importcpp: "#.set_rotate_mat_normaxis(#, #, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## normalized.

proc set_rotate_mat_normaxis*(this: LMatrix3d, angle: float64, axis: LVecBase3d) {.importcpp: "#.set_rotate_mat_normaxis(#, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## normalized.

proc rotate_mat_normaxis*(_: typedesc[LMatrix3d], angle: float64, axis: LVecBase3d, cs: CoordinateSystem): LMatrix3d {.importcpp: "LMatrix3d::rotate_mat_normaxis(#, #, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## normalized.

proc rotate_mat_normaxis*(_: typedesc[LMatrix3d], angle: float64, axis: LVecBase3d): LMatrix3d {.importcpp: "LMatrix3d::rotate_mat_normaxis(#, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## normalized.

proc set_shear_mat*(this: LMatrix3d, shear: LVecBase3d, cs: CoordinateSystem) {.importcpp: "#.set_shear_mat(#, #)".} ## \
## Fills mat with a matrix that applies the indicated shear in each of the
## three planes.

proc set_shear_mat*(this: LMatrix3d, shear: LVecBase3d) {.importcpp: "#.set_shear_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated shear in each of the
## three planes.

proc shear_mat*(_: typedesc[LMatrix3d], shear: LVecBase3d, cs: CoordinateSystem): LMatrix3d {.importcpp: "LMatrix3d::shear_mat(#, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shear_mat*(_: typedesc[LMatrix3d], shear: LVecBase3d): LMatrix3d {.importcpp: "LMatrix3d::shear_mat(#)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shear_mat*(_: typedesc[LMatrix3d], shxy: float64, shxz: float64, shyz: float64, cs: CoordinateSystem): LMatrix3d {.importcpp: "LMatrix3d::shear_mat(#, #, #, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shear_mat*(_: typedesc[LMatrix3d], shxy: float64, shxz: float64, shyz: float64): LMatrix3d {.importcpp: "LMatrix3d::shear_mat(#, #, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc set_scale_shear_mat*(this: LMatrix3d, scale: LVecBase3d, shear: LVecBase3d, cs: CoordinateSystem) {.importcpp: "#.set_scale_shear_mat(#, #, #)".} ## \
## Fills mat with a matrix that applies the indicated scale and shear.

proc set_scale_shear_mat*(this: LMatrix3d, scale: LVecBase3d, shear: LVecBase3d) {.importcpp: "#.set_scale_shear_mat(#, #)".} ## \
## Fills mat with a matrix that applies the indicated scale and shear.

proc scale_shear_mat*(_: typedesc[LMatrix3d], scale: LVecBase3d, shear: LVecBase3d, cs: CoordinateSystem): LMatrix3d {.importcpp: "LMatrix3d::scale_shear_mat(#, #, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scale_shear_mat*(_: typedesc[LMatrix3d], scale: LVecBase3d, shear: LVecBase3d): LMatrix3d {.importcpp: "LMatrix3d::scale_shear_mat(#, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scale_shear_mat*(_: typedesc[LMatrix3d], sx: float64, sy: float64, sz: float64, shxy: float64, shxz: float64, shyz: float64, cs: CoordinateSystem): LMatrix3d {.importcpp: "LMatrix3d::scale_shear_mat(#, #, #, #, #, #, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scale_shear_mat*(_: typedesc[LMatrix3d], sx: float64, sy: float64, sz: float64, shxy: float64, shxz: float64, shyz: float64): LMatrix3d {.importcpp: "LMatrix3d::scale_shear_mat(#, #, #, #, #, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc convert_mat*(_: typedesc[LMatrix3d], `from`: CoordinateSystem, to: CoordinateSystem): LMatrix3d {.importcpp: "LMatrix3d::convert_mat(#, #)", header: "lmatrix3.h".} ## \
## Returns a matrix that transforms from the indicated coordinate system to
## the indicated coordinate system.

proc almost_equal*(this: LMatrix3d, other: LMatrix3d): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two matrices are memberwise equal within a default
## tolerance based on the numeric type.

proc almost_equal*(this: LMatrix3d, other: LMatrix3d, threshold: float64): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two matrices are memberwise equal within a specified
## tolerance.

proc output*(this: LMatrix3d, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: LMatrix3d, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: LMatrix3d, `out`: ostream) {.importcpp: "#.write(#)".}

proc write_datagram_fixed*(this: LMatrix3d, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the matrix to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the matrix, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc read_datagram_fixed*(this: LMatrix3d, scan: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the matrix from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc write_datagram*(this: LMatrix3d, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the matrix to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the matrix using the standard width
## setting, especially when you are writing a bam file.

proc read_datagram*(this: LMatrix3d, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the matrix from the Datagram using get_stdfloat().

proc get_class_type*(_: typedesc[LMatrix3d]): TypeHandle {.importcpp: "LMatrix3d::get_class_type()", header: "lmatrix3.h".}

proc initLMatrix4d*(): LMatrix4d {.importcpp: "LMatrix4d()".}

proc initLMatrix4d*(upper3: LMatrix3d): LMatrix4d {.importcpp: "LMatrix4d(#)".} ## \
## Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
## translation component.

proc initLMatrix4d*(upper3: LMatrix3d, trans: LVecBase3d): LMatrix4d {.importcpp: "LMatrix4d(#, #)".}

proc initLMatrix4d*(other: LMatrix4d): LMatrix4d {.importcpp: "LMatrix4d(#)".}

proc initLMatrix4d*(param0: LVecBase4d, param1: LVecBase4d, param2: LVecBase4d, param3: LVecBase4d): LMatrix4d {.importcpp: "LMatrix4d(#, #, #, #)".} ## \
## Constructs the matrix from four individual rows.

proc initLMatrix4d*(other: UnalignedLMatrix4d): LMatrix4d {.importcpp: "LMatrix4d(#)".}

proc initLMatrix4d*(param0: float64, param1: float64, param2: float64, param3: float64, param4: float64, param5: float64, param6: float64, param7: float64, param8: float64, param9: float64, param10: float64, param11: float64, param12: float64, param13: float64, param14: float64, param15: float64): LMatrix4d {.importcpp: "LMatrix4d(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".}

proc fill*(this: LMatrix4d, fill_value: float64) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the matrix to the indicated fill_value.  This is of
## questionable value, but is sometimes useful when initializing to zero.

proc set*(this: LMatrix4d, e00: float64, e01: float64, e02: float64, e03: float64, e10: float64, e11: float64, e12: float64, e13: float64, e20: float64, e21: float64, e22: float64, e23: float64, e30: float64, e31: float64, e32: float64, e33: float64) {.importcpp: "#.set(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".}

proc set_upper_3*(this: LMatrix4d, upper3: LMatrix3d) {.importcpp: "#.set_upper_3(#)".} ## \
## Get and set the upper 3x3 rotation matrix.

proc get_upper_3*(this: LMatrix4d): LMatrix3d {.importcpp: "#.get_upper_3()".} ## \
## Retrieves the upper 3x3 submatrix.

proc size*(_: typedesc[LMatrix4d]): int {.importcpp: "LMatrix4d::size()", header: "lmatrix4.h".} ## \
## Returns 4: the number of rows of a LMatrix4.

proc set_row*(this: LMatrix4d, row: int, v: LVecBase3d) {.importcpp: "#.set_row(#, #)".} ## \
## Replaces the indicated row of the matrix with the indicated 3-component
## vector, ignoring the last column.

proc set_row*(this: LMatrix4d, row: int, v: LVecBase4d) {.importcpp: "#.set_row(#, #)".} ## \
## Replaces the indicated row of the matrix.

proc set_col*(this: LMatrix4d, col: int, v: LVecBase3d) {.importcpp: "#.set_col(#, #)".} ## \
## Replaces the indicated column of the matrix with the indicated 3-component
## vector, ignoring the last row.

proc set_col*(this: LMatrix4d, col: int, v: LVecBase4d) {.importcpp: "#.set_col(#, #)".} ## \
## Replaces the indicated column of the matrix.

proc get_row*(this: LMatrix4d, result_vec: LVecBase4d, row: int) {.importcpp: "#.get_row(#, #)".} ## \
## Stores the indicated row of the matrix as a 4-component vector.

proc get_row*(this: LMatrix4d, row: int): LVecBase4d {.importcpp: "#.get_row(#)".} ## \
## Retrieves the indicated row of the matrix as a 4-component vector.

proc get_col*(this: LMatrix4d, col: int): LVecBase4d {.importcpp: "#.get_col(#)".} ## \
## Retrieves the indicated column of the matrix as a 4-component vector.

proc get_row3*(this: LMatrix4d, result_vec: LVecBase3d, row: int) {.importcpp: "#.get_row3(#, #)".} ## \
## Stores the row column of the matrix as a 3-component vector, ignoring the
## last column.

proc get_row3*(this: LMatrix4d, row: int): LVecBase3d {.importcpp: "#.get_row3(#)".} ## \
## Retrieves the row column of the matrix as a 3-component vector, ignoring
## the last column.

proc get_col3*(this: LMatrix4d, col: int): LVecBase3d {.importcpp: "#.get_col3(#)".} ## \
## Retrieves the indicated column of the matrix as a 3-component vector,
## ignoring the last row.

proc is_nan*(this: LMatrix4d): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the matrix is not-a-number, false
## otherwise.

proc is_identity*(this: LMatrix4d): bool {.importcpp: "#.is_identity()".} ## \
## Returns true if this is (close enough to) the identity matrix, false
## otherwise.

proc get_cell*(this: LMatrix4d, row: int, col: int): float64 {.importcpp: "#.get_cell(#, #)".} ## \
## Returns a particular element of the matrix.

proc set_cell*(this: LMatrix4d, row: int, col: int, value: float64) {.importcpp: "#.set_cell(#, #, #)".} ## \
## Changes a particular element of the matrix.

proc get_data*(this: LMatrix4d) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the nine data elements in the matrix.
## The remaining elements occupy the next eight positions in row-major order.

proc get_num_components*(this: LMatrix4d): int {.importcpp: "#.get_num_components()".} ## \
## Returns the number of elements in the matrix, 16.

proc begin*(this: LMatrix4d) {.importcpp: "#.begin()".} ## \
## Returns an iterator that may be used to traverse the elements of the
## matrix, STL-style.

proc `<`*(this: LMatrix4d, other: LMatrix4d): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LMatrix4d, other: LMatrix4d): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LMatrix4d, other: LMatrix4d): bool {.importcpp: "#.operator !=(#)".}

proc compare_to*(this: LMatrix4d, other: LMatrix4d): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compare_to*(this: LMatrix4d, other: LMatrix4d, threshold: float64): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts matrices lexicographically, componentwise.  Returns a number less
## than 0 if this matrix sorts before the other one, greater than zero if it
## sorts after, 0 if they are equivalent (within the indicated tolerance).

proc get_hash*(this: LMatrix4d): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc get_hash*(this: LMatrix4d, threshold: float64): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc add_hash*(this: LMatrix4d, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc add_hash*(this: LMatrix4d, hash: clonglong, threshold: float64): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc xform*(this: LMatrix4d, v: LVecBase4d): LVecBase4d {.importcpp: "#.xform(#)".} ## \
## 4-component vector or point times matrix.  This is a fully general
## operation.

proc xform_point*(this: LMatrix4d, v: LVecBase3d): LVecBase3d {.importcpp: "#.xform_point(#)".} ## \
## The matrix transforms a 3-component point (including translation component)
## and returns the result.  This assumes the matrix is an affine transform.

proc xform_point_general*(this: LMatrix4d, v: LVecBase3d): LVecBase3d {.importcpp: "#.xform_point_general(#)".} ## \
## The matrix transforms a 3-component point (including translation component)
## and returns the result, as a fully general operation.

proc xform_vec*(this: LMatrix4d, v: LVecBase3d): LVecBase3d {.importcpp: "#.xform_vec(#)".} ## \
## The matrix transforms a 3-component vector (without translation component)
## and returns the result.  This assumes the matrix is an orthonormal
## transform.

proc xform_vec_general*(this: LMatrix4d, v: LVecBase3d): LVecBase3d {.importcpp: "#.xform_vec_general(#)".} ## \
## The matrix transforms a 3-component vector (without translation component)
## and returns the result, as a fully general operation.

proc xform_in_place*(this: LMatrix4d, v: LVecBase4d) {.importcpp: "#.xform_in_place(#)".} ## \
## 4-component vector or point times matrix.  This is a fully general
## operation.

proc xform_point_in_place*(this: LMatrix4d, v: LVecBase3d) {.importcpp: "#.xform_point_in_place(#)".} ## \
## The matrix transforms a 3-component point (including translation
## component).  This assumes the matrix is an affine transform.

proc xform_point_general_in_place*(this: LMatrix4d, v: LVecBase3d) {.importcpp: "#.xform_point_general_in_place(#)".} ## \
## The matrix transforms a 3-component point (including translation
## component), as a fully general operation.

proc xform_vec_in_place*(this: LMatrix4d, v: LVecBase3d) {.importcpp: "#.xform_vec_in_place(#)".} ## \
## The matrix transforms a 3-component vector (without translation component).
## This assumes the matrix is an orthonormal transform.

proc xform_vec_general_in_place*(this: LMatrix4d, v: LVecBase3d) {.importcpp: "#.xform_vec_general_in_place(#)".} ## \
## The matrix transforms a 3-component vector (without translation component),
## as a fully general operation.

proc multiply*(this: LMatrix4d, other1: LMatrix4d, other2: LMatrix4d) {.importcpp: "#.multiply(#, #)".} ## \
## this = other1 * other2

proc `*`*(this: LMatrix4d, other: LMatrix4d): LMatrix4d {.importcpp: "#.operator *(#)".}

proc `*`*(this: LMatrix4d, scalar: float64): LMatrix4d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LMatrix4d, scalar: float64): LMatrix4d {.importcpp: "#.operator /(#)".}

proc `+=`*(this: LMatrix4d, other: LMatrix4d): LMatrix4d {.importcpp: "#.operator +=(#)".} ## \
## Performs a memberwise addition between two matrices.

proc `-=`*(this: LMatrix4d, other: LMatrix4d): LMatrix4d {.importcpp: "#.operator -=(#)".} ## \
## Performs a memberwise subtraction between two matrices.

proc `*=`*(this: LMatrix4d, other: LMatrix4d): LMatrix4d {.importcpp: "#.operator *=(#)".}

proc `*=`*(this: LMatrix4d, scalar: float64): LMatrix4d {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: LMatrix4d, scalar: float64): LMatrix4d {.importcpp: "#.operator /=(#)".}

proc componentwise_mult*(this: LMatrix4d, other: LMatrix4d) {.importcpp: "#.componentwise_mult(#)".}

proc transpose_from*(this: LMatrix4d, other: LMatrix4d) {.importcpp: "#.transpose_from(#)".}

proc transpose_in_place*(this: LMatrix4d) {.importcpp: "#.transpose_in_place()".}

proc invert_from*(this: LMatrix4d, other: LMatrix4d): bool {.importcpp: "#.invert_from(#)".} ## \
## Computes the inverse of the other matrix, and stores the result in this
## matrix.  This is a fully general operation and makes no assumptions about
## the type of transform represented by the matrix.
##
## The other matrix must be a different object than this matrix.  However, if
## you need to invert a matrix in place, see invert_in_place.
##
## The return value is true if the matrix was successfully inverted, false if
## the was a singularity.

proc invert_affine_from*(this: LMatrix4d, other: LMatrix4d): bool {.importcpp: "#.invert_affine_from(#)".} ## \
## bugbug: we could optimize this for rotationscaletranslation matrices
## (transpose upper 3x3 and take negative of translation component)

proc invert_in_place*(this: LMatrix4d): bool {.importcpp: "#.invert_in_place()".} ## \
## Inverts the current matrix.  Returns true if the inverse is successful,
## false if the matrix was singular.

proc accumulate*(this: LMatrix4d, other: LMatrix4d, weight: float64) {.importcpp: "#.accumulate(#, #)".} ## \
## Computes `(*this) += other * weight`.

proc ident_mat*(_: typedesc[LMatrix4d]): LMatrix4d {.importcpp: "LMatrix4d::ident_mat()", header: "lmatrix4.h".} ## \
## Returns an identity matrix.
##
## This function definition must appear first, since some inline functions
## below take advantage of it.

proc ones_mat*(_: typedesc[LMatrix4d]): LMatrix4d {.importcpp: "LMatrix4d::ones_mat()", header: "lmatrix4.h".} ## \
## Returns an matrix filled with ones.

proc zeros_mat*(_: typedesc[LMatrix4d]): LMatrix4d {.importcpp: "LMatrix4d::zeros_mat()", header: "lmatrix4.h".} ## \
## Returns an matrix filled with zeros.

proc set_translate_mat*(this: LMatrix4d, trans: LVecBase3d) {.importcpp: "#.set_translate_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated translation.

proc set_rotate_mat*(this: LMatrix4d, angle: float64, axis: LVecBase3d, cs: CoordinateSystem) {.importcpp: "#.set_rotate_mat(#, #, #)".} ## \
## Sets mat to a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc set_rotate_mat*(this: LMatrix4d, angle: float64, axis: LVecBase3d) {.importcpp: "#.set_rotate_mat(#, #)".} ## \
## Sets mat to a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc set_rotate_mat_normaxis*(this: LMatrix4d, angle: float64, axis: LVecBase3d, cs: CoordinateSystem) {.importcpp: "#.set_rotate_mat_normaxis(#, #, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## prenormalized.

proc set_rotate_mat_normaxis*(this: LMatrix4d, angle: float64, axis: LVecBase3d) {.importcpp: "#.set_rotate_mat_normaxis(#, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## prenormalized.

proc set_scale_mat*(this: LMatrix4d, scale: LVecBase3d) {.importcpp: "#.set_scale_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated scale in each of the
## three axes.

proc set_shear_mat*(this: LMatrix4d, shear: LVecBase3d, cs: CoordinateSystem) {.importcpp: "#.set_shear_mat(#, #)".} ## \
## Fills mat with a matrix that applies the indicated shear in each of the
## three planes.

proc set_shear_mat*(this: LMatrix4d, shear: LVecBase3d) {.importcpp: "#.set_shear_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated shear in each of the
## three planes.

proc set_scale_shear_mat*(this: LMatrix4d, scale: LVecBase3d, shear: LVecBase3d, cs: CoordinateSystem) {.importcpp: "#.set_scale_shear_mat(#, #, #)".} ## \
## Fills mat with a matrix that applies the indicated scale and shear.

proc set_scale_shear_mat*(this: LMatrix4d, scale: LVecBase3d, shear: LVecBase3d) {.importcpp: "#.set_scale_shear_mat(#, #)".} ## \
## Fills mat with a matrix that applies the indicated scale and shear.

proc translate_mat*(_: typedesc[LMatrix4d], trans: LVecBase3d): LMatrix4d {.importcpp: "LMatrix4d::translate_mat(#)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated translation.

proc translate_mat*(_: typedesc[LMatrix4d], tx: float64, ty: float64, tz: float64): LMatrix4d {.importcpp: "LMatrix4d::translate_mat(#, #, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated translation.

proc rotate_mat*(_: typedesc[LMatrix4d], angle: float64, axis: LVecBase3d, cs: CoordinateSystem): LMatrix4d {.importcpp: "LMatrix4d::rotate_mat(#, #, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc rotate_mat*(_: typedesc[LMatrix4d], angle: float64, axis: LVecBase3d): LMatrix4d {.importcpp: "LMatrix4d::rotate_mat(#, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc rotate_mat_normaxis*(_: typedesc[LMatrix4d], angle: float64, axis: LVecBase3d, cs: CoordinateSystem): LMatrix4d {.importcpp: "LMatrix4d::rotate_mat_normaxis(#, #, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## prenormalized.

proc rotate_mat_normaxis*(_: typedesc[LMatrix4d], angle: float64, axis: LVecBase3d): LMatrix4d {.importcpp: "LMatrix4d::rotate_mat_normaxis(#, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## prenormalized.

proc scale_mat*(_: typedesc[LMatrix4d], scale: LVecBase3d): LMatrix4d {.importcpp: "LMatrix4d::scale_mat(#)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated scale in each of the three
## axes.

proc scale_mat*(_: typedesc[LMatrix4d], scale: float64): LMatrix4d {.importcpp: "LMatrix4d::scale_mat(#)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated uniform scale.

proc scale_mat*(_: typedesc[LMatrix4d], sx: float64, sy: float64, sz: float64): LMatrix4d {.importcpp: "LMatrix4d::scale_mat(#, #, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated scale in each of the three
## axes.

proc shear_mat*(_: typedesc[LMatrix4d], shear: LVecBase3d, cs: CoordinateSystem): LMatrix4d {.importcpp: "LMatrix4d::shear_mat(#, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shear_mat*(_: typedesc[LMatrix4d], shear: LVecBase3d): LMatrix4d {.importcpp: "LMatrix4d::shear_mat(#)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shear_mat*(_: typedesc[LMatrix4d], shxy: float64, shxz: float64, shyz: float64, cs: CoordinateSystem): LMatrix4d {.importcpp: "LMatrix4d::shear_mat(#, #, #, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shear_mat*(_: typedesc[LMatrix4d], shxy: float64, shxz: float64, shyz: float64): LMatrix4d {.importcpp: "LMatrix4d::shear_mat(#, #, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc scale_shear_mat*(_: typedesc[LMatrix4d], scale: LVecBase3d, shear: LVecBase3d, cs: CoordinateSystem): LMatrix4d {.importcpp: "LMatrix4d::scale_shear_mat(#, #, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scale_shear_mat*(_: typedesc[LMatrix4d], scale: LVecBase3d, shear: LVecBase3d): LMatrix4d {.importcpp: "LMatrix4d::scale_shear_mat(#, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scale_shear_mat*(_: typedesc[LMatrix4d], sx: float64, sy: float64, sz: float64, shxy: float64, shxz: float64, shyz: float64, cs: CoordinateSystem): LMatrix4d {.importcpp: "LMatrix4d::scale_shear_mat(#, #, #, #, #, #, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scale_shear_mat*(_: typedesc[LMatrix4d], sx: float64, sy: float64, sz: float64, shxy: float64, shxz: float64, shyz: float64): LMatrix4d {.importcpp: "LMatrix4d::scale_shear_mat(#, #, #, #, #, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc y_to_z_up_mat*(_: typedesc[LMatrix4d]): LMatrix4d {.importcpp: "LMatrix4d::y_to_z_up_mat()", header: "lmatrix4.h".} ## \
## Returns a matrix that transforms from the Y-up coordinate system to the
## Z-up coordinate system.

proc z_to_y_up_mat*(_: typedesc[LMatrix4d]): LMatrix4d {.importcpp: "LMatrix4d::z_to_y_up_mat()", header: "lmatrix4.h".} ## \
## Returns a matrix that transforms from the Y-up coordinate system to the
## Z-up coordinate system.

proc convert_mat*(_: typedesc[LMatrix4d], `from`: CoordinateSystem, to: CoordinateSystem): LMatrix4d {.importcpp: "LMatrix4d::convert_mat(#, #)", header: "lmatrix4.h".} ## \
## Returns a matrix that transforms from the indicated coordinate system to
## the indicated coordinate system.

proc almost_equal*(this: LMatrix4d, other: LMatrix4d): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two matrices are memberwise equal within a default
## tolerance based on the numeric type.

proc almost_equal*(this: LMatrix4d, other: LMatrix4d, threshold: float64): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two matrices are memberwise equal within a specified
## tolerance.  This is faster than the equivalence operator as this doesn't
## have to guarantee that it is transitive.

proc output*(this: LMatrix4d, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: LMatrix4d, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: LMatrix4d, `out`: ostream) {.importcpp: "#.write(#)".}

proc write_datagram_fixed*(this: LMatrix4d, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the matrix to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the matrix, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc read_datagram_fixed*(this: LMatrix4d, scan: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the matrix from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc write_datagram*(this: LMatrix4d, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the matrix to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the matrix using the standard width
## setting, especially when you are writing a bam file.

proc read_datagram*(this: LMatrix4d, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the matrix from the Datagram using get_stdfloat().

proc get_class_type*(_: typedesc[LMatrix4d]): TypeHandle {.importcpp: "LMatrix4d::get_class_type()", header: "lmatrix4.h".}

proc initUnalignedLMatrix4d*(): UnalignedLMatrix4d {.importcpp: "UnalignedLMatrix4d()".}

proc initUnalignedLMatrix4d*(copy: LMatrix4d): UnalignedLMatrix4d {.importcpp: "UnalignedLMatrix4d(#)".}

proc initUnalignedLMatrix4d*(copy: UnalignedLMatrix4d): UnalignedLMatrix4d {.importcpp: "UnalignedLMatrix4d(#)".}

proc initUnalignedLMatrix4d*(e00: float64, e01: float64, e02: float64, e03: float64, e10: float64, e11: float64, e12: float64, e13: float64, e20: float64, e21: float64, e22: float64, e23: float64, e30: float64, e31: float64, e32: float64, e33: float64): UnalignedLMatrix4d {.importcpp: "UnalignedLMatrix4d(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".}

proc set*(this: UnalignedLMatrix4d, e00: float64, e01: float64, e02: float64, e03: float64, e10: float64, e11: float64, e12: float64, e13: float64, e20: float64, e21: float64, e22: float64, e23: float64, e30: float64, e31: float64, e32: float64, e33: float64) {.importcpp: "#.set(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".}

proc get_data*(this: UnalignedLMatrix4d) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the nine data elements in the matrix.
## The remaining elements occupy the next eight positions in row-major order.

proc get_num_components*(this: UnalignedLMatrix4d): int {.importcpp: "#.get_num_components()".} ## \
## Returns the number of elements in the matrix, sixteen.

proc `==`*(this: UnalignedLMatrix4d, other: UnalignedLMatrix4d): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: UnalignedLMatrix4d, other: UnalignedLMatrix4d): bool {.importcpp: "#.operator !=(#)".}

proc get_class_type*(_: typedesc[UnalignedLMatrix4d]): TypeHandle {.importcpp: "UnalignedLMatrix4d::get_class_type()", header: "unalignedLMatrix4d.h".}

proc `*`*(m: LMatrix3d, q: LQuaterniond): LMatrix3d {.importcpp: "operator *(#, #)".}

proc `*`*(m: LMatrix3f, q: LQuaternionf): LMatrix3f {.importcpp: "operator *(#, #)".}

proc `*`*(m: LMatrix4d, q: LQuaterniond): LMatrix4d {.importcpp: "operator *(#, #)".}

proc `*`*(m: LMatrix4f, q: LQuaternionf): LMatrix4f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LPoint2d, m: LMatrix3d): LPoint2d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LPoint2f, m: LMatrix3f): LPoint2f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LPoint3d, m: LMatrix3d): LPoint3d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LPoint3d, m: LMatrix4d): LPoint3d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LPoint3f, m: LMatrix3f): LPoint3f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LPoint3f, m: LMatrix4f): LPoint3f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LPoint4d, m: LMatrix4d): LPoint4d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LPoint4f, m: LMatrix4f): LPoint4f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVecBase3d, m: LMatrix3d): LVecBase3d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVecBase3f, m: LMatrix3f): LVecBase3f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVecBase4d, m: LMatrix4d): LVecBase4d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVecBase4f, m: LMatrix4f): LVecBase4f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVector2d, m: LMatrix3d): LVector2d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVector2f, m: LMatrix3f): LVector2f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVector3d, m: LMatrix3d): LVector3d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVector3d, m: LMatrix4d): LVector3d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVector3f, m: LMatrix3f): LVector3f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVector3f, m: LMatrix4f): LVector3f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVector4d, m: LMatrix4d): LVector4d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVector4f, m: LMatrix4f): LVector4f {.importcpp: "operator *(#, #)".}

proc `*=`*(v: LPoint2d, m: LMatrix3d) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LPoint2f, m: LMatrix3f) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LPoint3d, m: LMatrix3d) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LPoint3d, m: LMatrix4d) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LPoint3f, m: LMatrix3f) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LPoint3f, m: LMatrix4f) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVecBase3d, m: LMatrix3d) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVecBase3f, m: LMatrix3f) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVecBase4d, m: LMatrix4d) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVecBase4f, m: LMatrix4f) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVector2d, m: LMatrix3d) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVector2f, m: LMatrix3f) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVector3d, m: LMatrix3d) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVector3d, m: LMatrix4d) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVector3f, m: LMatrix3f) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVector3f, m: LMatrix4f) {.importcpp: "operator *=(#, #)".}

proc generic_write_datagram*(dest: Datagram, value: LMatrix3d) {.importcpp: "generic_write_datagram(#, #)".}

proc generic_write_datagram*(dest: Datagram, value: LMatrix3f) {.importcpp: "generic_write_datagram(#, #)".}

proc generic_write_datagram*(dest: Datagram, value: LMatrix4d) {.importcpp: "generic_write_datagram(#, #)".}

proc generic_write_datagram*(dest: Datagram, value: LMatrix4f) {.importcpp: "generic_write_datagram(#, #)".}

proc generic_read_datagram*(result: LMatrix3d, source: DatagramIterator) {.importcpp: "generic_read_datagram(#, #)".}

proc generic_read_datagram*(result: LMatrix3f, source: DatagramIterator) {.importcpp: "generic_read_datagram(#, #)".}

proc generic_read_datagram*(result: LMatrix4d, source: DatagramIterator) {.importcpp: "generic_read_datagram(#, #)".}

proc generic_read_datagram*(result: LMatrix4f, source: DatagramIterator) {.importcpp: "generic_read_datagram(#, #)".}

proc compose_matrix*(mat: LMatrix3d, scale: LVecBase3d, hpr: LVecBase3d, cs: CoordinateSystem) {.importcpp: "compose_matrix(#, #, #, #)".}

proc compose_matrix*(mat: LMatrix3d, scale: LVecBase3d, hpr: LVecBase3d) {.importcpp: "compose_matrix(#, #, #)".}

proc compose_matrix*(mat: LMatrix3d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d, cs: CoordinateSystem) {.importcpp: "compose_matrix(#, #, #, #, #)".}

proc compose_matrix*(mat: LMatrix3d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d) {.importcpp: "compose_matrix(#, #, #, #)".}

proc compose_matrix*(mat: LMatrix3f, scale: LVecBase3f, hpr: LVecBase3f, cs: CoordinateSystem) {.importcpp: "compose_matrix(#, #, #, #)".}

proc compose_matrix*(mat: LMatrix3f, scale: LVecBase3f, hpr: LVecBase3f) {.importcpp: "compose_matrix(#, #, #)".}

proc compose_matrix*(mat: LMatrix3f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f, cs: CoordinateSystem) {.importcpp: "compose_matrix(#, #, #, #, #)".}

proc compose_matrix*(mat: LMatrix3f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f) {.importcpp: "compose_matrix(#, #, #, #)".}

proc compose_matrix*(mat: LMatrix4d, scale: LVecBase3d, hpr: LVecBase3d, translate: LVecBase3d, cs: CoordinateSystem) {.importcpp: "compose_matrix(#, #, #, #, #)".}

proc compose_matrix*(mat: LMatrix4d, scale: LVecBase3d, hpr: LVecBase3d, translate: LVecBase3d) {.importcpp: "compose_matrix(#, #, #, #)".}

proc compose_matrix*(mat: LMatrix4d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d, translate: LVecBase3d, cs: CoordinateSystem) {.importcpp: "compose_matrix(#, #, #, #, #, #)".}

proc compose_matrix*(mat: LMatrix4d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d, translate: LVecBase3d) {.importcpp: "compose_matrix(#, #, #, #, #)".}

proc compose_matrix*(mat: LMatrix4f, scale: LVecBase3f, hpr: LVecBase3f, translate: LVecBase3f, cs: CoordinateSystem) {.importcpp: "compose_matrix(#, #, #, #, #)".}

proc compose_matrix*(mat: LMatrix4f, scale: LVecBase3f, hpr: LVecBase3f, translate: LVecBase3f) {.importcpp: "compose_matrix(#, #, #, #)".}

proc compose_matrix*(mat: LMatrix4f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f, translate: LVecBase3f, cs: CoordinateSystem) {.importcpp: "compose_matrix(#, #, #, #, #, #)".}

proc compose_matrix*(mat: LMatrix4f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f, translate: LVecBase3f) {.importcpp: "compose_matrix(#, #, #, #, #)".}

proc decompose_matrix*(mat: LMatrix3d, scale: LVecBase3d, hpr: LVecBase3d, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix(#, #, #, #)".}

proc decompose_matrix*(mat: LMatrix3d, scale: LVecBase3d, hpr: LVecBase3d): bool {.importcpp: "decompose_matrix(#, #, #)".}

proc decompose_matrix*(mat: LMatrix3d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix(#, #, #, #, #)".}

proc decompose_matrix*(mat: LMatrix3d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d): bool {.importcpp: "decompose_matrix(#, #, #, #)".}

proc decompose_matrix*(mat: LMatrix3f, scale: LVecBase3f, hpr: LVecBase3f, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix(#, #, #, #)".}

proc decompose_matrix*(mat: LMatrix3f, scale: LVecBase3f, hpr: LVecBase3f): bool {.importcpp: "decompose_matrix(#, #, #)".}

proc decompose_matrix*(mat: LMatrix3f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix(#, #, #, #, #)".}

proc decompose_matrix*(mat: LMatrix3f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f): bool {.importcpp: "decompose_matrix(#, #, #, #)".}

proc decompose_matrix*(mat: LMatrix4d, scale: LVecBase3d, hpr: LVecBase3d, translate: LVecBase3d, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix(#, #, #, #, #)".}

proc decompose_matrix*(mat: LMatrix4d, scale: LVecBase3d, hpr: LVecBase3d, translate: LVecBase3d): bool {.importcpp: "decompose_matrix(#, #, #, #)".}

proc decompose_matrix*(mat: LMatrix4d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d, translate: LVecBase3d, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix(#, #, #, #, #, #)".}

proc decompose_matrix*(mat: LMatrix4d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d, translate: LVecBase3d): bool {.importcpp: "decompose_matrix(#, #, #, #, #)".}

proc decompose_matrix*(mat: LMatrix4f, scale: LVecBase3f, hpr: LVecBase3f, translate: LVecBase3f, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix(#, #, #, #, #)".}

proc decompose_matrix*(mat: LMatrix4f, scale: LVecBase3f, hpr: LVecBase3f, translate: LVecBase3f): bool {.importcpp: "decompose_matrix(#, #, #, #)".}

proc decompose_matrix*(mat: LMatrix4f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f, translate: LVecBase3f, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix(#, #, #, #, #, #)".}

proc decompose_matrix*(mat: LMatrix4f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f, translate: LVecBase3f): bool {.importcpp: "decompose_matrix(#, #, #, #, #)".}

proc decompose_matrix_old_hpr*(mat: LMatrix3d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix_old_hpr(#, #, #, #, #)".}

proc decompose_matrix_old_hpr*(mat: LMatrix3d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d): bool {.importcpp: "decompose_matrix_old_hpr(#, #, #, #)".}

proc decompose_matrix_old_hpr*(mat: LMatrix3f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix_old_hpr(#, #, #, #, #)".}

proc decompose_matrix_old_hpr*(mat: LMatrix3f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f): bool {.importcpp: "decompose_matrix_old_hpr(#, #, #, #)".}

proc old_to_new_hpr*(old_hpr: LVecBase3d): LVecBase3d {.importcpp: "old_to_new_hpr(#)".}

proc old_to_new_hpr*(old_hpr: LVecBase3f): LVecBase3f {.importcpp: "old_to_new_hpr(#)".}

proc initLQuaternionf*(): LQuaternionf {.importcpp: "LQuaternionf()".}

proc initLQuaternionf*(param0: LQuaternionf): LQuaternionf {.importcpp: "LQuaternionf(#)".}

proc initLQuaternionf*(copy: LVecBase4f): LQuaternionf {.importcpp: "LQuaternionf(#)".}

proc initLQuaternionf*(r: float32, copy: LVecBase3f): LQuaternionf {.importcpp: "LQuaternionf(#, #)".}

proc initLQuaternionf*(r: float32, i: float32, j: float32, k: float32): LQuaternionf {.importcpp: "LQuaternionf(#, #, #, #)".}

proc pure_imaginary*(_: typedesc[LQuaternionf], v: LVector3f): LQuaternionf {.importcpp: "LQuaternionf::pure_imaginary(#)", header: "lquaternion.h".}

proc conjugate*(this: LQuaternionf): LQuaternionf {.importcpp: "#.conjugate()".} ## \
## Returns the complex conjugate of this quat.

proc xform*(this: LQuaternionf, v: LVecBase3f): LVecBase3f {.importcpp: "#.xform(#)".} ## \
## Transforms a 3-d vector by the indicated rotation

proc xform*(this: LQuaternionf, v: LVecBase4f): LVecBase4f {.importcpp: "#.xform(#)".} ## \
## Transforms a 4-d vector by the indicated rotation

proc multiply*(this: LQuaternionf, rhs: LQuaternionf): LQuaternionf {.importcpp: "#.multiply(#)".} ## \
## actual multiply call (non virtual)

proc `-`*(this: LQuaternionf): LQuaternionf {.importcpp: "#.operator -()".}

proc `+`*(this: LQuaternionf, other: LQuaternionf): LQuaternionf {.importcpp: "#.operator +(#)".}

proc `-`*(this: LQuaternionf, other: LQuaternionf): LQuaternionf {.importcpp: "#.operator -(#)".}

proc angle_rad*(this: LQuaternionf, other: LQuaternionf): float32 {.importcpp: "#.angle_rad(#)".} ## \
## Returns the angle between the orientation represented by this quaternion
## and the other one, expressed in radians.

proc angle_deg*(this: LQuaternionf, other: LQuaternionf): float32 {.importcpp: "#.angle_deg(#)".} ## \
## Returns the angle between the orientation represented by this quaternion
## and the other one, expressed in degrees.

proc `*`*(this: LQuaternionf, param0: LMatrix3f): LMatrix3f {.importcpp: "#.operator *(#)".}

proc `*`*(this: LQuaternionf, param0: LMatrix4f): LMatrix4f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LQuaternionf, scalar: float32): LQuaternionf {.importcpp: "#.operator /(#)".}

proc `*=`*(this: LQuaternionf, param0: LQuaternionf): LQuaternionf {.importcpp: "#.operator *=(#)".}

proc almost_equal*(this: LQuaternionf, other: LQuaternionf): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two quaternions are memberwise equal within a default
## tolerance based on the numeric type.

proc almost_equal*(this: LQuaternionf, other: LQuaternionf, threshold: float32): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two quaternions are memberwise equal within a specified
## tolerance.

proc is_same_direction*(this: LQuaternionf, other: LQuaternionf): bool {.importcpp: "#.is_same_direction(#)".} ## \
## Returns true if two quaternions represent the same rotation within a
## default tolerance based on the numeric type.

proc almost_same_direction*(this: LQuaternionf, other: LQuaternionf, threshold: float32): bool {.importcpp: "#.almost_same_direction(#, #)".} ## \
## Returns true if two quaternions represent the same rotation within a
## specified tolerance.

proc output*(this: LQuaternionf, param0: ostream) {.importcpp: "#.output(#)".}

proc extract_to_matrix*(this: LQuaternionf, m: LMatrix3f) {.importcpp: "#.extract_to_matrix(#)".} ## \
## Based on the quat lib from VRPN.

proc extract_to_matrix*(this: LQuaternionf, m: LMatrix4f) {.importcpp: "#.extract_to_matrix(#)".} ## \
## Based on the quat lib from VRPN.

proc set_from_matrix*(this: LQuaternionf, m: LMatrix3f) {.importcpp: "#.set_from_matrix(#)".} ## \
## Sets the quaternion according to the rotation represented by the matrix.
## Originally we tried an algorithm presented by Do-While Jones, but that
## turned out to be broken.  This is based on the quat lib from UNC.

proc set_from_matrix*(this: LQuaternionf, m: LMatrix4f) {.importcpp: "#.set_from_matrix(#)".}

proc set_hpr*(this: LQuaternionf, hpr: LVecBase3f, cs: CoordinateSystem) {.importcpp: "#.set_hpr(#, #)".} ## \
## Sets the quaternion as the unit quaternion that is equivalent to these
## Euler angles.  (from Real-time Rendering, p.49)

proc set_hpr*(this: LQuaternionf, hpr: LVecBase3f) {.importcpp: "#.set_hpr(#)".} ## \
## Sets the quaternion as the unit quaternion that is equivalent to these
## Euler angles.  (from Real-time Rendering, p.49)

proc get_hpr*(this: LQuaternionf, cs: CoordinateSystem): LVecBase3f {.importcpp: "#.get_hpr(#)".} ## \
## Extracts the equivalent Euler angles from the unit quaternion.

proc get_hpr*(this: LQuaternionf): LVecBase3f {.importcpp: "#.get_hpr()".} ## \
## Extracts the equivalent Euler angles from the unit quaternion.

proc get_axis*(this: LQuaternionf): LVector3f {.importcpp: "#.get_axis()".} ## \
## This, along with get_angle(), returns the rotation represented by the
## quaternion as an angle about an arbitrary axis.  This returns the axis; it
## is not normalized.

proc get_axis_normalized*(this: LQuaternionf): LVector3f {.importcpp: "#.get_axis_normalized()".} ## \
## This, along with get_angle(), returns the rotation represented by the
## quaternion as an angle about an arbitrary axis.  This returns the
## normalized axis.

proc get_angle_rad*(this: LQuaternionf): float32 {.importcpp: "#.get_angle_rad()".} ## \
## This, along with get_axis(), returns the rotation represented by the
## quaternion as an angle about an arbitrary axis.  This returns the angle, in
## radians counterclockwise about the axis.
##
## It is necessary to ensure the quaternion has been normalized (for instance,
## with a call to normalize()) before calling this method.

proc get_angle*(this: LQuaternionf): float32 {.importcpp: "#.get_angle()".} ## \
## This, along with get_axis(), returns the rotation represented by the
## quaternion as an angle about an arbitrary axis.  This returns the angle, in
## degrees counterclockwise about the axis.
##
## It is necessary to ensure the quaternion has been normalized (for instance,
## with a call to normalize()) before calling this method.

proc set_from_axis_angle_rad*(this: LQuaternionf, angle_rad: float32, axis: LVector3f) {.importcpp: "#.set_from_axis_angle_rad(#, #)".} ## \
## angle_rad is the angle about the axis in radians.  axis must be normalized.

proc set_from_axis_angle*(this: LQuaternionf, angle_deg: float32, axis: LVector3f) {.importcpp: "#.set_from_axis_angle(#, #)".} ## \
## angle_deg is the angle about the axis in degrees.  axis must be normalized.

proc get_up*(this: LQuaternionf, cs: CoordinateSystem): LVector3f {.importcpp: "#.get_up(#)".} ## \
## Returns the orientation represented by this quaternion, expressed as an up
## vector.

proc get_up*(this: LQuaternionf): LVector3f {.importcpp: "#.get_up()".} ## \
## Returns the orientation represented by this quaternion, expressed as an up
## vector.

proc get_right*(this: LQuaternionf, cs: CoordinateSystem): LVector3f {.importcpp: "#.get_right(#)".} ## \
## Returns the orientation represented by this quaternion, expressed as a
## right vector.

proc get_right*(this: LQuaternionf): LVector3f {.importcpp: "#.get_right()".} ## \
## Returns the orientation represented by this quaternion, expressed as a
## right vector.

proc get_forward*(this: LQuaternionf, cs: CoordinateSystem): LVector3f {.importcpp: "#.get_forward(#)".} ## \
## Returns the orientation represented by this quaternion, expressed as a
## forward vector.

proc get_forward*(this: LQuaternionf): LVector3f {.importcpp: "#.get_forward()".} ## \
## Returns the orientation represented by this quaternion, expressed as a
## forward vector.

proc get_r*(this: LQuaternionf): float32 {.importcpp: "#.get_r()".}

proc get_i*(this: LQuaternionf): float32 {.importcpp: "#.get_i()".}

proc get_j*(this: LQuaternionf): float32 {.importcpp: "#.get_j()".}

proc get_k*(this: LQuaternionf): float32 {.importcpp: "#.get_k()".}

proc set_r*(this: LQuaternionf, r: float32) {.importcpp: "#.set_r(#)".}

proc set_i*(this: LQuaternionf, i: float32) {.importcpp: "#.set_i(#)".}

proc set_j*(this: LQuaternionf, j: float32) {.importcpp: "#.set_j(#)".}

proc set_k*(this: LQuaternionf, k: float32) {.importcpp: "#.set_k(#)".}

proc normalize*(this: LQuaternionf): bool {.importcpp: "#.normalize()".}

proc conjugate_from*(this: LQuaternionf, other: LQuaternionf): bool {.importcpp: "#.conjugate_from(#)".} ## \
## Computes the conjugate of the other quat, and stores the result in this
## quat.  This is a fully general operation and makes no assumptions about the
## type of transform represented by the quat.
##
## The other quat must be a different object than this quat.  However, if you
## need to get a conjugate of a quat in place, see conjugate_in_place.
##
## The return value is true if the quat was successfully inverted, false if
## there was a singularity.

proc conjugate_in_place*(this: LQuaternionf): bool {.importcpp: "#.conjugate_in_place()".} ## \
## Sets this to be the conjugate of the current quat.  Returns true if the
## successful, false if the quat was singular.

proc invert_from*(this: LQuaternionf, other: LQuaternionf): bool {.importcpp: "#.invert_from(#)".} ## \
## Computes the inverse of the other quat, and stores the result in this quat.
## This is a fully general operation and makes no assumptions about the type
## of transform represented by the quat.
##
## The other quat must be a different object than this quat.  However, if you
## need to invert a quat in place, see invert_in_place.
##
## The return value is true if the quat was successfully inverted, false if
## there was a singularity.

proc invert_in_place*(this: LQuaternionf): bool {.importcpp: "#.invert_in_place()".} ## \
## Inverts the current quat.  Returns true if the inverse is successful, false
## if the quat was singular.

proc is_identity*(this: LQuaternionf): bool {.importcpp: "#.is_identity()".} ## \
## Returns true if this quaternion represents the identity transformation: no
## rotation.

proc is_almost_identity*(this: LQuaternionf, tolerance: float32): bool {.importcpp: "#.is_almost_identity(#)".} ## \
## Returns true if this quaternion represents the identity transformation
## within a given tolerance.

proc ident_quat*(_: typedesc[LQuaternionf]): LQuaternionf {.importcpp: "LQuaternionf::ident_quat()", header: "lquaternion.h".} ## \
## Returns an identity quaternion.

proc get_class_type*(_: typedesc[LQuaternionf]): TypeHandle {.importcpp: "LQuaternionf::get_class_type()", header: "lquaternion.h".}

proc initLQuaterniond*(): LQuaterniond {.importcpp: "LQuaterniond()".}

proc initLQuaterniond*(param0: LQuaterniond): LQuaterniond {.importcpp: "LQuaterniond(#)".}

proc initLQuaterniond*(copy: LVecBase4d): LQuaterniond {.importcpp: "LQuaterniond(#)".}

proc initLQuaterniond*(r: float64, copy: LVecBase3d): LQuaterniond {.importcpp: "LQuaterniond(#, #)".}

proc initLQuaterniond*(r: float64, i: float64, j: float64, k: float64): LQuaterniond {.importcpp: "LQuaterniond(#, #, #, #)".}

proc pure_imaginary*(_: typedesc[LQuaterniond], v: LVector3d): LQuaterniond {.importcpp: "LQuaterniond::pure_imaginary(#)", header: "lquaternion.h".}

proc conjugate*(this: LQuaterniond): LQuaterniond {.importcpp: "#.conjugate()".} ## \
## Returns the complex conjugate of this quat.

proc xform*(this: LQuaterniond, v: LVecBase3d): LVecBase3d {.importcpp: "#.xform(#)".} ## \
## Transforms a 3-d vector by the indicated rotation

proc xform*(this: LQuaterniond, v: LVecBase4d): LVecBase4d {.importcpp: "#.xform(#)".} ## \
## Transforms a 4-d vector by the indicated rotation

proc multiply*(this: LQuaterniond, rhs: LQuaterniond): LQuaterniond {.importcpp: "#.multiply(#)".} ## \
## actual multiply call (non virtual)

proc `-`*(this: LQuaterniond): LQuaterniond {.importcpp: "#.operator -()".}

proc `+`*(this: LQuaterniond, other: LQuaterniond): LQuaterniond {.importcpp: "#.operator +(#)".}

proc `-`*(this: LQuaterniond, other: LQuaterniond): LQuaterniond {.importcpp: "#.operator -(#)".}

proc angle_rad*(this: LQuaterniond, other: LQuaterniond): float64 {.importcpp: "#.angle_rad(#)".} ## \
## Returns the angle between the orientation represented by this quaternion
## and the other one, expressed in radians.

proc angle_deg*(this: LQuaterniond, other: LQuaterniond): float64 {.importcpp: "#.angle_deg(#)".} ## \
## Returns the angle between the orientation represented by this quaternion
## and the other one, expressed in degrees.

proc `*`*(this: LQuaterniond, param0: LMatrix3d): LMatrix3d {.importcpp: "#.operator *(#)".}

proc `*`*(this: LQuaterniond, param0: LMatrix4d): LMatrix4d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LQuaterniond, scalar: float64): LQuaterniond {.importcpp: "#.operator /(#)".}

proc `*=`*(this: LQuaterniond, param0: LQuaterniond): LQuaterniond {.importcpp: "#.operator *=(#)".}

proc almost_equal*(this: LQuaterniond, other: LQuaterniond): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two quaternions are memberwise equal within a default
## tolerance based on the numeric type.

proc almost_equal*(this: LQuaterniond, other: LQuaterniond, threshold: float64): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two quaternions are memberwise equal within a specified
## tolerance.

proc is_same_direction*(this: LQuaterniond, other: LQuaterniond): bool {.importcpp: "#.is_same_direction(#)".} ## \
## Returns true if two quaternions represent the same rotation within a
## default tolerance based on the numeric type.

proc almost_same_direction*(this: LQuaterniond, other: LQuaterniond, threshold: float64): bool {.importcpp: "#.almost_same_direction(#, #)".} ## \
## Returns true if two quaternions represent the same rotation within a
## specified tolerance.

proc output*(this: LQuaterniond, param0: ostream) {.importcpp: "#.output(#)".}

proc extract_to_matrix*(this: LQuaterniond, m: LMatrix3d) {.importcpp: "#.extract_to_matrix(#)".} ## \
## Based on the quat lib from VRPN.

proc extract_to_matrix*(this: LQuaterniond, m: LMatrix4d) {.importcpp: "#.extract_to_matrix(#)".} ## \
## Based on the quat lib from VRPN.

proc set_from_matrix*(this: LQuaterniond, m: LMatrix3d) {.importcpp: "#.set_from_matrix(#)".} ## \
## Sets the quaternion according to the rotation represented by the matrix.
## Originally we tried an algorithm presented by Do-While Jones, but that
## turned out to be broken.  This is based on the quat lib from UNC.

proc set_from_matrix*(this: LQuaterniond, m: LMatrix4d) {.importcpp: "#.set_from_matrix(#)".}

proc set_hpr*(this: LQuaterniond, hpr: LVecBase3d, cs: CoordinateSystem) {.importcpp: "#.set_hpr(#, #)".} ## \
## Sets the quaternion as the unit quaternion that is equivalent to these
## Euler angles.  (from Real-time Rendering, p.49)

proc set_hpr*(this: LQuaterniond, hpr: LVecBase3d) {.importcpp: "#.set_hpr(#)".} ## \
## Sets the quaternion as the unit quaternion that is equivalent to these
## Euler angles.  (from Real-time Rendering, p.49)

proc get_hpr*(this: LQuaterniond, cs: CoordinateSystem): LVecBase3d {.importcpp: "#.get_hpr(#)".} ## \
## Extracts the equivalent Euler angles from the unit quaternion.

proc get_hpr*(this: LQuaterniond): LVecBase3d {.importcpp: "#.get_hpr()".} ## \
## Extracts the equivalent Euler angles from the unit quaternion.

proc get_axis*(this: LQuaterniond): LVector3d {.importcpp: "#.get_axis()".} ## \
## This, along with get_angle(), returns the rotation represented by the
## quaternion as an angle about an arbitrary axis.  This returns the axis; it
## is not normalized.

proc get_axis_normalized*(this: LQuaterniond): LVector3d {.importcpp: "#.get_axis_normalized()".} ## \
## This, along with get_angle(), returns the rotation represented by the
## quaternion as an angle about an arbitrary axis.  This returns the
## normalized axis.

proc get_angle_rad*(this: LQuaterniond): float64 {.importcpp: "#.get_angle_rad()".} ## \
## This, along with get_axis(), returns the rotation represented by the
## quaternion as an angle about an arbitrary axis.  This returns the angle, in
## radians counterclockwise about the axis.
##
## It is necessary to ensure the quaternion has been normalized (for instance,
## with a call to normalize()) before calling this method.

proc get_angle*(this: LQuaterniond): float64 {.importcpp: "#.get_angle()".} ## \
## This, along with get_axis(), returns the rotation represented by the
## quaternion as an angle about an arbitrary axis.  This returns the angle, in
## degrees counterclockwise about the axis.
##
## It is necessary to ensure the quaternion has been normalized (for instance,
## with a call to normalize()) before calling this method.

proc set_from_axis_angle_rad*(this: LQuaterniond, angle_rad: float64, axis: LVector3d) {.importcpp: "#.set_from_axis_angle_rad(#, #)".} ## \
## angle_rad is the angle about the axis in radians.  axis must be normalized.

proc set_from_axis_angle*(this: LQuaterniond, angle_deg: float64, axis: LVector3d) {.importcpp: "#.set_from_axis_angle(#, #)".} ## \
## angle_deg is the angle about the axis in degrees.  axis must be normalized.

proc get_up*(this: LQuaterniond, cs: CoordinateSystem): LVector3d {.importcpp: "#.get_up(#)".} ## \
## Returns the orientation represented by this quaternion, expressed as an up
## vector.

proc get_up*(this: LQuaterniond): LVector3d {.importcpp: "#.get_up()".} ## \
## Returns the orientation represented by this quaternion, expressed as an up
## vector.

proc get_right*(this: LQuaterniond, cs: CoordinateSystem): LVector3d {.importcpp: "#.get_right(#)".} ## \
## Returns the orientation represented by this quaternion, expressed as a
## right vector.

proc get_right*(this: LQuaterniond): LVector3d {.importcpp: "#.get_right()".} ## \
## Returns the orientation represented by this quaternion, expressed as a
## right vector.

proc get_forward*(this: LQuaterniond, cs: CoordinateSystem): LVector3d {.importcpp: "#.get_forward(#)".} ## \
## Returns the orientation represented by this quaternion, expressed as a
## forward vector.

proc get_forward*(this: LQuaterniond): LVector3d {.importcpp: "#.get_forward()".} ## \
## Returns the orientation represented by this quaternion, expressed as a
## forward vector.

proc get_r*(this: LQuaterniond): float64 {.importcpp: "#.get_r()".}

proc get_i*(this: LQuaterniond): float64 {.importcpp: "#.get_i()".}

proc get_j*(this: LQuaterniond): float64 {.importcpp: "#.get_j()".}

proc get_k*(this: LQuaterniond): float64 {.importcpp: "#.get_k()".}

proc set_r*(this: LQuaterniond, r: float64) {.importcpp: "#.set_r(#)".}

proc set_i*(this: LQuaterniond, i: float64) {.importcpp: "#.set_i(#)".}

proc set_j*(this: LQuaterniond, j: float64) {.importcpp: "#.set_j(#)".}

proc set_k*(this: LQuaterniond, k: float64) {.importcpp: "#.set_k(#)".}

proc normalize*(this: LQuaterniond): bool {.importcpp: "#.normalize()".}

proc conjugate_from*(this: LQuaterniond, other: LQuaterniond): bool {.importcpp: "#.conjugate_from(#)".} ## \
## Computes the conjugate of the other quat, and stores the result in this
## quat.  This is a fully general operation and makes no assumptions about the
## type of transform represented by the quat.
##
## The other quat must be a different object than this quat.  However, if you
## need to get a conjugate of a quat in place, see conjugate_in_place.
##
## The return value is true if the quat was successfully inverted, false if
## there was a singularity.

proc conjugate_in_place*(this: LQuaterniond): bool {.importcpp: "#.conjugate_in_place()".} ## \
## Sets this to be the conjugate of the current quat.  Returns true if the
## successful, false if the quat was singular.

proc invert_from*(this: LQuaterniond, other: LQuaterniond): bool {.importcpp: "#.invert_from(#)".} ## \
## Computes the inverse of the other quat, and stores the result in this quat.
## This is a fully general operation and makes no assumptions about the type
## of transform represented by the quat.
##
## The other quat must be a different object than this quat.  However, if you
## need to invert a quat in place, see invert_in_place.
##
## The return value is true if the quat was successfully inverted, false if
## there was a singularity.

proc invert_in_place*(this: LQuaterniond): bool {.importcpp: "#.invert_in_place()".} ## \
## Inverts the current quat.  Returns true if the inverse is successful, false
## if the quat was singular.

proc is_identity*(this: LQuaterniond): bool {.importcpp: "#.is_identity()".} ## \
## Returns true if this quaternion represents the identity transformation: no
## rotation.

proc is_almost_identity*(this: LQuaterniond, tolerance: float64): bool {.importcpp: "#.is_almost_identity(#)".} ## \
## Returns true if this quaternion represents the identity transformation
## within a given tolerance.

proc ident_quat*(_: typedesc[LQuaterniond]): LQuaterniond {.importcpp: "LQuaterniond::ident_quat()", header: "lquaternion.h".} ## \
## Returns an identity quaternion.

proc get_class_type*(_: typedesc[LQuaterniond]): TypeHandle {.importcpp: "LQuaterniond::get_class_type()", header: "lquaternion.h".}

proc initLRotationf*(): LRotationf {.importcpp: "LRotationf()".}

proc initLRotationf*(m: LMatrix3f): LRotationf {.importcpp: "LRotationf(#)".} ## \
## lmatrix3

proc initLRotationf*(m: LMatrix4f): LRotationf {.importcpp: "LRotationf(#)".} ## \
## lmatrix4

proc initLRotationf*(c: LQuaternionf): LRotationf {.importcpp: "LRotationf(#)".}

proc initLRotationf*(param0: LRotationf): LRotationf {.importcpp: "LRotationf(#)".}

proc initLRotationf*(copy: LVecBase4f): LRotationf {.importcpp: "LRotationf(#)".}

proc initLRotationf*(axis: LVector3f, angle: float32): LRotationf {.importcpp: "LRotationf(#, #)".} ## \
## axis + angle (in degrees)

proc initLRotationf*(h: float32, p: float32, r: float32): LRotationf {.importcpp: "LRotationf(#, #, #)".} ## \
## Sets the rotation from the given Euler angles.

proc initLRotationf*(r: float32, i: float32, j: float32, k: float32): LRotationf {.importcpp: "LRotationf(#, #, #, #)".}

proc `*`*(this: LRotationf, other: LQuaternionf): LQuaternionf {.importcpp: "#.operator *(#)".}

proc `*`*(this: LRotationf, other: LRotationf): LRotationf {.importcpp: "#.operator *(#)".}

proc `*`*(this: LRotationf, scalar: float32): LRotationf {.importcpp: "#.operator *(#)".}

proc `/`*(this: LRotationf, scalar: float32): LRotationf {.importcpp: "#.operator /(#)".}

proc get_class_type*(_: typedesc[LRotationf]): TypeHandle {.importcpp: "LRotationf::get_class_type()", header: "lrotation.h".}

proc initLRotationd*(): LRotationd {.importcpp: "LRotationd()".}

proc initLRotationd*(m: LMatrix3d): LRotationd {.importcpp: "LRotationd(#)".} ## \
## lmatrix3

proc initLRotationd*(m: LMatrix4d): LRotationd {.importcpp: "LRotationd(#)".} ## \
## lmatrix4

proc initLRotationd*(c: LQuaterniond): LRotationd {.importcpp: "LRotationd(#)".}

proc initLRotationd*(param0: LRotationd): LRotationd {.importcpp: "LRotationd(#)".}

proc initLRotationd*(copy: LVecBase4d): LRotationd {.importcpp: "LRotationd(#)".}

proc initLRotationd*(axis: LVector3d, angle: float64): LRotationd {.importcpp: "LRotationd(#, #)".} ## \
## axis + angle (in degrees)

proc initLRotationd*(h: float64, p: float64, r: float64): LRotationd {.importcpp: "LRotationd(#, #, #)".} ## \
## Sets the rotation from the given Euler angles.

proc initLRotationd*(r: float64, i: float64, j: float64, k: float64): LRotationd {.importcpp: "LRotationd(#, #, #, #)".}

proc `*`*(this: LRotationd, other: LQuaterniond): LQuaterniond {.importcpp: "#.operator *(#)".}

proc `*`*(this: LRotationd, other: LRotationd): LRotationd {.importcpp: "#.operator *(#)".}

proc `*`*(this: LRotationd, scalar: float64): LRotationd {.importcpp: "#.operator *(#)".}

proc `/`*(this: LRotationd, scalar: float64): LRotationd {.importcpp: "#.operator /(#)".}

proc get_class_type*(_: typedesc[LRotationd]): TypeHandle {.importcpp: "LRotationd::get_class_type()", header: "lrotation.h".}

proc initLOrientationf*(): LOrientationf {.importcpp: "LOrientationf()".}

proc initLOrientationf*(m: LMatrix3f): LOrientationf {.importcpp: "LOrientationf(#)".} ## \
## matrix3

proc initLOrientationf*(m: LMatrix4f): LOrientationf {.importcpp: "LOrientationf(#)".} ## \
## matrix4

proc initLOrientationf*(param0: LOrientationf): LOrientationf {.importcpp: "LOrientationf(#)".}

proc initLOrientationf*(c: LQuaternionf): LOrientationf {.importcpp: "LOrientationf(#)".}

proc initLOrientationf*(point_at: LVector3f, twist: float32): LOrientationf {.importcpp: "LOrientationf(#, #)".} ## \
## vector + twist

proc initLOrientationf*(r: float32, i: float32, j: float32, k: float32): LOrientationf {.importcpp: "LOrientationf(#, #, #, #)".}

proc `*`*(this: LOrientationf, other: LQuaternionf): LOrientationf {.importcpp: "#.operator *(#)".}

proc `*`*(this: LOrientationf, other: LRotationf): LOrientationf {.importcpp: "#.operator *(#)".}

proc get_class_type*(_: typedesc[LOrientationf]): TypeHandle {.importcpp: "LOrientationf::get_class_type()", header: "lorientation.h".}

proc initLOrientationd*(): LOrientationd {.importcpp: "LOrientationd()".}

proc initLOrientationd*(m: LMatrix3d): LOrientationd {.importcpp: "LOrientationd(#)".} ## \
## matrix3

proc initLOrientationd*(m: LMatrix4d): LOrientationd {.importcpp: "LOrientationd(#)".} ## \
## matrix4

proc initLOrientationd*(param0: LOrientationd): LOrientationd {.importcpp: "LOrientationd(#)".}

proc initLOrientationd*(c: LQuaterniond): LOrientationd {.importcpp: "LOrientationd(#)".}

proc initLOrientationd*(point_at: LVector3d, twist: float64): LOrientationd {.importcpp: "LOrientationd(#, #)".} ## \
## vector + twist

proc initLOrientationd*(r: float64, i: float64, j: float64, k: float64): LOrientationd {.importcpp: "LOrientationd(#, #, #, #)".}

proc `*`*(this: LOrientationd, other: LQuaterniond): LOrientationd {.importcpp: "#.operator *(#)".}

proc `*`*(this: LOrientationd, other: LRotationd): LOrientationd {.importcpp: "#.operator *(#)".}

proc get_class_type*(_: typedesc[LOrientationd]): TypeHandle {.importcpp: "LOrientationd::get_class_type()", header: "lorientation.h".}

proc initConfigVariableColor*(param0: ConfigVariableColor): ConfigVariableColor {.importcpp: "ConfigVariableColor(#)".}

proc initConfigVariableColor*(name: string): ConfigVariableColor {.importcpp: "ConfigVariableColor(nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableColor*(name: string, default_value: LColor, description: string, flags: int): ConfigVariableColor {.importcpp: "ConfigVariableColor(nimStringToStdString(#), #, nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableColor*(name: string, default_value: LColor, description: string): ConfigVariableColor {.importcpp: "ConfigVariableColor(nimStringToStdString(#), #, nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableColor*(name: string, default_value: LColor): ConfigVariableColor {.importcpp: "ConfigVariableColor(nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableColor*(name: string, default_value: string, description: string, flags: int): ConfigVariableColor {.importcpp: "ConfigVariableColor(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableColor*(name: string, default_value: string, description: string): ConfigVariableColor {.importcpp: "ConfigVariableColor(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableColor*(name: string, default_value: string): ConfigVariableColor {.importcpp: "ConfigVariableColor(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc `typecast`*(this: ConfigVariableColor): LColor {.importcpp: "#.operator typecast()".}

proc `[]`*(this: ConfigVariableColor, n: int): float32 {.importcpp: "#.operator [](#)".}

proc set_value*(this: ConfigVariableColor, value: LColor) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

proc get_value*(this: ConfigVariableColor): LColor {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc get_default_value*(this: ConfigVariableColor): LColor {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

proc make_copy*(this: BoundingVolume): BoundingVolume {.importcpp: "#->make_copy()".}

proc is_empty*(this: BoundingVolume): bool {.importcpp: "#->is_empty()".} ## \
## Any kind of volume might be empty.  This is a degenerate volume that
## contains no points; it's not the same as, for instance, a sphere with
## radius zero, since that contains one point (the center).  It intersects
## with no other volumes.

proc is_infinite*(this: BoundingVolume): bool {.importcpp: "#->is_infinite()".} ## \
## The other side of the empty coin is an infinite volume.  This is a
## degenerate state of a normally finite volume that contains all points.
## (Note that some kinds of infinite bounding volumes, like binary separating
## planes, do not contain all points and thus correctly return is_infinite()
## == false, even though they are technically infinite.  This is a special
## case of the word 'infinite' meaning the volume covers all points in space.)
##
## It completely intersects with all other volumes except empty volumes.

proc set_infinite*(this: BoundingVolume) {.importcpp: "#->set_infinite()".} ## \
## Marks the volume as infinite, even if it is normally finite.  You can think
## of this as an infinite extend_by() operation.

proc extend_by*(this: BoundingVolume, vol: BoundingVolume): bool {.importcpp: "#->extend_by(#)".} ## \
## Increases the size of the volume to include the given volume.

proc contains*(this: BoundingVolume, vol: BoundingVolume): int {.importcpp: "#->contains(#)".} ## \
## Returns the appropriate set of IntersectionFlags to indicate the amount of
## intersection with the indicated volume.

proc output*(this: BoundingVolume, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: BoundingVolume, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: BoundingVolume, `out`: ostream) {.importcpp: "#->write(#)".}

proc get_class_type*(_: typedesc[BoundingVolume]): TypeHandle {.importcpp: "BoundingVolume::get_class_type()", header: "boundingVolume.h".}

proc extend_by*(this: GeometricBoundingVolume, vol: GeometricBoundingVolume): bool {.importcpp: "#->extend_by(#)".} ## \
## Increases the size of the volume to include the given volume.

proc extend_by*(this: GeometricBoundingVolume, point: LPoint3): bool {.importcpp: "#->extend_by(#)".} ## \
## Increases the size of the volume to include the given point.

proc contains*(this: GeometricBoundingVolume, vol: GeometricBoundingVolume): int {.importcpp: "#->contains(#)".} ## \
## Returns the appropriate set of IntersectionFlags to indicate the amount of
## intersection with the indicated volume.

proc contains*(this: GeometricBoundingVolume, point: LPoint3): int {.importcpp: "#->contains(#)".} ## \
## Returns the appropriate set of IntersectionFlags to indicate the amount of
## intersection with the indicated point.

proc contains*(this: GeometricBoundingVolume, a: LPoint3, b: LPoint3): int {.importcpp: "#->contains(#, #)".} ## \
## Returns the appropriate set of IntersectionFlags to indicate the amount of
## intersection with the indicated line segment.

proc get_approx_center*(this: GeometricBoundingVolume): LPoint3 {.importcpp: "#->get_approx_center()".}

proc xform*(this: GeometricBoundingVolume, mat: LMatrix4) {.importcpp: "#->xform(#)".}

proc get_class_type*(_: typedesc[GeometricBoundingVolume]): TypeHandle {.importcpp: "GeometricBoundingVolume::get_class_type()", header: "geometricBoundingVolume.h".}

proc get_min*(this: FiniteBoundingVolume): LPoint3 {.importcpp: "#->get_min()".}

proc get_max*(this: FiniteBoundingVolume): LPoint3 {.importcpp: "#->get_max()".}

proc get_volume*(this: FiniteBoundingVolume): float32 {.importcpp: "#->get_volume()".}

proc get_class_type*(_: typedesc[FiniteBoundingVolume]): TypeHandle {.importcpp: "FiniteBoundingVolume::get_class_type()", header: "finiteBoundingVolume.h".}

proc initLParabolaf*(): LParabolaf {.importcpp: "LParabolaf()".} ## \
## Constructs a meaningless degenerate parabola.

proc initLParabolaf*(copy: LParabolaf): LParabolaf {.importcpp: "LParabolaf(#)".}

proc initLParabolaf*(a: LVecBase3f, b: LVecBase3f, c: LVecBase3f): LParabolaf {.importcpp: "LParabolaf(#, #, #)".} ## \
## Constructs a parabola given the three points of the parametric equation:
## the acceleration, initial velocity, and start point.

proc xform*(this: LParabolaf, mat: LMatrix4f) {.importcpp: "#.xform(#)".} ## \
## Transforms the parabola by the indicated matrix.

proc get_a*(this: LParabolaf): LVecBase3f {.importcpp: "#.get_a()".} ## \
## Returns the first point of the parabola's parametric equation: the
## acceleration.

proc get_b*(this: LParabolaf): LVecBase3f {.importcpp: "#.get_b()".} ## \
## Returns the second point of the parabola's parametric equation: the initial
## velocity.

proc get_c*(this: LParabolaf): LVecBase3f {.importcpp: "#.get_c()".} ## \
## Returns the third point of the parabola's parametric equation: the start
## point.

proc calc_point*(this: LParabolaf, t: float32): LPoint3f {.importcpp: "#.calc_point(#)".} ## \
## Computes the point on the parabola at time t.

proc output*(this: LParabolaf, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: LParabolaf, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: LParabolaf, `out`: ostream) {.importcpp: "#.write(#)".}

proc write_datagram_fixed*(this: LParabolaf, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the parabola to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the parabola, regardless of the setting
## of Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc read_datagram_fixed*(this: LParabolaf, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the parabola from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc write_datagram*(this: LParabolaf, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the parabola to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc read_datagram*(this: LParabolaf, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the parabola from the Datagram using get_stdfloat().

proc initLParabolad*(): LParabolad {.importcpp: "LParabolad()".} ## \
## Constructs a meaningless degenerate parabola.

proc initLParabolad*(copy: LParabolad): LParabolad {.importcpp: "LParabolad(#)".}

proc initLParabolad*(a: LVecBase3d, b: LVecBase3d, c: LVecBase3d): LParabolad {.importcpp: "LParabolad(#, #, #)".} ## \
## Constructs a parabola given the three points of the parametric equation:
## the acceleration, initial velocity, and start point.

proc xform*(this: LParabolad, mat: LMatrix4d) {.importcpp: "#.xform(#)".} ## \
## Transforms the parabola by the indicated matrix.

proc get_a*(this: LParabolad): LVecBase3d {.importcpp: "#.get_a()".} ## \
## Returns the first point of the parabola's parametric equation: the
## acceleration.

proc get_b*(this: LParabolad): LVecBase3d {.importcpp: "#.get_b()".} ## \
## Returns the second point of the parabola's parametric equation: the initial
## velocity.

proc get_c*(this: LParabolad): LVecBase3d {.importcpp: "#.get_c()".} ## \
## Returns the third point of the parabola's parametric equation: the start
## point.

proc calc_point*(this: LParabolad, t: float64): LPoint3d {.importcpp: "#.calc_point(#)".} ## \
## Computes the point on the parabola at time t.

proc output*(this: LParabolad, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: LParabolad, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: LParabolad, `out`: ostream) {.importcpp: "#.write(#)".}

proc write_datagram_fixed*(this: LParabolad, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the parabola to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the parabola, regardless of the setting
## of Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc read_datagram_fixed*(this: LParabolad, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the parabola from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc write_datagram*(this: LParabolad, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the parabola to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc read_datagram*(this: LParabolad, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the parabola from the Datagram using get_stdfloat().

proc initLPlanef*(): LPlanef {.importcpp: "LPlanef()".} ## \
## Creates a default plane.  This plane happens to intersect the origin,
## perpendicular to the Z axis.  It's not clear how useful a default plane is.

proc initLPlanef*(param0: LPlanef): LPlanef {.importcpp: "LPlanef(#)".}

proc initLPlanef*(a: LPoint3f, b: LPoint3f, c: LPoint3f): LPlanef {.importcpp: "LPlanef(#, #, #)".} ## \
## Constructs a plane given three counter-clockwise points, as seen from the
## front of the plane (that is, viewed from the end of the normal vector,
## looking down).

proc initLPlanef*(copy: LVecBase4f): LPlanef {.importcpp: "LPlanef(#)".}

proc initLPlanef*(normal: LVector3f, point: LPoint3f): LPlanef {.importcpp: "LPlanef(#, #)".} ## \
## Constructs a plane given a surface normal vector and a point within the
## plane.

proc initLPlanef*(a: float32, b: float32, c: float32, d: float32): LPlanef {.importcpp: "LPlanef(#, #, #, #)".} ## \
## Constructs a plane given the four terms of the plane equation.

proc `*`*(this: LPlanef, mat: LMatrix3f): LPlanef {.importcpp: "#.operator *(#)".}

proc `*`*(this: LPlanef, mat: LMatrix4f): LPlanef {.importcpp: "#.operator *(#)".}

proc `*=`*(this: LPlanef, mat: LMatrix4f): LPlanef {.importcpp: "#.operator *=(#)".}

proc xform*(this: LPlanef, mat: LMatrix4f) {.importcpp: "#.xform(#)".} ## \
## Transforms the plane by the indicated matrix.

proc `-`*(this: LPlanef): LPlanef {.importcpp: "#.operator -()".}

proc get_reflection_mat*(this: LPlanef): LMatrix4f {.importcpp: "#.get_reflection_mat()".} ## \
## This computes a transform matrix that reflects the universe to the other
## side of the plane, as in a mirror.

proc get_normal*(this: LPlanef): LVector3f {.importcpp: "#.get_normal()".} ## \
## Returns the surface normal of the plane.

proc get_point*(this: LPlanef): LPoint3f {.importcpp: "#.get_point()".} ## \
## Returns an arbitrary point in the plane.  This can be used along with the
## normal returned by get_normal() to reconstruct the plane.

proc dist_to_plane*(this: LPlanef, point: LPoint3f): float32 {.importcpp: "#.dist_to_plane(#)".} ## \
## Returns the straight-line shortest distance from the point to the plane.
## The returned value is positive if the point is in front of the plane (on
## the side with the normal), or negative in the point is behind the plane (on
## the opposite side from the normal). It's zero if the point is exactly in
## the plane.

proc normalize*(this: LPlanef): bool {.importcpp: "#.normalize()".} ## \
## Normalizes the plane in place.  Returns true if the plane was normalized,
## false if the plane had a zero-length normal vector.

proc normalized*(this: LPlanef): LPlanef {.importcpp: "#.normalized()".} ## \
## Normalizes the plane and returns the normalized plane as a copy.  If the
## plane's normal was a zero-length vector, the same plane is returned.

proc project*(this: LPlanef, point: LPoint3f): LPoint3f {.importcpp: "#.project(#)".} ## \
## Returns the point within the plane nearest to the indicated point in space.

proc flip*(this: LPlanef) {.importcpp: "#.flip()".} ## \
## Convenience method that flips the plane in-place.  This is done by simply
## flipping the normal vector.

proc intersects_line*(this: LPlanef, intersection_point: LPoint3f, p1: LPoint3f, p2: LPoint3f): bool {.importcpp: "#.intersects_line(#, #, #)".} ## \
## Returns true if the plane intersects the infinite line passing through
## points p1 and p2, false if the line is parallel.  The points p1 and p2 are
## used only to define the Euclidean line; they have no other bearing on the
## intersection test.  If true, sets intersection_point to the point of
## intersection.

proc intersects_plane*(this: LPlanef, `from`: LPoint3f, delta: LVector3f, other: LPlanef): bool {.importcpp: "#.intersects_plane(#, #, #)".} ## \
## Returns true if the two planes intersect, false if they do not.  If they do
## intersect, then from and delta are filled in with the parametric
## representation of the line of intersection: that is, from is a point on
## that line, and delta is a vector showing the direction of the line.

proc output*(this: LPlanef, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: LPlanef, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: LPlanef, `out`: ostream) {.importcpp: "#.write(#)".}

proc initLPlaned*(): LPlaned {.importcpp: "LPlaned()".} ## \
## Creates a default plane.  This plane happens to intersect the origin,
## perpendicular to the Z axis.  It's not clear how useful a default plane is.

proc initLPlaned*(param0: LPlaned): LPlaned {.importcpp: "LPlaned(#)".}

proc initLPlaned*(a: LPoint3d, b: LPoint3d, c: LPoint3d): LPlaned {.importcpp: "LPlaned(#, #, #)".} ## \
## Constructs a plane given three counter-clockwise points, as seen from the
## front of the plane (that is, viewed from the end of the normal vector,
## looking down).

proc initLPlaned*(copy: LVecBase4d): LPlaned {.importcpp: "LPlaned(#)".}

proc initLPlaned*(normal: LVector3d, point: LPoint3d): LPlaned {.importcpp: "LPlaned(#, #)".} ## \
## Constructs a plane given a surface normal vector and a point within the
## plane.

proc initLPlaned*(a: float64, b: float64, c: float64, d: float64): LPlaned {.importcpp: "LPlaned(#, #, #, #)".} ## \
## Constructs a plane given the four terms of the plane equation.

proc `*`*(this: LPlaned, mat: LMatrix3d): LPlaned {.importcpp: "#.operator *(#)".}

proc `*`*(this: LPlaned, mat: LMatrix4d): LPlaned {.importcpp: "#.operator *(#)".}

proc `*=`*(this: LPlaned, mat: LMatrix4d): LPlaned {.importcpp: "#.operator *=(#)".}

proc xform*(this: LPlaned, mat: LMatrix4d) {.importcpp: "#.xform(#)".} ## \
## Transforms the plane by the indicated matrix.

proc `-`*(this: LPlaned): LPlaned {.importcpp: "#.operator -()".}

proc get_reflection_mat*(this: LPlaned): LMatrix4d {.importcpp: "#.get_reflection_mat()".} ## \
## This computes a transform matrix that reflects the universe to the other
## side of the plane, as in a mirror.

proc get_normal*(this: LPlaned): LVector3d {.importcpp: "#.get_normal()".} ## \
## Returns the surface normal of the plane.

proc get_point*(this: LPlaned): LPoint3d {.importcpp: "#.get_point()".} ## \
## Returns an arbitrary point in the plane.  This can be used along with the
## normal returned by get_normal() to reconstruct the plane.

proc dist_to_plane*(this: LPlaned, point: LPoint3d): float64 {.importcpp: "#.dist_to_plane(#)".} ## \
## Returns the straight-line shortest distance from the point to the plane.
## The returned value is positive if the point is in front of the plane (on
## the side with the normal), or negative in the point is behind the plane (on
## the opposite side from the normal). It's zero if the point is exactly in
## the plane.

proc normalize*(this: LPlaned): bool {.importcpp: "#.normalize()".} ## \
## Normalizes the plane in place.  Returns true if the plane was normalized,
## false if the plane had a zero-length normal vector.

proc normalized*(this: LPlaned): LPlaned {.importcpp: "#.normalized()".} ## \
## Normalizes the plane and returns the normalized plane as a copy.  If the
## plane's normal was a zero-length vector, the same plane is returned.

proc project*(this: LPlaned, point: LPoint3d): LPoint3d {.importcpp: "#.project(#)".} ## \
## Returns the point within the plane nearest to the indicated point in space.

proc flip*(this: LPlaned) {.importcpp: "#.flip()".} ## \
## Convenience method that flips the plane in-place.  This is done by simply
## flipping the normal vector.

proc intersects_line*(this: LPlaned, intersection_point: LPoint3d, p1: LPoint3d, p2: LPoint3d): bool {.importcpp: "#.intersects_line(#, #, #)".} ## \
## Returns true if the plane intersects the infinite line passing through
## points p1 and p2, false if the line is parallel.  The points p1 and p2 are
## used only to define the Euclidean line; they have no other bearing on the
## intersection test.  If true, sets intersection_point to the point of
## intersection.

proc intersects_plane*(this: LPlaned, `from`: LPoint3d, delta: LVector3d, other: LPlaned): bool {.importcpp: "#.intersects_plane(#, #, #)".} ## \
## Returns true if the two planes intersect, false if they do not.  If they do
## intersect, then from and delta are filled in with the parametric
## representation of the line of intersection: that is, from is a point on
## that line, and delta is a vector showing the direction of the line.

proc output*(this: LPlaned, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: LPlaned, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: LPlaned, `out`: ostream) {.importcpp: "#.write(#)".}

proc newBoundingBox*(): BoundingBox {.importcpp: "new BoundingBox()".} ## \
## Constructs an empty box object.

proc newBoundingBox*(min: LPoint3, max: LPoint3): BoundingBox {.importcpp: "new BoundingBox(#, #)".} ## \
## Constructs a specific box object.

proc get_num_points*(this: BoundingBox): int {.importcpp: "#->get_num_points()".} ## \
## Returns 8: the number of vertices of a rectangular solid.

proc get_point*(this: BoundingBox, n: int): LPoint3 {.importcpp: "#->get_point(#)".} ## \
## Returns the nth vertex of the rectangular solid.

proc get_num_planes*(this: BoundingBox): int {.importcpp: "#->get_num_planes()".} ## \
## Returns 6: the number of faces of a rectangular solid.

proc get_plane*(this: BoundingBox, n: int): LPlane {.importcpp: "#->get_plane(#)".} ## \
## Returns the nth face of the rectangular solid.

proc set_min_max*(this: BoundingBox, min: LPoint3, max: LPoint3) {.importcpp: "#->set_min_max(#, #)".} ## \
## Sets the min and max point of the rectangular solid.

proc get_class_type*(_: typedesc[BoundingBox]): TypeHandle {.importcpp: "BoundingBox::get_class_type()", header: "boundingBox.h".}

proc initLFrustumf*(): LFrustumf {.importcpp: "LFrustumf()".}

proc initLFrustumf*(param0: LFrustumf): LFrustumf {.importcpp: "LFrustumf(#)".}

proc make_ortho_2D*(this: LFrustumf) {.importcpp: "#.make_ortho_2D()".} ## \
## Sets up a two-dimensional orthographic frustum

proc make_ortho_2D*(this: LFrustumf, l: float32, r: float32, t: float32, b: float32) {.importcpp: "#.make_ortho_2D(#, #, #, #)".} ## \
## Sets up a two-dimensional orthographic frustum

proc make_ortho*(this: LFrustumf, fnear: float32, ffar: float32) {.importcpp: "#.make_ortho(#, #)".} ## \
## Behaves like gluOrtho

proc make_ortho*(this: LFrustumf, fnear: float32, ffar: float32, l: float32, r: float32, t: float32, b: float32) {.importcpp: "#.make_ortho(#, #, #, #, #, #)".} ## \
## Behaves like gluOrtho

proc make_perspective_hfov*(this: LFrustumf, xfov: float32, aspect: float32, fnear: float32, ffar: float32) {.importcpp: "#.make_perspective_hfov(#, #, #, #)".} ## \
## Behaves like gluPerspective (Aspect = width/height, Yfov in degrees) aspect
## +------------+ |            | 1 |            | yfov |            |
## +------------+
##
## -------+------ \     | \    | \   | \  | \ | \| W yfov

proc make_perspective_vfov*(this: LFrustumf, yfov: float32, aspect: float32, fnear: float32, ffar: float32) {.importcpp: "#.make_perspective_vfov(#, #, #, #)".}

proc make_perspective*(this: LFrustumf, xfov: float32, yfov: float32, fnear: float32, ffar: float32) {.importcpp: "#.make_perspective(#, #, #, #)".}

proc initLFrustumd*(): LFrustumd {.importcpp: "LFrustumd()".}

proc initLFrustumd*(param0: LFrustumd): LFrustumd {.importcpp: "LFrustumd(#)".}

proc make_ortho_2D*(this: LFrustumd) {.importcpp: "#.make_ortho_2D()".} ## \
## Sets up a two-dimensional orthographic frustum

proc make_ortho_2D*(this: LFrustumd, l: float64, r: float64, t: float64, b: float64) {.importcpp: "#.make_ortho_2D(#, #, #, #)".} ## \
## Sets up a two-dimensional orthographic frustum

proc make_ortho*(this: LFrustumd, fnear: float64, ffar: float64) {.importcpp: "#.make_ortho(#, #)".} ## \
## Behaves like gluOrtho

proc make_ortho*(this: LFrustumd, fnear: float64, ffar: float64, l: float64, r: float64, t: float64, b: float64) {.importcpp: "#.make_ortho(#, #, #, #, #, #)".} ## \
## Behaves like gluOrtho

proc make_perspective_hfov*(this: LFrustumd, xfov: float64, aspect: float64, fnear: float64, ffar: float64) {.importcpp: "#.make_perspective_hfov(#, #, #, #)".} ## \
## Behaves like gluPerspective (Aspect = width/height, Yfov in degrees) aspect
## +------------+ |            | 1 |            | yfov |            |
## +------------+
##
## -------+------ \     | \    | \   | \  | \ | \| W yfov

proc make_perspective_vfov*(this: LFrustumd, yfov: float64, aspect: float64, fnear: float64, ffar: float64) {.importcpp: "#.make_perspective_vfov(#, #, #, #)".}

proc make_perspective*(this: LFrustumd, xfov: float64, yfov: float64, fnear: float64, ffar: float64) {.importcpp: "#.make_perspective(#, #, #, #)".}

proc newBoundingHexahedron*(frustum: LFrustum, is_ortho: bool, cs: CoordinateSystem): BoundingHexahedron {.importcpp: "new BoundingHexahedron(#, #, #)".}

proc newBoundingHexahedron*(frustum: LFrustum, is_ortho: bool): BoundingHexahedron {.importcpp: "new BoundingHexahedron(#, #)".}

proc newBoundingHexahedron*(fll: LPoint3, flr: LPoint3, fur: LPoint3, ful: LPoint3, nll: LPoint3, nlr: LPoint3, nur: LPoint3, nul: LPoint3): BoundingHexahedron {.importcpp: "new BoundingHexahedron(#, #, #, #, #, #, #, #)".}

proc get_num_points*(this: BoundingHexahedron): int {.importcpp: "#->get_num_points()".} ## \
## Returns 8: the number of vertices of a hexahedron.

proc get_point*(this: BoundingHexahedron, n: int): LPoint3 {.importcpp: "#->get_point(#)".} ## \
## Returns the nth vertex of the hexahedron.

proc get_num_planes*(this: BoundingHexahedron): int {.importcpp: "#->get_num_planes()".} ## \
## Returns 6: the number of faces of a hexahedron.

proc get_plane*(this: BoundingHexahedron, n: int): LPlane {.importcpp: "#->get_plane(#)".} ## \
## Returns the nth face of the hexahedron.

proc get_class_type*(_: typedesc[BoundingHexahedron]): TypeHandle {.importcpp: "BoundingHexahedron::get_class_type()", header: "boundingHexahedron.h".}

proc newBoundingLine*(a: LPoint3, b: LPoint3): BoundingLine {.importcpp: "new BoundingLine(#, #)".}

proc get_point_a*(this: BoundingLine): LPoint3 {.importcpp: "#->get_point_a()".} ## \
## Returns the first point that defines the line.

proc get_point_b*(this: BoundingLine): LPoint3 {.importcpp: "#->get_point_b()".} ## \
## Returns the second point that defines the line.

proc get_class_type*(_: typedesc[BoundingLine]): TypeHandle {.importcpp: "BoundingLine::get_class_type()", header: "boundingLine.h".}

proc newBoundingPlane*(): BoundingPlane {.importcpp: "new BoundingPlane()".} ## \
## Constructs an empty "plane" that has no intersections.

proc newBoundingPlane*(plane: LPlane): BoundingPlane {.importcpp: "new BoundingPlane(#)".}

proc get_plane*(this: BoundingPlane): LPlane {.importcpp: "#->get_plane()".}

proc get_class_type*(_: typedesc[BoundingPlane]): TypeHandle {.importcpp: "BoundingPlane::get_class_type()", header: "boundingPlane.h".}

proc newBoundingSphere*(): BoundingSphere {.importcpp: "new BoundingSphere()".} ## \
## Constructs an empty sphere.

proc newBoundingSphere*(center: LPoint3, radius: float32): BoundingSphere {.importcpp: "new BoundingSphere(#, #)".} ## \
## Constructs a specific sphere.

proc get_center*(this: BoundingSphere): LPoint3 {.importcpp: "#->get_center()".}

proc get_radius*(this: BoundingSphere): float32 {.importcpp: "#->get_radius()".}

proc set_center*(this: BoundingSphere, center: LPoint3) {.importcpp: "#->set_center(#)".} ## \
## Sets the center point of the sphere.

proc set_radius*(this: BoundingSphere, radius: float32) {.importcpp: "#->set_radius(#)".} ## \
## Sets the radius of the sphere.

proc get_class_type*(_: typedesc[BoundingSphere]): TypeHandle {.importcpp: "BoundingSphere::get_class_type()", header: "boundingSphere.h".}

proc newIntersectionBoundingVolume*(): IntersectionBoundingVolume {.importcpp: "new IntersectionBoundingVolume()".} ## \
## Constructs an empty intersection.

proc get_num_components*(this: IntersectionBoundingVolume): int {.importcpp: "#->get_num_components()".} ## \
## Returns the number of components in the intersection.

proc get_component*(this: IntersectionBoundingVolume, n: int): GeometricBoundingVolume {.importcpp: "#->get_component(#)".} ## \
## Returns the nth component in the intersection.

proc clear_components*(this: IntersectionBoundingVolume) {.importcpp: "#->clear_components()".} ## \
## Removes all components from the volume.

proc add_component*(this: IntersectionBoundingVolume, component: GeometricBoundingVolume) {.importcpp: "#->add_component(#)".} ## \
## Adds a new component to the volume.  This does not necessarily increase the
## total number of components by one, and you may or may not be able to find
## this component in the volume by a subsequent call to get_component();
## certain optimizations may prevent the component from being added, or have
## other unexpected effects on the total set of components.

proc get_class_type*(_: typedesc[IntersectionBoundingVolume]): TypeHandle {.importcpp: "IntersectionBoundingVolume::get_class_type()", header: "intersectionBoundingVolume.h".}

proc heads_up*(mat: LMatrix3d, fwd: LVector3d, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #)".}

proc heads_up*(mat: LMatrix3d, fwd: LVector3d, up: LVector3d, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #, #)".}

proc heads_up*(mat: LMatrix3d, fwd: LVector3d, up: LVector3d) {.importcpp: "heads_up(#, #, #)".}

proc heads_up*(mat: LMatrix3d, fwd: LVector3d) {.importcpp: "heads_up(#, #)".}

proc heads_up*(mat: LMatrix3f, fwd: LVector3f, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #)".}

proc heads_up*(mat: LMatrix3f, fwd: LVector3f, up: LVector3f, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #, #)".}

proc heads_up*(mat: LMatrix3f, fwd: LVector3f, up: LVector3f) {.importcpp: "heads_up(#, #, #)".}

proc heads_up*(mat: LMatrix3f, fwd: LVector3f) {.importcpp: "heads_up(#, #)".}

proc heads_up*(mat: LMatrix4d, fwd: LVector3d, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #)".}

proc heads_up*(mat: LMatrix4d, fwd: LVector3d, up: LVector3d, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #, #)".}

proc heads_up*(mat: LMatrix4d, fwd: LVector3d, up: LVector3d) {.importcpp: "heads_up(#, #, #)".}

proc heads_up*(mat: LMatrix4d, fwd: LVector3d) {.importcpp: "heads_up(#, #)".}

proc heads_up*(mat: LMatrix4f, fwd: LVector3f, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #)".}

proc heads_up*(mat: LMatrix4f, fwd: LVector3f, up: LVector3f, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #, #)".}

proc heads_up*(mat: LMatrix4f, fwd: LVector3f, up: LVector3f) {.importcpp: "heads_up(#, #, #)".}

proc heads_up*(mat: LMatrix4f, fwd: LVector3f) {.importcpp: "heads_up(#, #)".}

proc heads_up*(quat: LQuaterniond, fwd: LVector3d, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #)".}

proc heads_up*(quat: LQuaterniond, fwd: LVector3d, up: LVector3d, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #, #)".}

proc heads_up*(quat: LQuaterniond, fwd: LVector3d, up: LVector3d) {.importcpp: "heads_up(#, #, #)".}

proc heads_up*(quat: LQuaterniond, fwd: LVector3d) {.importcpp: "heads_up(#, #)".}

proc heads_up*(quat: LQuaternionf, fwd: LVector3f, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #)".}

proc heads_up*(quat: LQuaternionf, fwd: LVector3f, up: LVector3f, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #, #)".}

proc heads_up*(quat: LQuaternionf, fwd: LVector3f, up: LVector3f) {.importcpp: "heads_up(#, #, #)".}

proc heads_up*(quat: LQuaternionf, fwd: LVector3f) {.importcpp: "heads_up(#, #)".}

proc look_at*(mat: LMatrix3d, fwd: LVector3d, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #)".}

proc look_at*(mat: LMatrix3d, fwd: LVector3d, up: LVector3d, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #, #)".}

proc look_at*(mat: LMatrix3d, fwd: LVector3d, up: LVector3d) {.importcpp: "look_at(#, #, #)".}

proc look_at*(mat: LMatrix3d, fwd: LVector3d) {.importcpp: "look_at(#, #)".}

proc look_at*(mat: LMatrix3f, fwd: LVector3f, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #)".}

proc look_at*(mat: LMatrix3f, fwd: LVector3f, up: LVector3f, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #, #)".}

proc look_at*(mat: LMatrix3f, fwd: LVector3f, up: LVector3f) {.importcpp: "look_at(#, #, #)".}

proc look_at*(mat: LMatrix3f, fwd: LVector3f) {.importcpp: "look_at(#, #)".}

proc look_at*(mat: LMatrix4d, fwd: LVector3d, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #)".}

proc look_at*(mat: LMatrix4d, fwd: LVector3d, up: LVector3d, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #, #)".}

proc look_at*(mat: LMatrix4d, fwd: LVector3d, up: LVector3d) {.importcpp: "look_at(#, #, #)".}

proc look_at*(mat: LMatrix4d, fwd: LVector3d) {.importcpp: "look_at(#, #)".}

proc look_at*(mat: LMatrix4f, fwd: LVector3f, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #)".}

proc look_at*(mat: LMatrix4f, fwd: LVector3f, up: LVector3f, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #, #)".}

proc look_at*(mat: LMatrix4f, fwd: LVector3f, up: LVector3f) {.importcpp: "look_at(#, #, #)".}

proc look_at*(mat: LMatrix4f, fwd: LVector3f) {.importcpp: "look_at(#, #)".}

proc look_at*(quat: LQuaterniond, fwd: LVector3d, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #)".}

proc look_at*(quat: LQuaterniond, fwd: LVector3d, up: LVector3d, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #, #)".}

proc look_at*(quat: LQuaterniond, fwd: LVector3d, up: LVector3d) {.importcpp: "look_at(#, #, #)".}

proc look_at*(quat: LQuaterniond, fwd: LVector3d) {.importcpp: "look_at(#, #)".}

proc look_at*(quat: LQuaternionf, fwd: LVector3f, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #)".}

proc look_at*(quat: LQuaternionf, fwd: LVector3f, up: LVector3f, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #, #)".}

proc look_at*(quat: LQuaternionf, fwd: LVector3f, up: LVector3f) {.importcpp: "look_at(#, #, #)".}

proc look_at*(quat: LQuaternionf, fwd: LVector3f) {.importcpp: "look_at(#, #)".}

proc initMersenne*(param0: Mersenne): Mersenne {.importcpp: "Mersenne(#)".}

proc initMersenne*(seed: int): Mersenne {.importcpp: "Mersenne(#)".} ## \
## initializes mt[N] with a seed */

proc get_uint31*(this: Mersenne): int {.importcpp: "#.get_uint31()".} ## \
## generates a random number on [0,0x7fffffff]-interval */

proc newOmniBoundingVolume*(): OmniBoundingVolume {.importcpp: "new OmniBoundingVolume()".}

proc get_class_type*(_: typedesc[OmniBoundingVolume]): TypeHandle {.importcpp: "OmniBoundingVolume::get_class_type()", header: "omniBoundingVolume.h".}

proc newUnionBoundingVolume*(): UnionBoundingVolume {.importcpp: "new UnionBoundingVolume()".} ## \
## Constructs an empty union.

proc get_num_components*(this: UnionBoundingVolume): int {.importcpp: "#->get_num_components()".} ## \
## Returns the number of components in the union.

proc get_component*(this: UnionBoundingVolume, n: int): GeometricBoundingVolume {.importcpp: "#->get_component(#)".} ## \
## Returns the nth component in the union.

proc clear_components*(this: UnionBoundingVolume) {.importcpp: "#->clear_components()".} ## \
## Removes all components from the volume.

proc add_component*(this: UnionBoundingVolume, component: GeometricBoundingVolume) {.importcpp: "#->add_component(#)".} ## \
## Adds a new component to the volume.  This does not necessarily increase the
## total number of components by one, and you may or may not be able to find
## this component in the volume by a subsequent call to get_component();
## certain optimizations may prevent the component from being added, or have
## other unexpected effects on the total set of components.

proc filter_intersection*(this: UnionBoundingVolume, volume: BoundingVolume) {.importcpp: "#->filter_intersection(#)".} ## \
## Removes from the union any components that have no intersection with the
## indicated volume.

proc get_class_type*(_: typedesc[UnionBoundingVolume]): TypeHandle {.importcpp: "UnionBoundingVolume::get_class_type()", header: "unionBoundingVolume.h".}

proc initRandomizer*(copy: Randomizer): Randomizer {.importcpp: "Randomizer(#)".}

proc initRandomizer*(seed: int): Randomizer {.importcpp: "Randomizer(#)".} ## \
## If seed is nonzero, it is used to define the tables; if it is zero a random
## seed is generated.

proc initRandomizer*(): Randomizer {.importcpp: "Randomizer()".} ## \
## If seed is nonzero, it is used to define the tables; if it is zero a random
## seed is generated.

proc random_int*(this: Randomizer, range: int): int {.importcpp: "#.random_int(#)".} ## \
## Returns a random integer in the range [0, range).

proc random_real*(this: Randomizer, range: float64): float64 {.importcpp: "#.random_real(#)".} ## \
## Returns a random double in the range [0, range).

proc random_real_unit*(this: Randomizer): float64 {.importcpp: "#.random_real_unit()".} ## \
## Returns a random double in the range [-0.5, 0.5).

proc get_next_seed*(_: typedesc[Randomizer]): int {.importcpp: "Randomizer::get_next_seed()", header: "randomizer.h".} ## \
## Returns a random seed value for the next global Randomizer object.

proc get_seed*(this: Randomizer): int {.importcpp: "#.get_seed()".} ## \
## Returns a unique seed value based on the seed value passed to this
## Randomizer object (and on its current state).

proc get_seed*(this: PerlinNoise): int {.importcpp: "#.get_seed()".} ## \
## Returns a unique seed value based on the seed value passed to this
## PerlinNoise object (and on its current state).

proc initPerlinNoise2*(): PerlinNoise2 {.importcpp: "PerlinNoise2()".} ## \
## Randomizes the tables to make a unique noise function.  Uses a default
## scale (noise frequency), table size, and seed.

proc initPerlinNoise2*(copy: PerlinNoise2): PerlinNoise2 {.importcpp: "PerlinNoise2(#)".} ## \
## Makes an exact copy of the existing PerlinNoise object, including its
## random seed.

proc initPerlinNoise2*(sx: float64, sy: float64, table_size: int, seed: int): PerlinNoise2 {.importcpp: "PerlinNoise2(#, #, #, #)".} ## \
## Randomizes the tables to make a unique noise function.
##
## If seed is nonzero, it is used to define the tables; if it is zero a random
## seed is generated.

proc initPerlinNoise2*(sx: float64, sy: float64, table_size: int): PerlinNoise2 {.importcpp: "PerlinNoise2(#, #, #)".} ## \
## Randomizes the tables to make a unique noise function.
##
## If seed is nonzero, it is used to define the tables; if it is zero a random
## seed is generated.

proc initPerlinNoise2*(sx: float64, sy: float64): PerlinNoise2 {.importcpp: "PerlinNoise2(#, #)".} ## \
## Randomizes the tables to make a unique noise function.
##
## If seed is nonzero, it is used to define the tables; if it is zero a random
## seed is generated.

proc set_scale*(this: PerlinNoise2, scale: LVecBase2d) {.importcpp: "#.set_scale(#)".} ## \
## Changes the scale (frequency) of the noise.

proc set_scale*(this: PerlinNoise2, scale: LVecBase2f) {.importcpp: "#.set_scale(#)".} ## \
## Changes the scale (frequency) of the noise.

proc set_scale*(this: PerlinNoise2, scale: float64) {.importcpp: "#.set_scale(#)".} ## \
## Changes the scale (frequency) of the noise.

proc set_scale*(this: PerlinNoise2, sx: float64, sy: float64) {.importcpp: "#.set_scale(#, #)".} ## \
## Changes the scale (frequency) of the noise.

proc noise*(this: PerlinNoise2, value: LVecBase2d): float64 {.importcpp: "#.noise(#)".} ## \
## Returns the noise function of the three inputs.

proc noise*(this: PerlinNoise2, value: LVecBase2f): float32 {.importcpp: "#.noise(#)".} ## \
## Returns the noise function of the three inputs.

proc noise*(this: PerlinNoise2, x: float64, y: float64): float64 {.importcpp: "#.noise(#, #)".} ## \
## Returns the noise function of the three inputs.

proc initPerlinNoise3*(): PerlinNoise3 {.importcpp: "PerlinNoise3()".} ## \
## Randomizes the tables to make a unique noise function.  Uses a default
## scale (noise frequency), table size, and seed.

proc initPerlinNoise3*(copy: PerlinNoise3): PerlinNoise3 {.importcpp: "PerlinNoise3(#)".} ## \
## Makes an exact copy of the existing PerlinNoise object, including its
## random seed.

proc initPerlinNoise3*(sx: float64, sy: float64, sz: float64, table_size: int, seed: int): PerlinNoise3 {.importcpp: "PerlinNoise3(#, #, #, #, #)".} ## \
## Randomizes the tables to make a unique noise function.
##
## If seed is nonzero, it is used to define the tables; if it is zero a random
## seed is generated.

proc initPerlinNoise3*(sx: float64, sy: float64, sz: float64, table_size: int): PerlinNoise3 {.importcpp: "PerlinNoise3(#, #, #, #)".} ## \
## Randomizes the tables to make a unique noise function.
##
## If seed is nonzero, it is used to define the tables; if it is zero a random
## seed is generated.

proc initPerlinNoise3*(sx: float64, sy: float64, sz: float64): PerlinNoise3 {.importcpp: "PerlinNoise3(#, #, #)".} ## \
## Randomizes the tables to make a unique noise function.
##
## If seed is nonzero, it is used to define the tables; if it is zero a random
## seed is generated.

proc set_scale*(this: PerlinNoise3, scale: LVecBase3d) {.importcpp: "#.set_scale(#)".} ## \
## Changes the scale (frequency) of the noise.

proc set_scale*(this: PerlinNoise3, scale: LVecBase3f) {.importcpp: "#.set_scale(#)".} ## \
## Changes the scale (frequency) of the noise.

proc set_scale*(this: PerlinNoise3, scale: float64) {.importcpp: "#.set_scale(#)".} ## \
## Changes the scale (frequency) of the noise.

proc set_scale*(this: PerlinNoise3, sx: float64, sy: float64, sz: float64) {.importcpp: "#.set_scale(#, #, #)".} ## \
## Changes the scale (frequency) of the noise.

proc noise*(this: PerlinNoise3, value: LVecBase3d): float64 {.importcpp: "#.noise(#)".} ## \
## Returns the noise function of the three inputs.

proc noise*(this: PerlinNoise3, value: LVecBase3f): float32 {.importcpp: "#.noise(#)".} ## \
## Returns the noise function of the three inputs.

proc noise*(this: PerlinNoise3, x: float64, y: float64, z: float64): float64 {.importcpp: "#.noise(#, #, #)".} ## \
## Returns the noise function of the three inputs.

proc rotate_to*(mat: LMatrix3d, a: LVector3d, b: LVector3d) {.importcpp: "rotate_to(#, #, #)".}

proc rotate_to*(mat: LMatrix3f, a: LVector3f, b: LVector3f) {.importcpp: "rotate_to(#, #, #)".}

proc rotate_to*(mat: LMatrix4d, a: LVector3d, b: LVector3d) {.importcpp: "rotate_to(#, #, #)".}

proc rotate_to*(mat: LMatrix4f, a: LVector3f, b: LVector3f) {.importcpp: "rotate_to(#, #, #)".}

proc initStackedPerlinNoise2*(): StackedPerlinNoise2 {.importcpp: "StackedPerlinNoise2()".} ## \
## Creates a StackedPerlinNoise2 object with no levels.  You should call
## add_level() to add each level by hand.

proc initStackedPerlinNoise2*(copy: StackedPerlinNoise2): StackedPerlinNoise2 {.importcpp: "StackedPerlinNoise2(#)".} ## \
## Creates an exact duplicate of the existing StackedPerlinNoise2 object,
## including the random seed.

proc initStackedPerlinNoise2*(sx: float64, sy: float64, num_levels: int, scale_factor: float64, amp_scale: float64, table_size: int, seed: int): StackedPerlinNoise2 {.importcpp: "StackedPerlinNoise2(#, #, #, #, #, #, #)".} ## \
## Creates num_levels nested PerlinNoise2 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise2*(sx: float64, sy: float64, num_levels: int, scale_factor: float64, amp_scale: float64, table_size: int): StackedPerlinNoise2 {.importcpp: "StackedPerlinNoise2(#, #, #, #, #, #)".} ## \
## Creates num_levels nested PerlinNoise2 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise2*(sx: float64, sy: float64, num_levels: int, scale_factor: float64, amp_scale: float64): StackedPerlinNoise2 {.importcpp: "StackedPerlinNoise2(#, #, #, #, #)".} ## \
## Creates num_levels nested PerlinNoise2 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise2*(sx: float64, sy: float64, num_levels: int, scale_factor: float64): StackedPerlinNoise2 {.importcpp: "StackedPerlinNoise2(#, #, #, #)".} ## \
## Creates num_levels nested PerlinNoise2 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise2*(sx: float64, sy: float64, num_levels: int): StackedPerlinNoise2 {.importcpp: "StackedPerlinNoise2(#, #, #)".} ## \
## Creates num_levels nested PerlinNoise2 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise2*(sx: float64, sy: float64): StackedPerlinNoise2 {.importcpp: "StackedPerlinNoise2(#, #)".} ## \
## Creates num_levels nested PerlinNoise2 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc add_level*(this: StackedPerlinNoise2, level: PerlinNoise2, amp: float64) {.importcpp: "#.add_level(#, #)".} ## \
## Adds an arbitrary PerlinNoise2 object, and an associated amplitude, to the
## stack.

proc add_level*(this: StackedPerlinNoise2, level: PerlinNoise2) {.importcpp: "#.add_level(#)".} ## \
## Adds an arbitrary PerlinNoise2 object, and an associated amplitude, to the
## stack.

proc clear*(this: StackedPerlinNoise2) {.importcpp: "#.clear()".} ## \
## Removes all levels from the stack.  You must call add_level() again to
## restore them.

proc noise*(this: StackedPerlinNoise2, value: LVecBase2d): float64 {.importcpp: "#.noise(#)".} ## \
## Returns the noise function of the three inputs.

proc noise*(this: StackedPerlinNoise2, value: LVecBase2f): float32 {.importcpp: "#.noise(#)".} ## \
## Returns the noise function of the three inputs.

proc noise*(this: StackedPerlinNoise2, x: float64, y: float64): float64 {.importcpp: "#.noise(#, #)".} ## \
## Returns the noise function of the three inputs.

proc initStackedPerlinNoise3*(): StackedPerlinNoise3 {.importcpp: "StackedPerlinNoise3()".} ## \
## Creates a StackedPerlinNoise3 object with no levels.  You should call
## add_level() to add each level by hand.

proc initStackedPerlinNoise3*(copy: StackedPerlinNoise3): StackedPerlinNoise3 {.importcpp: "StackedPerlinNoise3(#)".} ## \
## Creates an exact duplicate of the existing StackedPerlinNoise3 object,
## including the random seed.

proc initStackedPerlinNoise3*(sx: float64, sy: float64, sz: float64, num_levels: int, scale_factor: float64, amp_scale: float64, table_size: int, seed: int): StackedPerlinNoise3 {.importcpp: "StackedPerlinNoise3(#, #, #, #, #, #, #, #)".} ## \
## Creates num_levels nested PerlinNoise3 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise3*(sx: float64, sy: float64, sz: float64, num_levels: int, scale_factor: float64, amp_scale: float64, table_size: int): StackedPerlinNoise3 {.importcpp: "StackedPerlinNoise3(#, #, #, #, #, #, #)".} ## \
## Creates num_levels nested PerlinNoise3 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise3*(sx: float64, sy: float64, sz: float64, num_levels: int, scale_factor: float64, amp_scale: float64): StackedPerlinNoise3 {.importcpp: "StackedPerlinNoise3(#, #, #, #, #, #)".} ## \
## Creates num_levels nested PerlinNoise3 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise3*(sx: float64, sy: float64, sz: float64, num_levels: int, scale_factor: float64): StackedPerlinNoise3 {.importcpp: "StackedPerlinNoise3(#, #, #, #, #)".} ## \
## Creates num_levels nested PerlinNoise3 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise3*(sx: float64, sy: float64, sz: float64, num_levels: int): StackedPerlinNoise3 {.importcpp: "StackedPerlinNoise3(#, #, #, #)".} ## \
## Creates num_levels nested PerlinNoise3 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise3*(sx: float64, sy: float64, sz: float64): StackedPerlinNoise3 {.importcpp: "StackedPerlinNoise3(#, #, #)".} ## \
## Creates num_levels nested PerlinNoise3 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc add_level*(this: StackedPerlinNoise3, level: PerlinNoise3, amp: float64) {.importcpp: "#.add_level(#, #)".} ## \
## Adds an arbitrary PerlinNoise3 object, and an associated amplitude, to the
## stack.

proc add_level*(this: StackedPerlinNoise3, level: PerlinNoise3) {.importcpp: "#.add_level(#)".} ## \
## Adds an arbitrary PerlinNoise3 object, and an associated amplitude, to the
## stack.

proc clear*(this: StackedPerlinNoise3) {.importcpp: "#.clear()".} ## \
## Removes all levels from the stack.  You must call add_level() again to
## restore them.

proc noise*(this: StackedPerlinNoise3, value: LVecBase3d): float64 {.importcpp: "#.noise(#)".} ## \
## Returns the noise function of the three inputs.

proc noise*(this: StackedPerlinNoise3, value: LVecBase3f): float32 {.importcpp: "#.noise(#)".} ## \
## Returns the noise function of the three inputs.

proc noise*(this: StackedPerlinNoise3, x: float64, y: float64, z: float64): float64 {.importcpp: "#.noise(#, #, #)".} ## \
## Returns the noise function of the three inputs.

proc initTriangulator*(): Triangulator {.importcpp: "Triangulator()".}

proc initTriangulator*(param0: Triangulator): Triangulator {.importcpp: "Triangulator(#)".}

proc clear*(this: Triangulator) {.importcpp: "#.clear()".} ## \
## Removes all vertices and polygon specifications from the Triangulator, and
## prepares it to start over.

proc add_vertex*(this: Triangulator, point: LPoint2d): int {.importcpp: "#.add_vertex(#)".} ## \
## Adds a new vertex to the vertex pool.  Returns the vertex index number.

proc add_vertex*(this: Triangulator, x: float64, y: float64): int {.importcpp: "#.add_vertex(#, #)".} ## \
## Adds a new vertex to the vertex pool.  Returns the vertex index number.

proc get_num_vertices*(this: Triangulator): int {.importcpp: "#.get_num_vertices()".} ## \
## Returns the number of vertices in the pool.  Note that the Triangulator
## might append new vertices, in addition to those added by the user, if any
## of the polygon is self-intersecting, or if any of the holes intersect some
## part of the polygon edges.

proc get_vertex*(this: Triangulator, n: int): LPoint2d {.importcpp: "#.get_vertex(#)".} ## \
## Returns the nth vertex.

proc clear_polygon*(this: Triangulator) {.importcpp: "#.clear_polygon()".} ## \
## Removes the current polygon definition (and its set of holes), but does not
## clear the vertex pool.

proc add_polygon_vertex*(this: Triangulator, index: int) {.importcpp: "#.add_polygon_vertex(#)".} ## \
## Adds the next consecutive vertex of the polygon.  This vertex should index
## into the vertex pool established by repeated calls to add_vertex().
##
## The vertices may be listed in either clockwise or counterclockwise order.
## Vertices should not be repeated.  In particular, do not repeat the first
## vertex at the end.

proc is_left_winding*(this: Triangulator): bool {.importcpp: "#.is_left_winding()".} ## \
## Returns true if the polygon vertices are listed in counterclockwise order,
## or false if they appear to be listed in clockwise order.

proc begin_hole*(this: Triangulator) {.importcpp: "#.begin_hole()".} ## \
## Finishes the previous hole, if any, and prepares to add a new hole.

proc add_hole_vertex*(this: Triangulator, index: int) {.importcpp: "#.add_hole_vertex(#)".} ## \
## Adds the next consecutive vertex of the current hole.  This vertex should
## index into the vertex pool established by repeated calls to add_vertex().
##
## The vertices may be listed in either clockwise or counterclockwise order.
## Vertices should not be repeated.

proc triangulate*(this: Triangulator) {.importcpp: "#.triangulate()".} ## \
## Does the work of triangulating the specified polygon.  After this call, you
## may retrieve the new triangles one at a time by iterating through
## get_triangle_v0/1/2().

proc get_num_triangles*(this: Triangulator): int {.importcpp: "#.get_num_triangles()".} ## \
## Returns the number of triangles generated by the previous call to
## triangulate().

proc get_triangle_v0*(this: Triangulator, n: int): int {.importcpp: "#.get_triangle_v0(#)".} ## \
## Returns vertex 0 of the nth triangle generated by the previous call to
## triangulate().
##
## This is a zero-based index into the vertices added by repeated calls to
## add_vertex().

proc get_triangle_v1*(this: Triangulator, n: int): int {.importcpp: "#.get_triangle_v1(#)".} ## \
## Returns vertex 1 of the nth triangle generated by the previous call to
## triangulate().
##
## This is a zero-based index into the vertices added by repeated calls to
## add_vertex().

proc get_triangle_v2*(this: Triangulator, n: int): int {.importcpp: "#.get_triangle_v2(#)".} ## \
## Returns vertex 2 of the nth triangle generated by the previous call to
## triangulate().
##
## This is a zero-based index into the vertices added by repeated calls to
## add_vertex().

proc initTriangulator3*(): Triangulator3 {.importcpp: "Triangulator3()".}

proc initTriangulator3*(param0: Triangulator3): Triangulator3 {.importcpp: "Triangulator3(#)".}

proc clear*(this: Triangulator3) {.importcpp: "#.clear()".} ## \
## Removes all vertices and polygon specifications from the Triangulator, and
## prepares it to start over.

proc add_vertex*(this: Triangulator3, point: LPoint3d): int {.importcpp: "#.add_vertex(#)".} ## \
## Adds a new vertex to the vertex pool.  Returns the vertex index number.

proc add_vertex*(this: Triangulator3, x: float64, y: float64, z: float64): int {.importcpp: "#.add_vertex(#, #, #)".} ## \
## Adds a new vertex to the vertex pool.  Returns the vertex index number.

proc get_num_vertices*(this: Triangulator3): int {.importcpp: "#.get_num_vertices()".} ## \
## Returns the number of vertices in the pool.  Note that the Triangulator
## might append new vertices, in addition to those added by the user, if any
## of the polygon is self-intersecting, or if any of the holes intersect some
## part of the polygon edges.

proc get_vertex*(this: Triangulator3, n: int): LPoint3d {.importcpp: "#.get_vertex(#)".} ## \
## Returns the nth vertex.

proc triangulate*(this: Triangulator3) {.importcpp: "#.triangulate()".} ## \
## Does the work of triangulating the specified polygon.  After this call, you
## may retrieve the new triangles one at a time by iterating through
## get_triangle_v0/1/2().

proc get_plane*(this: Triangulator3): LPlaned {.importcpp: "#.get_plane()".} ## \
## Returns the plane of the polygon.  This is only available after calling
## triangulate().

proc is_valid*(this: ParametricCurve): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the curve is defined.  This base class function always
## returns true; derived classes might override this to sometimes return
## false.

proc get_max_t*(this: ParametricCurve): float32 {.importcpp: "#->get_max_t()".} ## \
## Returns the upper bound of t for the entire curve.  The curve is defined in
## the range 0.0f <= t <= get_max_t().  This base class function always
## returns 1.0f; derived classes might override this to return something else.

proc set_curve_type*(this: ParametricCurve, `type`: int) {.importcpp: "#->set_curve_type(#)".} ## \
## Sets the flag indicating the use to which the curve is intended to be put.
## This flag is optional and only serves to provide a hint to the egg reader
## and writer code; it has no effect on the curve's behavior.
##
## Setting the curve type also sets the num_dimensions to 3 or 1 according to
## the type.
##
## THis flag may have one of the values PCT_XYZ, PCT_HPR, or PCT_T.

proc get_curve_type*(this: ParametricCurve): int {.importcpp: "#->get_curve_type()".} ## \
## Returns the flag indicating the use to which the curve is intended to be
## put.

proc set_num_dimensions*(this: ParametricCurve, num: int) {.importcpp: "#->set_num_dimensions(#)".} ## \
## Specifies the number of significant dimensions in the curve's vertices.
## This should be one of 1, 2, or 3. Normally, XYZ and HPR curves have three
## dimensions; time curves should always have one dimension.  This only serves
## as a hint to the mopath editor, and also controls how the curve is written
## out.

proc get_num_dimensions*(this: ParametricCurve): int {.importcpp: "#->get_num_dimensions()".} ## \
## Returns the number of significant dimensions in the curve's vertices, as
## set by a previous call to set_num_dimensions().  This is only a hint as to
## how the curve is intended to be used; the actual number of dimensions of
## any curve is always three.

proc calc_length*(this: ParametricCurve): float32 {.importcpp: "#->calc_length()".} ## \
## Approximates the length of the entire curve to within a few decimal places.

proc calc_length*(this: ParametricCurve, `from`: float32, to: float32): float32 {.importcpp: "#->calc_length(#, #)".} ## \
## Approximates the length of the curve segment from parametric time 'from' to
## time 'to'.

proc find_length*(this: ParametricCurve, start_t: float32, length_offset: float32): float32 {.importcpp: "#->find_length(#, #)".} ## \
## Returns the parametric value corresponding to the indicated distance along
## the curve from the starting parametric value.
##
## This is the inverse of calc_length(): rather than determining the length
## along the curve between two parametric points, it determines the position
## in parametric time of a point n units along the curve.
##
## The search distance must not be negative.

proc get_point*(this: ParametricCurve, t: float32, point: LVecBase3): bool {.importcpp: "#->get_point(#, #)".}

proc get_tangent*(this: ParametricCurve, t: float32, tangent: LVecBase3): bool {.importcpp: "#->get_tangent(#, #)".}

proc get_pt*(this: ParametricCurve, t: float32, point: LVecBase3, tangent: LVecBase3): bool {.importcpp: "#->get_pt(#, #, #)".}

proc get_2ndtangent*(this: ParametricCurve, t: float32, tangent2: LVecBase3): bool {.importcpp: "#->get_2ndtangent(#, #)".}

proc adjust_point*(this: ParametricCurve, t: float32, px: float32, py: float32, pz: float32): bool {.importcpp: "#->adjust_point(#, #, #, #)".} ## \
## Recomputes the curve such that it passes through the point (px, py, pz) at
## time t, but keeps the same tangent value at that point.

proc adjust_tangent*(this: ParametricCurve, t: float32, tx: float32, ty: float32, tz: float32): bool {.importcpp: "#->adjust_tangent(#, #, #, #)".} ## \
## Recomputes the curve such that it has the tangent (tx, ty, tz) at time t,
## but keeps the same position at the point.

proc adjust_pt*(this: ParametricCurve, t: float32, px: float32, py: float32, pz: float32, tx: float32, ty: float32, tz: float32): bool {.importcpp: "#->adjust_pt(#, #, #, #, #, #, #)".} ## \
## Recomputes the curve such that it passes through the point (px, py, pz)
## with the tangent (tx, ty, tz).

proc recompute*(this: ParametricCurve): bool {.importcpp: "#->recompute()".} ## \
## Recalculates the curve, if necessary.  Returns true if the resulting curve
## is valid, false otherwise.

proc stitch*(this: ParametricCurve, a: ParametricCurve, b: ParametricCurve): bool {.importcpp: "#->stitch(#, #)".} ## \
## Regenerates this curve as one long curve: the first curve connected end-to-
## end with the second one.  Either a or b may be the same as 'this'.
##
## Returns true if successful, false on failure or if the curve type does not
## support stitching.

proc write_egg*(this: ParametricCurve, filename: Filename, cs: CoordinateSystem): bool {.importcpp: "#->write_egg(#, #)".} ## \
## Writes an egg description of the nurbs curve to the specified output file.
## Returns true if the file is successfully written.

proc write_egg*(this: ParametricCurve, filename: Filename): bool {.importcpp: "#->write_egg(#)".} ## \
## Writes an egg description of the nurbs curve to the specified output file.
## Returns true if the file is successfully written.

proc write_egg*(this: ParametricCurve, `out`: ostream, filename: Filename, cs: CoordinateSystem): bool {.importcpp: "#->write_egg(#, #, #)".} ## \
## Writes an egg description of the nurbs curve to the specified output
## stream.  Returns true if the file is successfully written.

proc get_class_type*(_: typedesc[ParametricCurve]): TypeHandle {.importcpp: "ParametricCurve::get_class_type()", header: "parametricCurve.h".}

proc get_class_type*(_: typedesc[CubicCurveseg]): TypeHandle {.importcpp: "CubicCurveseg::get_class_type()", header: "cubicCurveseg.h".}

proc newParametricCurveCollection*(): ParametricCurveCollection {.importcpp: "new ParametricCurveCollection()".}

proc newParametricCurveCollection*(param0: ParametricCurveCollection): ParametricCurveCollection {.importcpp: "new ParametricCurveCollection(#)".}

proc add_curve*(this: ParametricCurveCollection, curve: ParametricCurve) {.importcpp: "#->add_curve(#)".} ## \
## Adds a new ParametricCurve to the collection.

proc add_curve*(this: ParametricCurveCollection, curve: ParametricCurve, index: int) {.importcpp: "#->add_curve(#, #)".} ## \
## Adds a new ParametricCurve to the collection at the indicated index.
## @deprecated Use insert_curve(index, curve) instead.

proc insert_curve*(this: ParametricCurveCollection, index: clonglong, curve: ParametricCurve) {.importcpp: "#->insert_curve(#, #)".} ## \
## Adds a new ParametricCurve to the collection at the indicated index.

proc add_curves*(this: ParametricCurveCollection, node: PandaNode): int {.importcpp: "#->add_curves(#)".} ## \
## Adds all the curves found in the scene graph rooted at the given node.
## Returns the number of curves found.

proc remove_curve*(this: ParametricCurveCollection, curve: ParametricCurve): bool {.importcpp: "#->remove_curve(#)".} ## \
## Removes the indicated ParametricCurve from the collection.  Returns true if
## the curve was removed, false if it was not a member of the collection.

proc remove_curve*(this: ParametricCurveCollection, index: clonglong) {.importcpp: "#->remove_curve(#)".} ## \
## Removes the indicated ParametricCurve from the collection, by its index
## number.

proc set_curve*(this: ParametricCurveCollection, index: clonglong, curve: ParametricCurve) {.importcpp: "#->set_curve(#, #)".} ## \
## Replaces the indicated ParametricCurve from the collection, by its index
## number.

proc has_curve*(this: ParametricCurveCollection, curve: ParametricCurve): bool {.importcpp: "#->has_curve(#)".} ## \
## Returns true if the indicated ParametricCurve appears in this collection,
## false otherwise.

proc clear*(this: ParametricCurveCollection) {.importcpp: "#->clear()".} ## \
## Removes all ParametricCurves from the collection.

proc clear_timewarps*(this: ParametricCurveCollection) {.importcpp: "#->clear_timewarps()".} ## \
## Removes all the timewarp curves from the collection.

proc get_num_curves*(this: ParametricCurveCollection): int {.importcpp: "#->get_num_curves()".} ## \
## Returns the number of ParametricCurves in the collection.

proc get_curve*(this: ParametricCurveCollection, index: int): ParametricCurve {.importcpp: "#->get_curve(#)".} ## \
## Returns the nth ParametricCurve in the collection.

proc get_xyz_curve*(this: ParametricCurveCollection): ParametricCurve {.importcpp: "#->get_xyz_curve()".} ## \
## Returns the first XYZ curve in the collection, if any, or NULL if there are
## none.

proc get_hpr_curve*(this: ParametricCurveCollection): ParametricCurve {.importcpp: "#->get_hpr_curve()".} ## \
## Returns the first HPR curve in the collection, if any, or NULL if there are
## none.

proc get_default_curve*(this: ParametricCurveCollection): ParametricCurve {.importcpp: "#->get_default_curve()".} ## \
## If there is an XYZ curve in the collection, returns it; otherwise, returns
## the first curve whose type is unspecified.  Returns NULL if no curve meets
## the criteria.

proc get_num_timewarps*(this: ParametricCurveCollection): int {.importcpp: "#->get_num_timewarps()".} ## \
## Returns the number of timewarp curves in the collection.

proc get_timewarp_curve*(this: ParametricCurveCollection, n: int): ParametricCurve {.importcpp: "#->get_timewarp_curve(#)".} ## \
## Returns the nth timewarp curve in the collection.

proc get_max_t*(this: ParametricCurveCollection): float32 {.importcpp: "#->get_max_t()".} ## \
## Returns the maximum T value associated with the *last* curve in the
## collection.  Normally, this will be either the XYZ or HPR curve, or a
## timewarp curve.

proc make_even*(this: ParametricCurveCollection, max_t: float32, segments_per_unit: float32) {.importcpp: "#->make_even(#, #)".} ## \
## Discards all existing timewarp curves and recomputes a new timewarp curve
## that maps distance along the curve to parametric time, so that the distance
## between any two points in parametric time is proportional to the
## approximate distance of those same two points along the XYZ curve.
##
## segments_per_unit represents the number of segments to take per each unit
## of parametric time of the original XYZ curve.
##
## The new timewarp curve (and thus, the apparent range of the collection)
## will range from 0 to max_t.

proc face_forward*(this: ParametricCurveCollection, segments_per_unit: float32) {.importcpp: "#->face_forward(#)".} ## \
## Discards the existing HPR curve and generates a new one that looks in the
## direction of travel along the XYZ curve, based on the XYZ curve's tangent
## at each point.

proc reset_max_t*(this: ParametricCurveCollection, max_t: float32) {.importcpp: "#->reset_max_t(#)".} ## \
## Adjusts the apparent length of the curve by applying a new timewarp that
## maps the range [0..max_t] to the range [0..get_max_t()].  After this call,
## the curve collection will contain one more timewarp curve, and get_max_t()
## will return the given max_t value.

proc evaluate*(this: ParametricCurveCollection, t: float32, result: LMatrix4, cs: CoordinateSystem): bool {.importcpp: "#->evaluate(#, #, #)".} ## \
## Computes the transform matrix representing translation to the position
## indicated by the first XYZ curve in the collection and the rotation
## indicated by the first HPR curve in the collection, after t has been
## modified by all the timewarp curves in the collection applied in sequence,
## from back to front.
##
## Returns true if the point is valid (i.e.  t is within the bounds indicated
## by all the timewarp curves and within the bounds of the curves themselves),
## or false otherwise.

proc evaluate*(this: ParametricCurveCollection, t: float32, result: LMatrix4): bool {.importcpp: "#->evaluate(#, #)".} ## \
## Computes the transform matrix representing translation to the position
## indicated by the first XYZ curve in the collection and the rotation
## indicated by the first HPR curve in the collection, after t has been
## modified by all the timewarp curves in the collection applied in sequence,
## from back to front.
##
## Returns true if the point is valid (i.e.  t is within the bounds indicated
## by all the timewarp curves and within the bounds of the curves themselves),
## or false otherwise.

proc evaluate*(this: ParametricCurveCollection, t: float32, xyz: LVecBase3, hpr: LVecBase3): bool {.importcpp: "#->evaluate(#, #, #)".} ## \
## Computes the position and rotation represented by the first XYZ and HPR
## curves in the collection at the given point t, after t has been modified by
## all the timewarp curves in the collection applied in sequence, from back to
## front.
##
## Returns true if the point is valid (i.e.  t is within the bounds indicated
## by all the timewarp curves and within the bounds of the curves themselves),
## or false otherwise.

proc evaluate_t*(this: ParametricCurveCollection, t: float32): float32 {.importcpp: "#->evaluate_t(#)".} ## \
## Determines the value of t that should be passed to the XYZ and HPR curves,
## after applying the given value of t to all the timewarps.  Return -1.0f if
## the value of t exceeds one of the timewarps' ranges.

proc evaluate_xyz*(this: ParametricCurveCollection, t: float32, xyz: LVecBase3): bool {.importcpp: "#->evaluate_xyz(#, #)".} ## \
## Computes only the XYZ part of the curves.  See evaluate().

proc evaluate_hpr*(this: ParametricCurveCollection, t: float32, hpr: LVecBase3): bool {.importcpp: "#->evaluate_hpr(#, #)".} ## \
## Computes only the HPR part of the curves.  See evaluate().

proc adjust_xyz*(this: ParametricCurveCollection, t: float32, xyz: LVecBase3): bool {.importcpp: "#->adjust_xyz(#, #)".} ## \
## Adjust the XYZ curve at the indicated time to the new value.  The curve
## shape will change correspondingly.  Returns true if successful, false if
## unable to make the adjustment for some reason.

proc adjust_xyz*(this: ParametricCurveCollection, t: float32, x: float32, y: float32, z: float32): bool {.importcpp: "#->adjust_xyz(#, #, #, #)".} ## \
## Adjust the XYZ curve at the indicated time to the new value.  The curve
## shape will change correspondingly.  Returns true if successful, false if
## unable to make the adjustment for some reason.

proc adjust_hpr*(this: ParametricCurveCollection, t: float32, xyz: LVecBase3): bool {.importcpp: "#->adjust_hpr(#, #)".} ## \
## Adjust the HPR curve at the indicated time to the new value.  The curve
## shape will change correspondingly.  Returns true if successful, false if
## unable to make the adjustment for some reason.

proc adjust_hpr*(this: ParametricCurveCollection, t: float32, h: float32, p: float32, r: float32): bool {.importcpp: "#->adjust_hpr(#, #, #, #)".} ## \
## Adjust the HPR curve at the indicated time to the new value.  The curve
## shape will change correspondingly.  Returns true if successful, false if
## unable to make the adjustment for some reason.

proc recompute*(this: ParametricCurveCollection): bool {.importcpp: "#->recompute()".} ## \
## Ensures all the curves are freshly computed and up-to-date.  Returns true
## if everything is valid, false if at least one curve is incorrect.

proc stitch*(this: ParametricCurveCollection, a: ParametricCurveCollection, b: ParametricCurveCollection): bool {.importcpp: "#->stitch(#, #)".} ## \
## Regenerates this curve as one long curve: the first curve connected end-to-
## end with the second one.  Either a or b may be the same as 'this'.  This
## will lose any timewarps on the input curves.
##
## Returns true if successful, false on failure.

proc output*(this: ParametricCurveCollection, `out`: ostream) {.importcpp: "#->output(#)".} ## \
## Writes a brief one-line description of the ParametricCurveCollection to the
## indicated output stream.

proc write*(this: ParametricCurveCollection, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".} ## \
## Writes a complete multi-line description of the ParametricCurveCollection
## to the indicated output stream.

proc write*(this: ParametricCurveCollection, `out`: ostream) {.importcpp: "#->write(#)".} ## \
## Writes a complete multi-line description of the ParametricCurveCollection
## to the indicated output stream.

proc write_egg*(this: ParametricCurveCollection, filename: Filename, cs: CoordinateSystem): bool {.importcpp: "#->write_egg(#, #)".} ## \
## Writes an egg description of all the nurbs curves in the collection to the
## specified output file.  Returns true if the file is successfully written.

proc write_egg*(this: ParametricCurveCollection, filename: Filename): bool {.importcpp: "#->write_egg(#)".} ## \
## Writes an egg description of all the nurbs curves in the collection to the
## specified output file.  Returns true if the file is successfully written.

proc write_egg*(this: ParametricCurveCollection, `out`: ostream, filename: Filename, cs: CoordinateSystem): bool {.importcpp: "#->write_egg(#, #, #)".} ## \
## Writes an egg description of all the nurbs curves in the collection to the
## specified output stream.  Returns true if the file is successfully written.

proc initCurveFitter*(): CurveFitter {.importcpp: "CurveFitter()".}

proc initCurveFitter*(param0: CurveFitter): CurveFitter {.importcpp: "CurveFitter(#)".}

proc reset*(this: CurveFitter) {.importcpp: "#.reset()".} ## \
## Removes all the data points previously added to the CurveFitter, and
## initializes it for a new curve.

proc add_xyz*(this: CurveFitter, t: float32, xyz: LVecBase3) {.importcpp: "#.add_xyz(#, #)".} ## \
## Adds a single sample xyz.

proc add_hpr*(this: CurveFitter, t: float32, hpr: LVecBase3) {.importcpp: "#.add_hpr(#, #)".} ## \
## Adds a single sample hpr.

proc add_xyz_hpr*(this: CurveFitter, t: float32, xyz: LVecBase3, hpr: LVecBase3) {.importcpp: "#.add_xyz_hpr(#, #, #)".} ## \
## Adds a single sample xyz & hpr simultaneously.

proc get_num_samples*(this: CurveFitter): int {.importcpp: "#.get_num_samples()".} ## \
## Returns the number of sample points that have been added.

proc get_sample_t*(this: CurveFitter, n: int): float32 {.importcpp: "#.get_sample_t(#)".} ## \
## Returns the parametric value of the nth sample added.

proc get_sample_xyz*(this: CurveFitter, n: int): LVecBase3 {.importcpp: "#.get_sample_xyz(#)".} ## \
## Returns the point in space of the nth sample added.

proc get_sample_hpr*(this: CurveFitter, n: int): LVecBase3 {.importcpp: "#.get_sample_hpr(#)".} ## \
## Returns the orientation of the nth sample added.

proc get_sample_tangent*(this: CurveFitter, n: int): LVecBase3 {.importcpp: "#.get_sample_tangent(#)".} ## \
## Returns the tangent associated with the nth sample added.  This is only
## meaningful if compute_tangents() has already been called.

proc remove_samples*(this: CurveFitter, begin: int, `end`: int) {.importcpp: "#.remove_samples(#, #)".} ## \
## Eliminates all samples from index begin, up to but not including index end,
## from the database.

proc sample*(this: CurveFitter, curves: ParametricCurveCollection, count: int) {.importcpp: "#.sample(#, #)".} ## \
## Generates a series of data points by sampling the given curve (or xyz/hpr
## curves) the indicated number of times.  The sampling is made evenly in
## parametric time, and then the timewarps, if any, are applied.

proc wrap_hpr*(this: CurveFitter) {.importcpp: "#.wrap_hpr()".} ## \
## Resets each HPR data point so that the maximum delta between any two
## consecutive points is 180 degrees, which should prevent incorrect HPR
## wrapping.

proc sort_points*(this: CurveFitter) {.importcpp: "#.sort_points()".} ## \
## Sorts all the data points in order by parametric time, in case they were
## added in an incorrect order.

proc desample*(this: CurveFitter, factor: float32) {.importcpp: "#.desample(#)".} ## \
## Removes sample points in order to reduce the complexity of a sampled curve.
## Keeps one out of every factor samples.  Also keeps the first and the last
## samples.

proc compute_tangents*(this: CurveFitter, scale: float32) {.importcpp: "#.compute_tangents(#)".} ## \
## Once a set of points has been built, and prior to calling MakeHermite() or
## MakeNurbs(), ComputeTangents() must be called to set up the tangents
## correctly (unless the tangents were defined as the points were added).

proc make_hermite*(this: CurveFitter): ParametricCurveCollection {.importcpp: "#.make_hermite()".} ## \
## Converts the current set of data points into a Hermite curve.

proc make_nurbs*(this: CurveFitter): ParametricCurveCollection {.importcpp: "#.make_nurbs()".} ## \
## Converts the current set of data points into a NURBS curve.  This gives a
## smoother curve than produced by MakeHermite().

proc output*(this: CurveFitter, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: CurveFitter, `out`: ostream) {.importcpp: "#.write(#)".}

proc get_class_type*(_: typedesc[CurveFitter]): TypeHandle {.importcpp: "CurveFitter::get_class_type()", header: "curveFitter.h".}

proc newPiecewiseCurve*(): PiecewiseCurve {.importcpp: "new PiecewiseCurve()".}

proc get_class_type*(_: typedesc[PiecewiseCurve]): TypeHandle {.importcpp: "PiecewiseCurve::get_class_type()", header: "piecewiseCurve.h".}

proc newHermiteCurve*(): HermiteCurve {.importcpp: "new HermiteCurve()".}

proc newHermiteCurve*(pc: ParametricCurve): HermiteCurve {.importcpp: "new HermiteCurve(#)".} ## \
## Constructs a Hermite from the indicated (possibly non-hermite) curve.

proc get_num_cvs*(this: HermiteCurve): int {.importcpp: "#->get_num_cvs()".} ## \
## Returns the number of CV's in the curve.

proc insert_cv*(this: HermiteCurve, t: float32): int {.importcpp: "#->insert_cv(#)".} ## \
## Inserts a new CV at the given parametric point along the curve.  If this
## parametric point is already on the curve, the CV is assigned an index
## between its two neighbors and the indices of all following CV's are
## incremented by 1; its in and out tangents are chosen to keep the curve
## consistent.  If the new parametric point is beyond the end of the existing
## curve, the curve is extended to meet it and the new CV's position, in
## tangent, and out tangent are set to zero.
##
## The index number of the new CV is returned.

proc append_cv*(this: HermiteCurve, `type`: int, v: LVecBase3): int {.importcpp: "#->append_cv(#, #)".}

proc append_cv*(this: HermiteCurve, `type`: int, x: float32, y: float32, z: float32): int {.importcpp: "#->append_cv(#, #, #, #)".} ## \
## Adds a new CV to the end of the curve.  The new CV is given initial in/out
## tangents of 0.  The return value is the index of the new CV.

proc remove_cv*(this: HermiteCurve, n: int): bool {.importcpp: "#->remove_cv(#)".} ## \
## Removes the given CV from the curve.  Returns true if the CV existed, false
## otherwise.

proc remove_all_cvs*(this: HermiteCurve) {.importcpp: "#->remove_all_cvs()".} ## \
## Removes all CV's from the curve.

proc set_cv_type*(this: HermiteCurve, n: int, `type`: int): bool {.importcpp: "#->set_cv_type(#, #)".} ## \
## Changes the given CV's continuity type.  Legal values are HC_CUT, HC_FREE,
## HC_G1, or HC_SMOOTH.
##
## Other than HC_CUT, these have no effect on the actual curve; it remains up
## to user software to impose the constraints these imply.
##
## HC_CUT implies a disconnection of the curve; HC_FREE imposes no constraints
## on the tangents; HC_G1 forces the tangents to be collinear, and HC_SMOOTH
## forces the tangents to be identical.  Setting type type to HC_G1 or
## HC_SMOOTH may adjust the out tangent to match the in tangent.

proc set_cv_point*(this: HermiteCurve, n: int, v: LVecBase3): bool {.importcpp: "#->set_cv_point(#, #)".}

proc set_cv_point*(this: HermiteCurve, n: int, x: float32, y: float32, z: float32): bool {.importcpp: "#->set_cv_point(#, #, #, #)".} ## \
## Changes the given CV's position.

proc set_cv_in*(this: HermiteCurve, n: int, v: LVecBase3): bool {.importcpp: "#->set_cv_in(#, #)".}

proc set_cv_in*(this: HermiteCurve, n: int, x: float32, y: float32, z: float32): bool {.importcpp: "#->set_cv_in(#, #, #, #)".} ## \
## Changes the given CV's in tangent.  Depending on the continuity type, this
## may also adjust the out tangent.

proc set_cv_out*(this: HermiteCurve, n: int, v: LVecBase3): bool {.importcpp: "#->set_cv_out(#, #)".}

proc set_cv_out*(this: HermiteCurve, n: int, x: float32, y: float32, z: float32): bool {.importcpp: "#->set_cv_out(#, #, #, #)".} ## \
## Changes the given CV's out tangent.  Depending on the continuity type, this
## may also adjust the in tangent.

proc set_cv_tstart*(this: HermiteCurve, n: int, tstart: float32): bool {.importcpp: "#->set_cv_tstart(#, #)".} ## \
## Changes the given CV's parametric starting time.  This may affect the shape
## of the curve.

proc set_cv_name*(this: HermiteCurve, n: int, name: string): bool {.importcpp: "#->set_cv_name(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name associated with a particular CV.

proc get_cv_type*(this: HermiteCurve, n: int): int {.importcpp: "#->get_cv_type(#)".} ## \
## Returns the given CV's continuity type, HC_CUT, HC_FREE, HC_G1, or
## HC_SMOOTH, or 0 if there is no such CV.

proc get_cv_point*(this: HermiteCurve, n: int): LVecBase3 {.importcpp: "#->get_cv_point(#)".} ## \
## Returns the position of the given CV.

proc get_cv_point*(this: HermiteCurve, n: int, v: LVecBase3) {.importcpp: "#->get_cv_point(#, #)".}

proc get_cv_in*(this: HermiteCurve, n: int): LVecBase3 {.importcpp: "#->get_cv_in(#)".} ## \
## Returns the in tangent of the given CV.

proc get_cv_in*(this: HermiteCurve, n: int, v: LVecBase3) {.importcpp: "#->get_cv_in(#, #)".}

proc get_cv_out*(this: HermiteCurve, n: int): LVecBase3 {.importcpp: "#->get_cv_out(#)".} ## \
## Returns the out tangent of the given CV.

proc get_cv_out*(this: HermiteCurve, n: int, v: LVecBase3) {.importcpp: "#->get_cv_out(#, #)".}

proc get_cv_tstart*(this: HermiteCurve, n: int): float32 {.importcpp: "#->get_cv_tstart(#)".} ## \
## Returns the starting point in parametric space of the given CV.

proc get_cv_name*(this: HermiteCurve, n: int): string {.importcpp: "nimStringFromStdString(#->get_cv_name(#))", header: stringConversionCode.} ## \
## Returns the name of the given CV, or NULL.

proc write_cv*(this: HermiteCurve, `out`: ostream, n: int) {.importcpp: "#->write_cv(#, #)".}

proc get_class_type*(_: typedesc[HermiteCurve]): TypeHandle {.importcpp: "HermiteCurve::get_class_type()", header: "hermiteCurve.h".}

proc set_order*(this: NurbsCurveInterface, order: int) {.importcpp: "#.set_order(#)".}

proc get_order*(this: NurbsCurveInterface): int {.importcpp: "#.get_order()".}

proc get_num_cvs*(this: NurbsCurveInterface): int {.importcpp: "#.get_num_cvs()".}

proc get_num_knots*(this: NurbsCurveInterface): int {.importcpp: "#.get_num_knots()".}

proc insert_cv*(this: NurbsCurveInterface, t: float32): bool {.importcpp: "#.insert_cv(#)".}

proc append_cv*(this: NurbsCurveInterface, v: LVecBase3): int {.importcpp: "#.append_cv(#)".}

proc append_cv*(this: NurbsCurveInterface, v: LVecBase4): int {.importcpp: "#.append_cv(#)".}

proc append_cv*(this: NurbsCurveInterface, x: float32, y: float32, z: float32): int {.importcpp: "#.append_cv(#, #, #)".}

proc remove_cv*(this: NurbsCurveInterface, n: int): bool {.importcpp: "#.remove_cv(#)".}

proc remove_all_cvs*(this: NurbsCurveInterface) {.importcpp: "#.remove_all_cvs()".}

proc set_cv_point*(this: NurbsCurveInterface, n: int, v: LVecBase3): bool {.importcpp: "#.set_cv_point(#, #)".} ## \
## Repositions the indicated CV.  Returns true if successful, false otherwise.

proc set_cv_point*(this: NurbsCurveInterface, n: int, x: float32, y: float32, z: float32): bool {.importcpp: "#.set_cv_point(#, #, #, #)".} ## \
## Repositions the indicated CV.  Returns true if successful, false otherwise.

proc get_cv_point*(this: NurbsCurveInterface, n: int): LVecBase3 {.importcpp: "#.get_cv_point(#)".} ## \
## Returns the position of the indicated CV.

proc set_cv_weight*(this: NurbsCurveInterface, n: int, w: float32): bool {.importcpp: "#.set_cv_weight(#, #)".} ## \
## Sets the weight of the indicated CV without affecting its position in 3-d
## space.

proc get_cv_weight*(this: NurbsCurveInterface, n: int): float32 {.importcpp: "#.get_cv_weight(#)".} ## \
## Returns the weight of the indicated CV.

proc set_cv*(this: NurbsCurveInterface, n: int, v: LVecBase4): bool {.importcpp: "#.set_cv(#, #)".}

proc get_cv*(this: NurbsCurveInterface, n: int): LVecBase4 {.importcpp: "#.get_cv(#)".}

proc set_knot*(this: NurbsCurveInterface, n: int, t: float32): bool {.importcpp: "#.set_knot(#, #)".}

proc get_knot*(this: NurbsCurveInterface, n: int): float32 {.importcpp: "#.get_knot(#)".}

proc write_cv*(this: NurbsCurveInterface, `out`: ostream, n: int) {.importcpp: "#.write_cv(#, #)".}

proc get_class_type*(_: typedesc[NurbsCurveInterface]): TypeHandle {.importcpp: "NurbsCurveInterface::get_class_type()", header: "nurbsCurveInterface.h".}

converter upcast_to_PiecewiseCurve*(this: NurbsCurve): PiecewiseCurve {.importcpp: "(PT(PiecewiseCurve)(#))".}

converter upcast_to_NurbsCurveInterface*(this: NurbsCurve): NurbsCurveInterface {.importcpp: "((NurbsCurveInterface *)(#.p()))".}

proc newNurbsCurve*(): NurbsCurve {.importcpp: "new NurbsCurve()".}

proc newNurbsCurve*(pc: ParametricCurve): NurbsCurve {.importcpp: "new NurbsCurve(#)".} ## \
## Constructs a NURBS curve equivalent to the indicated (possibly non-NURBS)
## curve.

proc get_class_type*(_: typedesc[NurbsCurve]): TypeHandle {.importcpp: "NurbsCurve::get_class_type()", header: "nurbsCurve.h".}

proc get_start_t*(this: NurbsCurveResult): float32 {.importcpp: "#->get_start_t()".} ## \
## Returns the first legal value of t on the curve.  Usually this is 0.0.

proc get_end_t*(this: NurbsCurveResult): float32 {.importcpp: "#->get_end_t()".} ## \
## Returns the last legal value of t on the curve.

proc eval_point*(this: NurbsCurveResult, t: float32, point: LVecBase3): bool {.importcpp: "#->eval_point(#, #)".} ## \
## Computes the point on the curve corresponding to the indicated value in
## parametric time.  Returns true if the t value is valid, false otherwise.

proc eval_tangent*(this: NurbsCurveResult, t: float32, tangent: LVecBase3): bool {.importcpp: "#->eval_tangent(#, #)".} ## \
## Computes the tangent to the curve at the indicated point in parametric
## time.  This tangent vector will not necessarily be normalized, and could be
## zero.  See also eval_point().

proc eval_extended_point*(this: NurbsCurveResult, t: float32, d: int): float32 {.importcpp: "#->eval_extended_point(#, #)".} ## \
## Evaluates the curve in n-dimensional space according to the extended
## vertices associated with the curve in the indicated dimension.

proc get_num_segments*(this: NurbsCurveResult): int {.importcpp: "#->get_num_segments()".} ## \
## Returns the number of piecewise continuous segments within the curve.  This
## number is usually not important unless you plan to call
## eval_segment_point().

proc eval_segment_point*(this: NurbsCurveResult, segment: int, t: float32, point: LVecBase3) {.importcpp: "#->eval_segment_point(#, #, #)".} ## \
## Evaluates the point on the curve corresponding to the indicated value in
## parametric time within the indicated curve segment.  t should be in the
## range [0, 1].
##
## The curve is internally represented as a number of connected (or possibly
## unconnected) piecewise continuous segments.  The exact number of segments
## for a particular curve depends on the knot vector, and is returned by
## get_num_segments().  Normally, eval_point() is used to evaluate a point
## along the continuous curve, but when you care more about local continuity,
## you can use eval_segment_point() to evaluate the points along each segment.

proc eval_segment_tangent*(this: NurbsCurveResult, segment: int, t: float32, tangent: LVecBase3) {.importcpp: "#->eval_segment_tangent(#, #, #)".} ## \
## As eval_segment_point, but computes the tangent to the curve at the
## indicated point.  The tangent vector will not necessarily be normalized,
## and could be zero, particularly at the endpoints.

proc eval_segment_extended_point*(this: NurbsCurveResult, segment: int, t: float32, d: int): float32 {.importcpp: "#->eval_segment_extended_point(#, #, #)".} ## \
## Evaluates the curve in n-dimensional space according to the extended
## vertices associated with the curve in the indicated dimension.

proc get_segment_t*(this: NurbsCurveResult, segment: int, t: float32): float32 {.importcpp: "#->get_segment_t(#, #)".} ## \
## Accepts a t value in the range [0, 1], and assumed to be relative to the
## indicated segment (as in eval_segment_point()), and returns the
## corresponding t value in the entire curve (as in eval_point()).

proc adaptive_sample*(this: NurbsCurveResult, tolerance: float32) {.importcpp: "#->adaptive_sample(#)".} ## \
## Determines the set of subdivisions necessary to approximate the curve with
## a set of linear segments, no point of which is farther than tolerance units
## from the actual curve.
##
## After this call, you may walk through the resulting set of samples with
## get_num_samples(), get_sample_t(), and get_sample_point().

proc get_num_samples*(this: NurbsCurveResult): int {.importcpp: "#->get_num_samples()".} ## \
## Returns the number of sample points generated by the previous call to
## adaptive_sample().

proc get_sample_t*(this: NurbsCurveResult, n: int): float32 {.importcpp: "#->get_sample_t(#)".} ## \
## Returns the t value of the nth sample point generated by the previous call
## to adaptive_sample().

proc get_sample_point*(this: NurbsCurveResult, n: int): LPoint3 {.importcpp: "#->get_sample_point(#)".} ## \
## Returns the point on the curve of the nth sample point generated by the
## previous call to adaptive_sample().
##
## For tangents, or extended points, you should use get_sample_t() and pass it
## into eval_tangent() or eval_extended_point().

proc newNurbsCurveResult*(param0: NurbsCurveResult): NurbsCurveResult {.importcpp: "new NurbsCurveResult(#)".}

proc newNurbsCurveEvaluator*(): NurbsCurveEvaluator {.importcpp: "new NurbsCurveEvaluator()".}

proc newNurbsCurveEvaluator*(param0: NurbsCurveEvaluator): NurbsCurveEvaluator {.importcpp: "new NurbsCurveEvaluator(#)".}

proc set_order*(this: NurbsCurveEvaluator, order: int) {.importcpp: "#->set_order(#)".} ## \
## Sets the order of the curve.  This resets the knot vector to the default
## knot vector for the number of vertices.
##
## The order must be 1, 2, 3, or 4, and the value is one more than the degree
## of the curve.

proc get_order*(this: NurbsCurveEvaluator): int {.importcpp: "#->get_order()".} ## \
## Returns the order of the curve as set by a previous call to set_order().

proc reset*(this: NurbsCurveEvaluator, num_vertices: int) {.importcpp: "#->reset(#)".} ## \
## Resets all the vertices and knots to their default values, and sets the
## curve up with the indicated number of vertices.  You must then call
## set_vertex() repeatedly to fill in all of the vertex values appropriately.

proc get_num_vertices*(this: NurbsCurveEvaluator): int {.importcpp: "#->get_num_vertices()".} ## \
## Returns the number of control vertices in the curve.  This is the number
## passed to the last call to reset().

proc set_vertex*(this: NurbsCurveEvaluator, i: int, vertex: LVecBase3, weight: float32) {.importcpp: "#->set_vertex(#, #, #)".} ## \
## Sets the nth control vertex of the curve.  This flavor sets the vertex as a
## 3-d coordinate and a weight; the 3-d coordinate values are implicitly
## scaled up by the weight factor.

proc set_vertex*(this: NurbsCurveEvaluator, i: int, vertex: LVecBase3) {.importcpp: "#->set_vertex(#, #)".} ## \
## Sets the nth control vertex of the curve.  This flavor sets the vertex as a
## 3-d coordinate and a weight; the 3-d coordinate values are implicitly
## scaled up by the weight factor.

proc set_vertex*(this: NurbsCurveEvaluator, i: int, vertex: LVecBase4) {.importcpp: "#->set_vertex(#, #)".} ## \
## Sets the nth control vertex of the curve, as a vertex in 4-d homogeneous
## space.  In this form, the first three components of the vertex should
## already have been scaled by the fourth component, which is the homogeneous
## weight.

proc get_vertex*(this: NurbsCurveEvaluator, i: int): LVecBase4 {.importcpp: "#->get_vertex(#)".} ## \
## Returns the nth control vertex of the curve, relative to its indicated
## coordinate space.

proc get_vertex*(this: NurbsCurveEvaluator, i: int, rel_to: NodePath): LVecBase4 {.importcpp: "#->get_vertex(#, #)".} ## \
## Returns the nth control vertex of the curve, relative to the given
## coordinate space.

proc set_vertex_space*(this: NurbsCurveEvaluator, i: int, space: NodePath) {.importcpp: "#->set_vertex_space(#, #)".} ## \
## Sets the coordinate space of the nth control vertex.  If this is not
## specified, or is set to an empty NodePath, the nth control vertex is deemed
## to be in the coordinate space passed to evaluate().
##
## This specifies the space as a fixed NodePath, which is always the same
## NodePath.  Also see setting the space as a path string, which can specify a
## different NodePath for different instances of the curve.

proc set_vertex_space*(this: NurbsCurveEvaluator, i: int, space: string) {.importcpp: "#->set_vertex_space(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the coordinate space of the nth control vertex.  If this is not
## specified, or is set to an empty string, the nth control vertex is deemed
## to be in the coordinate space passed to evaluate().
##
## This specifies the space as a string, which describes the path to find the
## node relative to the rel_to NodePath when the curve is evaluated.

proc get_vertex_space*(this: NurbsCurveEvaluator, i: int, rel_to: NodePath): NodePath {.importcpp: "#->get_vertex_space(#, #)".} ## \
## Returns the coordinate space of the nth control vertex of the curve,
## expressed as a NodePath.

proc set_extended_vertex*(this: NurbsCurveEvaluator, i: int, d: int, value: float32) {.importcpp: "#->set_extended_vertex(#, #, #)".} ## \
## Sets an n-dimensional vertex value.  This allows definition of a NURBS
## surface or curve in a sparse n-dimensional space, typically used for
## associating additional properties (like color or joint membership) with
## each vertex of a surface.
##
## The value d is an arbitrary integer value and specifies the dimension of
## question for this particular vertex.  Any number of dimensions may be
## specified, and they need not be consecutive.  If a value for a given
## dimension is not specified, is it implicitly 0.0.
##
## The value is implicitly scaled by the homogenous weight value--that is, the
## fourth component of the value passed to set_vertex().  This means the
## ordinary vertex must be set first, before the extended vertices can be set.

proc get_extended_vertex*(this: NurbsCurveEvaluator, i: int, d: int): float32 {.importcpp: "#->get_extended_vertex(#, #)".} ## \
## Returns an n-dimensional vertex value.  See set_extended_vertex().  This
## returns the value set for the indicated dimension, or 0.0 if nothing has
## been set.

proc get_num_knots*(this: NurbsCurveEvaluator): int {.importcpp: "#->get_num_knots()".} ## \
## Returns the number of knot values in the curve.  This is based on the
## number of vertices and the order.

proc set_knot*(this: NurbsCurveEvaluator, i: int, knot: float32) {.importcpp: "#->set_knot(#, #)".} ## \
## Sets the value of the nth knot.  Each knot value should be greater than or
## equal to the preceding value.  If no knot values are set, a default knot
## vector is supplied.

proc get_knot*(this: NurbsCurveEvaluator, i: int): float32 {.importcpp: "#->get_knot(#)".} ## \
## Returns the value of the nth knot.

proc normalize_knots*(this: NurbsCurveEvaluator) {.importcpp: "#->normalize_knots()".} ## \
## Normalizes the knot sequence so that the parametric range of the curve is 0
## .. 1.

proc get_num_segments*(this: NurbsCurveEvaluator): int {.importcpp: "#->get_num_segments()".} ## \
## Returns the number of piecewise continuous segments in the curve.  This is
## based on the knot vector.

proc evaluate*(this: NurbsCurveEvaluator, rel_to: NodePath): NurbsCurveResult {.importcpp: "#->evaluate(#)".} ## \
## Returns a NurbsCurveResult object that represents the result of applying
## the knots to all of the current values of the vertices, transformed into
## the indicated coordinate space.

proc evaluate*(this: NurbsCurveEvaluator): NurbsCurveResult {.importcpp: "#->evaluate()".} ## \
## Returns a NurbsCurveResult object that represents the result of applying
## the knots to all of the current values of the vertices, transformed into
## the indicated coordinate space.

proc evaluate*(this: NurbsCurveEvaluator, rel_to: NodePath, mat: LMatrix4): NurbsCurveResult {.importcpp: "#->evaluate(#, #)".} ## \
## Returns a NurbsCurveResult object that represents the result of applying
## the knots to all of the current values of the vertices, transformed into
## the indicated coordinate space, and then further transformed by the
## indicated matrix.

proc output*(this: NurbsCurveEvaluator, `out`: ostream) {.importcpp: "#->output(#)".}

proc get_start_u*(this: NurbsSurfaceResult): float32 {.importcpp: "#->get_start_u()".} ## \
## Returns the first legal value of u on the surface.  Usually this is 0.0.

proc get_end_u*(this: NurbsSurfaceResult): float32 {.importcpp: "#->get_end_u()".} ## \
## Returns the last legal value of u on the surface.

proc get_start_v*(this: NurbsSurfaceResult): float32 {.importcpp: "#->get_start_v()".} ## \
## Returns the first legal value of v on the surface.  Usually this is 0.0.

proc get_end_v*(this: NurbsSurfaceResult): float32 {.importcpp: "#->get_end_v()".} ## \
## Returns the last legal value of v on the surface.

proc eval_point*(this: NurbsSurfaceResult, u: float32, v: float32, point: LVecBase3): bool {.importcpp: "#->eval_point(#, #, #)".} ## \
## Computes the point on the surface corresponding to the indicated value in
## parametric time.  Returns true if the u, v values are valid, false
## otherwise.

proc eval_normal*(this: NurbsSurfaceResult, u: float32, v: float32, normal: LVecBase3): bool {.importcpp: "#->eval_normal(#, #, #)".} ## \
## Computes the normal to the surface at the indicated point in parametric
## time.  This normal vector will not necessarily be normalized, and could be
## zero.  See also eval_point().

proc eval_extended_point*(this: NurbsSurfaceResult, u: float32, v: float32, d: int): float32 {.importcpp: "#->eval_extended_point(#, #, #)".} ## \
## Evaluates the surface in n-dimensional space according to the extended
## vertices associated with the surface in the indicated dimension.

proc get_num_u_segments*(this: NurbsSurfaceResult): int {.importcpp: "#->get_num_u_segments()".} ## \
## Returns the number of piecewise continuous segments within the surface in
## the U direction.  This number is usually not important unless you plan to
## call eval_segment_point().

proc get_num_v_segments*(this: NurbsSurfaceResult): int {.importcpp: "#->get_num_v_segments()".} ## \
## Returns the number of piecewise continuous segments within the surface in
## the V direction.  This number is usually not important unless you plan to
## call eval_segment_point().

proc eval_segment_point*(this: NurbsSurfaceResult, ui: int, vi: int, u: float32, v: float32, point: LVecBase3) {.importcpp: "#->eval_segment_point(#, #, #, #, #)".} ## \
## Evaluates the point on the surface corresponding to the indicated value in
## parametric time within the indicated surface segment.  u and v should be in
## the range [0, 1].
##
## The surface is internally represented as a number of connected (or possibly
## unconnected) piecewise continuous segments.  The exact number of segments
## for a particular surface depends on the knot vector, and is returned by
## get_num_segments().  Normally, eval_point() is used to evaluate a point
## along the continuous surface, but when you care more about local
## continuity, you can use eval_segment_point() to evaluate the points along
## each segment.

proc eval_segment_normal*(this: NurbsSurfaceResult, ui: int, vi: int, u: float32, v: float32, normal: LVecBase3) {.importcpp: "#->eval_segment_normal(#, #, #, #, #)".} ## \
## As eval_segment_point, but computes the normal to the surface at the
## indicated point.  The normal vector will not necessarily be normalized, and
## could be zero.

proc eval_segment_extended_point*(this: NurbsSurfaceResult, ui: int, vi: int, u: float32, v: float32, d: int): float32 {.importcpp: "#->eval_segment_extended_point(#, #, #, #, #)".} ## \
## Evaluates the surface in n-dimensional space according to the extended
## vertices associated with the surface in the indicated dimension.

proc get_segment_u*(this: NurbsSurfaceResult, ui: int, u: float32): float32 {.importcpp: "#->get_segment_u(#, #)".} ## \
## Accepts a u value in the range [0, 1], and assumed to be relative to the
## indicated segment (as in eval_segment_point()), and returns the
## corresponding u value in the entire surface (as in eval_point()).

proc get_segment_v*(this: NurbsSurfaceResult, vi: int, v: float32): float32 {.importcpp: "#->get_segment_v(#, #)".} ## \
## Accepts a v value in the range [0, 1], and assumed to be relative to the
## indicated segment (as in eval_segment_point()), and returns the
## corresponding v value in the entire surface (as in eval_point()).

proc newNurbsSurfaceResult*(param0: NurbsSurfaceResult): NurbsSurfaceResult {.importcpp: "new NurbsSurfaceResult(#)".}

proc newNurbsSurfaceEvaluator*(): NurbsSurfaceEvaluator {.importcpp: "new NurbsSurfaceEvaluator()".}

proc newNurbsSurfaceEvaluator*(param0: NurbsSurfaceEvaluator): NurbsSurfaceEvaluator {.importcpp: "new NurbsSurfaceEvaluator(#)".}

proc set_u_order*(this: NurbsSurfaceEvaluator, u_order: int) {.importcpp: "#->set_u_order(#)".} ## \
## Sets the order of the surface in the U direction.  This resets the knot
## vector to the default knot vector for the number of vertices.
##
## The order must be 1, 2, 3, or 4, and the value is one more than the degree
## of the surface.

proc get_u_order*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_u_order()".} ## \
## Returns the order of the surface in the U direction as set by a previous
## call to set_u_order().

proc set_v_order*(this: NurbsSurfaceEvaluator, v_order: int) {.importcpp: "#->set_v_order(#)".} ## \
## Sets the order of the surface in the V direction.  This resets the knot
## vector to the default knot vector for the number of vertices.
##
## The order must be 1, 2, 3, or 4, and the value is one more than the degree
## of the surface.

proc get_v_order*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_v_order()".} ## \
## Returns the order of the surface in the V direction as set by a previous
## call to set_v_order().

proc reset*(this: NurbsSurfaceEvaluator, num_u_vertices: int, num_v_vertices: int) {.importcpp: "#->reset(#, #)".} ## \
## Resets all the vertices and knots to their default values, and sets the
## surface up with the indicated number of vertices.  You must then call
## set_vertex() repeatedly to fill in all of the vertex values appropriately.

proc get_num_u_vertices*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_num_u_vertices()".} ## \
## Returns the number of control vertices in the U direction on the surface.
## This is the number passed to the last call to reset().

proc get_num_v_vertices*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_num_v_vertices()".} ## \
## Returns the number of control vertices in the V direction on the surface.
## This is the number passed to the last call to reset().

proc set_vertex*(this: NurbsSurfaceEvaluator, ui: int, vi: int, vertex: LVecBase3, weight: float32) {.importcpp: "#->set_vertex(#, #, #, #)".} ## \
## Sets the nth control vertex of the surface.  This flavor sets the vertex as
## a 3-d coordinate and a weight; the 3-d coordinate values are implicitly
## scaled up by the weight factor.

proc set_vertex*(this: NurbsSurfaceEvaluator, ui: int, vi: int, vertex: LVecBase3) {.importcpp: "#->set_vertex(#, #, #)".} ## \
## Sets the nth control vertex of the surface.  This flavor sets the vertex as
## a 3-d coordinate and a weight; the 3-d coordinate values are implicitly
## scaled up by the weight factor.

proc set_vertex*(this: NurbsSurfaceEvaluator, ui: int, vi: int, vertex: LVecBase4) {.importcpp: "#->set_vertex(#, #, #)".} ## \
## Sets the nth control vertex of the surface, as a vertex in 4-d homogeneous
## space.  In this form, the first three components of the vertex should
## already have been scaled by the fourth component, which is the homogeneous
## weight.

proc get_vertex*(this: NurbsSurfaceEvaluator, ui: int, vi: int): LVecBase4 {.importcpp: "#->get_vertex(#, #)".} ## \
## Returns the nth control vertex of the surface, relative to its indicated
## coordinate space.

proc get_vertex*(this: NurbsSurfaceEvaluator, ui: int, vi: int, rel_to: NodePath): LVecBase4 {.importcpp: "#->get_vertex(#, #, #)".} ## \
## Returns the nth control vertex of the surface, relative to the given
## coordinate space.

proc set_vertex_space*(this: NurbsSurfaceEvaluator, ui: int, vi: int, space: NodePath) {.importcpp: "#->set_vertex_space(#, #, #)".} ## \
## Sets the coordinate space of the nth control vertex.  If this is not
## specified, or is set to an empty NodePath, the nth control vertex is deemed
## to be in the coordinate space passed to evaluate().
##
## This specifies the space as a fixed NodePath, which is always the same
## NodePath.  Also see setting the space as a path string, which can specify a
## different NodePath for different instances of the surface.

proc set_vertex_space*(this: NurbsSurfaceEvaluator, ui: int, vi: int, space: string) {.importcpp: "#->set_vertex_space(#, #, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the coordinate space of the nth control vertex.  If this is not
## specified, or is set to an empty string, the nth control vertex is deemed
## to be in the coordinate space passed to evaluate().
##
## This specifies the space as a string, which describes the path to find the
## node relative to the rel_to NodePath when the surface is evaluated.

proc get_vertex_space*(this: NurbsSurfaceEvaluator, ui: int, vi: int, rel_to: NodePath): NodePath {.importcpp: "#->get_vertex_space(#, #, #)".} ## \
## Returns the coordinate space of the nth control vertex of the surface,
## expressed as a NodePath.

proc set_extended_vertex*(this: NurbsSurfaceEvaluator, ui: int, vi: int, d: int, value: float32) {.importcpp: "#->set_extended_vertex(#, #, #, #)".} ## \
## Sets an n-dimensional vertex value.  This allows definition of a NURBS
## surface or surface in a sparse n-dimensional space, typically used for
## associating additional properties (like color or joint membership) with
## each vertex of a surface.
##
## The value d is an arbitrary integer value and specifies the dimension of
## question for this particular vertex.  Any number of dimensions may be
## specified, and they need not be consecutive.  If a value for a given
## dimension is not specified, is it implicitly 0.0.
##
## The value is implicitly scaled by the homogenous weight value--that is, the
## fourth component of the value passed to set_vertex().  This means the
## ordinary vertex must be set first, before the extended vertices can be set.

proc get_extended_vertex*(this: NurbsSurfaceEvaluator, ui: int, vi: int, d: int): float32 {.importcpp: "#->get_extended_vertex(#, #, #)".} ## \
## Returns an n-dimensional vertex value.  See set_extended_vertex().  This
## returns the value set for the indicated dimension, or 0.0 if nothing has
## been set.

proc get_num_u_knots*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_num_u_knots()".} ## \
## Returns the number of knot values in the surface in the U direction.  This
## is based on the number of vertices and the order.

proc set_u_knot*(this: NurbsSurfaceEvaluator, i: int, knot: float32) {.importcpp: "#->set_u_knot(#, #)".} ## \
## Sets the value of the nth knot.  Each knot value should be greater than or
## equal to the preceding value.  If no knot values are set, a default knot
## vector is supplied.

proc get_u_knot*(this: NurbsSurfaceEvaluator, i: int): float32 {.importcpp: "#->get_u_knot(#)".} ## \
## Returns the value of the nth knot.

proc normalize_u_knots*(this: NurbsSurfaceEvaluator) {.importcpp: "#->normalize_u_knots()".} ## \
## Normalizes the knot sequence so that the parametric range of the surface in
## the U direction is 0 .. 1.

proc get_num_v_knots*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_num_v_knots()".} ## \
## Returns the number of knot values in the surface in the V direction.  This
## is based on the number of vertices and the order.

proc set_v_knot*(this: NurbsSurfaceEvaluator, i: int, knot: float32) {.importcpp: "#->set_v_knot(#, #)".} ## \
## Sets the value of the nth knot.  Each knot value should be greater than or
## equal to the preceding value.  If no knot values are set, a default knot
## vector is supplied.

proc get_v_knot*(this: NurbsSurfaceEvaluator, i: int): float32 {.importcpp: "#->get_v_knot(#)".} ## \
## Returns the value of the nth knot.

proc normalize_v_knots*(this: NurbsSurfaceEvaluator) {.importcpp: "#->normalize_v_knots()".} ## \
## Normalizes the knot sequence so that the parametric range of the surface in
## the U direction is 0 .. 1.

proc get_num_u_segments*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_num_u_segments()".} ## \
## Returns the number of piecewise continuous segments in the surface in the U
## direction.  This is based on the knot vector.

proc get_num_v_segments*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_num_v_segments()".} ## \
## Returns the number of piecewise continuous segments in the surface in the V
## direction.  This is based on the knot vector.

proc evaluate*(this: NurbsSurfaceEvaluator, rel_to: NodePath): NurbsSurfaceResult {.importcpp: "#->evaluate(#)".} ## \
## Returns a NurbsSurfaceResult object that represents the result of applying
## the knots to all of the current values of the vertices, transformed into
## the indicated coordinate space.

proc evaluate*(this: NurbsSurfaceEvaluator): NurbsSurfaceResult {.importcpp: "#->evaluate()".} ## \
## Returns a NurbsSurfaceResult object that represents the result of applying
## the knots to all of the current values of the vertices, transformed into
## the indicated coordinate space.

proc output*(this: NurbsSurfaceEvaluator, `out`: ostream) {.importcpp: "#->output(#)".}

proc newRopeNode*(name: string): RopeNode {.importcpp: "new RopeNode(nimStringToStdString(#))", header: stringConversionCode.}

proc set_curve*(this: RopeNode, curve: NurbsCurveEvaluator) {.importcpp: "#->set_curve(#)".} ## \
## Sets the particular curve represented by the RopeNode.

proc get_curve*(this: RopeNode): NurbsCurveEvaluator {.importcpp: "#->get_curve()".} ## \
## Returns the curve represented by the RopeNode.

proc set_uv_direction*(this: RopeNode, u_dominant: bool) {.importcpp: "#->set_uv_direction(#)".} ## \
## Specify true to vary the U coordinate down the length of the rope, or false
## to vary the V coordinate.

proc get_uv_direction*(this: RopeNode): bool {.importcpp: "#->get_uv_direction()".} ## \
## Returns true if the rope runs down the U coordinate of the texture, or
## false if it runs down the V coordinate.

proc set_uv_scale*(this: RopeNode, scale: float32) {.importcpp: "#->set_uv_scale(#)".} ## \
## Specifies an additional scaling factor to apply to generated UV's along the
## rope.  This scale factor is applied in whichever direction is along the
## rope, as specified by set_uv_direction().

proc get_uv_scale*(this: RopeNode): float32 {.importcpp: "#->get_uv_scale()".} ## \
## Returns the scaling factor to apply to generated UV's for the rope.

proc set_tube_up*(this: RopeNode, tube_up: LVector3) {.importcpp: "#->set_tube_up(#)".} ## \
## Specifies a normal vector, generally perpendicular to the main axis of the
## starting point of the curve, that controls the "top" of the curve, when
## RenderMode is RM_tube.  This is used to orient the vertices that make up
## the tube.  If this vector is too nearly parallel with the starting
## direction of the curve, there may be a tendency for the whole tube to
## gimble-lock around its primary axis.

proc get_tube_up*(this: RopeNode): LVector3 {.importcpp: "#->get_tube_up()".} ## \
## Returns the normal vector used to control the "top" of the curve, when
## RenderMode is RM_tube.  See set_tube_up().

proc set_use_vertex_color*(this: RopeNode, flag: bool) {.importcpp: "#->set_use_vertex_color(#)".} ## \
## Sets the "use vertex color" flag.  When this is true, the R, G, B, A vertex
## color is assumed to be stored as the dimensions n + 0, n + 1, n + 2, n + 3,
## respectively, of the extended vertex values, where n is the value returned
## by get_vertex_color_dimension().  Use
## NurbsCurveEvaluator::set_extended_vertex() to set these values.

proc get_use_vertex_color*(this: RopeNode): bool {.importcpp: "#->get_use_vertex_color()".} ## \
## Returns the "use vertex color" flag.  See set_use_vertex_color().

proc get_vertex_color_dimension*(_: typedesc[RopeNode]): int {.importcpp: "RopeNode::get_vertex_color_dimension()", header: "ropeNode.h".} ## \
## Returns the numeric extended dimension in which the color components should
## be found.  See NurbsCurveEvaluator::set_extended_vertex().
##
## The color components will be expected at (n, n + 1, n + 2, n + 3).

proc set_num_subdiv*(this: RopeNode, num_subdiv: int) {.importcpp: "#->set_num_subdiv(#)".} ## \
## Specifies the number of subdivisions per cubic segment (that is, per unique
## knot value) to draw in a fixed uniform tesselation of the curve.

proc get_num_subdiv*(this: RopeNode): int {.importcpp: "#->get_num_subdiv()".} ## \
## Returns the number of subdivisions per cubic segment to draw.  See
## set_num_subdiv().

proc set_num_slices*(this: RopeNode, num_slices: int) {.importcpp: "#->set_num_slices(#)".} ## \
## Specifies the number of radial subdivisions to make if RenderMode is
## RM_tube.  It is ignored in the other render modes.
##
## Increasing this number increases the roundness of a cross-section of the
## tube.  The minimum value for a dimensional tube is 3; setting it to 2 will
## get you a thin piece of tape (which is similar to RM_billboard, except it
## won't rotate to face the camera).

proc get_num_slices*(this: RopeNode): int {.importcpp: "#->get_num_slices()".} ## \
## Returns the number of radial subdivisions to make if RenderMode is RM_tube.
## It is ignored in the other render modes.  See set_num_slices().

proc set_use_vertex_thickness*(this: RopeNode, flag: bool) {.importcpp: "#->set_use_vertex_thickness(#)".} ## \
## Sets the "use vertex thickness" flag.  When this is true, the vertex
## thickness is assumed to be stored as the dimension
## get_vertex_thickness_dimension(), of the extended vertex values.  Use
## NurbsCurveEvaluator::set_extended_vertex() to set these values.
##
## In this mode, the overall thickness is also applied as a scale to the
## vertex thickness.  Not all render modes support vertex thickness.

proc get_use_vertex_thickness*(this: RopeNode): bool {.importcpp: "#->get_use_vertex_thickness()".} ## \
## Returns the "use vertex thickness" flag.  See set_use_vertex_thickness().

proc get_vertex_thickness_dimension*(_: typedesc[RopeNode]): int {.importcpp: "RopeNode::get_vertex_thickness_dimension()", header: "ropeNode.h".} ## \
## Returns the numeric extended dimension in which the thickness component
## should be found.  See NurbsCurveEvaluator::set_extended_vertex().

proc set_thickness*(this: RopeNode, thickness: float32) {.importcpp: "#->set_thickness(#)".} ## \
## Specifies the thickness of the rope, in pixels or in spatial units,
## depending on the render mode.  See set_render_mode().
##
## The thickness may also be specified on a per-vertex basis.  See
## set_use_vertex_thickness().

proc get_thickness*(this: RopeNode): float32 {.importcpp: "#->get_thickness()".} ## \
## Returns the thickness of the rope.  See set_thickness().

proc set_matrix*(this: RopeNode, matrix: LMatrix4) {.importcpp: "#->set_matrix(#)".} ## \
## Specifies an optional matrix which is used to transform each control vertex
## after it has been transformed into the RopeNode's coordinate space, but
## before the polygon vertices are generated.

proc clear_matrix*(this: RopeNode) {.importcpp: "#->clear_matrix()".} ## \
## Resets the node's matrix to identity.  See set_matrix().

proc has_matrix*(this: RopeNode): bool {.importcpp: "#->has_matrix()".} ## \
## Returns true if the node has a matrix set, false otherwise.  See
## set_matrix().

proc get_matrix*(this: RopeNode): LMatrix4 {.importcpp: "#->get_matrix()".} ## \
## Returns the optional matrix which is used to transform each control vertex
## after it has been transformed into the RopeNode's coordinate space, but
## before the polygon vertices are generated.

proc reset_bound*(this: RopeNode, rel_to: NodePath) {.importcpp: "#->reset_bound(#)".} ## \
## Recomputes the bounding volume.  This is normally called automatically, but
## it must occasionally be called explicitly when the curve has changed
## properties outside of this node's knowledge.

proc get_class_type*(_: typedesc[RopeNode]): TypeHandle {.importcpp: "RopeNode::get_class_type()", header: "ropeNode.h".}

proc newSheetNode*(name: string): SheetNode {.importcpp: "new SheetNode(nimStringToStdString(#))", header: stringConversionCode.}

proc set_surface*(this: SheetNode, surface: NurbsSurfaceEvaluator) {.importcpp: "#->set_surface(#)".} ## \
## Sets the particular surface represented by the SheetNode.

proc get_surface*(this: SheetNode): NurbsSurfaceEvaluator {.importcpp: "#->get_surface()".} ## \
## Returns the surface represented by the SheetNode.

proc set_use_vertex_color*(this: SheetNode, flag: bool) {.importcpp: "#->set_use_vertex_color(#)".} ## \
## Sets the "use vertex color" flag.  When this is true, the R, G, B, A vertex
## color is assumed to be stored as the dimensions 0, 1, 2, 3, respectively,
## of the extended vertex values.  Use
## NurbsCurveEvaluator::set_extended_vertex() to set these values.

proc get_use_vertex_color*(this: SheetNode): bool {.importcpp: "#->get_use_vertex_color()".} ## \
## Returns the "use vertex color" flag.  See set_use_vertex_color().

proc set_num_u_subdiv*(this: SheetNode, num_u_subdiv: int) {.importcpp: "#->set_num_u_subdiv(#)".} ## \
## Specifies the number of subdivisions per cubic segment (that is, per unique
## knot value) to draw in a fixed uniform tesselation of the surface in the U
## direction.

proc get_num_u_subdiv*(this: SheetNode): int {.importcpp: "#->get_num_u_subdiv()".} ## \
## Returns the number of subdivisions per cubic segment to draw in the U
## direction.  See set_num_u_subdiv().

proc set_num_v_subdiv*(this: SheetNode, num_v_subdiv: int) {.importcpp: "#->set_num_v_subdiv(#)".} ## \
## Specifies the number of subdivisions per cubic segment (that is, per unique
## knot value) to draw in a fixed uniform tesselation of the surface in the V
## direction.

proc get_num_v_subdiv*(this: SheetNode): int {.importcpp: "#->get_num_v_subdiv()".} ## \
## Returns the number of subdivisions per cubic segment to draw in the V
## direction.  See set_num_v_subdiv().

proc reset_bound*(this: SheetNode, rel_to: NodePath) {.importcpp: "#->reset_bound(#)".} ## \
## Recomputes the bounding volume.  This is normally called automatically, but
## it must occasionally be called explicitly when the surface has changed
## properties outside of this node's knowledge.

proc get_class_type*(_: typedesc[SheetNode]): TypeHandle {.importcpp: "SheetNode::get_class_type()", header: "sheetNode.h".}

proc initpixel*(): pixel {.importcpp: "pixel()".}

proc initpixel*(fill: int): pixel {.importcpp: "pixel(#)".}

proc initpixel*(r: int, g: int, b: int): pixel {.importcpp: "pixel(#, #, #)".}

proc initpixel*(param0: pixel): pixel {.importcpp: "pixel(#)".}

proc `[]`*(this: pixel, i: int, assign_val: int) {.importcpp: "#.operator [](#, #)".}

proc `+`*(this: pixel, other: pixel): pixel {.importcpp: "#.operator +(#)".}

proc `-`*(this: pixel, other: pixel): pixel {.importcpp: "#.operator -(#)".}

proc `*`*(this: pixel, mult: float64): pixel {.importcpp: "#.operator *(#)".}

proc `+=`*(this: pixel, other: pixel): pixel {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: pixel, other: pixel): pixel {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: pixel, mult: float64): pixel {.importcpp: "#.operator *=(#)".}

proc `==`*(this: pixel, other: pixel): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: pixel, other: pixel): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: pixel, other: pixel): bool {.importcpp: "#.operator <(#)".}

proc size*(_: typedesc[pixel]): int {.importcpp: "pixel::size()", header: "pixel.h".}

proc output*(this: pixel, `out`: ostream) {.importcpp: "#.output(#)".}

proc decode_sRGB_float*(val: float32): float32 {.importcpp: "decode_sRGB_float(#)".}

proc decode_sRGB_float*(val: char): float32 {.importcpp: "decode_sRGB_float(#)".}

proc decode_sRGB_uchar*(val: float32): char {.importcpp: "decode_sRGB_uchar(#)".}

proc decode_sRGB_uchar*(val: char): char {.importcpp: "decode_sRGB_uchar(#)".}

proc encode_sRGB_float*(val: float32): float32 {.importcpp: "encode_sRGB_float(#)".}

proc encode_sRGB_float*(val: char): float32 {.importcpp: "encode_sRGB_float(#)".}

proc encode_sRGB_uchar*(val: float32): char {.importcpp: "encode_sRGB_uchar(#)".}

proc encode_sRGB_uchar*(val: char): char {.importcpp: "encode_sRGB_uchar(#)".}

proc get_name*(this: PNMFileType): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.}

proc get_num_extensions*(this: PNMFileType): int {.importcpp: "#.get_num_extensions()".} ## \
## Returns the number of different possible filename extensions associated
## with this particular file type.

proc get_extension*(this: PNMFileType, n: int): string {.importcpp: "nimStringFromStdString(#.get_extension(#))", header: stringConversionCode.} ## \
## Returns the nth possible filename extension associated with this particular
## file type, without a leading dot.

proc get_suggested_extension*(this: PNMFileType): string {.importcpp: "nimStringFromStdString(#.get_suggested_extension())", header: stringConversionCode.} ## \
## Returns a suitable filename extension (without a leading dot) to suggest
## for files of this type, or empty string if no suggestions are available.

proc get_class_type*(_: typedesc[PNMFileType]): TypeHandle {.importcpp: "PNMFileType::get_class_type()", header: "pNMFileType.h".}

proc get_num_types*(this: PNMFileTypeRegistry): int {.importcpp: "#.get_num_types()".} ## \
## Returns the total number of types registered.

proc get_type*(this: PNMFileTypeRegistry, n: int): PNMFileType {.importcpp: "#.get_type(#)".} ## \
## Returns the nth type registered.

proc get_type_from_extension*(this: PNMFileTypeRegistry, filename: string): PNMFileType {.importcpp: "#.get_type_from_extension(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Tries to determine what the PNMFileType is likely to be for a particular
## image file based on its extension.  Returns a suitable PNMFileType pointer,
## or NULL if no type can be determined.

proc get_type_from_magic_number*(this: PNMFileTypeRegistry, magic_number: string): PNMFileType {.importcpp: "#.get_type_from_magic_number(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Tries to determine what the PNMFileType is likely to be for a particular
## image file based on its magic number, the first two bytes read from the
## file.  Returns a suitable PNMFileType pointer, or NULL if no type can be
## determined.

proc get_type_by_handle*(this: PNMFileTypeRegistry, handle: TypeHandle): PNMFileType {.importcpp: "#.get_type_by_handle(#)".} ## \
## Returns the PNMFileType instance stored in the registry for the given
## TypeHandle, e.g.  as retrieved by a previous call to get_type() on the type
## instance.

proc write*(this: PNMFileTypeRegistry, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes a list of supported image file types to the indicated output stream,
## one per line.

proc write*(this: PNMFileTypeRegistry, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a list of supported image file types to the indicated output stream,
## one per line.

proc get_global_ptr*(_: typedesc[PNMFileTypeRegistry]): PNMFileTypeRegistry {.importcpp: "PNMFileTypeRegistry::get_global_ptr()", header: "pNMFileTypeRegistry.h".} ## \
## Returns a pointer to the global PNMFileTypeRegistry object.

proc initPNMFileTypeRegistry*(param0: PNMFileTypeRegistry): PNMFileTypeRegistry {.importcpp: "PNMFileTypeRegistry(#)".}

proc initPNMImageHeader*(): PNMImageHeader {.importcpp: "PNMImageHeader()".}

proc initPNMImageHeader*(copy: PNMImageHeader): PNMImageHeader {.importcpp: "PNMImageHeader(#)".}

proc get_num_channels*(this: PNMImageHeader): int {.importcpp: "#.get_num_channels()".} ## \
## Returns the number of channels in the image.

proc is_grayscale*(this: PNMImageHeader): bool {.importcpp: "#.is_grayscale()".} ## \
## Returns false if the image is a full-color image, and has red, green, and
## blue components; true if it is a grayscale image and has only a gray
## component.  (The gray color is actually stored in the blue channel, and the
## red and green channels are ignored.)

proc has_alpha*(this: PNMImageHeader): bool {.importcpp: "#.has_alpha()".} ## \
## Returns true if the image includes an alpha channel, false otherwise.
## Unlike is_grayscale(), if this returns false it is an error to call any of
## the functions accessing the alpha channel.

proc get_maxval*(this: PNMImageHeader): int {.importcpp: "#.get_maxval()".} ## \
## Returns the maximum channel value allowable for any pixel in this image;
## for instance, 255 for a typical 8-bit-per-channel image.  A pixel with this
## value is full on.

proc get_color_space*(this: PNMImageHeader): ColorSpace {.importcpp: "#.get_color_space()".} ## \
## Returns the color space that the image is encoded in, or CS_unspecified if
## unknown.

proc get_x_size*(this: PNMImageHeader): int {.importcpp: "#.get_x_size()".} ## \
## Returns the number of pixels in the X direction.  This is one more than the
## largest allowable X coordinate.

proc get_y_size*(this: PNMImageHeader): int {.importcpp: "#.get_y_size()".} ## \
## Returns the number of pixels in the Y direction.  This is one more than the
## largest allowable Y coordinate.

proc get_size*(this: PNMImageHeader): LVecBase2i {.importcpp: "#.get_size()".} ## \
## Returns the number of pixels in each direction.  This is one more than the
## largest allowable coordinates.

proc get_comment*(this: PNMImageHeader): string {.importcpp: "nimStringFromStdString(#.get_comment())", header: stringConversionCode.} ## \
## Gets the user comment from the file.

proc set_comment*(this: PNMImageHeader, comment: string) {.importcpp: "#.set_comment(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Writes a user comment string to the image (header).

proc has_type*(this: PNMImageHeader): bool {.importcpp: "#.has_type()".} ## \
## Returns true if the PNMImageHeader knows what type it is, false otherwise.

proc get_type*(this: PNMImageHeader): PNMFileType {.importcpp: "#.get_type()".} ## \
## If the file type is known (e.g.  has_type() returns true), returns its
## PNMFileType pointer; otherwise, returns NULL.

proc set_type*(this: PNMImageHeader, `type`: PNMFileType) {.importcpp: "#.set_type(#)".} ## \
## Sets the file type of this PNMImage.  This will be the default type used
## when an image is read, if the type cannot be determined by magic number or
## inferred by extension, or the type used when the image is written, if the
## type cannot be inferred from the filename extension.

proc read_header*(this: PNMImageHeader, filename: Filename, `type`: PNMFileType, report_unknown_type: bool): bool {.importcpp: "#.read_header(#, #, #)".} ## \
## Opens up the image file and tries to read its header information to
## determine its size, number of channels, etc.  If successful, updates the
## header information and returns true; otherwise, returns false.

proc read_header*(this: PNMImageHeader, filename: Filename, `type`: PNMFileType): bool {.importcpp: "#.read_header(#, #)".} ## \
## Opens up the image file and tries to read its header information to
## determine its size, number of channels, etc.  If successful, updates the
## header information and returns true; otherwise, returns false.

proc read_header*(this: PNMImageHeader, filename: Filename): bool {.importcpp: "#.read_header(#)".} ## \
## Opens up the image file and tries to read its header information to
## determine its size, number of channels, etc.  If successful, updates the
## header information and returns true; otherwise, returns false.

proc read_header*(this: PNMImageHeader, data: istream, filename: string, `type`: PNMFileType, report_unknown_type: bool): bool {.importcpp: "#.read_header(#, nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Reads the image header information only from the indicated stream.
##
## The filename is advisory only, and may be used to suggest a type if it has
## a known extension.
##
## If type is non-NULL, it is a suggestion for the type of file it is (and a
## non-NULL type will override any magic number test or filename extension
## lookup).
##
## Returns true if successful, false on error.

proc read_header*(this: PNMImageHeader, data: istream, filename: string, `type`: PNMFileType): bool {.importcpp: "#.read_header(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Reads the image header information only from the indicated stream.
##
## The filename is advisory only, and may be used to suggest a type if it has
## a known extension.
##
## If type is non-NULL, it is a suggestion for the type of file it is (and a
## non-NULL type will override any magic number test or filename extension
## lookup).
##
## Returns true if successful, false on error.

proc read_header*(this: PNMImageHeader, data: istream, filename: string): bool {.importcpp: "#.read_header(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reads the image header information only from the indicated stream.
##
## The filename is advisory only, and may be used to suggest a type if it has
## a known extension.
##
## If type is non-NULL, it is a suggestion for the type of file it is (and a
## non-NULL type will override any magic number test or filename extension
## lookup).
##
## Returns true if successful, false on error.

proc read_header*(this: PNMImageHeader, data: istream): bool {.importcpp: "#.read_header(#)".} ## \
## Reads the image header information only from the indicated stream.
##
## The filename is advisory only, and may be used to suggest a type if it has
## a known extension.
##
## If type is non-NULL, it is a suggestion for the type of file it is (and a
## non-NULL type will override any magic number test or filename extension
## lookup).
##
## Returns true if successful, false on error.

proc output*(this: PNMImageHeader, `out`: ostream) {.importcpp: "#.output(#)".}

proc initPfmFile*(): PfmFile {.importcpp: "PfmFile()".}

proc initPfmFile*(copy: PfmFile): PfmFile {.importcpp: "PfmFile(#)".}

proc clear*(this: PfmFile) {.importcpp: "#.clear()".} ## \
## Eliminates all data in the file.

proc clear*(this: PfmFile, x_size: int, y_size: int, num_channels: int) {.importcpp: "#.clear(#, #, #)".} ## \
## Resets to an empty table with a specific size.  The case of num_channels ==
## 0 is allowed only in the case that x_size and y_size are also == 0; and
## this makes an empty (and invalid) PfmFile.

proc read*(this: PfmFile, fullpath: Filename): bool {.importcpp: "#.read(#)".} ## \
## Reads the PFM data from the indicated file, returning true on success,
## false on failure.
##
## This can also handle reading a standard image file supported by PNMImage;
## it will be quietly converted to a floating-point type.

proc read*(this: PfmFile, `in`: istream, fullpath: Filename): bool {.importcpp: "#.read(#, #)".} ## \
## Reads the PFM data from the indicated stream, returning true on success,
## false on failure.
##
## This can also handle reading a standard image file supported by PNMImage;
## it will be quietly converted to a floating-point type.

proc read*(this: PfmFile, `in`: istream): bool {.importcpp: "#.read(#)".} ## \
## Reads the PFM data from the indicated stream, returning true on success,
## false on failure.
##
## This can also handle reading a standard image file supported by PNMImage;
## it will be quietly converted to a floating-point type.

proc write*(this: PfmFile, fullpath: Filename): bool {.importcpp: "#.write(#)".} ## \
## Writes the PFM data to the indicated file, returning true on success, false
## on failure.
##
## If the type implied by the filename extension supports floating-point, the
## data will be written directly; otherwise, the floating-point data will be
## quietly converted to the appropriate integer type.

proc write*(this: PfmFile, `out`: ostream, fullpath: Filename): bool {.importcpp: "#.write(#, #)".} ## \
## Writes the PFM data to the indicated stream, returning true on success,
## false on failure.

proc write*(this: PfmFile, `out`: ostream): bool {.importcpp: "#.write(#)".} ## \
## Writes the PFM data to the indicated stream, returning true on success,
## false on failure.

proc load*(this: PfmFile, pnmimage: PNMImage): bool {.importcpp: "#.load(#)".} ## \
## Fills the PfmFile with the data from the indicated PNMImage, converted to
## floating-point values.

proc store*(this: PfmFile, pnmimage: PNMImage): bool {.importcpp: "#.store(#)".} ## \
## Copies the data to the indicated PNMImage, converting to RGB values.

proc store_mask*(this: PfmFile, pnmimage: PNMImage): bool {.importcpp: "#.store_mask(#)".} ## \
## Stores 1 or 0 values into the indicated PNMImage, according to has_point()
## for each pixel.  Each valid point gets a 1 value; each nonexistent point
## gets a 0 value.

proc store_mask*(this: PfmFile, pnmimage: PNMImage, min_point: LVecBase4f, max_point: LVecBase4f): bool {.importcpp: "#.store_mask(#, #, #)".} ## \
## Stores 1 or 0 values into the indicated PNMImage, according to has_point()
## for each pixel.  Each valid point gets a 1 value; each nonexistent point
## gets a 0 value.
##
## This flavor of store_mask also checks whether the valid points are within
## the specified min/max range.  Any valid points without the condition
## min_point[c] <= value[c] <= max_point[c], for any c, are stored with a 0 in
## the mask.

proc is_valid*(this: PfmFile): bool {.importcpp: "#.is_valid()".}

proc get_scale*(this: PfmFile): float32 {.importcpp: "#.get_scale()".} ## \
## The "scale" is reported in the pfm header and is probably meaningless.

proc set_scale*(this: PfmFile, scale: float32) {.importcpp: "#.set_scale(#)".} ## \
## The "scale" is reported in the pfm header and is probably meaningless.

proc has_point*(this: PfmFile, x: int, y: int): bool {.importcpp: "#.has_point(#, #)".} ## \
## Returns true if there is a valid point at x, y.  This always returns true
## unless a "no data" value has been set, in which case it returns false if
## the point at x, y is the "no data" value.

proc get_channel*(this: PfmFile, x: int, y: int, c: int): float32 {.importcpp: "#.get_channel(#, #, #)".} ## \
## Returns the cth channel of the point value at the indicated point.

proc set_channel*(this: PfmFile, x: int, y: int, c: int, value: float32) {.importcpp: "#.set_channel(#, #, #, #)".} ## \
## Replaces the cth channel of the point value at the indicated point.

proc get_point1*(this: PfmFile, x: int, y: int): float32 {.importcpp: "#.get_point1(#, #)".} ## \
## Returns the 1-component point value at the indicated point.

proc set_point1*(this: PfmFile, x: int, y: int, point: float32) {.importcpp: "#.set_point1(#, #, #)".} ## \
## Replaces the 1-component point value at the indicated point.

proc get_point2*(this: PfmFile, x: int, y: int): LPoint2f {.importcpp: "#.get_point2(#, #)".} ## \
## Returns the 2-component point value at the indicated point.  In a 1-channel
## image, the channel value is in the x component.

proc set_point2*(this: PfmFile, x: int, y: int, point: LVecBase2d) {.importcpp: "#.set_point2(#, #, #)".} ## \
## Replaces the 2-component point value at the indicated point.  In a
## 1-channel image, the channel value is in the x component.

proc set_point2*(this: PfmFile, x: int, y: int, point: LVecBase2f) {.importcpp: "#.set_point2(#, #, #)".} ## \
## Replaces the 2-component point value at the indicated point.  In a
## 1-channel image, the channel value is in the x component.

proc modify_point2*(this: PfmFile, x: int, y: int): LPoint2f {.importcpp: "#.modify_point2(#, #)".} ## \
## Returns a modifiable 2-component point value at the indicated point.

proc get_point*(this: PfmFile, x: int, y: int): LPoint3f {.importcpp: "#.get_point(#, #)".} ## \
## Returns the 3-component point value at the indicated point.  In a 1-channel
## image, the channel value is in the x component.

proc set_point*(this: PfmFile, x: int, y: int, point: LVecBase3d) {.importcpp: "#.set_point(#, #, #)".} ## \
## Replaces the 3-component point value at the indicated point.  In a
## 1-channel image, the channel value is in the x component.

proc set_point*(this: PfmFile, x: int, y: int, point: LVecBase3f) {.importcpp: "#.set_point(#, #, #)".} ## \
## Replaces the 3-component point value at the indicated point.  In a
## 1-channel image, the channel value is in the x component.

proc modify_point*(this: PfmFile, x: int, y: int): LPoint3f {.importcpp: "#.modify_point(#, #)".} ## \
## Returns a modifiable 3-component point value at the indicated point.

proc get_point3*(this: PfmFile, x: int, y: int): LPoint3f {.importcpp: "#.get_point3(#, #)".} ## \
## Returns the 3-component point value at the indicated point.  In a 1-channel
## image, the channel value is in the x component.

proc set_point3*(this: PfmFile, x: int, y: int, point: LVecBase3d) {.importcpp: "#.set_point3(#, #, #)".} ## \
## Replaces the 3-component point value at the indicated point.  In a
## 1-channel image, the channel value is in the x component.

proc set_point3*(this: PfmFile, x: int, y: int, point: LVecBase3f) {.importcpp: "#.set_point3(#, #, #)".} ## \
## Replaces the 3-component point value at the indicated point.  In a
## 1-channel image, the channel value is in the x component.

proc modify_point3*(this: PfmFile, x: int, y: int): LPoint3f {.importcpp: "#.modify_point3(#, #)".} ## \
## Returns a modifiable 3-component point value at the indicated point.

proc get_point4*(this: PfmFile, x: int, y: int): LPoint4f {.importcpp: "#.get_point4(#, #)".} ## \
## Returns the 4-component point value at the indicated point.  In a 1-channel
## image, the channel value is in the x component.

proc set_point4*(this: PfmFile, x: int, y: int, point: LVecBase4d) {.importcpp: "#.set_point4(#, #, #)".} ## \
## Replaces the 4-component point value at the indicated point.  In a
## 1-channel image, the channel value is in the x component.

proc set_point4*(this: PfmFile, x: int, y: int, point: LVecBase4f) {.importcpp: "#.set_point4(#, #, #)".} ## \
## Replaces the 4-component point value at the indicated point.  In a
## 1-channel image, the channel value is in the x component.

proc modify_point4*(this: PfmFile, x: int, y: int): LPoint4f {.importcpp: "#.modify_point4(#, #)".} ## \
## Returns a modifiable 4-component point value at the indicated point.

proc fill*(this: PfmFile, value: LPoint2f) {.importcpp: "#.fill(#)".} ## \
## Fills the table with all of the same value.

proc fill*(this: PfmFile, value: LPoint3f) {.importcpp: "#.fill(#)".} ## \
## Fills the table with all of the same value.

proc fill*(this: PfmFile, value: LPoint4f) {.importcpp: "#.fill(#)".} ## \
## Fills the table with all of the same value.

proc fill*(this: PfmFile, value: float32) {.importcpp: "#.fill(#)".} ## \
## Fills the table with all of the same value.

proc fill_nan*(this: PfmFile) {.importcpp: "#.fill_nan()".} ## \
## Fills the table with all NaN.

proc fill_no_data_value*(this: PfmFile) {.importcpp: "#.fill_no_data_value()".} ## \
## Fills the table with the current no_data value, so that the table is empty.

proc fill_channel*(this: PfmFile, channel: int, value: float32) {.importcpp: "#.fill_channel(#, #)".} ## \
## Fills the indicated channel with all of the same value, leaving the other
## channels unchanged.

proc fill_channel_nan*(this: PfmFile, channel: int) {.importcpp: "#.fill_channel_nan(#)".} ## \
## Fills the indicated channel with NaN, leaving the other channels unchanged.

proc fill_channel_masked*(this: PfmFile, channel: int, value: float32) {.importcpp: "#.fill_channel_masked(#, #)".} ## \
## Fills the indicated channel with all of the same value, but only where the
## table already has a data point.  Leaves empty points unchanged.

proc fill_channel_masked_nan*(this: PfmFile, channel: int) {.importcpp: "#.fill_channel_masked_nan(#)".} ## \
## Fills the indicated channel with NaN, but only where the table already has
## a data point.  Leaves empty points unchanged.

proc calc_average_point*(this: PfmFile, result: LPoint3f, x: float32, y: float32, radius: float32): bool {.importcpp: "#.calc_average_point(#, #, #, #)".} ## \
## Computes the unweighted average point of all points within the box centered
## at (x, y) with the indicated Manhattan-distance radius.  Missing points are
## assigned the value of their nearest neighbor.  Returns true if successful,
## or false if the point value cannot be determined.

proc calc_bilinear_point*(this: PfmFile, result: LPoint3f, x: float32, y: float32): bool {.importcpp: "#.calc_bilinear_point(#, #, #)".} ## \
## Computes the weighted average of the four nearest points to the floating-
## point index (x, y).  Returns true if the point has any contributors, false
## if the point is unknown.

proc calc_min_max*(this: PfmFile, min_points: LVecBase3f, max_points: LVecBase3f): bool {.importcpp: "#.calc_min_max(#, #)".} ## \
## Calculates the minimum and maximum x, y, and z depth component values,
## representing the bounding box of depth values, and places them in the
## indicated vectors.  Returns true if successful, false if the mesh contains
## no points.

proc calc_autocrop*(this: PfmFile, range: LVecBase4d): bool {.importcpp: "#.calc_autocrop(#)".} ## \
## Computes the minimum range of x and y across the PFM file that include all
## points.  If there are no points with no_data_value in the grid--that is,
## all points are included--then this will return (0, get_x_size(), 0,
## get_y_size()).

proc calc_autocrop*(this: PfmFile, range: LVecBase4f): bool {.importcpp: "#.calc_autocrop(#)".} ## \
## Computes the minimum range of x and y across the PFM file that include all
## points.  If there are no points with no_data_value in the grid--that is,
## all points are included--then this will return (0, get_x_size(), 0,
## get_y_size()).

proc is_row_empty*(this: PfmFile, y: int, x_begin: int, x_end: int): bool {.importcpp: "#.is_row_empty(#, #, #)".} ## \
## Returns true if all of the points on row y, in the range [x_begin, x_end),
## are the no_data value, or false if any one of these points has a value.

proc is_column_empty*(this: PfmFile, x: int, y_begin: int, y_end: int): bool {.importcpp: "#.is_column_empty(#, #, #)".} ## \
## Returns true if all of the points on column x, from [y_begin, y_end), are
## the no_data value, or false if any one of these points has a value.

proc set_zero_special*(this: PfmFile, zero_special: bool) {.importcpp: "#.set_zero_special(#)".} ## \
## Sets the zero_special flag.  When this flag is true, values of (0, 0, 0) in
## the pfm file are treated as a special case, and are not processed.
##
## This is a special case of set_no_data_value().

proc set_no_data_chan4*(this: PfmFile, chan4: bool) {.importcpp: "#.set_no_data_chan4(#)".} ## \
## Sets the no_data_chan4 flag.  When this flag is true, and the pfm file has
## 4 channels, then a negative value in the fourth channel indicates no data.
## When it is false, all points are valid.
##
## This is a special case of set_no_data_value().

proc set_no_data_nan*(this: PfmFile, num_channels: int) {.importcpp: "#.set_no_data_nan(#)".} ## \
## Sets the no_data_nan flag.  When num_channels is nonzero, then a NaN value
## in any of the first num_channels channels indicates no data for that point.
## If num_channels is zero, then all points are valid.
##
## This is a special case of set_no_data_value().

proc set_no_data_value*(this: PfmFile, no_data_value: LPoint4d) {.importcpp: "#.set_no_data_value(#)".} ## \
## Sets the special value that means "no data" when it appears in the pfm
## file.

proc set_no_data_value*(this: PfmFile, no_data_value: LPoint4f) {.importcpp: "#.set_no_data_value(#)".} ## \
## Sets the special value that means "no data" when it appears in the pfm
## file.

proc set_no_data_threshold*(this: PfmFile, no_data_value: LPoint4d) {.importcpp: "#.set_no_data_threshold(#)".} ## \
## Sets the special threshold value.  Points that are below this value in all
## components are considered "no value".

proc set_no_data_threshold*(this: PfmFile, no_data_value: LPoint4f) {.importcpp: "#.set_no_data_threshold(#)".} ## \
## Sets the special threshold value.  Points that are below this value in all
## components are considered "no value".

proc clear_no_data_value*(this: PfmFile) {.importcpp: "#.clear_no_data_value()".} ## \
## Removes the special value that means "no data" when it appears in the pfm
## file.  All points will thus be considered valid.

proc has_no_data_value*(this: PfmFile): bool {.importcpp: "#.has_no_data_value()".} ## \
## Returns whether a "no data" value has been established by
## set_no_data_value().

proc has_no_data_threshold*(this: PfmFile): bool {.importcpp: "#.has_no_data_threshold()".} ## \
## Returns whether a "no data" threshold value has been established by
## set_no_data_threshold().

proc get_no_data_value*(this: PfmFile): LPoint4f {.importcpp: "#.get_no_data_value()".} ## \
## If has_no_data_value() returns true, this returns the particular "no data"
## value.

proc resize*(this: PfmFile, new_x_size: int, new_y_size: int) {.importcpp: "#.resize(#, #)".} ## \
## Applies a simple filter to resample the pfm file in-place to the indicated
## size.  Don't confuse this with applying a scale to all of the points via
## xform().

proc box_filter_from*(this: PfmFile, radius: float32, copy: PfmFile) {.importcpp: "#.box_filter_from(#, #)".} ## \
## Makes a resized copy of the indicated image into this one using the
## indicated filter.  The image to be copied is squashed and stretched to
## match the dimensions of the current image, applying the appropriate filter
## to perform the stretching.

proc gaussian_filter_from*(this: PfmFile, radius: float32, copy: PfmFile) {.importcpp: "#.gaussian_filter_from(#, #)".} ## \
## Makes a resized copy of the indicated image into this one using the
## indicated filter.  The image to be copied is squashed and stretched to
## match the dimensions of the current image, applying the appropriate filter
## to perform the stretching.

proc quick_filter_from*(this: PfmFile, copy: PfmFile) {.importcpp: "#.quick_filter_from(#)".} ## \
## Resizes from the given image, with a fixed radius of 0.5. This is a very
## specialized and simple algorithm that doesn't handle dropping below the
## Nyquist rate very well, but is quite a bit faster than the more general
## box_filter(), above.

proc reverse_rows*(this: PfmFile) {.importcpp: "#.reverse_rows()".} ## \
## Performs an in-place reversal of the row (y) data.

proc flip*(this: PfmFile, flip_x: bool, flip_y: bool, transpose: bool) {.importcpp: "#.flip(#, #, #)".} ## \
## Reverses, transposes, and/or rotates the table in-place according to the
## specified parameters.  If flip_x is true, the x axis is reversed; if flip_y
## is true, the y axis is reversed.  Then, if transpose is true, the x and y
## axes are exchanged.  These parameters can be used to select any combination
## of 90-degree or 180-degree rotations and flips.

proc xform*(this: PfmFile, transform: LMatrix4d) {.importcpp: "#.xform(#)".} ## \
## Applies the indicated transform matrix to all points in-place.

proc xform*(this: PfmFile, transform: LMatrix4f) {.importcpp: "#.xform(#)".} ## \
## Applies the indicated transform matrix to all points in-place.

proc forward_distort*(this: PfmFile, dist: PfmFile, scale_factor: float32) {.importcpp: "#.forward_distort(#, #)".} ## \
## Applies the distortion indicated in the supplied dist map to the current
## map.  The dist map is understood to be a mapping of points in the range
## 0..1 in the first two dimensions.
##
## The operation can be expressed symbolically as:
##
## this(u, v) = this(dist(u, v))
##
## If scale_factor is not 1, it should be a value > 1, and it specifies the
## factor to upscale the working table while processing, to reduce artifacts
## from integer truncation.
##
## By convention, the y axis is inverted in the distortion map relative to the
## coordinates here.  A y value of 0 in the distortion map corresponds with a
## v value of 1 in this file.

proc forward_distort*(this: PfmFile, dist: PfmFile) {.importcpp: "#.forward_distort(#)".} ## \
## Applies the distortion indicated in the supplied dist map to the current
## map.  The dist map is understood to be a mapping of points in the range
## 0..1 in the first two dimensions.
##
## The operation can be expressed symbolically as:
##
## this(u, v) = this(dist(u, v))
##
## If scale_factor is not 1, it should be a value > 1, and it specifies the
## factor to upscale the working table while processing, to reduce artifacts
## from integer truncation.
##
## By convention, the y axis is inverted in the distortion map relative to the
## coordinates here.  A y value of 0 in the distortion map corresponds with a
## v value of 1 in this file.

proc reverse_distort*(this: PfmFile, dist: PfmFile, scale_factor: float32) {.importcpp: "#.reverse_distort(#, #)".} ## \
## Applies the distortion indicated in the supplied dist map to the current
## map.  The dist map is understood to be a mapping of points in the range
## 0..1 in the first two dimensions.
##
## The operation can be expressed symbolically as:
##
## this(u, v) = dist(this(u, v))
##
## If scale_factor is not 1, it should be a value > 1, and it specifies the
## factor to upscale the working table while processing, to reduce artifacts
## from integer truncation.
##
## By convention, the y axis in inverted in the distortion map relative to the
## coordinates here.  A y value of 0 in the distortion map corresponds with a
## v value of 1 in this file.

proc reverse_distort*(this: PfmFile, dist: PfmFile) {.importcpp: "#.reverse_distort(#)".} ## \
## Applies the distortion indicated in the supplied dist map to the current
## map.  The dist map is understood to be a mapping of points in the range
## 0..1 in the first two dimensions.
##
## The operation can be expressed symbolically as:
##
## this(u, v) = dist(this(u, v))
##
## If scale_factor is not 1, it should be a value > 1, and it specifies the
## factor to upscale the working table while processing, to reduce artifacts
## from integer truncation.
##
## By convention, the y axis in inverted in the distortion map relative to the
## coordinates here.  A y value of 0 in the distortion map corresponds with a
## v value of 1 in this file.

proc apply_1d_lut*(this: PfmFile, channel: int, lut: PfmFile, x_scale: float32) {.importcpp: "#.apply_1d_lut(#, #, #)".} ## \
## Assumes that lut is an X by 1, 1-component PfmFile whose X axis maps points
## to target points.  For each point in this pfm file, computes: p(u,
## v)[channel] = lut(p(u, v)[channel] * x_scale, 0)[0]

proc apply_1d_lut*(this: PfmFile, channel: int, lut: PfmFile) {.importcpp: "#.apply_1d_lut(#, #)".} ## \
## Assumes that lut is an X by 1, 1-component PfmFile whose X axis maps points
## to target points.  For each point in this pfm file, computes: p(u,
## v)[channel] = lut(p(u, v)[channel] * x_scale, 0)[0]

proc merge*(this: PfmFile, other: PfmFile) {.importcpp: "#.merge(#)".} ## \
## Wherever there is missing data in this PfmFile (that is, wherever
## has_point() returns false), copy data from the other PfmFile, which must be
## exactly the same dimensions as this one.

proc apply_mask*(this: PfmFile, other: PfmFile) {.importcpp: "#.apply_mask(#)".} ## \
## Wherever there is missing data in the other PfmFile, set this the
## corresponding point in this PfmFile to missing as well, so that this
## PfmFile has only points where both files have points.
##
## The point is set to "missing" by setting it the no_data_value.

proc copy_channel*(this: PfmFile, to_channel: int, other: PfmFile, from_channel: int) {.importcpp: "#.copy_channel(#, #, #)".} ## \
## Copies just the specified channel values from the indicated PfmFile (which
## could be same as this PfmFile) into the specified channel of this one.

proc copy_channel_masked*(this: PfmFile, to_channel: int, other: PfmFile, from_channel: int) {.importcpp: "#.copy_channel_masked(#, #, #)".} ## \
## Copies just the specified channel values from the indicated PfmFile, but
## only where the other file has a data point.

proc apply_crop*(this: PfmFile, x_begin: int, x_end: int, y_begin: int, y_end: int) {.importcpp: "#.apply_crop(#, #, #, #)".} ## \
## Reduces the PFM file to the cells in the rectangle bounded by (x_begin,
## x_end, y_begin, y_end), where the _end cells are not included.

proc clear_to_texcoords*(this: PfmFile, x_size: int, y_size: int) {.importcpp: "#.clear_to_texcoords(#, #)".} ## \
## Replaces this PfmFile with a new PfmFile of size x_size x y_size x 3,
## containing the x y 0 values in the range 0 .. 1 according to the x y index.

proc pull_spot*(this: PfmFile, delta: LPoint4f, xc: float32, yc: float32, xr: float32, yr: float32, exponent: float32): int {.importcpp: "#.pull_spot(#, #, #, #, #, #)".} ## \
## Applies delta * t to the point values within radius (xr, yr) distance of
## (xc, yc).  The t value is scaled from 1.0 at the center to 0.0 at radius
## (xr, yr), and this scale follows the specified exponent.  Returns the
## number of points affected.

proc calc_tight_bounds*(this: PfmFile, min_point: LPoint3f, max_point: LPoint3f): bool {.importcpp: "#.calc_tight_bounds(#, #)".} ## \
## Calculates the minimum and maximum vertices of all points within the table.
## Assumes the table contains 3-D points.
##
## The return value is true if any points in the table, or false if none are.

proc compute_planar_bounds*(this: PfmFile, center: LPoint2d, point_dist: float32, sample_radius: float32, points_only: bool): BoundingHexahedron {.importcpp: "#.compute_planar_bounds(#, #, #, #)".} ## \
## Computes the minmax bounding volume of the points in 3-D space, assuming
## the points represent a mostly-planar surface.
##
## This algorithm works by sampling the (square) sample_radius pixels at the
## four point_dist corners around the center (cx - pd, cx + pd) and so on, to
## approximate the plane of the surface.  Then all of the points are projected
## into that plane and the bounding volume of the entire mesh within that
## plane is determined.  If points_only is true, the bounding volume of only
## those four points is determined.
##
## center, point_dist and sample_radius are in UV space, i.e.  in the range
## 0..1.

proc compute_planar_bounds*(this: PfmFile, center: LPoint2f, point_dist: float32, sample_radius: float32, points_only: bool): BoundingHexahedron {.importcpp: "#.compute_planar_bounds(#, #, #, #)".} ## \
## Computes the minmax bounding volume of the points in 3-D space, assuming
## the points represent a mostly-planar surface.
##
## This algorithm works by sampling the (square) sample_radius pixels at the
## four point_dist corners around the center (cx - pd, cx + pd) and so on, to
## approximate the plane of the surface.  Then all of the points are projected
## into that plane and the bounding volume of the entire mesh within that
## plane is determined.  If points_only is true, the bounding volume of only
## those four points is determined.
##
## center, point_dist and sample_radius are in UV space, i.e.  in the range
## 0..1.

proc compute_sample_point*(this: PfmFile, result: LPoint3f, x: float32, y: float32, sample_radius: float32) {.importcpp: "#.compute_sample_point(#, #, #, #)".} ## \
## Computes the average of all the point within sample_radius (manhattan
## distance) and the indicated point.
##
## The point coordinates are given in UV space, in the range 0..1.

proc copy_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.copy_sub_image(#, #, #, #, #, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc copy_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.copy_sub_image(#, #, #, #, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc copy_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.copy_sub_image(#, #, #, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc copy_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int) {.importcpp: "#.copy_sub_image(#, #, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc copy_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int) {.importcpp: "#.copy_sub_image(#, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc add_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int, pixel_scale: float32) {.importcpp: "#.add_sub_image(#, #, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc add_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.add_sub_image(#, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc add_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.add_sub_image(#, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc add_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.add_sub_image(#, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc add_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int) {.importcpp: "#.add_sub_image(#, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc add_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int) {.importcpp: "#.add_sub_image(#, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc mult_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int, pixel_scale: float32) {.importcpp: "#.mult_sub_image(#, #, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc mult_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.mult_sub_image(#, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc mult_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.mult_sub_image(#, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc mult_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.mult_sub_image(#, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc mult_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int) {.importcpp: "#.mult_sub_image(#, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc mult_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int) {.importcpp: "#.mult_sub_image(#, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc divide_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int, pixel_scale: float32) {.importcpp: "#.divide_sub_image(#, #, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are divided into the
## pixels of the destination, after scaling by the specified pixel_scale.
## dest(x, y) = dest(x, y) / (copy(x, y) * pixel_scale).

proc divide_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.divide_sub_image(#, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are divided into the
## pixels of the destination, after scaling by the specified pixel_scale.
## dest(x, y) = dest(x, y) / (copy(x, y) * pixel_scale).

proc divide_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.divide_sub_image(#, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are divided into the
## pixels of the destination, after scaling by the specified pixel_scale.
## dest(x, y) = dest(x, y) / (copy(x, y) * pixel_scale).

proc divide_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.divide_sub_image(#, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are divided into the
## pixels of the destination, after scaling by the specified pixel_scale.
## dest(x, y) = dest(x, y) / (copy(x, y) * pixel_scale).

proc divide_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int) {.importcpp: "#.divide_sub_image(#, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are divided into the
## pixels of the destination, after scaling by the specified pixel_scale.
## dest(x, y) = dest(x, y) / (copy(x, y) * pixel_scale).

proc divide_sub_image*(this: PfmFile, copy: PfmFile, xto: int, yto: int) {.importcpp: "#.divide_sub_image(#, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are divided into the
## pixels of the destination, after scaling by the specified pixel_scale.
## dest(x, y) = dest(x, y) / (copy(x, y) * pixel_scale).

proc `*=`*(this: PfmFile, multiplier: float32): PfmFile {.importcpp: "#.operator *=(#)".}

proc indirect_1d_lookup*(this: PfmFile, index_image: PfmFile, channel: int, pixel_values: PfmFile) {.importcpp: "#.indirect_1d_lookup(#, #, #)".} ## \
## index_image is a WxH 1-channel image, while pixel_values is an Nx1
## image with any number of channels.  Typically pixel_values will be
## a 256x1 image.
##
## Fills the PfmFile with a new image the same width and height as
## index_image, with the same number of channels as pixel_values.
##
## Each pixel of the new image is computed with the formula:
##
## new_image(x, y) = pixel_values(index_image(x, y)[channel], 0)
##
## At present, no interpolation is performed; the nearest value in
## pixel_values is discovered.  This may change in the future.

proc gamma_correct*(this: PfmFile, from_gamma: float32, to_gamma: float32) {.importcpp: "#.gamma_correct(#, #)".} ## \
## Assuming the image was constructed with a gamma curve of from_gamma in the
## RGB channels, converts it to an image with a gamma curve of to_gamma in the
## RGB channels.  Does not affect the alpha channel.

proc gamma_correct_alpha*(this: PfmFile, from_gamma: float32, to_gamma: float32) {.importcpp: "#.gamma_correct_alpha(#, #)".} ## \
## Assuming the image was constructed with a gamma curve of from_gamma in the
## alpha channel, converts it to an image with a gamma curve of to_gamma in
## the alpha channel.  Does not affect the RGB channels.

proc apply_exponent*(this: PfmFile, gray_exponent: float32) {.importcpp: "#.apply_exponent(#)".} ## \
## Adjusts each channel of the image by raising the corresponding component
## value to the indicated exponent, such that L' = L ^ exponent.

proc apply_exponent*(this: PfmFile, gray_exponent: float32, alpha_exponent: float32) {.importcpp: "#.apply_exponent(#, #)".} ## \
## Adjusts each channel of the image by raising the corresponding component
## value to the indicated exponent, such that L' = L ^ exponent.

proc apply_exponent*(this: PfmFile, c0_exponent: float32, c1_exponent: float32, c2_exponent: float32) {.importcpp: "#.apply_exponent(#, #, #)".} ## \
## Adjusts each channel of the image by raising the corresponding component
## value to the indicated exponent, such that L' = L ^ exponent.  For a
## grayscale image, the blue_exponent value is used for the grayscale value,
## and red_exponent and green_exponent are unused.

proc apply_exponent*(this: PfmFile, c0_exponent: float32, c1_exponent: float32, c2_exponent: float32, c3_exponent: float32) {.importcpp: "#.apply_exponent(#, #, #, #)".} ## \
## Adjusts each channel of the image by raising the corresponding component
## value to the indicated exponent, such that L' = L ^ exponent.

proc output*(this: PfmFile, `out`: ostream) {.importcpp: "#.output(#)".}

proc make_transparent*(_: typedesc[PNMBrush]): PNMBrush {.importcpp: "PNMBrush::make_transparent()", header: "pNMBrush.h".} ## \
## Returns a new brush that does not paint anything.  Can be used as either a
## pen or a fill brush to make borderless or unfilled shapes, respectively.

proc make_pixel*(_: typedesc[PNMBrush], color: LColorf): PNMBrush {.importcpp: "PNMBrush::make_pixel(#)", header: "pNMBrush.h".} ## \
## Returns a new brush that paints a single pixel of the indicated color on a
## border, or paints a solid color in an interior.

proc make_spot*(_: typedesc[PNMBrush], color: LColorf, radius: float32, fuzzy: bool): PNMBrush {.importcpp: "PNMBrush::make_spot(#, #, #)", header: "pNMBrush.h".} ## \
## Returns a new brush that paints a spot of the indicated color and radius.
## If fuzzy is true, the spot is fuzzy; otherwise, it is hard-edged.

proc make_image*(_: typedesc[PNMBrush], image: PNMImage, xc: float32, yc: float32): PNMBrush {.importcpp: "PNMBrush::make_image(#, #, #)", header: "pNMBrush.h".} ## \
## Returns a new brush that paints with the indicated image.  xc and yc
## indicate the pixel in the center of the brush.
##
## The brush makes a copy of the image; it is safe to deallocate or modify the
## image after making this call.

proc initPNMImage*(): PNMImage {.importcpp: "PNMImage()".}

proc initPNMImage*(filename: Filename, `type`: PNMFileType): PNMImage {.importcpp: "PNMImage(#, #)".}

proc initPNMImage*(filename: Filename): PNMImage {.importcpp: "PNMImage(#)".}

proc initPNMImage*(copy: PNMImage): PNMImage {.importcpp: "PNMImage(#)".}

proc initPNMImage*(x_size: int, y_size: int, num_channels: int, maxval: int, `type`: PNMFileType, color_space: ColorSpace): PNMImage {.importcpp: "PNMImage(#, #, #, #, #, #)".}

proc initPNMImage*(x_size: int, y_size: int, num_channels: int, maxval: int, `type`: PNMFileType): PNMImage {.importcpp: "PNMImage(#, #, #, #, #)".}

proc initPNMImage*(x_size: int, y_size: int, num_channels: int, maxval: int): PNMImage {.importcpp: "PNMImage(#, #, #, #)".}

proc initPNMImage*(x_size: int, y_size: int, num_channels: int): PNMImage {.importcpp: "PNMImage(#, #, #)".}

proc initPNMImage*(x_size: int, y_size: int): PNMImage {.importcpp: "PNMImage(#, #)".}

proc clamp_val*(this: PNMImage, input_value: int): int {.importcpp: "#.clamp_val(#)".} ## \
## A handy function to clamp values to [0..get_maxval()].

proc to_val*(this: PNMImage, input_value: LRGBColorf): xel {.importcpp: "#.to_val(#)".} ## \
## A handy function to scale non-alpha values from [0..1] to
## [0..get_maxval()].  Do not use this for alpha values, see to_alpha_val.

proc to_val*(this: PNMImage, input_value: float32): int {.importcpp: "#.to_val(#)".} ## \
## A handy function to scale non-alpha values from [0..1] to
## [0..get_maxval()].  Do not use this for alpha values, see to_alpha_val.

proc to_alpha_val*(this: PNMImage, input_value: float32): int {.importcpp: "#.to_alpha_val(#)".} ## \
## A handy function to scale alpha values from [0..1] to [0..get_maxval()].

proc from_val*(this: PNMImage, input_value: xel): LRGBColorf {.importcpp: "#.from_val(#)".} ## \
## A handy function to scale non-alpha values from [0..get_maxval()] to
## [0..1].  Do not use this for alpha values, see from_alpha_val.

proc from_val*(this: PNMImage, input_value: int): float32 {.importcpp: "#.from_val(#)".} ## \
## A handy function to scale non-alpha values from [0..get_maxval()] to
## [0..1].  Do not use this for alpha values, see from_alpha_val.

proc from_alpha_val*(this: PNMImage, input_value: int): float32 {.importcpp: "#.from_alpha_val(#)".} ## \
## A handy function to scale alpha values from [0..get_maxval()] to [0..1].

proc clear*(this: PNMImage) {.importcpp: "#.clear()".} ## \
## Frees all memory allocated for the image, and clears all its parameters
## (size, color, type, etc).

proc clear*(this: PNMImage, x_size: int, y_size: int, num_channels: int, maxval: int, `type`: PNMFileType, color_space: ColorSpace) {.importcpp: "#.clear(#, #, #, #, #, #)".} ## \
## This flavor of clear() reinitializes the image to an empty (black) image
## with the given dimensions.

proc clear*(this: PNMImage, x_size: int, y_size: int, num_channels: int, maxval: int, `type`: PNMFileType) {.importcpp: "#.clear(#, #, #, #, #)".} ## \
## This flavor of clear() reinitializes the image to an empty (black) image
## with the given dimensions.

proc clear*(this: PNMImage, x_size: int, y_size: int, num_channels: int, maxval: int) {.importcpp: "#.clear(#, #, #, #)".} ## \
## This flavor of clear() reinitializes the image to an empty (black) image
## with the given dimensions.

proc clear*(this: PNMImage, x_size: int, y_size: int, num_channels: int) {.importcpp: "#.clear(#, #, #)".} ## \
## This flavor of clear() reinitializes the image to an empty (black) image
## with the given dimensions.

proc clear*(this: PNMImage, x_size: int, y_size: int) {.importcpp: "#.clear(#, #)".} ## \
## This flavor of clear() reinitializes the image to an empty (black) image
## with the given dimensions.

proc copy_from*(this: PNMImage, copy: PNMImage) {.importcpp: "#.copy_from(#)".} ## \
## Makes this image become a copy of the other image.

proc copy_channel*(this: PNMImage, copy: PNMImage, src_channel: int, dest_channel: int) {.importcpp: "#.copy_channel(#, #, #)".} ## \
## Copies a channel from one image into another.  Images must be the same size

proc copy_channel*(this: PNMImage, copy: PNMImage, xto: int, yto: int, cto: int, xfrom: int, yfrom: int, cfrom: int, x_size: int, y_size: int) {.importcpp: "#.copy_channel(#, #, #, #, #, #, #, #, #)".} ## \
## Copies just a single channel from the source image into a single channel of
## this image, leaving the remaining channels alone.

proc copy_channel*(this: PNMImage, copy: PNMImage, xto: int, yto: int, cto: int, xfrom: int, yfrom: int, cfrom: int, x_size: int) {.importcpp: "#.copy_channel(#, #, #, #, #, #, #, #)".} ## \
## Copies just a single channel from the source image into a single channel of
## this image, leaving the remaining channels alone.

proc copy_channel*(this: PNMImage, copy: PNMImage, xto: int, yto: int, cto: int, xfrom: int, yfrom: int, cfrom: int) {.importcpp: "#.copy_channel(#, #, #, #, #, #, #)".} ## \
## Copies just a single channel from the source image into a single channel of
## this image, leaving the remaining channels alone.

proc copy_channel*(this: PNMImage, copy: PNMImage, xto: int, yto: int, cto: int, xfrom: int, yfrom: int) {.importcpp: "#.copy_channel(#, #, #, #, #, #)".} ## \
## Copies just a single channel from the source image into a single channel of
## this image, leaving the remaining channels alone.

proc copy_channel*(this: PNMImage, copy: PNMImage, xto: int, yto: int, cto: int, xfrom: int) {.importcpp: "#.copy_channel(#, #, #, #, #)".} ## \
## Copies just a single channel from the source image into a single channel of
## this image, leaving the remaining channels alone.

proc copy_channel*(this: PNMImage, copy: PNMImage, xto: int, yto: int, cto: int) {.importcpp: "#.copy_channel(#, #, #, #)".} ## \
## Copies just a single channel from the source image into a single channel of
## this image, leaving the remaining channels alone.

proc copy_channel_bits*(this: PNMImage, copy: PNMImage, src_channel: int, dest_channel: int, src_mask: int, right_shift: int) {.importcpp: "#.copy_channel_bits(#, #, #, #, #)".} ## \
## Copies some subset of the bits of the specified channel from one image into
## some subset of the bits of the specified channel in another image.  Images
## must be the same size.
##
## If right_shift is negative, it means a left shift.

proc copy_header_from*(this: PNMImage, header: PNMImageHeader) {.importcpp: "#.copy_header_from(#)".} ## \
## Copies just the header information into this image.  This will blow away
## any image data stored in the image.  The new image data will be allocated,
## but left unitialized.

proc take_from*(this: PNMImage, orig: PNMImage) {.importcpp: "#.take_from(#)".} ## \
## Move the contents of the other image into this one, and empty the other
## image.

proc fill*(this: PNMImage, gray: float32) {.importcpp: "#.fill(#)".} ## \
## Sets the entire image (except the alpha channel) to the given grayscale
## level.

proc fill*(this: PNMImage) {.importcpp: "#.fill()".} ## \
## Sets the entire image (except the alpha channel) to the given grayscale
## level.

proc fill*(this: PNMImage, red: float32, green: float32, blue: float32) {.importcpp: "#.fill(#, #, #)".} ## \
## Sets the entire image (except the alpha channel) to the given color.

proc fill_val*(this: PNMImage, gray: int) {.importcpp: "#.fill_val(#)".} ## \
## Sets the entire image (except the alpha channel) to the given grayscale
## level.

proc fill_val*(this: PNMImage) {.importcpp: "#.fill_val()".} ## \
## Sets the entire image (except the alpha channel) to the given grayscale
## level.

proc fill_val*(this: PNMImage, red: int, green: int, blue: int) {.importcpp: "#.fill_val(#, #, #)".} ## \
## Sets the entire image (except the alpha channel) to the given color.

proc alpha_fill*(this: PNMImage, alpha: float32) {.importcpp: "#.alpha_fill(#)".} ## \
## Sets the entire alpha channel to the given level.

proc alpha_fill*(this: PNMImage) {.importcpp: "#.alpha_fill()".} ## \
## Sets the entire alpha channel to the given level.

proc alpha_fill_val*(this: PNMImage, alpha: int) {.importcpp: "#.alpha_fill_val(#)".} ## \
## Sets the entire alpha channel to the given level.

proc alpha_fill_val*(this: PNMImage) {.importcpp: "#.alpha_fill_val()".} ## \
## Sets the entire alpha channel to the given level.

proc set_read_size*(this: PNMImage, x_size: int, y_size: int) {.importcpp: "#.set_read_size(#, #)".} ## \
## Specifies the size to we'd like to scale the image upon reading it.  This
## will affect the next call to read().  This is usually used to reduce the
## image size, e.g.  for a thumbnail.
##
## If the file type reader supports it (e.g.  JPEG), then this will scale the
## image during the read operation, consequently reducing memory and CPU
## utilization.  If the file type reader does not support it, this will load
## the image normally, and them perform a linear scale after it has been
## loaded.

proc clear_read_size*(this: PNMImage) {.importcpp: "#.clear_read_size()".} ## \
## Undoes the effect of a previous call to set_read_size().

proc has_read_size*(this: PNMImage): bool {.importcpp: "#.has_read_size()".} ## \
## Returns true if set_read_size() has been called.

proc get_read_x_size*(this: PNMImage): int {.importcpp: "#.get_read_x_size()".} ## \
## Returns the requested x_size of the image if set_read_size() has been
## called, or the image x_size otherwise (if it is known).

proc get_read_y_size*(this: PNMImage): int {.importcpp: "#.get_read_y_size()".} ## \
## Returns the requested y_size of the image if set_read_size() has been
## called, or the image y_size otherwise (if it is known).

proc get_color_space*(this: PNMImage): ColorSpace {.importcpp: "#.get_color_space()".} ## \
## Returns the color space in which the image is encoded.

proc read*(this: PNMImage, filename: Filename, `type`: PNMFileType, report_unknown_type: bool): bool {.importcpp: "#.read(#, #, #)".} ## \
## Reads the indicated image filename.  If type is non-NULL, it is a
## suggestion for the type of file it is.  Returns true if successful, false
## on error.

proc read*(this: PNMImage, filename: Filename, `type`: PNMFileType): bool {.importcpp: "#.read(#, #)".} ## \
## Reads the indicated image filename.  If type is non-NULL, it is a
## suggestion for the type of file it is.  Returns true if successful, false
## on error.

proc read*(this: PNMImage, filename: Filename): bool {.importcpp: "#.read(#)".} ## \
## Reads the indicated image filename.  If type is non-NULL, it is a
## suggestion for the type of file it is.  Returns true if successful, false
## on error.

proc read*(this: PNMImage, data: istream, filename: string, `type`: PNMFileType, report_unknown_type: bool): bool {.importcpp: "#.read(#, nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Reads the image data from the indicated stream.
##
## The filename is advisory only, and may be used to suggest a type if it has
## a known extension.
##
## If type is non-NULL, it is a suggestion for the type of file it is (and a
## non-NULL type will override any magic number test or filename extension
## lookup).
##
## Returns true if successful, false on error.

proc read*(this: PNMImage, data: istream, filename: string, `type`: PNMFileType): bool {.importcpp: "#.read(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Reads the image data from the indicated stream.
##
## The filename is advisory only, and may be used to suggest a type if it has
## a known extension.
##
## If type is non-NULL, it is a suggestion for the type of file it is (and a
## non-NULL type will override any magic number test or filename extension
## lookup).
##
## Returns true if successful, false on error.

proc read*(this: PNMImage, data: istream, filename: string): bool {.importcpp: "#.read(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reads the image data from the indicated stream.
##
## The filename is advisory only, and may be used to suggest a type if it has
## a known extension.
##
## If type is non-NULL, it is a suggestion for the type of file it is (and a
## non-NULL type will override any magic number test or filename extension
## lookup).
##
## Returns true if successful, false on error.

proc read*(this: PNMImage, data: istream): bool {.importcpp: "#.read(#)".} ## \
## Reads the image data from the indicated stream.
##
## The filename is advisory only, and may be used to suggest a type if it has
## a known extension.
##
## If type is non-NULL, it is a suggestion for the type of file it is (and a
## non-NULL type will override any magic number test or filename extension
## lookup).
##
## Returns true if successful, false on error.

proc write*(this: PNMImage, filename: Filename, `type`: PNMFileType): bool {.importcpp: "#.write(#, #)".} ## \
## Writes the image to the indicated filename.  If type is non-NULL, it is a
## suggestion for the type of image file to write.

proc write*(this: PNMImage, filename: Filename): bool {.importcpp: "#.write(#)".} ## \
## Writes the image to the indicated filename.  If type is non-NULL, it is a
## suggestion for the type of image file to write.

proc write*(this: PNMImage, data: ostream, filename: string, `type`: PNMFileType): bool {.importcpp: "#.write(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Writes the image to the indicated ostream.
##
## The filename is advisory only, and may be used suggest a type if it has a
## known extension.
##
## If type is non-NULL, it is a suggestion for the type of image file to
## write.

proc write*(this: PNMImage, data: ostream, filename: string): bool {.importcpp: "#.write(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Writes the image to the indicated ostream.
##
## The filename is advisory only, and may be used suggest a type if it has a
## known extension.
##
## If type is non-NULL, it is a suggestion for the type of image file to
## write.

proc write*(this: PNMImage, data: ostream): bool {.importcpp: "#.write(#)".} ## \
## Writes the image to the indicated ostream.
##
## The filename is advisory only, and may be used suggest a type if it has a
## known extension.
##
## If type is non-NULL, it is a suggestion for the type of image file to
## write.

proc is_valid*(this: PNMImage): bool {.importcpp: "#.is_valid()".} ## \
## Returns true if the image has been read in or correctly initialized with a
## height and width.  If this returns false, virtually all member functions
## except clear() and read() are invalid function calls.

proc set_num_channels*(this: PNMImage, num_channels: int) {.importcpp: "#.set_num_channels(#)".} ## \
## Changes the number of channels associated with the image.  The new number
## of channels must be an integer in the range 1 through 4, inclusive.  This
## will allocate and/or deallocate memory as necessary to accommodate; see
## set_color_type().

proc set_color_space*(this: PNMImage, color_space: ColorSpace) {.importcpp: "#.set_color_space(#)".} ## \
## Converts the colors in the image to the indicated color space.  This may be
## a lossy operation, in particular when going from sRGB to linear.  The alpha
## channel remains untouched.
##
## Note that, because functions like get_xel() and set_xel() work on
## linearized floating-point values, this conversion won't affect those values
## (aside from some minor discrepancies due to storage precision).  It does
## affect the values used by get_xel_val() and set_xel_val(), though, since
## those operate on encoded colors.
##
## Some color spaces, particularly scRGB, may enforce the use of a particular
## maxval setting.

proc add_alpha*(this: PNMImage) {.importcpp: "#.add_alpha()".} ## \
## Adds an alpha channel to the image, if it does not already have one.  The
## alpha channel is initialized to zeros.

proc remove_alpha*(this: PNMImage) {.importcpp: "#.remove_alpha()".} ## \
## Removes the image's alpha channel, if it exists.

proc make_grayscale*(this: PNMImage) {.importcpp: "#.make_grayscale()".} ## \
## Converts the image from RGB to grayscale.  Any alpha channel, if present,
## is left undisturbed.

proc make_grayscale*(this: PNMImage, rc: float32, gc: float32, bc: float32) {.importcpp: "#.make_grayscale(#, #, #)".} ## \
## Converts the image from RGB to grayscale.  Any alpha channel, if present,
## is left undisturbed.  The optional rc, gc, bc values represent the relative
## weights to apply to each channel to convert it to grayscale.

proc make_rgb*(this: PNMImage) {.importcpp: "#.make_rgb()".} ## \
## Converts the image from grayscale to RGB.  Any alpha channel, if present,
## is left undisturbed.

proc premultiply_alpha*(this: PNMImage) {.importcpp: "#.premultiply_alpha()".} ## \
## Converts an image in-place to its "premultiplied" form, where, for every
## pixel in the image, the red, green, and blue components are multiplied by
## that pixel's alpha value.
##
## This does not modify any alpha values.

proc unpremultiply_alpha*(this: PNMImage) {.importcpp: "#.unpremultiply_alpha()".} ## \
## Converts an image in-place to its "straight alpha" form (presumably from a
## "premultiplied" form), where, for every pixel in the image, the red, green,
## and blue components are divided by that pixel's alpha value.
##
## This does not modify any alpha values.

proc reverse_rows*(this: PNMImage) {.importcpp: "#.reverse_rows()".} ## \
## Performs an in-place reversal of the row (y) data.

proc flip*(this: PNMImage, flip_x: bool, flip_y: bool, transpose: bool) {.importcpp: "#.flip(#, #, #)".} ## \
## Reverses, transposes, and/or rotates the image in-place according to the
## specified parameters.  If flip_x is true, the x axis is reversed; if flip_y
## is true, the y axis is reversed.  Then, if transpose is true, the x and y
## axes are exchanged.  These parameters can be used to select any combination
## of 90-degree or 180-degree rotations and flips.

proc set_maxval*(this: PNMImage, maxval: int) {.importcpp: "#.set_maxval(#)".} ## \
## Rescales the image to the indicated maxval.

proc get_xel_val*(this: PNMImage, x: int, y: int): xel {.importcpp: "#.get_xel_val(#, #)".} ## \
## Returns the RGB color at the indicated pixel.  Each component is in the
## range 0..maxval.

proc set_xel_val*(this: PNMImage, x: int, y: int, value: xel) {.importcpp: "#.set_xel_val(#, #, #)".} ## \
## Changes the RGB color at the indicated pixel.  Each component is in the
## range 0..maxval, encoded in the configured color space.  See set_xel if you
## instead have a linearized and normalized floating-point value.

proc set_xel_val*(this: PNMImage, x: int, y: int, gray: int) {.importcpp: "#.set_xel_val(#, #, #)".} ## \
## Changes all three color components at the indicated pixel to the same
## value.  The value is in the range component is in the range 0..maxval,
## encoded in the configured color space.  See set_xel if you instead have a
## linearized and normalized floating-point value.

proc set_xel_val*(this: PNMImage, x: int, y: int, r: int, g: int, b: int) {.importcpp: "#.set_xel_val(#, #, #, #, #)".} ## \
## Changes the RGB color at the indicated pixel.  Each component is in the
## range 0..maxval, encoded in the configured color space.  See set_xel if you
## instead have a linearized and normalized floating-point value.

proc get_red_val*(this: PNMImage, x: int, y: int): int {.importcpp: "#.get_red_val(#, #)".} ## \
## Returns the red component color at the indicated pixel.  The value returned
## is in the range 0..maxval and encoded in the configured color space.

proc get_green_val*(this: PNMImage, x: int, y: int): int {.importcpp: "#.get_green_val(#, #)".} ## \
## Returns the green component color at the indicated pixel.  The value
## returned is in the range 0..maxval and encoded in the configured color
## space.

proc get_blue_val*(this: PNMImage, x: int, y: int): int {.importcpp: "#.get_blue_val(#, #)".} ## \
## Returns the blue component color at the indicated pixel.  The value
## returned is in the range 0..maxval and encoded in the configured color
## space.

proc get_gray_val*(this: PNMImage, x: int, y: int): int {.importcpp: "#.get_gray_val(#, #)".} ## \
## Returns the gray component color at the indicated pixel.  This only has a
## meaningful value for grayscale images; for other image types, this returns
## the value of the blue channel only.  However, also see the get_bright()
## function.  The value returned is in the range 0..maxval and encoded in the
## configured color space.

proc get_alpha_val*(this: PNMImage, x: int, y: int): int {.importcpp: "#.get_alpha_val(#, #)".} ## \
## Returns the alpha component color at the indicated pixel.  It is an error
## to call this unless has_alpha() is true.  The value returned is in the
## range 0..maxval and always linear.

proc set_red_val*(this: PNMImage, x: int, y: int, r: int) {.importcpp: "#.set_red_val(#, #, #)".} ## \
## Sets the red component color only at the indicated pixel.  The value given
## should be in the range 0..maxval, encoded in the configured color space.
## See set_red if you instead have a linearized and normalized floating-point
## value.

proc set_green_val*(this: PNMImage, x: int, y: int, g: int) {.importcpp: "#.set_green_val(#, #, #)".} ## \
## Sets the green component color only at the indicated pixel.  The value
## given should be in the range 0..maxval, encoded in the configured color
## space.  See set_green if you instead have a linearized and normalized
## floating-point value.

proc set_blue_val*(this: PNMImage, x: int, y: int, b: int) {.importcpp: "#.set_blue_val(#, #, #)".} ## \
## Sets the blue component color only at the indicated pixel.  The value given
## should be in the range 0..maxval, encoded in the configured color space.
## See set_blue if you instead have a linearized and normalized floating-point
## value.

proc set_gray_val*(this: PNMImage, x: int, y: int, gray: int) {.importcpp: "#.set_gray_val(#, #, #)".} ## \
## Sets the gray component color at the indicated pixel.  This is only
## meaningful for grayscale images; for other image types, this simply sets
## the blue component color.  However, also see set_xel_val(), which can set
## all the component colors to the same grayscale level, and hence works
## correctly both for grayscale and color images.  The value given should be
## in the range 0..maxval, encoded in the configured color space.  See
## set_gray if you instead have a linearized normalized floating-point value.

proc set_alpha_val*(this: PNMImage, x: int, y: int, a: int) {.importcpp: "#.set_alpha_val(#, #, #)".} ## \
## Sets the alpha component color only at the indicated pixel.  It is an error
## to call this unless has_alpha() is true.  The value given should be in the
## range 0..maxval.
##
## This value is always linearly encoded, even if the image is set to the sRGB
## color space.

proc get_channel_val*(this: PNMImage, x: int, y: int, channel: int): int {.importcpp: "#.get_channel_val(#, #, #)".} ## \
## Returns the nth component color at the indicated pixel.  The channel index
## should be in the range 0..(get_num_channels()-1).  The channels are ordered
## B, G, R, A.  This is slightly less optimal than accessing the component
## values directly by named methods.  The value returned is in the range
## 0..maxval.

proc set_channel_val*(this: PNMImage, x: int, y: int, channel: int, value: int) {.importcpp: "#.set_channel_val(#, #, #, #)".} ## \
## Sets the nth component color at the indicated pixel.  The channel index
## should be in the range 0..(get_num_channels()-1).  The channels are ordered
## B, G, R, A.  This is slightly less optimal than setting the component
## values directly by named methods.  The value given should be in the range
## 0..maxval.

proc get_channel*(this: PNMImage, x: int, y: int, channel: int): float32 {.importcpp: "#.get_channel(#, #, #)".} ## \
## Returns the nth component color at the indicated pixel.  The channel index
## should be in the range 0..(get_num_channels()-1).  The channels are ordered
## B, G, R, A.  This is slightly less optimal than accessing the component
## values directly by named methods.  The value returned is a float in the
## range 0..1.

proc set_channel*(this: PNMImage, x: int, y: int, channel: int, value: float32) {.importcpp: "#.set_channel(#, #, #, #)".} ## \
## Sets the nth component color at the indicated pixel.  The channel index
## should be in the range 0..(get_num_channels()-1).  The channels are ordered
## B, G, R, A.  This is slightly less optimal than setting the component
## values directly by named methods.  The value given should be a float in the
## range 0..1.

proc get_xel*(this: PNMImage, x: int, y: int): LRGBColorf {.importcpp: "#.get_xel(#, #)".} ## \
## Returns the RGB color at the indicated pixel.  Each component is a
## linearized float in the range 0..1.

proc set_xel*(this: PNMImage, x: int, y: int, value: LRGBColorf) {.importcpp: "#.set_xel(#, #, #)".} ## \
## Changes the RGB color at the indicated pixel.  Each component is a
## linearized float in the range 0..1.

proc set_xel*(this: PNMImage, x: int, y: int, gray: float32) {.importcpp: "#.set_xel(#, #, #)".} ## \
## Changes all three color components at the indicated pixel to the same
## value.  The value is a linearized float in the range 0..1.

proc set_xel*(this: PNMImage, x: int, y: int, r: float32, g: float32, b: float32) {.importcpp: "#.set_xel(#, #, #, #, #)".} ## \
## Changes the RGB color at the indicated pixel.  Each component is a
## linearized float in the range 0..1.

proc get_xel_a*(this: PNMImage, x: int, y: int): LColorf {.importcpp: "#.get_xel_a(#, #)".} ## \
## Returns the RGBA color at the indicated pixel.  Each component is a
## linearized float in the range 0..1.

proc set_xel_a*(this: PNMImage, x: int, y: int, value: LColorf) {.importcpp: "#.set_xel_a(#, #, #)".} ## \
## Changes the RGBA color at the indicated pixel.  Each component is a
## linearized float in the range 0..1.

proc set_xel_a*(this: PNMImage, x: int, y: int, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_xel_a(#, #, #, #, #, #)".} ## \
## Changes the RGBA color at the indicated pixel.  Each component is a
## linearized float in the range 0..1.

proc get_red*(this: PNMImage, x: int, y: int): float32 {.importcpp: "#.get_red(#, #)".} ## \
## Returns the red component color at the indicated pixel.  The value returned
## is a linearized float in the range 0..1.

proc get_green*(this: PNMImage, x: int, y: int): float32 {.importcpp: "#.get_green(#, #)".} ## \
## Returns the green component color at the indicated pixel.  The value
## returned is a linearized float in the range 0..1.

proc get_blue*(this: PNMImage, x: int, y: int): float32 {.importcpp: "#.get_blue(#, #)".} ## \
## Returns the blue component color at the indicated pixel.  The value
## returned is a linearized float in the range 0..1.

proc get_gray*(this: PNMImage, x: int, y: int): float32 {.importcpp: "#.get_gray(#, #)".} ## \
## Returns the gray component color at the indicated pixel.  This only has a
## meaningful value for grayscale images; for other image types, this returns
## the value of the blue channel only.  However, also see the get_bright()
## function.  The value returned is a linearized float in the range 0..1.

proc get_alpha*(this: PNMImage, x: int, y: int): float32 {.importcpp: "#.get_alpha(#, #)".} ## \
## Returns the alpha component color at the indicated pixel.  It is an error
## to call this unless has_alpha() is true.  The value returned is a float in
## the range 0..1.

proc set_red*(this: PNMImage, x: int, y: int, r: float32) {.importcpp: "#.set_red(#, #, #)".} ## \
## Sets the red component color only at the indicated pixel.  The value given
## should be a linearized float in the range 0..1.

proc set_green*(this: PNMImage, x: int, y: int, g: float32) {.importcpp: "#.set_green(#, #, #)".} ## \
## Sets the green component color only at the indicated pixel.  The value
## given should be a linearized float in the range 0..1.

proc set_blue*(this: PNMImage, x: int, y: int, b: float32) {.importcpp: "#.set_blue(#, #, #)".} ## \
## Sets the blue component color only at the indicated pixel.  The value given
## should be a linearized float in the range 0..1.

proc set_gray*(this: PNMImage, x: int, y: int, gray: float32) {.importcpp: "#.set_gray(#, #, #)".} ## \
## Sets the gray component color at the indicated pixel.  This is only
## meaningful for grayscale images; for other image types, this simply sets
## the blue component color.  However, also see set_xel(), which can set all
## the component colors to the same grayscale level, and hence works correctly
## both for grayscale and color images.  The value given should be a
## linearized float in the range 0..1.

proc set_alpha*(this: PNMImage, x: int, y: int, a: float32) {.importcpp: "#.set_alpha(#, #, #)".} ## \
## Sets the alpha component color only at the indicated pixel.  It is an error
## to call this unless has_alpha() is true.  The value given should be in the
## range 0..1.

proc get_bright*(this: PNMImage, x: int, y: int): float32 {.importcpp: "#.get_bright(#, #)".} ## \
## Returns the linear brightness of the given xel, as a linearized float in
## the range 0..1.  This flavor of get_bright() returns the correct grayscale
## brightness level for both full-color and grayscale images.

proc get_bright*(this: PNMImage, x: int, y: int, rc: float32, gc: float32, bc: float32): float32 {.importcpp: "#.get_bright(#, #, #, #, #)".} ## \
## This flavor of get_bright() works correctly only for color images.  It
## returns a single brightness value for the RGB color at the indicated pixel,
## based on the supplied weights for each component.

proc get_bright*(this: PNMImage, x: int, y: int, rc: float32, gc: float32, bc: float32, ac: float32): float32 {.importcpp: "#.get_bright(#, #, #, #, #, #)".} ## \
## This flavor of get_bright() works correctly only for four-channel images.
## It returns a single brightness value for the RGBA color at the indicated
## pixel, based on the supplied weights for each component.

proc blend*(this: PNMImage, x: int, y: int, val: LRGBColorf, alpha: float32) {.importcpp: "#.blend(#, #, #, #)".} ## \
## Smoothly blends the indicated pixel value in with whatever was already in
## the image, based on the given alpha value.  An alpha of 1.0 is fully opaque
## and completely replaces whatever was there previously; alpha of 0.0 is
## fully transparent and does nothing.

proc blend*(this: PNMImage, x: int, y: int, r: float32, g: float32, b: float32, alpha: float32) {.importcpp: "#.blend(#, #, #, #, #, #)".} ## \
## Smoothly blends the indicated pixel value in with whatever was already in
## the image, based on the given alpha value.  An alpha of 1.0 is fully opaque
## and completely replaces whatever was there previously; alpha of 0.0 is
## fully transparent and does nothing.

proc copy_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.copy_sub_image(#, #, #, #, #, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc copy_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.copy_sub_image(#, #, #, #, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc copy_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.copy_sub_image(#, #, #, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc copy_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int) {.importcpp: "#.copy_sub_image(#, #, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc copy_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int) {.importcpp: "#.copy_sub_image(#, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc blend_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int, pixel_scale: float32) {.importcpp: "#.blend_sub_image(#, #, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the alpha channel of the copy is used
## to blend the copy into the destination image, instead of overwriting pixels
## unconditionally.
##
## If pixel_scale is not 1.0, it specifies an amount to scale each *alpha*
## value of the source image before applying it to the target image.
##
## If pixel_scale is 1.0 and the copy has no alpha channel, this degenerates
## into copy_sub_image().

proc blend_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.blend_sub_image(#, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the alpha channel of the copy is used
## to blend the copy into the destination image, instead of overwriting pixels
## unconditionally.
##
## If pixel_scale is not 1.0, it specifies an amount to scale each *alpha*
## value of the source image before applying it to the target image.
##
## If pixel_scale is 1.0 and the copy has no alpha channel, this degenerates
## into copy_sub_image().

proc blend_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.blend_sub_image(#, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the alpha channel of the copy is used
## to blend the copy into the destination image, instead of overwriting pixels
## unconditionally.
##
## If pixel_scale is not 1.0, it specifies an amount to scale each *alpha*
## value of the source image before applying it to the target image.
##
## If pixel_scale is 1.0 and the copy has no alpha channel, this degenerates
## into copy_sub_image().

proc blend_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.blend_sub_image(#, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the alpha channel of the copy is used
## to blend the copy into the destination image, instead of overwriting pixels
## unconditionally.
##
## If pixel_scale is not 1.0, it specifies an amount to scale each *alpha*
## value of the source image before applying it to the target image.
##
## If pixel_scale is 1.0 and the copy has no alpha channel, this degenerates
## into copy_sub_image().

proc blend_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int) {.importcpp: "#.blend_sub_image(#, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the alpha channel of the copy is used
## to blend the copy into the destination image, instead of overwriting pixels
## unconditionally.
##
## If pixel_scale is not 1.0, it specifies an amount to scale each *alpha*
## value of the source image before applying it to the target image.
##
## If pixel_scale is 1.0 and the copy has no alpha channel, this degenerates
## into copy_sub_image().

proc blend_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int) {.importcpp: "#.blend_sub_image(#, #, #)".} ## \
## Behaves like copy_sub_image(), except the alpha channel of the copy is used
## to blend the copy into the destination image, instead of overwriting pixels
## unconditionally.
##
## If pixel_scale is not 1.0, it specifies an amount to scale each *alpha*
## value of the source image before applying it to the target image.
##
## If pixel_scale is 1.0 and the copy has no alpha channel, this degenerates
## into copy_sub_image().

proc add_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int, pixel_scale: float32) {.importcpp: "#.add_sub_image(#, #, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc add_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.add_sub_image(#, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc add_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.add_sub_image(#, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc add_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.add_sub_image(#, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc add_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int) {.importcpp: "#.add_sub_image(#, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc add_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int) {.importcpp: "#.add_sub_image(#, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc mult_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int, pixel_scale: float32) {.importcpp: "#.mult_sub_image(#, #, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc mult_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.mult_sub_image(#, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc mult_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.mult_sub_image(#, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc mult_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.mult_sub_image(#, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc mult_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int) {.importcpp: "#.mult_sub_image(#, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc mult_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int) {.importcpp: "#.mult_sub_image(#, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc darken_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int, pixel_scale: float32) {.importcpp: "#.darken_sub_image(#, #, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the darker
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.  The scale is
## applied with the center at 1.0: scaling the pixel value smaller brings it
## closer to 1.0.

proc darken_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.darken_sub_image(#, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the darker
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.  The scale is
## applied with the center at 1.0: scaling the pixel value smaller brings it
## closer to 1.0.

proc darken_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.darken_sub_image(#, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the darker
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.  The scale is
## applied with the center at 1.0: scaling the pixel value smaller brings it
## closer to 1.0.

proc darken_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.darken_sub_image(#, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the darker
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.  The scale is
## applied with the center at 1.0: scaling the pixel value smaller brings it
## closer to 1.0.

proc darken_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int) {.importcpp: "#.darken_sub_image(#, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the darker
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.  The scale is
## applied with the center at 1.0: scaling the pixel value smaller brings it
## closer to 1.0.

proc darken_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int) {.importcpp: "#.darken_sub_image(#, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the darker
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.  The scale is
## applied with the center at 1.0: scaling the pixel value smaller brings it
## closer to 1.0.

proc lighten_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int, pixel_scale: float32) {.importcpp: "#.lighten_sub_image(#, #, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the lighter
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.

proc lighten_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.lighten_sub_image(#, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the lighter
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.

proc lighten_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.lighten_sub_image(#, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the lighter
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.

proc lighten_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.lighten_sub_image(#, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the lighter
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.

proc lighten_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int) {.importcpp: "#.lighten_sub_image(#, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the lighter
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.

proc lighten_sub_image*(this: PNMImage, copy: PNMImage, xto: int, yto: int) {.importcpp: "#.lighten_sub_image(#, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the lighter
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.

proc threshold*(this: PNMImage, select_image: PNMImage, channel: int, threshold: float32, lt: PNMImage, ge: PNMImage) {.importcpp: "#.threshold(#, #, #, #, #)".} ## \
## Selectively copies each pixel from either one source or another source,
## depending on the pixel value of the indicated channel of select_image.
##
## For each pixel (x, y):
##
## s = select_image.get_channel(x, y, channel). Set this image's (x, y) to:
##
## lt.get_xel(x, y) if s < threshold, or
##
## ge.get_xel(x, y) if s >= threshold
##
## Any of select_image, lt, or ge may be the same PNMImge object as this
## image, or the same as each other; or they may all be different.  All images
## must be the same size.  As a special case, lt and ge may both be 1x1 images
## instead of the source image size.

proc fill_distance_inside*(this: PNMImage, mask: PNMImage, threshold: float32, radius: int, shrink_from_border: bool) {.importcpp: "#.fill_distance_inside(#, #, #, #)".} ## \
## Replaces this image with a grayscale image whose gray channel represents
## the linear Manhattan distance from the nearest dark pixel in the given mask
## image, up to the specified radius value (which also becomes the new
## maxval).  radius may range from 0 to maxmaxval; smaller values will compute
## faster.  A dark pixel is defined as one whose pixel value is < threshold.
##
## If shrink_from_border is true, then the mask image is considered to be
## surrounded by a border of dark pixels; otherwise, the border isn't
## considered.
##
## This can be used, in conjunction with threshold, to shrink a mask image
## inwards by a certain number of pixels.
##
## The mask image may be the same image as this one, in which case it is
## destructively modified by this process.

proc fill_distance_outside*(this: PNMImage, mask: PNMImage, threshold: float32, radius: int) {.importcpp: "#.fill_distance_outside(#, #, #)".} ## \
## Replaces this image with a grayscale image whose gray channel represents
## the linear Manhattan distance from the nearest white pixel in the given
## mask image, up to the specified radius value (which also becomes the new
## maxval).  radius may range from 0 to maxmaxval; smaller values will compute
## faster.  A white pixel is defined as one whose pixel value is >= threshold.
##
## This can be used, in conjunction with threshold, to grow a mask image
## outwards by a certain number of pixels.
##
## The mask image may be the same image as this one, in which case it is
## destructively modified by this process.

proc indirect_1d_lookup*(this: PNMImage, index_image: PNMImage, channel: int, pixel_values: PNMImage) {.importcpp: "#.indirect_1d_lookup(#, #, #)".} ## \
## index_image is a WxH grayscale image, while pixel_values is an Nx1 color
## (or grayscale) image.  Typically pixel_values will be a 256x1 image.
##
## Fills the PNMImage with a new image the same width and height as
## index_image, with the same number of channels as pixel_values.
##
## Each pixel of the new image is computed with the formula:
##
## new_image(x, y) = pixel_values(index_image(x, y)[channel], 0)
##
## At present, no interpolation is performed; the nearest value in
## pixel_values is discovered.  This may change in the future.

proc rescale*(this: PNMImage, min_val: float32, max_val: float32) {.importcpp: "#.rescale(#, #)".} ## \
## Rescales the RGB channel values so that any values in the original image
## between min_val and max_val are expanded to the range 0 .. 1.  Values below
## min_val are set to 0, and values above max_val are set to 1. Does not
## affect the alpha channel, if any.

proc render_spot*(this: PNMImage, fg: LColorf, bg: LColorf, min_radius: float32, max_radius: float32) {.importcpp: "#.render_spot(#, #, #, #)".} ## \
## Renders a solid-color circle, with a fuzzy edge, into the center of the
## PNMImage.  If the PNMImage is non-square, this actually renders an ellipse.
##
## The min_radius and max_radius are in the scale 0..1, where 1.0 means the
## full width of the image.  If min_radius == max_radius, the edge is sharp
## (but still antialiased); otherwise, the pixels between min_radius and
## max_radius are smoothly blended between fg and bg colors.

proc expand_border*(this: PNMImage, left: int, right: int, bottom: int, top: int, color: LColorf) {.importcpp: "#.expand_border(#, #, #, #, #)".} ## \
## Expands the image by the indicated number of pixels on each edge.  The new
## pixels are set to the indicated color.
##
## If any of the values is negative, this actually crops the image.

proc box_filter*(this: PNMImage, radius: float32) {.importcpp: "#.box_filter(#)".} ## \
## This flavor of box_filter() will apply the filter over the entire image
## without resizing or copying; the effect is that of a blur operation.

proc box_filter*(this: PNMImage) {.importcpp: "#.box_filter()".} ## \
## This flavor of box_filter() will apply the filter over the entire image
## without resizing or copying; the effect is that of a blur operation.

proc gaussian_filter*(this: PNMImage, radius: float32) {.importcpp: "#.gaussian_filter(#)".} ## \
## This flavor of gaussian_filter() will apply the filter over the entire
## image without resizing or copying; the effect is that of a blur operation.

proc gaussian_filter*(this: PNMImage) {.importcpp: "#.gaussian_filter()".} ## \
## This flavor of gaussian_filter() will apply the filter over the entire
## image without resizing or copying; the effect is that of a blur operation.

proc unfiltered_stretch_from*(this: PNMImage, copy: PNMImage) {.importcpp: "#.unfiltered_stretch_from(#)".} ## \
## Resizes from the indicated image into this one by performing a nearest-
## point sample.

proc box_filter_from*(this: PNMImage, radius: float32, copy: PNMImage) {.importcpp: "#.box_filter_from(#, #)".} ## \
## Makes a resized copy of the indicated image into this one using the
## indicated filter.  The image to be copied is squashed and stretched to
## match the dimensions of the current image, applying the appropriate filter
## to perform the stretching.

proc gaussian_filter_from*(this: PNMImage, radius: float32, copy: PNMImage) {.importcpp: "#.gaussian_filter_from(#, #)".} ## \
## Makes a resized copy of the indicated image into this one using the
## indicated filter.  The image to be copied is squashed and stretched to
## match the dimensions of the current image, applying the appropriate filter
## to perform the stretching.

proc quick_filter_from*(this: PNMImage, copy: PNMImage, xborder: int, yborder: int) {.importcpp: "#.quick_filter_from(#, #, #)".} ## \
## Resizes from the given image, with a fixed radius of 0.5. This is a very
## specialized and simple algorithm that doesn't handle dropping below the
## Nyquist rate very well, but is quite a bit faster than the more general
## box_filter(), above.  If borders are specified, they will further restrict
## the size of the resulting image.  There's no point in using
## quick_box_filter() on a single image.

proc quick_filter_from*(this: PNMImage, copy: PNMImage, xborder: int) {.importcpp: "#.quick_filter_from(#, #)".} ## \
## Resizes from the given image, with a fixed radius of 0.5. This is a very
## specialized and simple algorithm that doesn't handle dropping below the
## Nyquist rate very well, but is quite a bit faster than the more general
## box_filter(), above.  If borders are specified, they will further restrict
## the size of the resulting image.  There's no point in using
## quick_box_filter() on a single image.

proc quick_filter_from*(this: PNMImage, copy: PNMImage) {.importcpp: "#.quick_filter_from(#)".} ## \
## Resizes from the given image, with a fixed radius of 0.5. This is a very
## specialized and simple algorithm that doesn't handle dropping below the
## Nyquist rate very well, but is quite a bit faster than the more general
## box_filter(), above.  If borders are specified, they will further restrict
## the size of the resulting image.  There's no point in using
## quick_box_filter() on a single image.

proc quantize*(this: PNMImage, max_colors: clonglong) {.importcpp: "#.quantize(#)".} ## \
## Reduces the number of unique colors in the image to (at most) the given
## count.  Fewer colors than requested may be left in the image after this
## operation, but never more.
##
## At present, this is only supported on images without an alpha channel.
##
## @since 1.10.5

proc perlin_noise_fill*(this: PNMImage, perlin: StackedPerlinNoise2) {.importcpp: "#.perlin_noise_fill(#)".} ## \
## Variant of perlin_noise_fill that uses an existing StackedPerlinNoise2
## object.

proc perlin_noise_fill*(this: PNMImage, sx: float32, sy: float32, table_size: int, seed: int) {.importcpp: "#.perlin_noise_fill(#, #, #, #)".} ## \
## Fills the image with a grayscale perlin noise pattern based on the
## indicated parameters.  Uses set_xel to set the grayscale values.  The sx
## and sy parameters are in multiples of the size of this image.  See also the
## PerlinNoise2 class in mathutil.

proc perlin_noise_fill*(this: PNMImage, sx: float32, sy: float32, table_size: int) {.importcpp: "#.perlin_noise_fill(#, #, #)".} ## \
## Fills the image with a grayscale perlin noise pattern based on the
## indicated parameters.  Uses set_xel to set the grayscale values.  The sx
## and sy parameters are in multiples of the size of this image.  See also the
## PerlinNoise2 class in mathutil.

proc perlin_noise_fill*(this: PNMImage, sx: float32, sy: float32) {.importcpp: "#.perlin_noise_fill(#, #)".} ## \
## Fills the image with a grayscale perlin noise pattern based on the
## indicated parameters.  Uses set_xel to set the grayscale values.  The sx
## and sy parameters are in multiples of the size of this image.  See also the
## PerlinNoise2 class in mathutil.

proc remix_channels*(this: PNMImage, conv: LMatrix4) {.importcpp: "#.remix_channels(#)".} ## \
## Transforms every pixel using the operation (Ro,Go,Bo) =
## conv.xform_point(Ri,Gi,Bi); Input must be a color image.

proc gamma_correct*(this: PNMImage, from_gamma: float32, to_gamma: float32) {.importcpp: "#.gamma_correct(#, #)".} ## \
## Assuming the image was constructed with a gamma curve of from_gamma in the
## RGB channels, converts it to an image with a gamma curve of to_gamma in the
## RGB channels.  Does not affect the alpha channel.

proc gamma_correct_alpha*(this: PNMImage, from_gamma: float32, to_gamma: float32) {.importcpp: "#.gamma_correct_alpha(#, #)".} ## \
## Assuming the image was constructed with a gamma curve of from_gamma in the
## alpha channel, converts it to an image with a gamma curve of to_gamma in
## the alpha channel.  Does not affect the RGB channels.

proc apply_exponent*(this: PNMImage, gray_exponent: float32) {.importcpp: "#.apply_exponent(#)".} ## \
## Adjusts each channel of the image by raising the corresponding component
## value to the indicated exponent, such that L' = L ^ exponent.

proc apply_exponent*(this: PNMImage, gray_exponent: float32, alpha_exponent: float32) {.importcpp: "#.apply_exponent(#, #)".} ## \
## Adjusts each channel of the image by raising the corresponding component
## value to the indicated exponent, such that L' = L ^ exponent.

proc apply_exponent*(this: PNMImage, red_exponent: float32, green_exponent: float32, blue_exponent: float32) {.importcpp: "#.apply_exponent(#, #, #)".} ## \
## Adjusts each channel of the image by raising the corresponding component
## value to the indicated exponent, such that L' = L ^ exponent.  For a
## grayscale image, the blue_exponent value is used for the grayscale value,
## and red_exponent and green_exponent are unused.

proc apply_exponent*(this: PNMImage, red_exponent: float32, green_exponent: float32, blue_exponent: float32, alpha_exponent: float32) {.importcpp: "#.apply_exponent(#, #, #, #)".} ## \
## Adjusts each channel of the image by raising the corresponding component
## value to the indicated exponent, such that L' = L ^ exponent.  For a
## grayscale image, the blue_exponent value is used for the grayscale value,
## and red_exponent and green_exponent are unused.

proc get_average_xel*(this: PNMImage): LRGBColorf {.importcpp: "#.get_average_xel()".} ## \
## Returns the average color of all of the pixels in the image.

proc get_average_xel_a*(this: PNMImage): LColorf {.importcpp: "#.get_average_xel_a()".} ## \
## Returns the average color of all of the pixels in the image, including the
## alpha channel.

proc get_average_gray*(this: PNMImage): float32 {.importcpp: "#.get_average_gray()".} ## \
## Returns the average grayscale component of all of the pixels in the image.

proc do_fill_distance*(this: PNMImage, xi: int, yi: int, d: int) {.importcpp: "#.do_fill_distance(#, #, #)".} ## \
## Recursively fills in the minimum distance measured from a certain set of
## points into the gray channel.

proc `~`*(this: PNMImage): PNMImage {.importcpp: "#.operator ~()".}

proc `+`*(this: PNMImage, other: LColorf): PNMImage {.importcpp: "#.operator +(#)".}

proc `+`*(this: PNMImage, other: PNMImage): PNMImage {.importcpp: "#.operator +(#)".}

proc `-`*(this: PNMImage, other: LColorf): PNMImage {.importcpp: "#.operator -(#)".}

proc `-`*(this: PNMImage, other: PNMImage): PNMImage {.importcpp: "#.operator -(#)".}

proc `*`*(this: PNMImage, other: LColorf): PNMImage {.importcpp: "#.operator *(#)".}

proc `*`*(this: PNMImage, other: PNMImage): PNMImage {.importcpp: "#.operator *(#)".}

proc `*`*(this: PNMImage, multiplier: float32): PNMImage {.importcpp: "#.operator *(#)".}

proc `+=`*(this: PNMImage, other: LColorf): PNMImage {.importcpp: "#.operator +=(#)".}

proc `+=`*(this: PNMImage, other: PNMImage): PNMImage {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: PNMImage, other: LColorf): PNMImage {.importcpp: "#.operator -=(#)".}

proc `-=`*(this: PNMImage, other: PNMImage): PNMImage {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: PNMImage, other: LColorf): PNMImage {.importcpp: "#.operator *=(#)".}

proc `*=`*(this: PNMImage, other: PNMImage): PNMImage {.importcpp: "#.operator *=(#)".}

proc `*=`*(this: PNMImage, multiplier: float32): PNMImage {.importcpp: "#.operator *=(#)".}

proc initPNMPainter*(image: PNMImage, xo: int, yo: int): PNMPainter {.importcpp: "PNMPainter(#, #, #)".} ## \
## The constructor stores a pointer to the PNMImage you pass it, but it does
## not take ownership of the object; you are responsible for ensuring that the
## PNMImage does not destruct during the lifetime of the PNMPainter object.
##
## The xo, yo coordinates specify an optional offset for fill coordinates.  If
## you are painting with a pattern fill, these specify the virtual coordinates
## of the upper-left corner of the image, which can allow you to adjust the
## pattern to line up with nested images, if necessary.

proc initPNMPainter*(image: PNMImage, xo: int): PNMPainter {.importcpp: "PNMPainter(#, #)".} ## \
## The constructor stores a pointer to the PNMImage you pass it, but it does
## not take ownership of the object; you are responsible for ensuring that the
## PNMImage does not destruct during the lifetime of the PNMPainter object.
##
## The xo, yo coordinates specify an optional offset for fill coordinates.  If
## you are painting with a pattern fill, these specify the virtual coordinates
## of the upper-left corner of the image, which can allow you to adjust the
## pattern to line up with nested images, if necessary.

proc initPNMPainter*(image: PNMImage): PNMPainter {.importcpp: "PNMPainter(#)".} ## \
## The constructor stores a pointer to the PNMImage you pass it, but it does
## not take ownership of the object; you are responsible for ensuring that the
## PNMImage does not destruct during the lifetime of the PNMPainter object.
##
## The xo, yo coordinates specify an optional offset for fill coordinates.  If
## you are painting with a pattern fill, these specify the virtual coordinates
## of the upper-left corner of the image, which can allow you to adjust the
## pattern to line up with nested images, if necessary.

proc initPNMPainter*(param0: PNMPainter): PNMPainter {.importcpp: "PNMPainter(#)".}

proc set_pen*(this: PNMPainter, pen: PNMBrush) {.importcpp: "#.set_pen(#)".} ## \
## Specifies a PNMBrush that will be used for drawing lines and edges.  If the
## brush is a bitmap brush, its image will be smeared pixelwise along the
## line.
##
## Unlike the PNMImage passed to the constructor, the PNMPainter will take
## ownership of the pen.  It is not necessary to keep a separate pointer to
## it.

proc get_pen*(this: PNMPainter): PNMBrush {.importcpp: "#.get_pen()".} ## \
## Returns the current pen.  See set_pen().

proc set_fill*(this: PNMPainter, fill: PNMBrush) {.importcpp: "#.set_fill(#)".} ## \
## Specifies a PNMBrush that will be used for filling in the interiors of
## objects.  If the brush is a bitmap brush, its image will be tiled
## throughout the space.
##
## Unlike the PNMImage passed to the constructor, the PNMPainter will take
## ownership of the fill brush.  It is not necessary to keep a separate
## pointer to it.

proc get_fill*(this: PNMPainter): PNMBrush {.importcpp: "#.get_fill()".} ## \
## Returns the current fill brush.  See set_fill().

proc draw_point*(this: PNMPainter, x: float32, y: float32) {.importcpp: "#.draw_point(#, #)".} ## \
## Draws an antialiased point on the PNMImage, using the current pen.

proc draw_line*(this: PNMPainter, xa: float32, ya: float32, xb: float32, yb: float32) {.importcpp: "#.draw_line(#, #, #, #)".} ## \
## Draws an antialiased line on the PNMImage, using the current pen.

proc draw_rectangle*(this: PNMPainter, xa: float32, ya: float32, xb: float32, yb: float32) {.importcpp: "#.draw_rectangle(#, #, #, #)".} ## \
## Draws a filled rectangule on the PNMImage, using the current pen for the
## outline, and the current fill brush for the interior.
##
## The two coordinates specify any two diagonally opposite corners.

proc get_character*(this: TextGlyph): int {.importcpp: "#->get_character()".} ## \
## Returns the Unicode value that corresponds to the character this glyph
## represents.

proc has_quad*(this: TextGlyph): bool {.importcpp: "#->has_quad()".} ## \
## Returns true if this glyph contains the definition for a simple quad,
## rather than a more complex piece of geometry.
##
## You may still call get_geom() even if this returns true, which will
## synthesize a Geom for this quad.

proc get_quad*(this: TextGlyph, dimensions: LVecBase4, texcoords: LVecBase4): bool {.importcpp: "#->get_quad(#, #)".} ## \
## Assuming that this glyph is representable as a textured quad, returns its
## dimensions and UV range.  Returns false if it is not representable as a
## quad, or if it is whitespace.
##
## The order of the components is left, bottom, right, top.

proc get_state*(this: TextGlyph): RenderState {.importcpp: "#->get_state()".} ## \
## Returns the state in which the glyph should be rendered.

proc get_advance*(this: TextGlyph): float32 {.importcpp: "#->get_advance()".} ## \
## Returns the distance by which the character pointer should be advanced
## after placing this character; i.e.  the approximate width the character
## takes up on the line.

proc is_whitespace*(this: TextGlyph): bool {.importcpp: "#->is_whitespace()".} ## \
## Returns true if this glyph represents invisible whitespace, or false if it
## corresponds to some visible character.

proc get_class_type*(_: typedesc[TextGlyph]): TypeHandle {.importcpp: "TextGlyph::get_class_type()", header: "textGlyph.h".}

converter upcast_to_TypedReferenceCount*(this: TextFont): TypedReferenceCount {.importcpp: "(PT(TypedReferenceCount)(#))".}

converter upcast_to_Namable*(this: TextFont): Namable {.importcpp: "((Namable *)(#.p()))".}

proc make_copy*(this: TextFont): TextFont {.importcpp: "#->make_copy()".}

proc is_valid*(this: TextFont): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the font is valid and ready to use, false otherwise.

proc `typecast bool`*(this: TextFont): bool {.importcpp: "#->operator typecast bool()".}

proc get_line_height*(this: TextFont): float32 {.importcpp: "#->get_line_height()".} ## \
## Returns the number of units high each line of text is.

proc set_line_height*(this: TextFont, line_height: float32) {.importcpp: "#->set_line_height(#)".} ## \
## Changes the number of units high each line of text is.

proc get_space_advance*(this: TextFont): float32 {.importcpp: "#->get_space_advance()".} ## \
## Returns the number of units wide a space is.

proc set_space_advance*(this: TextFont, space_advance: float32) {.importcpp: "#->set_space_advance(#)".} ## \
## Changes the number of units wide a space is.

proc get_glyph*(this: TextFont, character: int): TextGlyph {.importcpp: "#->get_glyph(#)".} ## \
## Gets the glyph associated with the given character code, as well as an
## optional scaling parameter that should be applied to the glyph's geometry
## and advance parameters.  Returns the glyph on success.  On failure, it may
## still return a printable glyph, or it may return NULL.

proc get_kerning*(this: TextFont, first: int, second: int): float32 {.importcpp: "#->get_kerning(#, #)".} ## \
## Returns the amount by which to offset the second glyph when it directly
## follows the first glyph.  This is an additional offset that is added on top
## of the advance.

proc write*(this: TextFont, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc get_class_type*(_: typedesc[TextFont]): TypeHandle {.importcpp: "TextFont::get_class_type()", header: "textFont.h".}

proc get_page*(this: DynamicTextGlyph): DynamicTextPage {.importcpp: "#->get_page()".} ## \
## Returns the DynamicTextPage that this glyph is on.

proc get_size*(this: DynamicTextPage): LVecBase2i {.importcpp: "#->get_size()".} ## \
## Returns the size of the page (texture), in pixels.

proc get_x_size*(this: DynamicTextPage): int {.importcpp: "#->get_x_size()".} ## \
## Returns the x size of the page (texture), in pixels.

proc get_y_size*(this: DynamicTextPage): int {.importcpp: "#->get_y_size()".} ## \
## Returns the y size of the page (texture), in pixels.

proc is_empty*(this: DynamicTextPage): bool {.importcpp: "#->is_empty()".} ## \
## Returns true if the page has no glyphs, false otherwise.

proc get_class_type*(_: typedesc[DynamicTextPage]): TypeHandle {.importcpp: "DynamicTextPage::get_class_type()", header: "dynamicTextPage.h".}

proc newDynamicTextPage*(param0: DynamicTextPage): DynamicTextPage {.importcpp: "new DynamicTextPage(#)".}

proc intersects*(this: DynamicTextGlyph, x: int, y: int, x_size: int, y_size: int): bool {.importcpp: "#->intersects(#, #, #, #)".} ## \
## Returns true if the particular position this glyph has been assigned to
## overlaps the rectangle whose top left corner is at x, y and whose size is
## given by x_size, y_size, or false otherwise.

proc get_left*(this: DynamicTextGlyph): float32 {.importcpp: "#->get_left()".} ## \
## Returns the vertex coordinates that can be used when creating a custom text
## renderer.

proc get_bottom*(this: DynamicTextGlyph): float32 {.importcpp: "#->get_bottom()".} ## \
## Returns the vertex coordinates that can be used when creating a custom text
## renderer.

proc get_right*(this: DynamicTextGlyph): float32 {.importcpp: "#->get_right()".} ## \
## Returns the vertex coordinates that can be used when creating a custom text
## renderer.

proc get_top*(this: DynamicTextGlyph): float32 {.importcpp: "#->get_top()".} ## \
## Returns the vertex coordinates that can be used when creating a custom text
## renderer.

proc get_uv_left*(this: DynamicTextGlyph): float32 {.importcpp: "#->get_uv_left()".} ## \
## Returns the UV coordinates that can be used when creating a custom text
## renderer.

proc get_uv_bottom*(this: DynamicTextGlyph): float32 {.importcpp: "#->get_uv_bottom()".} ## \
## Returns the UV coordinates that can be used when creating a custom text
## renderer.

proc get_uv_right*(this: DynamicTextGlyph): float32 {.importcpp: "#->get_uv_right()".} ## \
## Returns the UV coordinates that can be used when creating a custom text
## renderer.

proc get_uv_top*(this: DynamicTextGlyph): float32 {.importcpp: "#->get_uv_top()".} ## \
## Returns the UV coordinates that can be used when creating a custom text
## renderer.

proc get_class_type*(_: typedesc[DynamicTextGlyph]): TypeHandle {.importcpp: "DynamicTextGlyph::get_class_type()", header: "dynamicTextGlyph.h".}

converter upcast_to_TextFont*(this: DynamicTextFont): TextFont {.importcpp: "(PT(TextFont)(#))".}

converter upcast_to_FreetypeFont*(this: DynamicTextFont): FreetypeFont {.importcpp: "((FreetypeFont *)(#.p()))".}

proc newDynamicTextFont*(copy: DynamicTextFont): DynamicTextFont {.importcpp: "new DynamicTextFont(#)".}

proc newDynamicTextFont*(font_filename: Filename, face_index: int): DynamicTextFont {.importcpp: "new DynamicTextFont(#, #)".} ## \
## The constructor expects the name of some font file that FreeType can read,
## along with face_index, indicating which font within the file to load
## (usually 0).

proc newDynamicTextFont*(font_filename: Filename): DynamicTextFont {.importcpp: "new DynamicTextFont(#)".} ## \
## The constructor expects the name of some font file that FreeType can read,
## along with face_index, indicating which font within the file to load
## (usually 0).

proc newDynamicTextFont*(font_data: string, data_length: int, face_index: int): DynamicTextFont {.importcpp: "new DynamicTextFont(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## This constructor accepts a table of data representing the font file, loaded
## from some source other than a filename on disk.

proc make_copy*(this: DynamicTextFont): TextFont {.importcpp: "#->make_copy()".} ## \
## Returns a new copy of the same font.

proc get_name*(this: DynamicTextFont): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Disambiguates the get_name() method between that inherited from TextFont
## and that inherited from FreetypeFont.

proc set_point_size*(this: DynamicTextFont, point_size: float32): bool {.importcpp: "#->set_point_size(#)".} ## \
## Sets the point size of the font.  This controls the apparent size of the
## font onscreen.  By convention, a 10 point font is about 1 screen unit high.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

proc get_point_size*(this: DynamicTextFont): float32 {.importcpp: "#->get_point_size()".} ## \
## Returns the point size of the font.

proc set_pixels_per_unit*(this: DynamicTextFont, pixels_per_unit: float32): bool {.importcpp: "#->set_pixels_per_unit(#)".} ## \
## Set the resolution of the texture map, and hence the clarity of the
## resulting font.  This sets the number of pixels in the texture map that are
## used for each onscreen unit.
##
## Setting this number larger results in an easier to read font, but at the
## cost of more texture memory.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

proc get_pixels_per_unit*(this: DynamicTextFont): float32 {.importcpp: "#->get_pixels_per_unit()".} ## \
## Returns the resolution of the texture map.  See set_pixels_per_unit().

proc set_scale_factor*(this: DynamicTextFont, scale_factor: float32): bool {.importcpp: "#->set_scale_factor(#)".} ## \
## Sets the factor by which the font is rendered larger by the FreeType
## library before being filtered down to its actual size in the texture as
## specified by set_pixels_per_unit().  This may be set to a number larger
## than 1.0 to improve the font's antialiasing (since FreeType doesn't really
## do a swell job of antialiasing by itself).  There is some performance
## implication for setting this different than 1.0, but it is probably small.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

proc get_scale_factor*(this: DynamicTextFont): float32 {.importcpp: "#->get_scale_factor()".} ## \
## Returns the antialiasing scale factor.  See set_scale_factor().

proc set_native_antialias*(this: DynamicTextFont, native_antialias: bool) {.importcpp: "#->set_native_antialias(#)".} ## \
## Sets whether the Freetype library's built-in antialias mode is enabled.
## There are two unrelated ways to achieve antialiasing: with Freetype's
## native antialias mode, and with the use of a scale_factor greater than one.
## By default, both modes are enabled.
##
## At low resolutions, some fonts may do better with one mode or the other.
## In general, Freetype's native antialiasing will produce less blurry
## results, but may introduce more artifacts.

proc get_native_antialias*(this: DynamicTextFont): bool {.importcpp: "#->get_native_antialias()".} ## \
## Returns whether Freetype's built-in antialias mode is enabled.  See
## set_native_antialias().

proc get_font_pixel_size*(this: DynamicTextFont): int {.importcpp: "#->get_font_pixel_size()".} ## \
## This is used to report whether the requested pixel size is being only
## approximated by a fixed-pixel-size font.  This returns 0 in the normal
## case, in which a scalable font is used, or the fixed-pixel-size font has
## exactly the requested pixel size.
##
## If this returns non-zero, it is the pixel size of the font that we are
## using to approximate our desired size.

proc get_line_height*(this: DynamicTextFont): float32 {.importcpp: "#->get_line_height()".} ## \
## Returns the number of units high each line of text is.

proc get_space_advance*(this: DynamicTextFont): float32 {.importcpp: "#->get_space_advance()".} ## \
## Returns the number of units wide a space is.

proc set_texture_margin*(this: DynamicTextFont, texture_margin: int) {.importcpp: "#->set_texture_margin(#)".} ## \
## Sets the number of pixels of padding that is added around the border of
## each glyph before adding it to the texture map.  This reduces the bleed in
## from neighboring glyphs in the texture map.

proc get_texture_margin*(this: DynamicTextFont): int {.importcpp: "#->get_texture_margin()".} ## \
## Returns the number of pixels of padding that is added around the border of
## each glyph in the texture map.  See set_texture_margin().

proc set_poly_margin*(this: DynamicTextFont, poly_margin: float32) {.importcpp: "#->set_poly_margin(#)".} ## \
## Sets the number of pixels of padding that is included around each glyph in
## the generated polygons.  This helps prevent the edges of the glyphs from
## being cut off at small minifications.  It is not related to the amount of
## extra pixels reserved in the texture map (but it should be set somewhat
## smaller than this number, which is controlled by set_texture_margin(), to
## prevent bleed-in from neighboring letters in the texture).

proc get_poly_margin*(this: DynamicTextFont): float32 {.importcpp: "#->get_poly_margin()".} ## \
## Returns the number of pixels of padding that is included around each glyph
## in the generated polygons.  See set_poly_margin().

proc set_page_size*(this: DynamicTextFont, page_size: LVecBase2i) {.importcpp: "#->set_page_size(#)".} ## \
## Sets the x, y size of the textures that are created for the
## DynamicTextFont.

proc set_page_size*(this: DynamicTextFont, x_size: int, y_size: int) {.importcpp: "#->set_page_size(#, #)".} ## \
## Sets the x, y size of the textures that are created for the
## DynamicTextFont.

proc get_page_size*(this: DynamicTextFont): LVecBase2i {.importcpp: "#->get_page_size()".} ## \
## Returns the size of the textures that are created for the DynamicTextFont.
## See set_page_size().

proc get_page_x_size*(this: DynamicTextFont): int {.importcpp: "#->get_page_x_size()".} ## \
## Returns the x size of the textures that are created for the
## DynamicTextFont.  See set_page_size().

proc get_page_y_size*(this: DynamicTextFont): int {.importcpp: "#->get_page_y_size()".} ## \
## Returns the y size of the textures that are created for the
## DynamicTextFont.  See set_page_size().

proc set_anisotropic_degree*(this: DynamicTextFont, anisotropic_degree: int) {.importcpp: "#->set_anisotropic_degree(#)".} ## \
## Enables or disables anisotropic filtering on the textures created for this
## font.  The default value is specified by the text-anisotropic-degree
## variable.  See Texture::set_anisotropic_degree().

proc get_anisotropic_degree*(this: DynamicTextFont): int {.importcpp: "#->get_anisotropic_degree()".} ## \
## Returns the current anisotropic degree for textures created for this font.
## See set_anisotropic_degree().

proc set_fg*(this: DynamicTextFont, fg: LColor) {.importcpp: "#->set_fg(#)".} ## \
## Changes the color of the foreground pixels of the font as they are rendered
## into the font texture.  The default is (1, 1, 1, 1), or opaque white, which
## allows text created with the font to be colored individually.  Normally,
## you would not change this unless you really need a particular color effect
## to appear in the font itself.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

proc get_fg*(this: DynamicTextFont): LColor {.importcpp: "#->get_fg()".} ## \
## Returns the color of the foreground pixels of the font as they are rendered
## into the font texture.  See set_fg().

proc set_bg*(this: DynamicTextFont, bg: LColor) {.importcpp: "#->set_bg(#)".} ## \
## Changes the color of the background pixels of the font as they are rendered
## into the font texture.  The default is (1, 1, 1, 0), or transparent white,
## which allows text created with the font to be colored individually.  (Note
## that it should not generally be (0, 0, 0, 0), which would tend to bleed
## into the foreground color, unless you have also specified a outline color
## of (0, 0, 0, 1)) .
##
## Normally, you would not change this unless you really need a particular
## color effect to appear in the font itself.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

proc get_bg*(this: DynamicTextFont): LColor {.importcpp: "#->get_bg()".} ## \
## Returns the color of the background pixels of the font as they are rendered
## into the font texture.  See set_bg().

proc set_outline*(this: DynamicTextFont, outline_color: LColor, outline_width: float32, outline_feather: float32) {.importcpp: "#->set_outline(#, #, #)".} ## \
## Sets up the font to have an outline around each font letter.  This is
## achieved via a Gaussian post-process as each letter is generated; there is
## some runtime cost for this effect, but it is minimal as each letter is
## normally generated only once and then cached.
##
## The color is the desired color of the outline, width is the number of
## points beyond the letter that the outline extends (a typical font is 10
## points high), and feather is a number in the range 0.0 .. 1.0 that controls
## the softness of the outline.  Set the width to 0.0 to disable the outline.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

proc get_outline_color*(this: DynamicTextFont): LColor {.importcpp: "#->get_outline_color()".} ## \
## Returns the color of the outline pixels of the font as they are rendered
## into the font texture.  See set_outline().

proc get_outline_width*(this: DynamicTextFont): float32 {.importcpp: "#->get_outline_width()".} ## \
## Returns the width of the outline pixels of the font, as the number of
## points beyond each letter.  See set_outline().

proc get_outline_feather*(this: DynamicTextFont): float32 {.importcpp: "#->get_outline_feather()".} ## \
## Returns the softness of the outline pixels of the font, as a value in the
## range 0.0 to 1.0. See set_outline().

proc get_num_pages*(this: DynamicTextFont): int {.importcpp: "#->get_num_pages()".} ## \
## Returns the number of pages associated with the font.  Initially, the font
## has zero pages; when the first piece of text is rendered with the font, it
## will add additional pages as needed.  Each page is a Texture object that
## contains the images for each of the glyphs currently in use somewhere.

proc get_page*(this: DynamicTextFont, n: int): DynamicTextPage {.importcpp: "#->get_page(#)".} ## \
## Returns the nth page associated with the font.  Initially, the font has
## zero pages; when the first piece of text is rendered with the font, it will
## add additional pages as needed.  Each page is a Texture object that
## contains the images for each of the glyphs currently in use somewhere.

proc garbage_collect*(this: DynamicTextFont): int {.importcpp: "#->garbage_collect()".} ## \
## Removes all of the glyphs from the font that are no longer being used by
## any Geoms.  Returns the number of glyphs removed.

proc clear*(this: DynamicTextFont) {.importcpp: "#->clear()".} ## \
## Drops all the glyphs out of the cache and frees any association with any
## previously-generated pages.
##
## Calling this frequently can result in wasted texture memory, as any
## previously rendered text will still keep a pointer to the old, previously-
## generated pages.  As long as the previously rendered text remains around,
## the old pages will also remain around.

proc write*(this: DynamicTextFont, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc get_class_type*(_: typedesc[DynamicTextFont]): TypeHandle {.importcpp: "DynamicTextFont::get_class_type()", header: "dynamicTextFont.h".}

proc has_font*(_: typedesc[FontPool], filename: string): bool {.importcpp: "FontPool::has_font(nimStringToStdString(#))", header: "fontPool.h".} ## \
## Returns true if the font has ever been loaded, false otherwise.

proc verify_font*(_: typedesc[FontPool], filename: string): bool {.importcpp: "FontPool::verify_font(nimStringToStdString(#))", header: "fontPool.h".} ## \
## Loads the given filename up into a font, if it has not already been loaded,
## and returns true to indicate success, or false to indicate failure.  If
## this returns true, it is guaranteed that a subsequent call to load_font()
## with the same font name will return a valid Font pointer.

proc load_font*(_: typedesc[FontPool], filename: string): TextFont {.importcpp: "FontPool::load_font(nimStringToStdString(#))", header: "fontPool.h".} ## \
## Loads the given filename up into a font, if it has not already been loaded,
## and returns the new font.  If a font with the same filename was previously
## loaded, returns that one instead.  If the font file cannot be found,
## returns NULL.

proc add_font*(_: typedesc[FontPool], filename: string, font: TextFont) {.importcpp: "FontPool::add_font(nimStringToStdString(#), #)", header: "fontPool.h".} ## \
## Adds the indicated already-loaded font to the pool.  The font will always
## replace any previously-loaded font in the pool that had the same filename.

proc release_font*(_: typedesc[FontPool], filename: string) {.importcpp: "FontPool::release_font(nimStringToStdString(#))", header: "fontPool.h".} ## \
## Removes the indicated font from the pool, indicating it will never be
## loaded again; the font may then be freed.  If this function is never
## called, a reference count will be maintained on every font every loaded,
## and fonts will never be freed.

proc release_all_fonts*(_: typedesc[FontPool]) {.importcpp: "FontPool::release_all_fonts()", header: "fontPool.h".} ## \
## Releases all fonts in the pool and restores the pool to the empty state.

proc garbage_collect*(_: typedesc[FontPool]): int {.importcpp: "FontPool::garbage_collect()", header: "fontPool.h".} ## \
## Releases only those fonts in the pool that have a reference count of
## exactly 1; i.e.  only those fonts that are not being used outside of the
## pool.  Returns the number of fonts released.

proc list_contents*(_: typedesc[FontPool], `out`: ostream) {.importcpp: "FontPool::list_contents(#)", header: "fontPool.h".} ## \
## Lists the contents of the font pool to the indicated output stream.

proc write*(_: typedesc[FontPool], `out`: ostream) {.importcpp: "FontPool::write(#)", header: "fontPool.h".} ## \
## Lists the contents of the font pool to the indicated output stream.

proc get_class_type*(_: typedesc[GeomTextGlyph]): TypeHandle {.importcpp: "GeomTextGlyph::get_class_type()", header: "geomTextGlyph.h".}

proc newStaticTextFont*(font_def: PandaNode, cs: CoordinateSystem): StaticTextFont {.importcpp: "new StaticTextFont(#, #)".} ## \
## The constructor expects the root node to a model generated via egg-mkfont,
## which consists of a set of models, one per each character in the font.
##
## If a CoordinateSystem value is specified, it informs the font of the
## coordinate system in which this model was generated.  "up" in this
## coordinate system will be the direction of the top of the letters.

proc newStaticTextFont*(font_def: PandaNode): StaticTextFont {.importcpp: "new StaticTextFont(#)".} ## \
## The constructor expects the root node to a model generated via egg-mkfont,
## which consists of a set of models, one per each character in the font.
##
## If a CoordinateSystem value is specified, it informs the font of the
## coordinate system in which this model was generated.  "up" in this
## coordinate system will be the direction of the top of the letters.

proc get_class_type*(_: typedesc[StaticTextFont]): TypeHandle {.importcpp: "StaticTextFont::get_class_type()", header: "staticTextFont.h".}

proc initTextProperties*(): TextProperties {.importcpp: "TextProperties()".}

proc initTextProperties*(copy: TextProperties): TextProperties {.importcpp: "TextProperties(#)".}

proc `==`*(this: TextProperties, other: TextProperties): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: TextProperties, other: TextProperties): bool {.importcpp: "#.operator !=(#)".}

proc clear*(this: TextProperties) {.importcpp: "#.clear()".} ## \
## Unsets all properties that have been specified so far, and resets the
## TextProperties structure to its initial empty state.

proc is_any_specified*(this: TextProperties): bool {.importcpp: "#.is_any_specified()".} ## \
## Returns true if any properties have been specified, false otherwise.

proc set_default_font*(_: typedesc[TextProperties], param0: TextFont) {.importcpp: "TextProperties::set_default_font(#)", header: "textProperties.h".} ## \
## Specifies the default font to be used for any TextNode whose font is
## uninitialized or NULL.  See set_font().

proc get_default_font*(_: typedesc[TextProperties]): TextFont {.importcpp: "TextProperties::get_default_font()", header: "textProperties.h".} ## \
## Specifies the default font to be used for any TextNode whose font is
## uninitialized or NULL.  See set_font().

proc set_font*(this: TextProperties, font: TextFont) {.importcpp: "#.set_font(#)".} ## \
## Sets the font that will be used when making text.  If this is set to NULL,
## the default font will be used, which can be set via set_default_font().

proc clear_font*(this: TextProperties) {.importcpp: "#.clear_font()".} ## \
## Restores the default font to the text.

proc has_font*(this: TextProperties): bool {.importcpp: "#.has_font()".}

proc get_font*(this: TextProperties): TextFont {.importcpp: "#.get_font()".} ## \
## Returns the font currently in use, if any.  If no font is in use, this
## returns the default font.

proc set_small_caps*(this: TextProperties, small_caps: bool) {.importcpp: "#.set_small_caps(#)".} ## \
## Sets the small_caps flag.  When this is set, lowercase letters are
## generated as scaled-down versions of their uppercase equivalents.  This is
## particularly useful to set for fonts that do not have lowercase letters.
##
## It is also a good idea to set this for a (dynamic) font that has already
## implemented lowercase letters as scaled-down versions of their uppercase
## equivalents, since without this flag the texture memory may needlessly
## duplicate equivalent glyphs for upper and lowercase letters.  Setting this
## flag causes the texture memory to share the mixed-case letters.
##
## The amount by which the lowercase letters are scaled is specified by
## set_small_caps_scale().

proc clear_small_caps*(this: TextProperties) {.importcpp: "#.clear_small_caps()".}

proc has_small_caps*(this: TextProperties): bool {.importcpp: "#.has_small_caps()".}

proc get_small_caps*(this: TextProperties): bool {.importcpp: "#.get_small_caps()".} ## \
## Returns the small_caps flag.  See set_small_caps().

proc set_small_caps_scale*(this: TextProperties, small_caps_scale: float32) {.importcpp: "#.set_small_caps_scale(#)".} ## \
## Sets the scale factor applied to lowercase letters from their uppercase
## equivalents, when the small_caps flag is in effect.  See set_small_caps().
## Normally, this will be a number less than one.

proc clear_small_caps_scale*(this: TextProperties) {.importcpp: "#.clear_small_caps_scale()".}

proc has_small_caps_scale*(this: TextProperties): bool {.importcpp: "#.has_small_caps_scale()".}

proc get_small_caps_scale*(this: TextProperties): float32 {.importcpp: "#.get_small_caps_scale()".} ## \
## Returns the scale factor applied to lowercase letters from their uppercase
## equivalents, when the small_caps flag is in effect.  See set_small_caps()
## and set_small_caps_scale().

proc set_slant*(this: TextProperties, slant: float32) {.importcpp: "#.set_slant(#)".} ## \
## Specifies the factor by which the text slants to the right.

proc clear_slant*(this: TextProperties) {.importcpp: "#.clear_slant()".}

proc has_slant*(this: TextProperties): bool {.importcpp: "#.has_slant()".}

proc get_slant*(this: TextProperties): float32 {.importcpp: "#.get_slant()".} ## \
## Returns the factor by which the text is specified to slant to the right.

proc set_underscore*(this: TextProperties, underscore: bool) {.importcpp: "#.set_underscore(#)".} ## \
## Sets the underscore flag.  When this is set, the text is underscored with a
## one-pixel line the same color as the text foreground, drawn at the
## baseline.

proc clear_underscore*(this: TextProperties) {.importcpp: "#.clear_underscore()".}

proc has_underscore*(this: TextProperties): bool {.importcpp: "#.has_underscore()".}

proc get_underscore*(this: TextProperties): bool {.importcpp: "#.get_underscore()".} ## \
## Returns the underscore flag.  See set_underscore().

proc set_underscore_height*(this: TextProperties, underscore_height: float32) {.importcpp: "#.set_underscore_height(#)".} ## \
## Specifies the vertical height of the underscore, relative to the text
## baseline.  This only has meaning if the underscore mode is enabled with
## set_underscore().

proc clear_underscore_height*(this: TextProperties) {.importcpp: "#.clear_underscore_height()".}

proc has_underscore_height*(this: TextProperties): bool {.importcpp: "#.has_underscore_height()".}

proc get_underscore_height*(this: TextProperties): float32 {.importcpp: "#.get_underscore_height()".} ## \
## Returns the vertical height of the underscore; see set_underscore_height().

proc clear_align*(this: TextProperties) {.importcpp: "#.clear_align()".} ## \
## Restores the default alignment of the text.

proc has_align*(this: TextProperties): bool {.importcpp: "#.has_align()".}

proc set_indent*(this: TextProperties, indent: float32) {.importcpp: "#.set_indent(#)".} ## \
## Specifies the amount of extra space that is inserted before the first
## character of each line.  This can be thought of as a left margin.

proc clear_indent*(this: TextProperties) {.importcpp: "#.clear_indent()".} ## \
## Removes the indent setting from the text.  Text will be as wide as it is.

proc has_indent*(this: TextProperties): bool {.importcpp: "#.has_indent()".}

proc get_indent*(this: TextProperties): float32 {.importcpp: "#.get_indent()".}

proc set_wordwrap*(this: TextProperties, wordwrap: float32) {.importcpp: "#.set_wordwrap(#)".} ## \
## Sets the text up to automatically wordwrap when it exceeds the indicated
## width.  This can be thought of as a right margin or margin width.

proc clear_wordwrap*(this: TextProperties) {.importcpp: "#.clear_wordwrap()".} ## \
## Removes the wordwrap setting from the text.  Text will be as wide as it is.

proc has_wordwrap*(this: TextProperties): bool {.importcpp: "#.has_wordwrap()".}

proc get_wordwrap*(this: TextProperties): float32 {.importcpp: "#.get_wordwrap()".}

proc set_preserve_trailing_whitespace*(this: TextProperties, preserve_trailing_whitespace: bool) {.importcpp: "#.set_preserve_trailing_whitespace(#)".} ## \
## Sets the preserve_trailing_whitespace flag.  When this is set, trailing
## whitespace at the end of the line is not stripped when the text is
## wordwrapped (it is stripped by default).  Since the trailing whitespace is
## invisible, this is important primarily for determining the proper width of
## a frame or card behind the text.

proc clear_preserve_trailing_whitespace*(this: TextProperties) {.importcpp: "#.clear_preserve_trailing_whitespace()".}

proc has_preserve_trailing_whitespace*(this: TextProperties): bool {.importcpp: "#.has_preserve_trailing_whitespace()".}

proc get_preserve_trailing_whitespace*(this: TextProperties): bool {.importcpp: "#.get_preserve_trailing_whitespace()".} ## \
## Returns the preserve_trailing_whitespace flag.  See
## set_preserve_trailing_whitespace().

proc set_text_color*(this: TextProperties, text_color: LColor) {.importcpp: "#.set_text_color(#)".}

proc set_text_color*(this: TextProperties, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_text_color(#, #, #, #)".}

proc clear_text_color*(this: TextProperties) {.importcpp: "#.clear_text_color()".} ## \
## Removes the text color specification; the text will be colored whatever it
## was in the source font file.

proc has_text_color*(this: TextProperties): bool {.importcpp: "#.has_text_color()".}

proc get_text_color*(this: TextProperties): LColor {.importcpp: "#.get_text_color()".}

proc set_shadow_color*(this: TextProperties, shadow_color: LColor) {.importcpp: "#.set_shadow_color(#)".}

proc set_shadow_color*(this: TextProperties, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_shadow_color(#, #, #, #)".}

proc clear_shadow_color*(this: TextProperties) {.importcpp: "#.clear_shadow_color()".} ## \
## Removes the shadow color specification.

proc has_shadow_color*(this: TextProperties): bool {.importcpp: "#.has_shadow_color()".}

proc get_shadow_color*(this: TextProperties): LColor {.importcpp: "#.get_shadow_color()".}

proc set_shadow*(this: TextProperties, shadow_offset: LVecBase2) {.importcpp: "#.set_shadow(#)".} ## \
## Specifies that the text should be drawn with a shadow, by creating a second
## copy of the text and offsetting it slightly behind the first.

proc set_shadow*(this: TextProperties, xoffset: float32, yoffset: float32) {.importcpp: "#.set_shadow(#, #)".} ## \
## Specifies that the text should be drawn with a shadow, by creating a second
## copy of the text and offsetting it slightly behind the first.

proc clear_shadow*(this: TextProperties) {.importcpp: "#.clear_shadow()".} ## \
## Specifies that a shadow will not be drawn behind the text.

proc has_shadow*(this: TextProperties): bool {.importcpp: "#.has_shadow()".}

proc get_shadow*(this: TextProperties): LVector2 {.importcpp: "#.get_shadow()".} ## \
## Returns the offset of the shadow as set by set_shadow().  It is an error to
## call this if has_shadow() is false.

proc set_bin*(this: TextProperties, bin: string) {.importcpp: "#.set_bin(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Names the CullBin that the text geometry should be assigned to.  If this is
## set, then a CullBinAttrib will be created to explicitly place each
## component in the named bin.
##
## The draw_order value will also be passed to each CullBinAttrib as
## appropriate; this is particularly useful if this names a CullBinFixed, e.g.
## "fixed".

proc clear_bin*(this: TextProperties) {.importcpp: "#.clear_bin()".} ## \
## Removes the effect of a previous call to set_bin().  Text will be drawn in
## whatever bin it would like to be drawn in, with no explicit ordering.

proc has_bin*(this: TextProperties): bool {.importcpp: "#.has_bin()".} ## \
## Returns true if an explicit drawing bin has been set via set_bin(), false
## otherwise.

proc get_bin*(this: TextProperties): string {.importcpp: "nimStringFromStdString(#.get_bin())", header: stringConversionCode.} ## \
## Returns the drawing bin set with set_bin(), or empty string if no bin has
## been set.

proc set_draw_order*(this: TextProperties, draw_order: int): int {.importcpp: "#.set_draw_order(#)".} ## \
## Sets the drawing order of text created by the TextNode.  This is actually
## the draw order of the card and frame.  The shadow is drawn at
## _draw_order+1, and the text at _draw_order+2.
##
## This affects the sorting order assigned to the nodes as they are created,
## and also is passed to whatever bin may be assigned via set_bin().
##
## The return value is the first unused draw_order number, e.g.  _draw_order +
## 3.

proc clear_draw_order*(this: TextProperties) {.importcpp: "#.clear_draw_order()".}

proc has_draw_order*(this: TextProperties): bool {.importcpp: "#.has_draw_order()".}

proc get_draw_order*(this: TextProperties): int {.importcpp: "#.get_draw_order()".} ## \
## Returns the drawing order set with set_draw_order().

proc set_tab_width*(this: TextProperties, tab_width: float32) {.importcpp: "#.set_tab_width(#)".} ## \
## Sets the width of each tab stop, in screen units.  A tab character embedded
## in the text will advance the horizontal position to the next tab stop.

proc clear_tab_width*(this: TextProperties) {.importcpp: "#.clear_tab_width()".}

proc has_tab_width*(this: TextProperties): bool {.importcpp: "#.has_tab_width()".}

proc get_tab_width*(this: TextProperties): float32 {.importcpp: "#.get_tab_width()".} ## \
## Returns the width set via set_tab_width().

proc set_glyph_scale*(this: TextProperties, glyph_scale: float32) {.importcpp: "#.set_glyph_scale(#)".} ## \
## Specifies the factor by which to scale each letter of the text as it is
## placed, in addition to any scales inherited from the node or from
## set_text_scale(). This can be used (possibly in conjunction with
## set_glyph_shift()) to implement superscripting or subscripting.
##
## The glyph scale is cumulative when applied to nested TextProperties.  It is
## intended primarily for implementing superscripts, not for scaling the text
## in general.  See also set_text_scale(), which is intended primarily for
## scaling the text in general, and is not cumulative.

proc clear_glyph_scale*(this: TextProperties) {.importcpp: "#.clear_glyph_scale()".}

proc has_glyph_scale*(this: TextProperties): bool {.importcpp: "#.has_glyph_scale()".}

proc get_glyph_scale*(this: TextProperties): float32 {.importcpp: "#.get_glyph_scale()".} ## \
## Returns the scale factor of each letter as specified by set_glyph_scale().

proc set_glyph_shift*(this: TextProperties, glyph_shift: float32) {.importcpp: "#.set_glyph_shift(#)".} ## \
## Specifies a vertical amount to shift each letter of the text as it is
## placed.  This can be used (possibly in conjunction with set_glyph_scale())
## to implement superscripting or subscripting.

proc clear_glyph_shift*(this: TextProperties) {.importcpp: "#.clear_glyph_shift()".}

proc has_glyph_shift*(this: TextProperties): bool {.importcpp: "#.has_glyph_shift()".}

proc get_glyph_shift*(this: TextProperties): float32 {.importcpp: "#.get_glyph_shift()".} ## \
## Returns the vertical shift of each letter as specified by
## set_glyph_shift().

proc set_text_scale*(this: TextProperties, text_scale: float32) {.importcpp: "#.set_text_scale(#)".} ## \
## Specifies the factor by which to scale the text, in addition to any
## scalings imposed by the node, as well as in addition to the glyph scale.
##
## The text scale is not cumulative when applied to nested TextProperties.
## See also set_glyph_scale(), which is cumulative.

proc clear_text_scale*(this: TextProperties) {.importcpp: "#.clear_text_scale()".}

proc has_text_scale*(this: TextProperties): bool {.importcpp: "#.has_text_scale()".}

proc get_text_scale*(this: TextProperties): float32 {.importcpp: "#.get_text_scale()".} ## \
## Returns the scale factor of the text as specified by set_text_scale().

proc clear_direction*(this: TextProperties) {.importcpp: "#.clear_direction()".} ## \
## Clears the text direction setting.  If no text direction is specified, it
## will be guessed based on the contents of the string.
##
## @since 1.10.0

proc has_direction*(this: TextProperties): bool {.importcpp: "#.has_direction()".} ## \
## @since 1.10.0

proc add_properties*(this: TextProperties, other: TextProperties) {.importcpp: "#.add_properties(#)".} ## \
## Sets any properties that are explicitly specified in other on this object.
## Leaves other properties unchanged.

proc write*(this: TextProperties, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: TextProperties, `out`: ostream) {.importcpp: "#.write(#)".}

proc get_class_type*(_: typedesc[TextProperties]): TypeHandle {.importcpp: "TextProperties::get_class_type()", header: "textProperties.h".}

proc initTextGraphic*(): TextGraphic {.importcpp: "TextGraphic()".}

proc initTextGraphic*(model: NodePath, frame: LVecBase4): TextGraphic {.importcpp: "TextGraphic(#, #)".}

proc initTextGraphic*(model: NodePath, left: float32, right: float32, bottom: float32, top: float32): TextGraphic {.importcpp: "TextGraphic(#, #, #, #, #)".}

proc initTextGraphic*(param0: TextGraphic): TextGraphic {.importcpp: "TextGraphic(#)".}

proc get_model*(this: TextGraphic): NodePath {.importcpp: "#.get_model()".} ## \
## Returns the NodePath associated with the graphic, that renders the desired
## image.

proc set_model*(this: TextGraphic, model: NodePath) {.importcpp: "#.set_model(#)".} ## \
## Changes the NodePath associated with the graphic.  This NodePath should
## contain geometry that will render the desired graphic image.

proc get_frame*(this: TextGraphic): LVecBase4 {.importcpp: "#.get_frame()".} ## \
## Returns the frame specified for the graphic.  This is the amount of space
## that will be reserved for the graphic when it is embedded in a text
## paragraph, in the form (left, right, bottom, top).
##
## The actual graphic, as rendered by the NodePath specified via set_model(),
## should more or less fit within this rectangle.  It is not required to fit
## completely within it, but if it does not, it may visually overlap with
## nearby text.

proc set_frame*(this: TextGraphic, frame: LVecBase4) {.importcpp: "#.set_frame(#)".} ## \
## Specifies the (left, right, bottom, top) bounding frame for the graphic.
## See get_frame().

proc set_frame*(this: TextGraphic, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#.set_frame(#, #, #, #)".} ## \
## Specifies the (left, right, bottom, top) bounding frame for the graphic.
## See get_frame().

proc get_instance_flag*(this: TextGraphic): bool {.importcpp: "#.get_instance_flag()".} ## \
## Returns the instance_flag.  See set_instance_flag().

proc set_instance_flag*(this: TextGraphic, instance_flag: bool) {.importcpp: "#.set_instance_flag(#)".} ## \
## Sets the instance_flag.  When this is true, the graphic is directly
## instanced to the scene graph whenever it appears; when it is false, the
## graphic is copied.  The default is false, which is best for most
## applications.  You might need to set it true for special kinds of
## "graphics" like interactive elements, for instance a PGEntry.

proc set_properties*(this: TextPropertiesManager, name: string, properties: TextProperties) {.importcpp: "#.set_properties(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Defines the TextProperties associated with the indicated name.  When the
## name is subsequently encountered in text embedded between \1 characters in
## a TextNode string, the following text will be rendered with these
## properties.
##
## If there was already a TextProperties structure associated with this name,
## it is quietly replaced with the new definition.

proc get_properties*(this: TextPropertiesManager, name: string): TextProperties {.importcpp: "#.get_properties(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the TextProperties associated with the indicated name.  If there
## was not previously a TextProperties associated with this name, a warning is
## printed and then a default TextProperties structure is associated with the
## name, and returned.
##
## Call has_properties() instead to check whether a particular name has been
## defined.

proc has_properties*(this: TextPropertiesManager, name: string): bool {.importcpp: "#.has_properties(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if a TextProperties structure has been associated with the
## indicated name, false otherwise.  Normally this means set_properties() has
## been called with this name, but because get_properties() will implicitly
## create a default TextProperties structure, it may also mean simply that
## get_properties() has been called with the indicated name.

proc clear_properties*(this: TextPropertiesManager, name: string) {.importcpp: "#.clear_properties(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the named TextProperties structure from the manager.

proc set_graphic*(this: TextPropertiesManager, name: string, model: NodePath) {.importcpp: "#.set_graphic(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## This flavor of set_graphic implicitly creates a frame for the model using
## the model's actual computed bounding volume, as derived from
## NodePath::calc_tight_bounds().  Create a TextGraphic object first if you
## want to have explicit control of the frame.

proc set_graphic*(this: TextPropertiesManager, name: string, graphic: TextGraphic) {.importcpp: "#.set_graphic(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Defines the TextGraphic associated with the indicated name.  When the name
## is subsequently encountered in text embedded between \5 characters in a
## TextNode string, the specified graphic will be embedded in the text at that
## point.
##
## If there was already a TextGraphic structure associated with this name, it
## is quietly replaced with the new definition.

proc get_graphic*(this: TextPropertiesManager, name: string): TextGraphic {.importcpp: "#.get_graphic(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the TextGraphic associated with the indicated name.  If there was
## not previously a TextGraphic associated with this name, a warning is
## printed and then a default TextGraphic structure is associated with the
## name, and returned.
##
## Call has_graphic() instead to check whether a particular name has been
## defined.

proc has_graphic*(this: TextPropertiesManager, name: string): bool {.importcpp: "#.has_graphic(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if a TextGraphic structure has been associated with the
## indicated name, false otherwise.  Normally this means set_graphic() has
## been called with this name, but because get_graphic() will implicitly
## create a default TextGraphic structure, it may also mean simply that
## get_graphic() has been called with the indicated name.

proc clear_graphic*(this: TextPropertiesManager, name: string) {.importcpp: "#.clear_graphic(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the named TextGraphic structure from the manager.

proc write*(this: TextPropertiesManager, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: TextPropertiesManager, `out`: ostream) {.importcpp: "#.write(#)".}

proc get_global_ptr*(_: typedesc[TextPropertiesManager]): TextPropertiesManager {.importcpp: "TextPropertiesManager::get_global_ptr()", header: "textPropertiesManager.h".} ## \
## Returns the pointer to the global TextPropertiesManager object.

proc initTextAssembler*(copy: TextAssembler): TextAssembler {.importcpp: "TextAssembler(#)".}

proc initTextAssembler*(encoder: TextEncoder): TextAssembler {.importcpp: "TextAssembler(#)".}

proc clear*(this: TextAssembler) {.importcpp: "#.clear()".} ## \
## Reinitializes the contents of the TextAssembler.

proc set_max_rows*(this: TextAssembler, max_rows: int) {.importcpp: "#.set_max_rows(#)".} ## \
## If max_rows is greater than zero, no more than max_rows will be accepted.
## Text beyond that will be truncated.
##
## Setting this will not truncate text immediately.  You must follow this up
## with a call to set_wtext() to truncate the existing text.

proc get_max_rows*(this: TextAssembler): int {.importcpp: "#.get_max_rows()".} ## \
## If max_rows is greater than zero, no more than max_rows will be accepted.
## Text beyond that will be truncated.

proc set_dynamic_merge*(this: TextAssembler, dynamic_merge: bool) {.importcpp: "#.set_dynamic_merge(#)".} ## \
## Sets the dynamic_merge flag.  See TextNode::set_flatten_flags().

proc get_dynamic_merge*(this: TextAssembler): bool {.importcpp: "#.get_dynamic_merge()".} ## \
## Returns the dynamic_merge flag.  See TextNode::set_flatten_flags().

proc set_multiline_mode*(this: TextAssembler, flag: bool) {.importcpp: "#.set_multiline_mode(#)".} ## \
## Sets the multiline mode flag.  Set the multiline mode to allow text to
## wrap.  It defaults to true.

proc get_multiline_mode*(this: TextAssembler): bool {.importcpp: "#.get_multiline_mode()".} ## \
## Returns the multline_mode flag.  See TextNode::set_multiline_mode().

proc set_properties*(this: TextAssembler, properties: TextProperties) {.importcpp: "#.set_properties(#)".} ## \
## Specifies the default TextProperties that are applied to the text in the
## absence of any nested property change sequences.

proc get_properties*(this: TextAssembler): TextProperties {.importcpp: "#.get_properties()".} ## \
## Returns the default TextProperties that are applied to the text in the
## absence of any nested property change sequences.

proc get_properties*(this: TextAssembler, n: int): TextProperties {.importcpp: "#.get_properties(#)".} ## \
## Returns the TextProperties in effect for the object at the indicated
## position in the pre-wordwrapped string.

proc get_properties*(this: TextAssembler, r: int, c: int): TextProperties {.importcpp: "#.get_properties(#, #)".} ## \
## Returns the TextProperties in effect for the object at the indicated
## position in the indicated row.

proc set_wtext*(this: TextAssembler, wtext: string): bool {.importcpp: "#.set_wtext(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Accepts a new text string and associated properties structure, and
## precomputes the wordwrapping layout appropriately.  After this call,
## get_wordwrapped_wtext() and get_num_rows() can be called.
##
## The return value is true if all the text is accepted, or false if some was
## truncated (see set_max_rows()).

proc set_wsubstr*(this: TextAssembler, wtext: string, start: int, count: int): bool {.importcpp: "#.set_wsubstr(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Replaces the 'count' characters from 'start' of the current text with the
## indicated replacement text.  If the replacement text does not have count
## characters, the length of the string will be changed accordingly.
##
## The substring may include nested formatting characters, but they must be
## self-contained and self-closed.  The formatting characters are not
## literally saved in the internal string; they are parsed at the time of the
## set_wsubstr() call.
##
## The return value is true if all the text is accepted, or false if some was
## truncated (see set_max_rows()).

proc get_plain_wtext*(this: TextAssembler): string {.importcpp: "nimStringFromStdString(#.get_plain_wtext())", header: stringConversionCode.} ## \
## Returns a wstring that represents the contents of the text, without any
## embedded properties characters.  If there is an embedded graphic object, a
## zero value is inserted in that position.
##
## This string has the same length as get_num_characters(), and the characters
## in this string correspond one-to-one with the characters returned by
## get_character(n).

proc get_wordwrapped_plain_wtext*(this: TextAssembler): string {.importcpp: "nimStringFromStdString(#.get_wordwrapped_plain_wtext())", header: stringConversionCode.} ## \
## Returns a wstring that represents the contents of the text, with newlines
## inserted according to the wordwrapping.  The string will contain no
## embedded properties characters.  If there is an embedded graphic object, a
## zero value is inserted in that position.
##
## This string has the same number of newline characters as get_num_rows(),
## and the characters in this string correspond one-to-one with the characters
## returned by get_character(r, c).

proc get_wtext*(this: TextAssembler): string {.importcpp: "nimStringFromStdString(#.get_wtext())", header: stringConversionCode.} ## \
## Returns a wstring that represents the contents of the text.
##
## The string will contain embedded properties characters, which may not
## exactly match the embedded properties characters of the original string,
## but it will encode the same way.

proc get_wordwrapped_wtext*(this: TextAssembler): string {.importcpp: "nimStringFromStdString(#.get_wordwrapped_wtext())", header: stringConversionCode.} ## \
## Returns a wstring that represents the contents of the text, with newlines
## inserted according to the wordwrapping.
##
## The string will contain embedded properties characters, which may not
## exactly match the embedded properties characters of the original string,
## but it will encode the same way.
##
## Embedded properties characters will be closed before every newline, then
## reopened (if necessary) on the subsequent character following the newline.
## This means it will be safe to divide the text up at the newline characters
## and treat each line as an independent piece.

proc calc_r*(this: TextAssembler, n: int): int {.importcpp: "#.calc_r(#)".} ## \
## Computes the row index of the nth character or graphic object in the text
## and returns it.
##
## If the nth character is not a normal printable character with a position in
## the wordwrapped string, returns -1 (for instance, a soft-hyphen character,
## or a newline character, may not have a corresponding position).

proc calc_c*(this: TextAssembler, n: int): int {.importcpp: "#.calc_c(#)".} ## \
## Computes the column index of the nth character or graphic object in the
## text and returns it.
##
## If the nth character is not a normal printable character with a position in
## the wordwrapped string, returns -1 (for instance, a soft-hyphen character,
## or a newline character, may not have a corresponding position).

proc calc_index*(this: TextAssembler, r: int, c: int): int {.importcpp: "#.calc_index(#, #)".} ## \
## Computes the character index of the character at the rth row and cth column
## position.  This is the inverse of calc_r_c().
##
## It is legal for c to exceed the index number of the last column by 1, and
## it is legal for r to exceed the index number of the last row by 1, if c is
## 0.

proc get_num_characters*(this: TextAssembler): int {.importcpp: "#.get_num_characters()".} ## \
## Returns the number of characters of text, before wordwrapping.

proc get_character*(this: TextAssembler, n: int): int {.importcpp: "#.get_character(#)".} ## \
## Returns the character at the indicated position in the pre-wordwrapped
## string.  If the object at this position is a graphic object instead of a
## character, returns 0.

proc get_character*(this: TextAssembler, r: int, c: int): int {.importcpp: "#.get_character(#, #)".} ## \
## Returns the character at the indicated position in the indicated row.  If
## the object at this position is a graphic object instead of a character,
## returns 0.

proc get_graphic*(this: TextAssembler, n: int): TextGraphic {.importcpp: "#.get_graphic(#)".} ## \
## Returns the graphic object at the indicated position in the pre-wordwrapped
## string.  If the object at this position is a character instead of a graphic
## object, returns NULL.

proc get_graphic*(this: TextAssembler, r: int, c: int): TextGraphic {.importcpp: "#.get_graphic(#, #)".} ## \
## Returns the graphic object at the indicated position in the indicated row.
## If the object at this position is a character instead of a graphic object,
## returns NULL.

proc get_width*(this: TextAssembler, n: int): float32 {.importcpp: "#.get_width(#)".} ## \
## Returns the width of the character or object at the indicated position in
## the pre-wordwrapped string.

proc get_width*(this: TextAssembler, r: int, c: int): float32 {.importcpp: "#.get_width(#, #)".} ## \
## Returns the width of the character or object at the indicated position in
## the indicated row.

proc get_num_rows*(this: TextAssembler): int {.importcpp: "#.get_num_rows()".} ## \
## Returns the number of rows of text after it has all been wordwrapped and
## assembled.

proc get_num_cols*(this: TextAssembler, r: int): int {.importcpp: "#.get_num_cols(#)".} ## \
## Returns the number of characters and/or graphic objects in the nth row.

proc get_xpos*(this: TextAssembler, r: int, c: int): float32 {.importcpp: "#.get_xpos(#, #)".} ## \
## Returns the x position of the origin of the character or graphic object at
## the indicated position in the indicated row.
##
## It is legal for c to exceed the index number of the last column by 1, and
## it is legal for r to exceed the index number of the last row by 1, if c is
## 0.

proc get_ypos*(this: TextAssembler, r: int, c: int): float32 {.importcpp: "#.get_ypos(#, #)".} ## \
## Returns the y position of the origin of all of the characters or graphic
## objects in the indicated row.
##
## It is legal for r to exceed the index number of the last row by 1.  The
## value of c is presently ignored.

proc assemble_text*(this: TextAssembler): PandaNode {.importcpp: "#.assemble_text()".} ## \
## Actually assembles all of the text into a GeomNode, and returns the node
## (or possibly a parent of the node, to keep the shadow separate).  Once this
## has been called, you may query the extents of the text via get_ul(),
## get_lr().

proc get_ul*(this: TextAssembler): LVector2 {.importcpp: "#.get_ul()".} ## \
## Returns the upper-left corner of the assembled text, in 2-d text
## coordinates.

proc get_lr*(this: TextAssembler): LVector2 {.importcpp: "#.get_lr()".} ## \
## Returns the lower-right corner of the assembled text, in 2-d text
## coordinates.

proc calc_width*(_: typedesc[TextAssembler], graphic: TextGraphic, properties: TextProperties): float32 {.importcpp: "TextAssembler::calc_width(#, #)", header: "textAssembler.h".} ## \
## Returns the width of a single TextGraphic image.

proc calc_width*(_: typedesc[TextAssembler], character: int, properties: TextProperties): float32 {.importcpp: "TextAssembler::calc_width(#, #)", header: "textAssembler.h".} ## \
## Returns the width of a single character, according to its associated font.
## This also correctly calculates the width of cheesy ligatures and accented
## characters, which may not exist in the font as such.
##
## This does not take kerning into account, however.

proc has_exact_character*(_: typedesc[TextAssembler], character: int, properties: TextProperties): bool {.importcpp: "TextAssembler::has_exact_character(#, #)", header: "textAssembler.h".} ## \
## Returns true if the named character exists in the font exactly as named,
## false otherwise.  Note that because Panda can assemble glyphs together
## automatically using cheesy accent marks, this is not a reliable indicator
## of whether a suitable glyph can be rendered for the character.  For that,
## use has_character() instead.
##
## This returns true for whitespace and Unicode whitespace characters (if they
## exist in the font), but returns false for characters that would render with
## the "invalid glyph".  It also returns false for characters that would be
## synthesized within Panda, but see has_character().

proc has_character*(_: typedesc[TextAssembler], character: int, properties: TextProperties): bool {.importcpp: "TextAssembler::has_character(#, #)", header: "textAssembler.h".} ## \
## Returns true if the named character exists in the font or can be
## synthesized by Panda, false otherwise.  (Panda can synthesize some accented
## characters by combining similar-looking glyphs from the font.)
##
## This returns true for whitespace and Unicode whitespace characters (if they
## exist in the font), but returns false for characters that would render with
## the "invalid glyph".

proc is_whitespace*(_: typedesc[TextAssembler], character: int, properties: TextProperties): bool {.importcpp: "TextAssembler::is_whitespace(#, #)", header: "textAssembler.h".} ## \
## Returns true if the indicated character represents whitespace in the font,
## or false if anything visible will be rendered for it.
##
## This returns true for whitespace and Unicode whitespace characters (if they
## exist in the font), and returns false for any other characters, including
## characters that do not exist in the font (these would be rendered with the
## "invalid glyph", which is visible).
##
## Note that this function can be reliably used to identify Unicode whitespace
## characters only if the font has all of the whitespace characters defined.
## It will return false for any character not in the font, even if it is an
## official Unicode whitespace character.

converter upcast_to_PandaNode*(this: TextNode): PandaNode {.importcpp: "(PT(PandaNode)(#))".}

converter upcast_to_TextEncoder*(this: TextNode): TextEncoder {.importcpp: "((TextEncoder *)(#.p()))".}

converter upcast_to_TextProperties*(this: TextNode): TextProperties {.importcpp: "((TextProperties *)(#.p()))".}

proc newTextNode*(name: string): TextNode {.importcpp: "new TextNode(nimStringToStdString(#))", header: stringConversionCode.}

proc newTextNode*(name: string, copy: TextProperties): TextNode {.importcpp: "new TextNode(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## It's sort of a copy constructor: it copies the indicated TextProperties,
## without copying a complete TextNode.

proc get_line_height*(this: TextNode): float32 {.importcpp: "#->get_line_height()".} ## \
## Returns the number of units high each line of text is.  This is based on
## the font.  Note that it is possible for the text to include nested font
## change commands, in which case the value of this method is questionable.

proc set_max_rows*(this: TextNode, max_rows: int) {.importcpp: "#->set_max_rows(#)".} ## \
## Sets the maximum number of rows that may be formatted by the TextNode.  If
## more text than this is attempted, it will be truncated and has_overflow()
## will return true.

proc clear_max_rows*(this: TextNode) {.importcpp: "#->clear_max_rows()".} ## \
## Resets the TextNode's default behavior of not limiting the number of rows
## of text.

proc has_max_rows*(this: TextNode): bool {.importcpp: "#->has_max_rows()".} ## \
## Returns true if a limit on the height of the TextNode has been set via
## set_max_rows(), false otherwise.

proc get_max_rows*(this: TextNode): int {.importcpp: "#->get_max_rows()".} ## \
## Returns the limit on the height of the TextNode specified by
## set_max_rows().

proc has_overflow*(this: TextNode): bool {.importcpp: "#->has_overflow()".} ## \
## Returns true if the last text set on the text node exceeded the max_rows
## constraint, or false if it all fit.

proc set_frame_color*(this: TextNode, frame_color: LColor) {.importcpp: "#->set_frame_color(#)".}

proc set_frame_color*(this: TextNode, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#->set_frame_color(#, #, #, #)".}

proc get_frame_color*(this: TextNode): LColor {.importcpp: "#->get_frame_color()".}

proc set_card_border*(this: TextNode, size: float32, uv_portion: float32) {.importcpp: "#->set_card_border(#, #)".}

proc clear_card_border*(this: TextNode) {.importcpp: "#->clear_card_border()".}

proc get_card_border_size*(this: TextNode): float32 {.importcpp: "#->get_card_border_size()".}

proc get_card_border_uv_portion*(this: TextNode): float32 {.importcpp: "#->get_card_border_uv_portion()".}

proc has_card_border*(this: TextNode): bool {.importcpp: "#->has_card_border()".}

proc set_card_color*(this: TextNode, card_color: LColor) {.importcpp: "#->set_card_color(#)".}

proc set_card_color*(this: TextNode, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#->set_card_color(#, #, #, #)".}

proc get_card_color*(this: TextNode): LColor {.importcpp: "#->get_card_color()".}

proc set_card_texture*(this: TextNode, card_texture: Texture) {.importcpp: "#->set_card_texture(#)".}

proc clear_card_texture*(this: TextNode) {.importcpp: "#->clear_card_texture()".}

proc has_card_texture*(this: TextNode): bool {.importcpp: "#->has_card_texture()".}

proc get_card_texture*(this: TextNode): Texture {.importcpp: "#->get_card_texture()".}

proc set_frame_as_margin*(this: TextNode, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_frame_as_margin(#, #, #, #)".} ## \
## Specifies that a border will be drawn around the text when it is next
## created.  The parameters are the amount of additional padding to insert
## between the frame and the text in each dimension, and all should generally
## be positive.

proc set_frame_actual*(this: TextNode, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_frame_actual(#, #, #, #)".} ## \
## Similar to set_frame_as_margin, except the frame is specified in actual
## coordinate units (relative to the text's origin), irrespective of the size
## of the text.  The left and bottom coordinates should generally be negative,
## while the right and top coordinates should generally be positive.

proc clear_frame*(this: TextNode) {.importcpp: "#->clear_frame()".} ## \
## Specifies that a border will not be drawn around the text.

proc has_frame*(this: TextNode): bool {.importcpp: "#->has_frame()".}

proc is_frame_as_margin*(this: TextNode): bool {.importcpp: "#->is_frame_as_margin()".} ## \
## If this is true, the frame was set via a call to set_frame_as_margin(), and
## the dimension of the frame as returned by get_frame_as_set() represent a
## margin all around the text.  If false, then the frame was set via a call to
## set_frame_actual(), and the dimensions of the frame as returned by
## get_frame_as_set() are relative to the text's origin.

proc get_frame_as_set*(this: TextNode): LVecBase4 {.importcpp: "#->get_frame_as_set()".} ## \
## Returns the dimensions of the frame as set by set_frame_as_margin() or
## set_frame_actual().  Use is_frame_actual() to determine how to interpret
## the values returned by this function.  It is an error to call this if
## has_frame() is false.

proc get_frame_actual*(this: TextNode): LVecBase4 {.importcpp: "#->get_frame_actual()".} ## \
## Returns the actual dimensions of the frame around the text.  If the frame
## was set via set_frame_as_margin(), the result returned by this function
## reflects the size of the current text; if the frame was set via
## set_frame_actual(), this returns the values actually set.
##
## If the text has no frame at all, this returns the dimensions of the text
## itself, as if the frame were set with a margin of 0, 0, 0, 0.

proc set_frame_line_width*(this: TextNode, line_width: float32) {.importcpp: "#->set_frame_line_width(#)".} ## \
## Specifies the thickness of the lines that will be used to draw the frame.

proc get_frame_line_width*(this: TextNode): float32 {.importcpp: "#->get_frame_line_width()".} ## \
## Returns the thickness of the lines that will be used to draw the frame.

proc set_frame_corners*(this: TextNode, corners: bool) {.importcpp: "#->set_frame_corners(#)".} ## \
## Enables or disables the drawing of corners for the frame.  These are extra
## points drawn at each of the four corners, to soften the ugly edges
## generated when the line width is greater than one.

proc get_frame_corners*(this: TextNode): bool {.importcpp: "#->get_frame_corners()".}

proc set_card_as_margin*(this: TextNode, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_card_as_margin(#, #, #, #)".} ## \
## Specifies that a (possibly opaque or semitransparent) card will be held
## behind the text when it is next created.  Like set_frame_as_margin, the
## parameters are the amount of additional padding to insert around the text
## in each dimension, and all should generally be positive.

proc set_card_actual*(this: TextNode, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_card_actual(#, #, #, #)".} ## \
## Similar to set_card_as_margin, except the card is specified in actual
## coordinate units (relative to the text's origin), irrespective of the size
## of the text.  The left and bottom coordinates should generally be negative,
## while the right and top coordinates should generally be positive.

proc set_card_decal*(this: TextNode, card_decal: bool) {.importcpp: "#->set_card_decal(#)".} ## \
## Sets the card_decal flag.  When this is true, the text is decalled onto the
## card, which is necessary if the TextNode is to be rendered in the 3-d world
## without putting it in a bin.

proc clear_card*(this: TextNode) {.importcpp: "#->clear_card()".} ## \
## Specifies that a card will not be drawn behind the text.

proc has_card*(this: TextNode): bool {.importcpp: "#->has_card()".}

proc get_card_decal*(this: TextNode): bool {.importcpp: "#->get_card_decal()".} ## \
## Returns the card_decal flag.  See set_card_decal().

proc is_card_as_margin*(this: TextNode): bool {.importcpp: "#->is_card_as_margin()".} ## \
## If this is true, the card was set via a call to set_card_as_margin(), and
## the dimension of the card as returned by get_card_as_set() represent a
## margin all around the text.  If false, then the card was set via a call to
## set_card_actual(), and the dimensions of the card as returned by
## get_card_as_set() are relative to the text's origin.

proc get_card_as_set*(this: TextNode): LVecBase4 {.importcpp: "#->get_card_as_set()".} ## \
## Returns the dimensions of the card as set by set_card_as_margin() or
## set_card_actual().  Use is_card_actual() to determine how to interpret the
## values returned by this function.  It is an error to call this if
## has_card() is false.

proc get_card_actual*(this: TextNode): LVecBase4 {.importcpp: "#->get_card_actual()".} ## \
## Returns the actual dimensions of the card around the text.  If the card was
## set via set_card_as_margin(), the result returned by this function reflects
## the size of the current text; if the card was set via set_card_actual(),
## this returns the values actually set.
##
## If the text has no card at all, this returns the dimensions of the text
## itself, as if the card were set with a margin of 0, 0, 0, 0.

proc get_card_transformed*(this: TextNode): LVecBase4 {.importcpp: "#->get_card_transformed()".} ## \
## Returns the actual card dimensions, transformed by the matrix set by
## set_transform().  This returns the card dimensions in actual coordinates as
## seen by the rest of the world.  Also see get_upper_left_3d() and
## get_lower_right_3d().

proc set_transform*(this: TextNode, transform: LMatrix4) {.importcpp: "#->set_transform(#)".} ## \
## Sets an additional transform that is applied to the entire text paragraph.

proc get_transform*(this: TextNode): LMatrix4 {.importcpp: "#->get_transform()".}

proc set_coordinate_system*(this: TextNode, cs: CoordinateSystem) {.importcpp: "#->set_coordinate_system(#)".} ## \
## Specifies the coordinate system in which the text will be generated.

proc get_coordinate_system*(this: TextNode): CoordinateSystem {.importcpp: "#->get_coordinate_system()".}

proc set_flatten_flags*(this: TextNode, flatten_flags: int) {.importcpp: "#->set_flatten_flags(#)".} ## \
## Sets the flatten flags.  This should be a union of the
## TextNode::FlattenFlags options.  This controls the degree of flattening
## performed on the TextNode's internal geometry (i.e.  the scene graph
## returned by generate()) each time the text is changed.  In general, more
## flattening means a more optimal result, but it will take more time to
## generate.
##
## The choice may be any of these three:
##
## FF_none - No flatten operation is called.  The letters are left as
## independent Geoms.
##
## FF_light - A flatten_light() operation is called.  The attributes are
## applied to the vertices, but no nodes are removed.
##
## FF_medium - A flatten_medium() operation is called.  The attributes are
## applied to the vertices, and a few trivial nodes are removed.
##
## FF_strong - A flatten_strong() operation is called.  The attributes are
## applied to the vertices, and the resulting nodes are aggressively combined
## into as few nodes as possible.
##
## In addition to the above choices, you may optionally include the following
## flag:
##
## FF_dynamic_merge - Copy the geoms into a single GeomVertexData as we go,
## instead of relying on the flatten operation at the end.  This pre-flattens
## the text considerably, and may obviate the need for flatten altogether; it
## also tends to improve performance considerably even if you do call flatten.
## However, it is not as fast as not calling flatten at all.
##
## The default is taken from the text-flatten and text-dynamic-merge config
## variables.

proc get_flatten_flags*(this: TextNode): int {.importcpp: "#->get_flatten_flags()".} ## \
## Returns the flatten flags.  See set_flatten_flags().

proc set_font*(this: TextNode, font: TextFont) {.importcpp: "#->set_font(#)".} ## \
## Sets the font that will be used when making text.  If this is set to NULL,
## the default font will be used, which can be set via set_default_font().

proc clear_font*(this: TextNode) {.importcpp: "#->clear_font()".} ## \
## Resets the font to the default font.

proc set_small_caps*(this: TextNode, small_caps: bool) {.importcpp: "#->set_small_caps(#)".} ## \
## Sets the small_caps flag.  When this is set, lowercase letters are
## generated as scaled-down versions of their uppercase equivalents.  This is
## particularly useful to set for fonts that do not have lowercase letters.
##
## It is also a good idea to set this for a (dynamic) font that has already
## implemented lowercase letters as scaled-down versions of their uppercase
## equivalents, since without this flag the texture memory may needlessly
## duplicate equivalent glyphs for upper and lowercase letters.  Setting this
## flag causes the texture memory to share the mixed-case letters.
##
## The amount by which the lowercase letters are scaled is specified by
## set_small_caps_scale().

proc clear_small_caps*(this: TextNode) {.importcpp: "#->clear_small_caps()".}

proc set_small_caps_scale*(this: TextNode, small_caps_scale: float32) {.importcpp: "#->set_small_caps_scale(#)".} ## \
## Sets the scale factor applied to lowercase letters from their uppercase
## equivalents, when the small_caps flag is in effect.  See set_small_caps().
## Normally, this will be a number less than one.

proc clear_small_caps_scale*(this: TextNode) {.importcpp: "#->clear_small_caps_scale()".}

proc set_slant*(this: TextNode, slant: float32) {.importcpp: "#->set_slant(#)".}

proc clear_slant*(this: TextNode) {.importcpp: "#->clear_slant()".}

proc clear_align*(this: TextNode) {.importcpp: "#->clear_align()".}

proc set_indent*(this: TextNode, indent: float32) {.importcpp: "#->set_indent(#)".} ## \
## Specifies the amount of extra space that is inserted before the first
## character of each line.  This can be thought of as a left margin.

proc clear_indent*(this: TextNode) {.importcpp: "#->clear_indent()".}

proc set_wordwrap*(this: TextNode, wordwrap: float32) {.importcpp: "#->set_wordwrap(#)".} ## \
## Sets the text up to automatically wordwrap when it exceeds the indicated
## width.  This can be thought of as a right margin or margin width.

proc clear_wordwrap*(this: TextNode) {.importcpp: "#->clear_wordwrap()".} ## \
## Removes the wordwrap setting from the TextNode.  Text will be as wide as it
## is.

proc set_text_color*(this: TextNode, text_color: LColor) {.importcpp: "#->set_text_color(#)".}

proc set_text_color*(this: TextNode, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#->set_text_color(#, #, #, #)".}

proc clear_text_color*(this: TextNode) {.importcpp: "#->clear_text_color()".} ## \
## Removes the text color specification; the text will be colored whatever it
## was in the source font file.

proc set_shadow_color*(this: TextNode, shadow_color: LColor) {.importcpp: "#->set_shadow_color(#)".}

proc set_shadow_color*(this: TextNode, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#->set_shadow_color(#, #, #, #)".}

proc clear_shadow_color*(this: TextNode) {.importcpp: "#->clear_shadow_color()".}

proc set_shadow*(this: TextNode, shadow_offset: LVecBase2) {.importcpp: "#->set_shadow(#)".} ## \
## Specifies that the text should be drawn with a shadow, by creating a second
## copy of the text and offsetting it slightly behind the first.

proc set_shadow*(this: TextNode, xoffset: float32, yoffset: float32) {.importcpp: "#->set_shadow(#, #)".} ## \
## Specifies that the text should be drawn with a shadow, by creating a second
## copy of the text and offsetting it slightly behind the first.

proc clear_shadow*(this: TextNode) {.importcpp: "#->clear_shadow()".} ## \
## Specifies that a shadow will not be drawn behind the text.

proc set_bin*(this: TextNode, bin: string) {.importcpp: "#->set_bin(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Names the GeomBin that the TextNode geometry should be assigned to.  If
## this is set, then a GeomBinTransition will be created to explicitly place
## each component in the named bin.
##
## The draw_order value will also be passed to each GeomBinTransition as
## appropriate; this is particularly useful if this names a GeomBinFixed, e.g.
## "fixed".

proc clear_bin*(this: TextNode) {.importcpp: "#->clear_bin()".} ## \
## Removes the effect of a previous call to set_bin().  Text will be drawn in
## whatever bin it would like to be drawn in, with no explicit ordering.

proc set_draw_order*(this: TextNode, draw_order: int): int {.importcpp: "#->set_draw_order(#)".} ## \
## Sets the drawing order of text created by the TextMaker.  This is actually
## the draw order of the card and frame.  The shadow is drawn at
## _draw_order+1, and the text at _draw_order+2.
##
## This affects the sorting order assigned to the arcs as they are created,
## and also is passed to whatever bin may be assigned via set_bin().
##
## The return value is the first unused draw_order number, e.g.  _draw_order +
## 3.

proc clear_draw_order*(this: TextNode) {.importcpp: "#->clear_draw_order()".}

proc set_tab_width*(this: TextNode, tab_width: float32) {.importcpp: "#->set_tab_width(#)".} ## \
## Sets the width of each tab stop, in screen units.  A tab character embedded
## in the text will advance the horizontal position to the next tab stop.

proc clear_tab_width*(this: TextNode) {.importcpp: "#->clear_tab_width()".}

proc set_glyph_scale*(this: TextNode, glyph_scale: float32) {.importcpp: "#->set_glyph_scale(#)".} ## \
## Specifies the factor by which to scale each letter of the text as it is
## placed.  This can be used (possibly in conjunction with set_glyph_shift())
## to implement superscripting or subscripting.

proc clear_glyph_scale*(this: TextNode) {.importcpp: "#->clear_glyph_scale()".}

proc set_glyph_shift*(this: TextNode, glyph_shift: float32) {.importcpp: "#->set_glyph_shift(#)".} ## \
## Specifies a vertical amount to shift each letter of the text as it is
## placed.  This can be used (possibly in conjunction with set_glyph_scale())
## to implement superscripting or subscripting.

proc clear_glyph_shift*(this: TextNode) {.importcpp: "#->clear_glyph_shift()".}

proc get_wordwrapped_text*(this: TextNode): string {.importcpp: "nimStringFromStdString(#->get_wordwrapped_text())", header: stringConversionCode.} ## \
## Returns a string that represents the contents of the text, as it has been
## formatted by wordwrap rules.
##
## In earlier versions, this did not contain any embedded special characters
## like \1 or \3; now it does.

proc calc_width*(this: TextNode, line: string): float32 {.importcpp: "#->calc_width(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the width of a line of text of arbitrary characters.  The line
## should not include the newline character.

proc calc_width*(this: TextNode, character: int): float32 {.importcpp: "#->calc_width(#)".} ## \
## Returns the width of a single character of the font, or 0.0 if the
## character is not known.  This may be a wide character (greater than 255).

proc has_exact_character*(this: TextNode, character: int): bool {.importcpp: "#->has_exact_character(#)".} ## \
## Returns true if the named character exists in the font exactly as named,
## false otherwise.  Note that because Panda can assemble glyphs together
## automatically using cheesy accent marks, this is not a reliable indicator
## of whether a suitable glyph can be rendered for the character.  For that,
## use has_character() instead.
##
## This returns true for whitespace and Unicode whitespace characters (if they
## exist in the font), but returns false for characters that would render with
## the "invalid glyph".  It also returns false for characters that would be
## synthesized within Panda, but see has_character().

proc has_character*(this: TextNode, character: int): bool {.importcpp: "#->has_character(#)".} ## \
## Returns true if the named character exists in the font or can be
## synthesized by Panda, false otherwise.  (Panda can synthesize some accented
## characters by combining similar-looking glyphs from the font.)
##
## This returns true for whitespace and Unicode whitespace characters (if they
## exist in the font), but returns false for characters that would render with
## the "invalid glyph".

proc is_whitespace*(this: TextNode, character: int): bool {.importcpp: "#->is_whitespace(#)".} ## \
## Returns true if the indicated character represents whitespace in the font,
## or false if anything visible will be rendered for it.
##
## This returns true for whitespace and Unicode whitespace characters (if they
## exist in the font), and returns false for any other characters, including
## characters that do not exist in the font (these would be rendered with the
## "invalid glyph", which is visible).
##
## Note that this function can be reliably used to identify Unicode whitespace
## characters only if the font has all of the whitespace characters defined.
## It will return false for any character not in the font, even if it is an
## official Unicode whitespace character.

proc get_wordwrapped_wtext*(this: TextNode): string {.importcpp: "nimStringFromStdString(#->get_wordwrapped_wtext())", header: stringConversionCode.} ## \
## Returns a wstring that represents the contents of the text, as it has been
## formatted by wordwrap rules.
##
## In earlier versions, this did not contain any embedded special characters
## like \1 or \3; now it does.

proc output*(this: TextNode, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: TextNode, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: TextNode, `out`: ostream) {.importcpp: "#->write(#)".}

proc get_left*(this: TextNode): float32 {.importcpp: "#->get_left()".} ## \
## Returns the leftmost extent of the text in local 2-d coordinates,
## unmodified by the set_transform() matrix.

proc get_right*(this: TextNode): float32 {.importcpp: "#->get_right()".} ## \
## Returns the rightmost extent of the text in local 2-d coordinates,
## unmodified by the set_transform() matrix.

proc get_bottom*(this: TextNode): float32 {.importcpp: "#->get_bottom()".} ## \
## Returns the bottommost extent of the text in local 2-d coordinates,
## unmodified by the set_transform() matrix.

proc get_top*(this: TextNode): float32 {.importcpp: "#->get_top()".} ## \
## Returns the topmost extent of the text in local 2-d coordinates, unmodified
## by the set_transform() matrix.

proc get_height*(this: TextNode): float32 {.importcpp: "#->get_height()".} ## \
## Returns the net height of the text in local 2-d coordinates.

proc get_width*(this: TextNode): float32 {.importcpp: "#->get_width()".} ## \
## Returns the net width of the text in local 2-d coordinates.

proc get_upper_left_3d*(this: TextNode): LPoint3 {.importcpp: "#->get_upper_left_3d()".} ## \
## Returns the upper-left extent of the text object, after it has been
## transformed into 3-d space by applying the set_transform() matrix.

proc get_lower_right_3d*(this: TextNode): LPoint3 {.importcpp: "#->get_lower_right_3d()".} ## \
## Returns the lower-right extent of the text object, after it has been
## transformed into 3-d space by applying the set_transform() matrix.

proc get_num_rows*(this: TextNode): int {.importcpp: "#->get_num_rows()".} ## \
## Returns the number of rows of text that were generated.  This counts word-
## wrapped rows as well as rows generated due to embedded newlines.

proc generate*(this: TextNode): PandaNode {.importcpp: "#->generate()".} ## \
## Generates the text, according to the parameters indicated within the
## TextNode, and returns a Node that may be parented within the tree to
## represent it.

proc update*(this: TextNode) {.importcpp: "#->update()".} ## \
## Can be called after the TextNode has been fully configured, to force the
## node to recompute its text immediately, rather than waiting for it to be
## drawn.  This call is optional.

proc force_update*(this: TextNode) {.importcpp: "#->force_update()".} ## \
## Forces the TextNode to recompute itself now, even if it believes nothing
## has changed.  Normally, this should not need to be called, but it may be
## useful if some properties change outside of the TextNode's knowledge (for
## instance, within the font).

proc get_internal_geom*(this: TextNode): PandaNode {.importcpp: "#->get_internal_geom()".} ## \
## Returns the actual node that is used internally to render the text, if the
## TextNode is parented within the scene graph.
##
## In general, you should not call this method.  Call generate() instead if
## you want to get a handle to geometry that represents the text.  This method
## is provided as a debugging aid only.

proc has_font*(this: TextNode): bool {.importcpp: "#->has_font()".}

proc has_small_caps*(this: TextNode): bool {.importcpp: "#->has_small_caps()".}

proc has_small_caps_scale*(this: TextNode): bool {.importcpp: "#->has_small_caps_scale()".}

proc has_slant*(this: TextNode): bool {.importcpp: "#->has_slant()".}

proc has_underscore*(this: TextNode): bool {.importcpp: "#->has_underscore()".}

proc clear_underscore*(this: TextNode) {.importcpp: "#->clear_underscore()".}

proc has_underscore_height*(this: TextNode): bool {.importcpp: "#->has_underscore_height()".}

proc clear_underscore_height*(this: TextNode) {.importcpp: "#->clear_underscore_height()".}

proc has_align*(this: TextNode): bool {.importcpp: "#->has_align()".}

proc has_indent*(this: TextNode): bool {.importcpp: "#->has_indent()".}

proc has_wordwrap*(this: TextNode): bool {.importcpp: "#->has_wordwrap()".}

proc has_preserve_trailing_whitespace*(this: TextNode): bool {.importcpp: "#->has_preserve_trailing_whitespace()".}

proc clear_preserve_trailing_whitespace*(this: TextNode) {.importcpp: "#->clear_preserve_trailing_whitespace()".}

proc has_text_color*(this: TextNode): bool {.importcpp: "#->has_text_color()".}

proc has_shadow_color*(this: TextNode): bool {.importcpp: "#->has_shadow_color()".}

proc has_shadow*(this: TextNode): bool {.importcpp: "#->has_shadow()".}

proc has_bin*(this: TextNode): bool {.importcpp: "#->has_bin()".} ## \
## Returns true if an explicit drawing bin has been set via set_bin(), false
## otherwise.

proc has_draw_order*(this: TextNode): bool {.importcpp: "#->has_draw_order()".}

proc has_tab_width*(this: TextNode): bool {.importcpp: "#->has_tab_width()".}

proc has_glyph_scale*(this: TextNode): bool {.importcpp: "#->has_glyph_scale()".}

proc has_glyph_shift*(this: TextNode): bool {.importcpp: "#->has_glyph_shift()".}

proc has_text_scale*(this: TextNode): bool {.importcpp: "#->has_text_scale()".}

proc clear_text_scale*(this: TextNode) {.importcpp: "#->clear_text_scale()".}

proc get_class_type*(_: typedesc[TextNode]): TypeHandle {.importcpp: "TextNode::get_class_type()", header: "textNode.h".}

proc newButtonThrower*(param0: ButtonThrower): ButtonThrower {.importcpp: "new ButtonThrower(#)".}

proc newButtonThrower*(name: string): ButtonThrower {.importcpp: "new ButtonThrower(nimStringToStdString(#))", header: stringConversionCode.}

proc set_button_down_event*(this: ButtonThrower, button_down_event: string) {.importcpp: "#->set_button_down_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the generic event that is generated (if any) each time a key or
## button is depressed.  Unlike the specific events that are unique to each
## key, this same event name is used for *all* button events, and the name of
## the button pressed (possibly with modifier prefixes) will be sent as a
## parameter.
##
## If this string is empty, no event is generated.  It is possible to generate
## both generic events and specific events for the same button.
##
## See also set_keystroke_event().

proc get_button_down_event*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_button_down_event())", header: stringConversionCode.} ## \
## Returns the button_down_event that has been set on this ButtonThrower.  See
## set_button_down_event().

proc set_button_up_event*(this: ButtonThrower, button_up_event: string) {.importcpp: "#->set_button_up_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the generic event that is generated (if any) each time a key or
## button is released.  See set_button_down_event().

proc get_button_up_event*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_button_up_event())", header: stringConversionCode.} ## \
## Returns the button_up_event that has been set on this ButtonThrower.  See
## set_button_up_event().

proc set_button_repeat_event*(this: ButtonThrower, button_repeat_event: string) {.importcpp: "#->set_button_repeat_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the generic event that is generated (if any) repeatedly while a
## key or button is held down.  Unlike the specific events that are unique to
## each key, this same event name is used for *all* button events, and the
## name of the button pressed (possibly with modifier prefixes) will be sent
## as a parameter.
##
## If this string is empty, no event is generated.  It is possible to generate
## both generic events and specific events for the same button.
##
## See also set_keystroke_event().

proc get_button_repeat_event*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_button_repeat_event())", header: stringConversionCode.} ## \
## Returns the button_repeat_event that has been set on this ButtonThrower.
## See set_button_repeat_event().

proc set_keystroke_event*(this: ButtonThrower, keystroke_event: string) {.importcpp: "#->set_keystroke_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the event that is generated (if any) for each keystroke that is
## received.  A keystroke is different than a button event: it represents the
## semantic meaning of the sequence of keys that have been pressed.  For
## instance, pressing shift and 4 together will generate the button event
## "shift-4", but it will generate the keystroke "$".
##
## If a key is held down, keyrepeat will cause the same keystroke event to be
## generated repeatedly.  This is different from the corresponding down event,
## which will only be generated once, followed by a number of button repeat
## events.
##
## This event is generated with a single wstring parameter, which is a one-
## character string that contains the keystroke generated.  If this event
## string is empty, no event is generated.
##
## See also set_button_down_event().

proc get_keystroke_event*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_keystroke_event())", header: stringConversionCode.} ## \
## Returns the keystroke_event that has been set on this ButtonThrower.  See
## set_keystroke_event().

proc set_candidate_event*(this: ButtonThrower, candidate_event: string) {.importcpp: "#->set_candidate_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the event that is generated (if any) for each IME candidate
## string event received.  Events of this nature are received only when the
## user is entering data using a Microsoft Input Method Editor, typically used
## for Asian languages such as Japanese or Korean.
##
## If you are designing a typing user interface, you should track this event
## to support the use of the IME.  In response to this event, you should
## display the candidate string in the entry box, with the appropriate
## sections highlighted, so the user can scroll through the available choices.
##
## This event is generated with four parameters, in order: the candidate
## string, the character at which to start the highlight, the character at
## which to end the highlight, and the current cursor position.

proc get_candidate_event*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_candidate_event())", header: stringConversionCode.} ## \
## Returns the candidate_event that has been set on this ButtonThrower.  See
## set_candidate_event().

proc set_move_event*(this: ButtonThrower, move_event: string) {.importcpp: "#->set_move_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the event that is generated (if any) each time the mouse is moved
## within the window.

proc get_move_event*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_move_event())", header: stringConversionCode.} ## \
## Returns the move_event that has been set on this ButtonThrower.  See
## set_move_event().

proc set_raw_button_down_event*(this: ButtonThrower, raw_button_down_event: string) {.importcpp: "#->set_raw_button_down_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Like set_button_down_event, but uses the raw, untransformed scan key from
## the operating system.  This uses buttons that are independent of the user's
## selected keyboard layout.

proc get_raw_button_down_event*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_raw_button_down_event())", header: stringConversionCode.} ## \
## Returns the raw_button_down_event that has been set on this ButtonThrower.
## See set_raw_button_down_event().

proc set_raw_button_up_event*(this: ButtonThrower, raw_button_up_event: string) {.importcpp: "#->set_raw_button_up_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the generic event that is generated (if any) each time a key or
## button is released.  See set_raw_button_down_event().

proc get_raw_button_up_event*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_raw_button_up_event())", header: stringConversionCode.} ## \
## Returns the raw_button_up_event that has been set on this ButtonThrower.
## See set_raw_button_up_event().

proc set_prefix*(this: ButtonThrower, prefix: string) {.importcpp: "#->set_prefix(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the prefix which is prepended to all specific event names (that is,
## event names generated from the button name itself, as opposed to the
## generic event names like set_button_down_event) thrown by this object.

proc get_prefix*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_prefix())", header: stringConversionCode.} ## \
## Returns the prefix that has been set on this ButtonThrower.  See
## set_prefix().

proc set_specific_flag*(this: ButtonThrower, specific_flag: bool) {.importcpp: "#->set_specific_flag(#)".} ## \
## Sets the flag that indicates whether specific events (events prefixed by
## set_prefix, and based on the event name) should be generated at all.  This
## is true by default, but may be disabled if you are only interested in the
## generic events (for instance, events like set_button_down_event).

proc get_specific_flag*(this: ButtonThrower): bool {.importcpp: "#->get_specific_flag()".} ## \
## Returns the flag that indicates whether specific events should be
## generated.  See set_specific_flag().

proc set_time_flag*(this: ButtonThrower, time_flag: bool) {.importcpp: "#->set_time_flag(#)".} ## \
## Sets the flag that indicates whether the time of the button event should be
## passed as a parameter or not.  When this is true, an additional parameter
## is generated on each event (before all the parameters named by
## add_parameter) that consists of a single double value, and reflects the
## time the button was pressed or released, as a value from
## ClockObject::get_global_clock().

proc get_time_flag*(this: ButtonThrower): bool {.importcpp: "#->get_time_flag()".} ## \
## Returns the flag that indicates whether the time of the button event should
## be passed as a parameter.

proc add_parameter*(this: ButtonThrower, obj: EventParameter) {.importcpp: "#->add_parameter(#)".} ## \
## Adds the indicated parameter to the list of parameters that will be passed
## with each event generated by this ButtonThrower.

proc get_num_parameters*(this: ButtonThrower): int {.importcpp: "#->get_num_parameters()".} ## \
## Returns the number of parameters that have been added to the list of
## parameters to be passed with each event generated by this ButtonThrower.

proc get_parameter*(this: ButtonThrower, n: int): EventParameter {.importcpp: "#->get_parameter(#)".} ## \
## Returns the nth parameter that has been added to the list of parameters
## passed with each event generated by this ButtonThrower.

proc get_modifier_buttons*(this: ButtonThrower): ModifierButtons {.importcpp: "#->get_modifier_buttons()".} ## \
## Returns the set of ModifierButtons that the ButtonThrower will consider
## important enough to prepend the event name with.  Normally, this set will
## be empty, and the ButtonThrower will therefore ignore all ModifierButtons
## attached to the key events, but if one or more buttons have been added to
## this set, and those modifier buttons are set on the button event, then the
## event name will be prepended with the names of the modifier buttons.

proc set_modifier_buttons*(this: ButtonThrower, mods: ModifierButtons) {.importcpp: "#->set_modifier_buttons(#)".} ## \
## Changes the set of ModifierButtons that the ButtonThrower will consider
## important enough to prepend the event name with.  Normally, this set will
## be empty, and the ButtonThrower will therefore ignore all ModifierButtons
## attached to the key events, but if one or more buttons have been added to
## this set, then the event name will be prepended with the names of the
## modifier buttons.
##
## It is recommended that you change this setting by first calling
## get_modifier_buttons(), making adjustments, and passing the new value to
## set_modifier_buttons().  This way the current state of the modifier buttons
## will not be lost.

proc set_throw_buttons_active*(this: ButtonThrower, flag: bool) {.importcpp: "#->set_throw_buttons_active(#)".} ## \
## Sets the flag that indicates whether the ButtonThrower will only process
## events for the explicitly named buttons or not.  Normally this is false,
## meaning all buttons are processed; set it true to indicate that only some
## buttons should be processed.  See add_throw_button().

proc get_throw_buttons_active*(this: ButtonThrower): bool {.importcpp: "#->get_throw_buttons_active()".} ## \
## Returns the flag that indicates whether the ButtonThrower will only process
## events for the explicitly named buttons or not.  See
## set_throw_buttons_active().

proc add_throw_button*(this: ButtonThrower, mods: ModifierButtons, button: ButtonHandle): bool {.importcpp: "#->add_throw_button(#, #)".} ## \
## Adds a new button to the set of buttons that the ButtonThrower explicitly
## processes.
##
## If set_throw_buttons_active is false (which is the default), the
## ButtonThrower will process all buttons.  Otherwise, the ButtonThrower will
## only process events for the button(s) explicitly named by this function;
## buttons not on the list will be ignored by this object and passed on
## downstream to the child node(s) in the data graph.  A button that *is* on
## the list will be processed by the ButtonThrower and not passed on to the
## child node(s).
##
## The return value is true if the button is added, or false if it was already
## in the set.

proc remove_throw_button*(this: ButtonThrower, mods: ModifierButtons, button: ButtonHandle): bool {.importcpp: "#->remove_throw_button(#, #)".} ## \
## Removes the indicated button from the set of buttons that the ButtonThrower
## explicitly processes.  See add_throw_button().
##
## The return value is true if the button is removed, or false if it was not
## on the set.

proc has_throw_button*(this: ButtonThrower, button: ButtonHandle): bool {.importcpp: "#->has_throw_button(#)".} ## \
## Returns true if the indicated button, in conjunction with any nonspecified
## modifier buttons, is on the set of buttons that will be processed by the
## ButtonThrower.  That is to say, returns true if this button was ever passed
## as the second parameter add_throw_button(), regardless of what the first
## parameter was.

proc has_throw_button*(this: ButtonThrower, mods: ModifierButtons, button: ButtonHandle): bool {.importcpp: "#->has_throw_button(#, #)".} ## \
## Returns true if the indicated button is on the set of buttons that will be
## processed by the ButtonThrower, false otherwise.  See add_throw_button().

proc clear_throw_buttons*(this: ButtonThrower) {.importcpp: "#->clear_throw_buttons()".} ## \
## Empties the set of buttons that were added via add_throw_button().  See
## add_throw_button().

proc get_class_type*(_: typedesc[ButtonThrower]): TypeHandle {.importcpp: "ButtonThrower::get_class_type()", header: "buttonThrower.h".}

proc require_button*(this: MouseInterfaceNode, button: ButtonHandle, is_down: bool) {.importcpp: "#->require_button(#, #)".} ## \
## Indicates that the indicated button must be in the required state (either
## up or down) in order for this particular MouseInterfaceNode to do anything.
## For instance, this may be called to make a Trackball object respect mouse
## input only when the control key is held down.

proc clear_button*(this: MouseInterfaceNode, button: ButtonHandle) {.importcpp: "#->clear_button(#)".} ## \
## Removes any requirement on the indicated button set by an earlier call to
## require_button().

proc clear_all_buttons*(this: MouseInterfaceNode) {.importcpp: "#->clear_all_buttons()".} ## \
## Removes all requirements on buttons set by an earlier call to
## require_button().

proc get_class_type*(_: typedesc[MouseInterfaceNode]): TypeHandle {.importcpp: "MouseInterfaceNode::get_class_type()", header: "mouseInterfaceNode.h".}

proc newMouseInterfaceNode*(param0: MouseInterfaceNode): MouseInterfaceNode {.importcpp: "new MouseInterfaceNode(#)".}

proc newDriveInterface*(param0: DriveInterface): DriveInterface {.importcpp: "new DriveInterface(#)".}

proc newDriveInterface*(name: string): DriveInterface {.importcpp: "new DriveInterface(nimStringToStdString(#))", header: stringConversionCode.}

proc newDriveInterface*(): DriveInterface {.importcpp: "new DriveInterface()".}

proc set_forward_speed*(this: DriveInterface, speed: float32) {.importcpp: "#->set_forward_speed(#)".} ## \
## Sets the speed of full forward motion, when the mouse is at the very top of
## the window.  This is in units (e.g.  feet) per second.

proc get_forward_speed*(this: DriveInterface): float32 {.importcpp: "#->get_forward_speed()".} ## \
## Returns the speed of full forward motion, when the mouse is at the very top
## of the window.  This is in units (e.g.  feet) per second.

proc set_reverse_speed*(this: DriveInterface, speed: float32) {.importcpp: "#->set_reverse_speed(#)".} ## \
## Sets the speed of full reverse motion, when the mouse is at the very bottom
## of the window.  This is in units (e.g.  feet) per second.

proc get_reverse_speed*(this: DriveInterface): float32 {.importcpp: "#->get_reverse_speed()".} ## \
## Returns the speed of full reverse motion, when the mouse is at the very
## bottom of the window.  This is in units (e.g.  feet) per second.

proc set_rotate_speed*(this: DriveInterface, speed: float32) {.importcpp: "#->set_rotate_speed(#)".} ## \
## Sets the maximum rate at which the user can rotate left or right, when the
## mouse is at the very edge of the window.  This is in degrees per second.

proc get_rotate_speed*(this: DriveInterface): float32 {.importcpp: "#->get_rotate_speed()".} ## \
## Returns the maximum rate at which the user can rotate left or right, when
## the mouse is at the very edge of the window.  This is in degrees per
## second.

proc set_vertical_dead_zone*(this: DriveInterface, zone: float32) {.importcpp: "#->set_vertical_dead_zone(#)".} ## \
## Sets the size of the horizontal bar in the center of the screen that
## represents the "dead zone" of vertical motion: the region in which the
## mouse does not report vertical motion.  This is in a fraction of the window
## height, so 0.5 will set a dead zone as large as half the screen.

proc get_vertical_dead_zone*(this: DriveInterface): float32 {.importcpp: "#->get_vertical_dead_zone()".} ## \
## Returns the size of the horizontal bar in the center of the screen that
## represents the "dead zone" of vertical motion: the region in which the
## mouse does not report vertical motion.  This is in a fraction of the window
## height, so 0.5 will set a dead zone as large as half the screen.

proc set_horizontal_dead_zone*(this: DriveInterface, zone: float32) {.importcpp: "#->set_horizontal_dead_zone(#)".} ## \
## Sets the size of the vertical bar in the center of the screen that
## represents the "dead zone" of horizontal motion: the region in which the
## mouse does not report horizontal motion.  This is in a fraction of the
## window width, so 0.5 will set a dead zone as large as half the screen.

proc get_horizontal_dead_zone*(this: DriveInterface): float32 {.importcpp: "#->get_horizontal_dead_zone()".} ## \
## Returns the size of the vertical bar in the center of the screen that
## represents the "dead zone" of horizontal motion: the region in which the
## mouse does not report horizontal motion.  This is in a fraction of the
## window width, so 0.5 will set a dead zone as large as half the screen.

proc set_vertical_ramp_up_time*(this: DriveInterface, ramp_up_time: float32) {.importcpp: "#->set_vertical_ramp_up_time(#)".} ## \
## Sets the amount of time, in seconds, it takes between the time an up or
## down arrow key is pressed and the time it registers full forward or
## backward motion.

proc get_vertical_ramp_up_time*(this: DriveInterface): float32 {.importcpp: "#->get_vertical_ramp_up_time()".} ## \
## Returns the amount of time, in seconds, it takes between the time an up or
## down arrow key is pressed and the time it registers full forward or
## backward motion.

proc set_vertical_ramp_down_time*(this: DriveInterface, ramp_down_time: float32) {.importcpp: "#->set_vertical_ramp_down_time(#)".} ## \
## Sets the amount of time, in seconds, it takes between the time an up or
## down arrow key is released and the time it registers no motion.

proc get_vertical_ramp_down_time*(this: DriveInterface): float32 {.importcpp: "#->get_vertical_ramp_down_time()".} ## \
## Returns the amount of time, in seconds, it takes between the time an up or
## down arrow key is released and the time it registers no motion.

proc set_horizontal_ramp_up_time*(this: DriveInterface, ramp_up_time: float32) {.importcpp: "#->set_horizontal_ramp_up_time(#)".} ## \
## Sets the amount of time, in seconds, it takes between the time a left or
## right arrow key is pressed and the time it registers full rotation.

proc get_horizontal_ramp_up_time*(this: DriveInterface): float32 {.importcpp: "#->get_horizontal_ramp_up_time()".} ## \
## Returns the amount of time, in seconds, it takes between the time a left or
## right arrow key is pressed and the time it registers full rotation.

proc set_horizontal_ramp_down_time*(this: DriveInterface, ramp_down_time: float32) {.importcpp: "#->set_horizontal_ramp_down_time(#)".} ## \
## Sets the amount of time, in seconds, it takes between the time a left or
## right arrow key is released and the time it registers no motion.

proc get_horizontal_ramp_down_time*(this: DriveInterface): float32 {.importcpp: "#->get_horizontal_ramp_down_time()".} ## \
## Returns the amount of time, in seconds, it takes between the time a left or
## right arrow key is released and the time it registers no motion.

proc get_speed*(this: DriveInterface): float32 {.importcpp: "#->get_speed()".} ## \
## Returns the speed of the previous update in units/sec

proc get_rot_speed*(this: DriveInterface): float32 {.importcpp: "#->get_rot_speed()".} ## \
## Returns the rot_speed of the previous update in units/sec

proc reset*(this: DriveInterface) {.importcpp: "#->reset()".} ## \
## Reinitializes the driver to the origin and resets any knowledge about
## buttons being held down.

proc get_pos*(this: DriveInterface): LPoint3 {.importcpp: "#->get_pos()".} ## \
## Returns the driver's position.

proc get_x*(this: DriveInterface): float32 {.importcpp: "#->get_x()".}

proc get_y*(this: DriveInterface): float32 {.importcpp: "#->get_y()".}

proc get_z*(this: DriveInterface): float32 {.importcpp: "#->get_z()".}

proc set_pos*(this: DriveInterface, vec: LVecBase3) {.importcpp: "#->set_pos(#)".} ## \
## Directly sets the driver's position.

proc set_pos*(this: DriveInterface, x: float32, y: float32, z: float32) {.importcpp: "#->set_pos(#, #, #)".}

proc set_x*(this: DriveInterface, x: float32) {.importcpp: "#->set_x(#)".}

proc set_y*(this: DriveInterface, y: float32) {.importcpp: "#->set_y(#)".}

proc set_z*(this: DriveInterface, z: float32) {.importcpp: "#->set_z(#)".}

proc get_hpr*(this: DriveInterface): LVecBase3 {.importcpp: "#->get_hpr()".} ## \
## Returns the driver's orientation.

proc get_h*(this: DriveInterface): float32 {.importcpp: "#->get_h()".}

proc get_p*(this: DriveInterface): float32 {.importcpp: "#->get_p()".}

proc get_r*(this: DriveInterface): float32 {.importcpp: "#->get_r()".}

proc set_hpr*(this: DriveInterface, hpr: LVecBase3) {.importcpp: "#->set_hpr(#)".} ## \
## Directly sets the driver's orientation.

proc set_hpr*(this: DriveInterface, h: float32, p: float32, r: float32) {.importcpp: "#->set_hpr(#, #, #)".}

proc set_h*(this: DriveInterface, h: float32) {.importcpp: "#->set_h(#)".}

proc set_p*(this: DriveInterface, p: float32) {.importcpp: "#->set_p(#)".}

proc set_r*(this: DriveInterface, r: float32) {.importcpp: "#->set_r(#)".}

proc set_force_roll*(this: DriveInterface, force_roll: float32) {.importcpp: "#->set_force_roll(#)".} ## \
## This function is no longer used and does nothing.  It will be removed soon.

proc set_ignore_mouse*(this: DriveInterface, ignore_mouse: bool) {.importcpp: "#->set_ignore_mouse(#)".} ## \
## Changes the state of the ignore_mouse flag.  If this flag is true, the
## DriveInterface will ignore mouse down button events (but still recognize
## mouse up button events); the user will not be able to start the
## DriveInterface going again if it is stopped, but if the user is currently
## holding down a mouse button it will not stop immediately until the user
## eventually releases the button.

proc get_ignore_mouse*(this: DriveInterface): bool {.importcpp: "#->get_ignore_mouse()".} ## \
## Returns the current setting of the ignore_mouse flag.  See
## set_ignore_mouse().

proc set_force_mouse*(this: DriveInterface, force_mouse: bool) {.importcpp: "#->set_force_mouse(#)".} ## \
## Changes the state of the force_mouse flag.  If this flag is true, the mouse
## button need not be held down in order to drive the avatar around.

proc get_force_mouse*(this: DriveInterface): bool {.importcpp: "#->get_force_mouse()".} ## \
## Returns the current setting of the force_mouse flag.  See
## set_force_mouse().

proc set_stop_this_frame*(this: DriveInterface, stop_this_frame: bool) {.importcpp: "#->set_stop_this_frame(#)".} ## \
## If stop_this_frame is true, the next time the frame is computed no motion
## will be allowed, and then the flag is reset to false.  This can be used to
## prevent too much movement when we know a long time has artificially
## elapsed, for instance when we take a screenshot, without munging the clock
## for everything else.

proc get_stop_this_frame*(this: DriveInterface): bool {.importcpp: "#->get_stop_this_frame()".} ## \
## Returns the current setting of the stop_this_frame flag.  See
## set_stop_this_frame().

proc set_mat*(this: DriveInterface, mat: LMatrix4) {.importcpp: "#->set_mat(#)".} ## \
## Stores the indicated transform in the DriveInterface.

proc get_mat*(this: DriveInterface): LMatrix4 {.importcpp: "#->get_mat()".} ## \
## Returns the current transform.

proc force_dgraph*(this: DriveInterface) {.importcpp: "#->force_dgraph()".} ## \
## This is a special kludge for DriveInterface to allow us to avoid the one-
## frame latency after a collision.  It forces an immediate partial data flow
## for all data graph nodes below this node, causing all data nodes that
## depend on this matrix to be updated immediately.

proc get_class_type*(_: typedesc[DriveInterface]): TypeHandle {.importcpp: "DriveInterface::get_class_type()", header: "driveInterface.h".}

proc newMouseSubregion*(param0: MouseSubregion): MouseSubregion {.importcpp: "new MouseSubregion(#)".}

proc newMouseSubregion*(name: string): MouseSubregion {.importcpp: "new MouseSubregion(nimStringToStdString(#))", header: stringConversionCode.}

proc get_left*(this: MouseSubregion): float32 {.importcpp: "#->get_left()".} ## \
## Retrieves the x coordinate of the left edge of the rectangle within the
## window.  This number will be in the range [0..1].

proc get_right*(this: MouseSubregion): float32 {.importcpp: "#->get_right()".} ## \
## Retrieves the x coordinate of the right edge of the rectangle within the
## window.  This number will be in the range [0..1].

proc get_bottom*(this: MouseSubregion): float32 {.importcpp: "#->get_bottom()".} ## \
## Retrieves the y coordinate of the bottom edge of the rectangle within the
## window.  This number will be in the range [0..1].

proc get_top*(this: MouseSubregion): float32 {.importcpp: "#->get_top()".} ## \
## Retrieves the y coordinate of the top edge of the rectangle within the
## window.  This number will be in the range [0..1].

proc set_dimensions*(this: MouseSubregion, l: float32, r: float32, b: float32, t: float32) {.importcpp: "#->set_dimensions(#, #, #, #)".} ## \
## Changes the region of the window in which the mouse is considered to be
## active.  The parameters are identical to those for a DisplayRegion: they
## range from 0 to 1, where 0,0 is the lower left corner and 1,1 is the upper
## right; (0, 1, 0, 1) represents the whole window.

proc get_class_type*(_: typedesc[MouseSubregion]): TypeHandle {.importcpp: "MouseSubregion::get_class_type()", header: "mouseSubregion.h".}

converter upcast_to_TypedWritableReferenceCount*(this: MouseWatcherRegion): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcast_to_Namable*(this: MouseWatcherRegion): Namable {.importcpp: "((Namable *)(#.p()))".}

proc newMouseWatcherRegion*(param0: MouseWatcherRegion): MouseWatcherRegion {.importcpp: "new MouseWatcherRegion(#)".}

proc newMouseWatcherRegion*(name: string, frame: LVecBase4): MouseWatcherRegion {.importcpp: "new MouseWatcherRegion(nimStringToStdString(#), #)", header: stringConversionCode.}

proc newMouseWatcherRegion*(name: string, left: float32, right: float32, bottom: float32, top: float32): MouseWatcherRegion {.importcpp: "new MouseWatcherRegion(nimStringToStdString(#), #, #, #, #)", header: stringConversionCode.}

proc set_frame*(this: MouseWatcherRegion, frame: LVecBase4) {.importcpp: "#->set_frame(#)".}

proc set_frame*(this: MouseWatcherRegion, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_frame(#, #, #, #)".}

proc get_frame*(this: MouseWatcherRegion): LVecBase4 {.importcpp: "#->get_frame()".}

proc get_area*(this: MouseWatcherRegion): float32 {.importcpp: "#->get_area()".} ## \
## Returns the area of the rectangular region.

proc set_sort*(this: MouseWatcherRegion, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Changes the sorting order of this particular region.  The sorting order is
## used to resolve conflicts in the case of overlapping region; the region
## with the highest sort value will be preferred, and between regions of the
## same sort value, the smallest region will be preferred.  The default
## sorting order, if none is explicitly specified, is 0.

proc get_sort*(this: MouseWatcherRegion): int {.importcpp: "#->get_sort()".} ## \
## Returns the current sorting order of this region.  See set_sort().

proc set_active*(this: MouseWatcherRegion, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets whether the region is active or not.  If it is not active, the
## MouseWatcher will never consider the mouse to be over the region.  The
## region might still receive keypress events if its set_keyboard() flag is
## true.

proc get_active*(this: MouseWatcherRegion): bool {.importcpp: "#->get_active()".} ## \
## Returns whether the region is active or not.  See set_active().

proc set_keyboard*(this: MouseWatcherRegion, keyboard: bool) {.importcpp: "#->set_keyboard(#)".} ## \
## Sets whether the region is interested in global keyboard events.  If this
## is true, then any keyboard button events will be passed to press() and
## release() regardless of the position of the mouse onscreen; otherwise,
## these events will only be passed if the mouse is over the region.

proc get_keyboard*(this: MouseWatcherRegion): bool {.importcpp: "#->get_keyboard()".} ## \
## Returns whether the region is interested in global keyboard events; see
## set_keyboard().

proc set_suppress_flags*(this: MouseWatcherRegion, suppress_flags: int) {.importcpp: "#->set_suppress_flags(#)".} ## \
## Sets which events are suppressed when the mouse is over the region.  This
## is the union of zero or more various SF_* values.  Normally, this is 0,
## indicating that no events are suppressed.
##
## If you set this to a non-zero value, for instance SF_mouse_position, then
## the mouse position will not be sent along the data graph when the mouse is
## over this particular region.

proc get_suppress_flags*(this: MouseWatcherRegion): int {.importcpp: "#->get_suppress_flags()".} ## \
## Returns the current suppress_flags.  See set_suppress_flags().

proc output*(this: MouseWatcherRegion, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: MouseWatcherRegion, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: MouseWatcherRegion, `out`: ostream) {.importcpp: "#->write(#)".}

proc get_class_type*(_: typedesc[MouseWatcherRegion]): TypeHandle {.importcpp: "MouseWatcherRegion::get_class_type()", header: "mouseWatcherRegion.h".}

proc add_region*(this: MouseWatcherBase, region: MouseWatcherRegion) {.importcpp: "#.add_region(#)".} ## \
## Adds the indicated region to the set of regions in the group.  It is no
## longer an error to call this for the same region more than once.

proc has_region*(this: MouseWatcherBase, region: MouseWatcherRegion): bool {.importcpp: "#.has_region(#)".} ## \
## Returns true if the indicated region has already been added to the
## MouseWatcherBase, false otherwise.

proc remove_region*(this: MouseWatcherBase, region: MouseWatcherRegion): bool {.importcpp: "#.remove_region(#)".} ## \
## Removes the indicated region from the group.  Returns true if it was
## successfully removed, or false if it wasn't there in the first place.

proc find_region*(this: MouseWatcherBase, name: string): MouseWatcherRegion {.importcpp: "#.find_region(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a pointer to the first region found with the indicated name.  If
## multiple regions share the same name, the one that is returned is
## indeterminate.

proc clear_regions*(this: MouseWatcherBase) {.importcpp: "#.clear_regions()".} ## \
## Removes all the regions from the group.

proc sort_regions*(this: MouseWatcherBase) {.importcpp: "#.sort_regions()".} ## \
## Sorts all the regions in this group into pointer order.

proc is_sorted*(this: MouseWatcherBase): bool {.importcpp: "#.is_sorted()".} ## \
## Returns true if the group has already been sorted, false otherwise.

proc get_num_regions*(this: MouseWatcherBase): clonglong {.importcpp: "#.get_num_regions()".} ## \
## Returns the number of regions in the group.

proc get_region*(this: MouseWatcherBase, n: clonglong): MouseWatcherRegion {.importcpp: "#.get_region(#)".} ## \
## Returns the nth region of the group; returns NULL if there is no nth
## region.  Note that this is not thread-safe; another thread might have
## removed the nth region before you called this method.

proc output*(this: MouseWatcherBase, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: MouseWatcherBase, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: MouseWatcherBase, `out`: ostream) {.importcpp: "#.write(#)".}

proc show_regions*(this: MouseWatcherBase, render2d: NodePath, bin_name: string, draw_order: int) {.importcpp: "#.show_regions(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Enables the visualization of all of the regions handled by this
## MouseWatcherBase.  The supplied NodePath should be the root of the 2-d
## scene graph for the window.

proc set_color*(this: MouseWatcherBase, color: LColor) {.importcpp: "#.set_color(#)".} ## \
## Specifies the color used to draw the region rectangles for the regions
## visualized by show_regions().

proc hide_regions*(this: MouseWatcherBase) {.importcpp: "#.hide_regions()".} ## \
## Stops the visualization created by a previous call to show_regions().

proc update_regions*(this: MouseWatcherBase) {.importcpp: "#.update_regions()".} ## \
## Refreshes the visualization created by show_regions().

proc get_class_type*(_: typedesc[MouseWatcherBase]): TypeHandle {.importcpp: "MouseWatcherBase::get_class_type()", header: "mouseWatcherBase.h".}

converter upcast_to_MouseWatcherBase*(this: MouseWatcherGroup): MouseWatcherBase {.importcpp: "((MouseWatcherBase *)(#.p()))".}

converter upcast_to_ReferenceCount*(this: MouseWatcherGroup): ReferenceCount {.importcpp: "(PT(ReferenceCount)(#))".}

proc get_class_type*(_: typedesc[MouseWatcherGroup]): TypeHandle {.importcpp: "MouseWatcherGroup::get_class_type()", header: "mouseWatcherGroup.h".}

converter upcast_to_DataNode*(this: MouseWatcher): DataNode {.importcpp: "(PT(DataNode)(#))".}

converter upcast_to_MouseWatcherBase*(this: MouseWatcher): MouseWatcherBase {.importcpp: "((MouseWatcherBase *)(#.p()))".}

proc newMouseWatcher*(name: string): MouseWatcher {.importcpp: "new MouseWatcher(nimStringToStdString(#))", header: stringConversionCode.}

proc newMouseWatcher*(): MouseWatcher {.importcpp: "new MouseWatcher()".}

proc remove_region*(this: MouseWatcher, region: MouseWatcherRegion): bool {.importcpp: "#->remove_region(#)".} ## \
## Removes the indicated region from the group.  Returns true if it was
## successfully removed, or false if it wasn't there in the first place.

proc has_mouse*(this: MouseWatcher): bool {.importcpp: "#->has_mouse()".} ## \
## Returns true if the mouse is anywhere within the window, false otherwise.
## Also see is_mouse_open().

proc is_mouse_open*(this: MouseWatcher): bool {.importcpp: "#->is_mouse_open()".} ## \
## Returns true if the mouse is within the window and not over some particular
## MouseWatcherRegion that is marked to suppress mouse events; that is, that
## the mouse is in open space within the window.

proc get_mouse*(this: MouseWatcher): LPoint2 {.importcpp: "#->get_mouse()".} ## \
## It is only valid to call this if has_mouse() returns true.  If so, this
## returns the current position of the mouse within the window.

proc get_mouse_x*(this: MouseWatcher): float32 {.importcpp: "#->get_mouse_x()".} ## \
## It is only valid to call this if has_mouse() returns true.  If so, this
## returns the current X position of the mouse within the window.

proc get_mouse_y*(this: MouseWatcher): float32 {.importcpp: "#->get_mouse_y()".} ## \
## It is only valid to call this if has_mouse() returns true.  If so, this
## returns the current Y position of the mouse within the window.

proc set_frame*(this: MouseWatcher, frame: LVecBase4) {.importcpp: "#->set_frame(#)".} ## \
## Sets the frame of the MouseWatcher.  This determines the coordinate space
## in which the MouseWatcherRegions should be expected to live.  Normally,
## this is left at -1, 1, -1, 1, which is the default setting, and matches the
## mouse coordinate range.
##
## Whatever values you specify here indicate the shape of the full screen, and
## the MouseWatcherRegions will be given in coordinate space matching it.  For
## instance, if you specify (0, 1, 0, 1), then a MouseWatcherRegion with the
## frame (0, 1, 0, .5) will cover the lower half of the screen.

proc set_frame*(this: MouseWatcher, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_frame(#, #, #, #)".} ## \
## Sets the frame of the MouseWatcher.  See the next flavor of this method for
## a more verbose explanation.

proc get_frame*(this: MouseWatcher): LVecBase4 {.importcpp: "#->get_frame()".} ## \
## Returns the frame of the MouseWatcher.  See set_frame().

proc is_over_region*(this: MouseWatcher): bool {.importcpp: "#->is_over_region()".} ## \
## Returns true if the mouse is over any rectangular region, false otherwise.

proc is_over_region*(this: MouseWatcher, pos: LPoint2): bool {.importcpp: "#->is_over_region(#)".} ## \
## Returns true if the mouse is over any rectangular region, false otherwise.

proc is_over_region*(this: MouseWatcher, x: float32, y: float32): bool {.importcpp: "#->is_over_region(#, #)".} ## \
## Returns true if the mouse is over any rectangular region, false otherwise.

proc get_over_region*(this: MouseWatcher): MouseWatcherRegion {.importcpp: "#->get_over_region()".} ## \
## Returns the smallest region the mouse is currently over, or NULL if it is
## over no region.

proc get_over_region*(this: MouseWatcher, pos: LPoint2): MouseWatcherRegion {.importcpp: "#->get_over_region(#)".} ## \
## Returns the preferred region the mouse is over.  In the case of overlapping
## regions, the region with the largest sort order is preferred; if two
## regions have the same sort order, then the smaller region is preferred.

proc get_over_region*(this: MouseWatcher, x: float32, y: float32): MouseWatcherRegion {.importcpp: "#->get_over_region(#, #)".} ## \
## Returns the smallest region the indicated point is over, or NULL if it is
## over no region.

proc is_button_down*(this: MouseWatcher, button: ButtonHandle): bool {.importcpp: "#->is_button_down(#)".} ## \
## Returns true if the indicated button is currently being held down, false
## otherwise.

proc set_button_down_pattern*(this: MouseWatcher, pattern: string) {.importcpp: "#->set_button_down_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the pattern string that indicates how the event names are generated
## when a button is depressed.  This is a string that may contain any of the
## following:
##
## %r  - the name of the region the mouse is over %b  - the name of the button
## pressed.
##
## The event name will be based on the in_pattern string specified here, with
## all occurrences of the above strings replaced with the corresponding
## values.

proc get_button_down_pattern*(this: MouseWatcher): string {.importcpp: "nimStringFromStdString(#->get_button_down_pattern())", header: stringConversionCode.} ## \
## Returns the string that indicates how event names are generated when a
## button is depressed.  See set_button_down_pattern().

proc set_button_up_pattern*(this: MouseWatcher, pattern: string) {.importcpp: "#->set_button_up_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the pattern string that indicates how the event names are generated
## when a button is released.  See set_button_down_pattern().

proc get_button_up_pattern*(this: MouseWatcher): string {.importcpp: "nimStringFromStdString(#->get_button_up_pattern())", header: stringConversionCode.} ## \
## Returns the string that indicates how event names are generated when a
## button is released.  See set_button_down_pattern().

proc set_button_repeat_pattern*(this: MouseWatcher, pattern: string) {.importcpp: "#->set_button_repeat_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the pattern string that indicates how the event names are generated
## when a button is continuously held and generates keyrepeat "down" events.
## This is a string that may contain any of the following:
##
## %r  - the name of the region the mouse is over %b  - the name of the button
## pressed.
##
## The event name will be based on the in_pattern string specified here, with
## all occurrences of the above strings replaced with the corresponding
## values.

proc get_button_repeat_pattern*(this: MouseWatcher): string {.importcpp: "nimStringFromStdString(#->get_button_repeat_pattern())", header: stringConversionCode.} ## \
## Returns the string that indicates how event names are names are generated
## when a button is continuously held and generates keyrepeat "down" events.
## See set_button_repeat_pattern().

proc set_enter_pattern*(this: MouseWatcher, pattern: string) {.importcpp: "#->set_enter_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the pattern string that indicates how the event names are generated
## when the mouse enters a region.  This is different from within_pattern, in
## that a mouse is only "entered" in the topmost region at a given time, while
## it might be "within" multiple nested regions.

proc get_enter_pattern*(this: MouseWatcher): string {.importcpp: "nimStringFromStdString(#->get_enter_pattern())", header: stringConversionCode.} ## \
## Returns the string that indicates how event names are generated when the
## mouse enters a region.  This is different from within_pattern, in that a
## mouse is only "entered" in the topmost region at a given time, while it
## might be "within" multiple nested regions.

proc set_leave_pattern*(this: MouseWatcher, pattern: string) {.importcpp: "#->set_leave_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the pattern string that indicates how the event names are generated
## when the mouse leaves a region.  This is different from without_pattern, in
## that a mouse is only "entered" in the topmost region at a given time, while
## it might be "within" multiple nested regions.

proc get_leave_pattern*(this: MouseWatcher): string {.importcpp: "nimStringFromStdString(#->get_leave_pattern())", header: stringConversionCode.} ## \
## Returns the string that indicates how event names are generated when the
## mouse leaves a region.  This is different from without_pattern, in that a
## mouse is only "entered" in the topmost region at a given time, while it
## might be "within" multiple nested regions.

proc set_within_pattern*(this: MouseWatcher, pattern: string) {.importcpp: "#->set_within_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the pattern string that indicates how the event names are generated
## when the mouse wanders over a region.  This is different from
## enter_pattern, in that a mouse is only "entered" in the topmost region at a
## given time, while it might be "within" multiple nested regions.

proc get_within_pattern*(this: MouseWatcher): string {.importcpp: "nimStringFromStdString(#->get_within_pattern())", header: stringConversionCode.} ## \
## Returns the string that indicates how event names are generated when the
## mouse wanders over a region.  This is different from enter_pattern, in that
## a mouse is only "entered" in the topmost region at a given time, while it
## might be "within" multiple nested regions.

proc set_without_pattern*(this: MouseWatcher, pattern: string) {.importcpp: "#->set_without_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the pattern string that indicates how the event names are generated
## when the mouse wanders out of a region.  This is different from
## leave_pattern, in that a mouse is only "entered" in the topmost region at a
## given time, while it might be "within" multiple nested regions.

proc get_without_pattern*(this: MouseWatcher): string {.importcpp: "nimStringFromStdString(#->get_without_pattern())", header: stringConversionCode.} ## \
## Returns the string that indicates how event names are generated when the
## mouse wanders out of a region.  This is different from leave_pattern, in
## that a mouse is only "entered" in the topmost region at a given time, while
## it might be "within" multiple nested regions.

proc set_geometry*(this: MouseWatcher, node: PandaNode) {.importcpp: "#->set_geometry(#)".} ## \
## Sets the node that will be transformed each frame by the mouse's
## coordinates.  It will also be hidden when the mouse goes outside the
## window.  This can be used to implement a software mouse pointer for when a
## hardware (or system) mouse pointer is unavailable.

proc has_geometry*(this: MouseWatcher): bool {.importcpp: "#->has_geometry()".} ## \
## Returns true if a software mouse pointer has been setup via set_geometry(),
## or false otherwise.  See set_geometry().

proc get_geometry*(this: MouseWatcher): PandaNode {.importcpp: "#->get_geometry()".} ## \
## Returns the node that has been set as the software mouse pointer, or NULL
## if no node has been set.  See has_geometry() and set_geometry().

proc clear_geometry*(this: MouseWatcher) {.importcpp: "#->clear_geometry()".} ## \
## Stops the use of the software cursor set up via set_geometry().

proc set_extra_handler*(this: MouseWatcher, eh: EventHandler) {.importcpp: "#->set_extra_handler(#)".} ## \
## As an optimization for the C++ Gui, an extra handler can be registered with
## a mouseWatcher so that events can be dealt with much sooner.

proc get_extra_handler*(this: MouseWatcher): EventHandler {.importcpp: "#->get_extra_handler()".} ## \
## As an optimization for the C++ Gui, an extra handler can be registered with
## a mouseWatcher so that events can be dealt with much sooner.

proc set_modifier_buttons*(this: MouseWatcher, mods: ModifierButtons) {.importcpp: "#->set_modifier_buttons(#)".} ## \
## Sets the buttons that should be monitored as modifier buttons for
## generating events to the MouseWatcherRegions.

proc get_modifier_buttons*(this: MouseWatcher): ModifierButtons {.importcpp: "#->get_modifier_buttons()".} ## \
## Returns the set of buttons that are being monitored as modifier buttons, as
## well as their current state.

proc set_display_region*(this: MouseWatcher, dr: DisplayRegion) {.importcpp: "#->set_display_region(#)".} ## \
## Constrains the MouseWatcher to watching the mouse within a particular
## indicated region of the screen.  DataNodes parented under the MouseWatcher
## will observe the mouse and keyboard events only when the mouse is within
## the indicated region, and the observed range will be from -1 .. 1 across
## the region.
##
## Do not delete the DisplayRegion while it is owned by the MouseWatcher.

proc clear_display_region*(this: MouseWatcher) {.importcpp: "#->clear_display_region()".} ## \
## Removes the display region constraint from the MouseWatcher, and restores
## it to the default behavior of watching the whole window.

proc get_display_region*(this: MouseWatcher): DisplayRegion {.importcpp: "#->get_display_region()".} ## \
## Returns the display region the MouseWatcher is constrained to by
## set_display_region(), or NULL if it is not constrained.

proc has_display_region*(this: MouseWatcher): bool {.importcpp: "#->has_display_region()".} ## \
## Returns true if the MouseWatcher has been constrained to a particular
## region of the screen via set_display_region(), or false otherwise.  If this
## returns true, get_display_region() may be used to return the particular
## region.

proc add_group*(this: MouseWatcher, group: MouseWatcherGroup): bool {.importcpp: "#->add_group(#)".} ## \
## Adds the indicated group of regions to the set of regions the MouseWatcher
## will monitor each frame.
##
## Since the MouseWatcher itself inherits from MouseWatcherBase, this
## operation is normally not necessary--you can simply add the Regions you
## care about one at a time.  Adding a complete group is useful when you may
## want to explicitly remove the regions as a group later.
##
## Returns true if the group was successfully added, or false if it was
## already on the list.

proc remove_group*(this: MouseWatcher, group: MouseWatcherGroup): bool {.importcpp: "#->remove_group(#)".} ## \
## Removes the indicated group from the set of extra groups associated with
## the MouseWatcher.  Returns true if successful, or false if the group was
## already removed or was never added via add_group().

proc replace_group*(this: MouseWatcher, old_group: MouseWatcherGroup, new_group: MouseWatcherGroup): bool {.importcpp: "#->replace_group(#, #)".} ## \
## Atomically removes old_group from the MouseWatcher, and replaces it with
## new_group.  Presumably old_group and new_group might have some regions in
## common; these are handled properly.
##
## If old_group is not already present, simply adds new_group and returns
## false.  Otherwise, removes old_group and adds new_group, and then returns
## true.

proc get_num_groups*(this: MouseWatcher): int {.importcpp: "#->get_num_groups()".} ## \
## Returns the number of separate groups added to the MouseWatcher via
## add_group().

proc get_group*(this: MouseWatcher, n: int): MouseWatcherGroup {.importcpp: "#->get_group(#)".} ## \
## Returns the nth group added to the MouseWatcher via add_group().

proc set_inactivity_timeout*(this: MouseWatcher, timeout: float64) {.importcpp: "#->set_inactivity_timeout(#)".} ## \
## Sets an inactivity timeout on the mouse activity.  When this timeout (in
## seconds) is exceeded with no keyboard or mouse activity, all currently-held
## buttons are automatically released.  This is intended to help protect
## against people who inadvertently (or intentionally) leave a keyboard key
## stuck down and then wander away from the keyboard.
##
## Also, when this timeout expires, the event specified by
## set_inactivity_timeout_event() will be generated.

proc has_inactivity_timeout*(this: MouseWatcher): bool {.importcpp: "#->has_inactivity_timeout()".} ## \
## Returns true if an inactivity timeout has been set, false otherwise.

proc get_inactivity_timeout*(this: MouseWatcher): float64 {.importcpp: "#->get_inactivity_timeout()".} ## \
## Returns the inactivity timeout that has been set.  It is an error to call
## this if has_inactivity_timeout() returns false.

proc clear_inactivity_timeout*(this: MouseWatcher) {.importcpp: "#->clear_inactivity_timeout()".} ## \
## Removes the inactivity timeout and restores the MouseWatcher to its default
## behavior of allowing a key to be held indefinitely.

proc set_inactivity_timeout_event*(this: MouseWatcher, event: string) {.importcpp: "#->set_inactivity_timeout_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the event string that will be generated when the inactivity
## timeout counter expires.  See set_inactivity_timeout().

proc get_inactivity_timeout_event*(this: MouseWatcher): string {.importcpp: "nimStringFromStdString(#->get_inactivity_timeout_event())", header: stringConversionCode.} ## \
## Returns the event string that will be generated when the inactivity timeout
## counter expires.  See set_inactivity_timeout().

proc get_trail_log*(this: MouseWatcher): PointerEventList {.importcpp: "#->get_trail_log()".} ## \
## Obtain the mouse trail log.  This is a PointerEventList.  Does not make a
## copy, therefore, this PointerEventList will be updated each time
## process_events gets called.
##
## To use trail logging, you need to enable the generation of pointer events
## in the GraphicsWindowInputDevice and set the trail log duration in the
## MouseWatcher.  Otherwise, the trail log will be empty.

proc num_trail_recent*(this: MouseWatcher): clonglong {.importcpp: "#->num_trail_recent()".} ## \
## This counter indicates how many events were added to the trail log this
## frame.  The trail log is updated once per frame, during the process_events
## operation.

proc set_trail_log_duration*(this: MouseWatcher, duration: float64) {.importcpp: "#->set_trail_log_duration(#)".} ## \
## If the duration is nonzero, causes the MouseWatcher to log the mouse's
## trail.  Events older than the specified duration are discarded.  If the
## duration is zero, logging is disabled.

proc get_trail_node*(this: MouseWatcher): GeomNode {.importcpp: "#->get_trail_node()".} ## \
## Returns a GeomNode that represents the mouse trail.  The intent is that you
## should reparent this GeomNode to Render2D, and then forget about it.  The
## MouseWatcher will continually update the trail node.  There is only one
## trail node, it does not create a new one each time you call get_trail_node.
##
## This is not a particularly beautiful way to render a mouse trail.  It is
## intended more for debugging purposes than for finished applications.  Even
## so, It is suggested that you might want to apply a line thickness and
## antialias mode to the line --- doing so makes it look a lot better.

proc clear_trail_node*(this: MouseWatcher) {.importcpp: "#->clear_trail_node()".} ## \
## If you have previously fetched the trail node using get_trail_node, then
## the MouseWatcher is continually updating the trail node every frame.  Using
## clear_trail_node causes the MouseWatcher to forget the trail node and stop
## updating it.

proc clear_trail_log*(this: MouseWatcher) {.importcpp: "#->clear_trail_log()".} ## \
## Clears the mouse trail log.  This does not prevent further accumulation of
## the log given future events.

proc note_activity*(this: MouseWatcher) {.importcpp: "#->note_activity()".} ## \
## Can be used in conjunction with the inactivity timeout to inform the
## MouseWatcher that the user has just performed some action which proves
## he/she is present.  It may be necessary to call this for external events,
## such as joystick action, that the MouseWatcher might otherwise not know
## about.  This will reset the current inactivity timer.  When the inactivity
## timer reaches the length of time specified by set_inactivity_timeout(),
## with no keyboard or mouse activity and no calls to note_activity(), then
## any buttons held will be automatically released.

proc get_class_type*(_: typedesc[MouseWatcher]): TypeHandle {.importcpp: "MouseWatcher::get_class_type()", header: "mouseWatcher.h".}

proc has_button*(this: MouseWatcherParameter): bool {.importcpp: "#.has_button()".} ## \
## Returns true if this parameter has an associated mouse or keyboard button,
## false otherwise.

proc get_button*(this: MouseWatcherParameter): ButtonHandle {.importcpp: "#.get_button()".} ## \
## Returns the mouse or keyboard button associated with this event.  If
## has_button(), above, returns false, this returns ButtonHandle::none().

proc is_keyrepeat*(this: MouseWatcherParameter): bool {.importcpp: "#.is_keyrepeat()".} ## \
## Returns true if the button-down even was generated due to keyrepeat, or
## false if it was an original button down.

proc has_keycode*(this: MouseWatcherParameter): bool {.importcpp: "#.has_keycode()".} ## \
## Returns true if this parameter has an associated keycode, false otherwise.

proc get_keycode*(this: MouseWatcherParameter): int {.importcpp: "#.get_keycode()".} ## \
## Returns the keycode associated with this event.  If has_keycode(), above,
## returns false, this returns 0.

proc has_candidate*(this: MouseWatcherParameter): bool {.importcpp: "#.has_candidate()".} ## \
## Returns true if this parameter has an associated candidate string, false
## otherwise.

proc get_candidate_string_encoded*(this: MouseWatcherParameter): string {.importcpp: "nimStringFromStdString(#.get_candidate_string_encoded())", header: stringConversionCode.} ## \
## Returns the candidate string associated with this event.  If
## has_candidate(), above, returns false, this returns the empty string.

proc get_highlight_start*(this: MouseWatcherParameter): clonglong {.importcpp: "#.get_highlight_start()".} ## \
## Returns the first highlighted character in the candidate string.

proc get_highlight_end*(this: MouseWatcherParameter): clonglong {.importcpp: "#.get_highlight_end()".} ## \
## Returns one more than the last highlighted character in the candidate
## string.

proc get_cursor_pos*(this: MouseWatcherParameter): clonglong {.importcpp: "#.get_cursor_pos()".} ## \
## Returns the position of the user's edit cursor within the candidate string.

proc get_modifier_buttons*(this: MouseWatcherParameter): ModifierButtons {.importcpp: "#.get_modifier_buttons()".} ## \
## Returns the set of modifier buttons that were being held down while the
## event was generated.

proc has_mouse*(this: MouseWatcherParameter): bool {.importcpp: "#.has_mouse()".} ## \
## Returns true if this parameter has an associated mouse position, false
## otherwise.

proc get_mouse*(this: MouseWatcherParameter): LPoint2 {.importcpp: "#.get_mouse()".} ## \
## Returns the mouse position at the time the event was generated, in the
## normalized range (-1 .. 1).  It is valid to call this only if has_mouse()
## returned true.

proc is_outside*(this: MouseWatcherParameter): bool {.importcpp: "#.is_outside()".} ## \
## Returns true if the mouse was outside the region at the time the event was
## generated, false otherwise.  This is only valid for "release" type events.

proc output*(this: MouseWatcherParameter, `out`: ostream) {.importcpp: "#.output(#)".}

proc newTrackball*(param0: Trackball): Trackball {.importcpp: "new Trackball(#)".}

proc newTrackball*(name: string): Trackball {.importcpp: "new Trackball(nimStringToStdString(#))", header: stringConversionCode.}

proc reset*(this: Trackball) {.importcpp: "#->reset()".} ## \
## Reinitializes all transforms to identity.

proc get_forward_scale*(this: Trackball): float32 {.importcpp: "#->get_forward_scale()".} ## \
## Returns the scale factor applied to forward and backward motion.  See
## set_forward_scale().

proc set_forward_scale*(this: Trackball, fwdscale: float32) {.importcpp: "#->set_forward_scale(#)".} ## \
## Changes the scale factor applied to forward and backward motion.  The
## larger this number, the faster the model will move in response to dollying
## in and out.

proc get_pos*(this: Trackball): LPoint3 {.importcpp: "#->get_pos()".} ## \
## Return the offset from the center of rotation.

proc get_x*(this: Trackball): float32 {.importcpp: "#->get_x()".}

proc get_y*(this: Trackball): float32 {.importcpp: "#->get_y()".}

proc get_z*(this: Trackball): float32 {.importcpp: "#->get_z()".}

proc set_pos*(this: Trackball, vec: LVecBase3) {.importcpp: "#->set_pos(#)".} ## \
## Directly set the offset from the rotational origin.

proc set_pos*(this: Trackball, x: float32, y: float32, z: float32) {.importcpp: "#->set_pos(#, #, #)".}

proc set_x*(this: Trackball, x: float32) {.importcpp: "#->set_x(#)".}

proc set_y*(this: Trackball, y: float32) {.importcpp: "#->set_y(#)".}

proc set_z*(this: Trackball, z: float32) {.importcpp: "#->set_z(#)".}

proc get_hpr*(this: Trackball): LVecBase3 {.importcpp: "#->get_hpr()".} ## \
## Return the trackball's orientation.

proc get_h*(this: Trackball): float32 {.importcpp: "#->get_h()".}

proc get_p*(this: Trackball): float32 {.importcpp: "#->get_p()".}

proc get_r*(this: Trackball): float32 {.importcpp: "#->get_r()".}

proc set_hpr*(this: Trackball, hpr: LVecBase3) {.importcpp: "#->set_hpr(#)".} ## \
## Directly set the mover's orientation.

proc set_hpr*(this: Trackball, h: float32, p: float32, r: float32) {.importcpp: "#->set_hpr(#, #, #)".}

proc set_h*(this: Trackball, h: float32) {.importcpp: "#->set_h(#)".}

proc set_p*(this: Trackball, p: float32) {.importcpp: "#->set_p(#)".}

proc set_r*(this: Trackball, r: float32) {.importcpp: "#->set_r(#)".}

proc reset_origin_here*(this: Trackball) {.importcpp: "#->reset_origin_here()".} ## \
## Reposition the center of rotation to coincide with the current translation
## offset.  Future rotations will be about the current origin.

proc move_origin*(this: Trackball, x: float32, y: float32, z: float32) {.importcpp: "#->move_origin(#, #, #)".} ## \
## Moves the center of rotation by the given amount.

proc get_origin*(this: Trackball): LPoint3 {.importcpp: "#->get_origin()".} ## \
## Returns the current center of rotation.

proc set_origin*(this: Trackball, origin: LVecBase3) {.importcpp: "#->set_origin(#)".} ## \
## Directly sets the center of rotation.

proc set_invert*(this: Trackball, flag: bool) {.importcpp: "#->set_invert(#)".} ## \
## Sets the invert flag.  When this is set, the inverse matrix is generated,
## suitable for joining to a camera, instead of parenting the scene under it.

proc get_invert*(this: Trackball): bool {.importcpp: "#->get_invert()".} ## \
## Returns the invert flag.  When this is set, the inverse matrix is
## generated, suitable for joining to a camera, instead of parenting the scene
## under it.

proc set_rel_to*(this: Trackball, rel_to: NodePath) {.importcpp: "#->set_rel_to(#)".} ## \
## Sets the NodePath that all trackball manipulations are to be assumed to be
## relative to.  For instance, set your camera node here to make the trackball
## motion camera relative.  The default is the empty path, which means
## trackball motion is in global space.

proc get_rel_to*(this: Trackball): NodePath {.importcpp: "#->get_rel_to()".} ## \
## Returns the NodePath that all trackball manipulations are relative to, or
## the empty path.

proc set_coordinate_system*(this: Trackball, cs: CoordinateSystem) {.importcpp: "#->set_coordinate_system(#)".} ## \
## Sets the coordinate system of the Trackball.  Normally, this is the default
## coordinate system.  This changes the axes the Trackball manipulates so that
## the user interface remains consistent across different coordinate systems.

proc get_coordinate_system*(this: Trackball): CoordinateSystem {.importcpp: "#->get_coordinate_system()".} ## \
## Returns the coordinate system of the Trackball.  See
## set_coordinate_system().

proc set_mat*(this: Trackball, mat: LMatrix4) {.importcpp: "#->set_mat(#)".} ## \
## Stores the indicated transform in the trackball.  This is a transform in
## global space, regardless of the rel_to node.

proc get_mat*(this: Trackball): LMatrix4 {.importcpp: "#->get_mat()".} ## \
## Returns the matrix represented by the trackball rotation.

proc get_trans_mat*(this: Trackball): LMatrix4 {.importcpp: "#->get_trans_mat()".} ## \
## Returns the actual transform that will be applied to the scene graph.  This
## is the same as get_mat(), unless invert is in effect.

proc get_class_type*(_: typedesc[Trackball]): TypeHandle {.importcpp: "Trackball::get_class_type()", header: "trackball.h".}

proc newTransform2SG*(param0: Transform2SG): Transform2SG {.importcpp: "new Transform2SG(#)".}

proc newTransform2SG*(name: string): Transform2SG {.importcpp: "new Transform2SG(nimStringToStdString(#))", header: stringConversionCode.}

proc set_node*(this: Transform2SG, node: PandaNode) {.importcpp: "#->set_node(#)".} ## \
## Sets the node that this object will adjust.

proc get_node*(this: Transform2SG): PandaNode {.importcpp: "#->get_node()".} ## \
## Returns the node that this object will adjust, or NULL if the node has not
## yet been set.

proc get_class_type*(_: typedesc[Transform2SG]): TypeHandle {.importcpp: "Transform2SG::get_class_type()", header: "transform2SG.h".}

proc play*(this: AnimInterface) {.importcpp: "#->play()".} ## \
## Runs the entire animation from beginning to end and stops.

proc play*(this: AnimInterface, `from`: float64, to: float64) {.importcpp: "#->play(#, #)".} ## \
## Runs the animation from the frame "from" to and including the frame "to",
## at which point the animation is stopped.  Both "from" and "to" frame
## numbers may be outside the range (0, get_num_frames()) and the animation
## will follow the range correctly, reporting numbers modulo get_num_frames().
## For instance, play(0, get_num_frames() * 2) will play the animation twice
## and then stop.

proc loop*(this: AnimInterface, restart: bool) {.importcpp: "#->loop(#)".} ## \
## Starts the entire animation looping.  If restart is true, the animation is
## restarted from the beginning; otherwise, it continues from the current
## frame.

proc loop*(this: AnimInterface, restart: bool, `from`: float64, to: float64) {.importcpp: "#->loop(#, #, #)".} ## \
## Loops the animation from the frame "from" to and including the frame "to",
## indefinitely.  If restart is true, the animation is restarted from the
## beginning; otherwise, it continues from the current frame.

proc pingpong*(this: AnimInterface, restart: bool) {.importcpp: "#->pingpong(#)".} ## \
## Starts the entire animation bouncing back and forth between its first frame
## and last frame.  If restart is true, the animation is restarted from the
## beginning; otherwise, it continues from the current frame.

proc pingpong*(this: AnimInterface, restart: bool, `from`: float64, to: float64) {.importcpp: "#->pingpong(#, #, #)".} ## \
## Loops the animation from the frame "from" to and including the frame "to",
## and then back in the opposite direction, indefinitely.

proc stop*(this: AnimInterface) {.importcpp: "#->stop()".} ## \
## Stops a currently playing or looping animation right where it is.  The
## animation remains posed at the current frame.

proc pose*(this: AnimInterface, frame: float64) {.importcpp: "#->pose(#)".} ## \
## Sets the animation to the indicated frame and holds it there.

proc set_play_rate*(this: AnimInterface, play_rate: float64) {.importcpp: "#->set_play_rate(#)".} ## \
## Changes the rate at which the animation plays.  1.0 is the normal speed,
## 2.0 is twice normal speed, and 0.5 is half normal speed.  0.0 is legal to
## pause the animation, and a negative value will play the animation
## backwards.

proc get_play_rate*(this: AnimInterface): float64 {.importcpp: "#->get_play_rate()".} ## \
## Returns the rate at which the animation plays.  See set_play_rate().

proc get_frame_rate*(this: AnimInterface): float64 {.importcpp: "#->get_frame_rate()".} ## \
## Returns the native frame rate of the animation.  This is the number of
## frames per second that will elapse when the play_rate is set to 1.0.  It is
## a fixed property of the animation and may not be adjusted by the user.

proc get_num_frames*(this: AnimInterface): int {.importcpp: "#->get_num_frames()".} ## \
## Returns the number of frames in the animation.  This is a property of the
## animation and may not be directly adjusted by the user (although it may
## change without warning with certain kinds of animations, since this is a
## virtual method that may be overridden).

proc get_frame*(this: AnimInterface): int {.importcpp: "#->get_frame()".} ## \
## Returns the current integer frame number.  This number will be in the range
## 0 <= f < get_num_frames().

proc get_next_frame*(this: AnimInterface): int {.importcpp: "#->get_next_frame()".} ## \
## Returns the current integer frame number + 1, constrained to the range 0 <=
## f < get_num_frames().
##
## If the play mode is PM_play, this will clamp to the same value as
## get_frame() at the end of the animation.  If the play mode is any other
## value, this will wrap around to frame 0 at the end of the animation.

proc get_frac*(this: AnimInterface): float64 {.importcpp: "#->get_frac()".} ## \
## Returns the fractional part of the current frame.  Normally, this is in the
## range 0.0 <= f < 1.0, but in the one special case of an animation playing
## to its end frame and stopping, it might exactly equal 1.0.
##
## It will always be true that get_full_frame() + get_frac() ==
## get_full_fframe().

proc get_full_frame*(this: AnimInterface): int {.importcpp: "#->get_full_frame()".} ## \
## Returns the current integer frame number.
##
## Unlike the value returned by get_frame(), this frame number may extend
## beyond the range of get_num_frames() if the frame range passed to play(),
## loop(), etc.  did.
##
## Unlike the value returned by get_full_fframe(), this return value will
## never exceed the value passed to to_frame in the play() method.

proc get_full_fframe*(this: AnimInterface): float64 {.importcpp: "#->get_full_fframe()".} ## \
## Returns the current floating-point frame number.
##
## Unlike the value returned by get_frame(), this frame number may extend
## beyond the range of get_num_frames() if the frame range passed to play(),
## loop(), etc.  did.
##
## Unlike the value returned by get_full_frame(), this return value may equal
## (to_frame + 1.0), when the animation has played to its natural end.
## However, in this case the return value of get_full_frame() will be
## to_frame, not (to_frame + 1).

proc is_playing*(this: AnimInterface): bool {.importcpp: "#->is_playing()".} ## \
## Returns true if the animation is currently playing, false if it is stopped
## (e.g.  because stop() or pose() was called, or because it reached the end
## of the animation after play() was called).

proc output*(this: AnimInterface, `out`: ostream) {.importcpp: "#->output(#)".}

proc get_class_type*(_: typedesc[AnimInterface]): TypeHandle {.importcpp: "AnimInterface::get_class_type()", header: "animInterface.h".}

proc initUpdateSeq*(): UpdateSeq {.importcpp: "UpdateSeq()".} ## \
## Creates an UpdateSeq in the 'initial' state.

proc initUpdateSeq*(copy: UpdateSeq): UpdateSeq {.importcpp: "UpdateSeq(#)".}

proc initial*(_: typedesc[UpdateSeq]): UpdateSeq {.importcpp: "UpdateSeq::initial()", header: "updateSeq.h".}

proc old*(_: typedesc[UpdateSeq]): UpdateSeq {.importcpp: "UpdateSeq::old()", header: "updateSeq.h".}

proc fresh*(_: typedesc[UpdateSeq]): UpdateSeq {.importcpp: "UpdateSeq::fresh()", header: "updateSeq.h".}

proc clear*(this: UpdateSeq) {.importcpp: "#.clear()".} ## \
## Resets the UpdateSeq to the 'initial' state.

proc is_initial*(this: UpdateSeq): bool {.importcpp: "#.is_initial()".} ## \
## Returns true if the UpdateSeq is in the 'initial' state.

proc is_old*(this: UpdateSeq): bool {.importcpp: "#.is_old()".} ## \
## Returns true if the UpdateSeq is in the 'old' state.

proc is_fresh*(this: UpdateSeq): bool {.importcpp: "#.is_fresh()".} ## \
## Returns true if the UpdateSeq is in the 'fresh' state.

proc is_special*(this: UpdateSeq): bool {.importcpp: "#.is_special()".} ## \
## Returns true if the UpdateSeq is in any special states, i.e.  'initial',
## 'old', or 'fresh'.

proc `==`*(this: UpdateSeq, other: UpdateSeq): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: UpdateSeq, other: UpdateSeq): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: UpdateSeq, other: UpdateSeq): bool {.importcpp: "#.operator <(#)".}

proc `<=`*(this: UpdateSeq, other: UpdateSeq): bool {.importcpp: "#.operator <=(#)".}

proc `>`*(this: UpdateSeq, other: UpdateSeq): bool {.importcpp: "#.operator >(#)".}

proc `>=`*(this: UpdateSeq, other: UpdateSeq): bool {.importcpp: "#.operator >=(#)".}

proc `++`*(this: UpdateSeq): UpdateSeq {.importcpp: "#.operator ++()".}

proc `++`*(this: UpdateSeq, param0: int): UpdateSeq {.importcpp: "#.operator ++(#)".}

proc get_seq*(this: UpdateSeq): int {.importcpp: "#.get_seq()".} ## \
## Returns the internal integer value associated with the UpdateSeq.  Useful
## for debugging only.

proc output*(this: UpdateSeq, `out`: ostream) {.importcpp: "#.output(#)".}

proc fillin*(this: TypedWritable, scan: DatagramIterator, manager: BamReader) {.importcpp: "#.fillin(#, #)".} ## \
## This internal function is intended to be called by each class's
## make_from_bam() method to read in all of the relevant data from the BamFile
## for the new object.  It is also called directly by the BamReader to re-read
## the data for an object that has been placed on the stream for an update.

proc mark_bam_modified*(this: TypedWritable) {.importcpp: "#.mark_bam_modified()".} ## \
## Increments the bam_modified counter, so that this object will be
## invalidated and retransmitted on any open bam streams.  This should
## normally not need to be called by user code; it should be called internally
## when the object has been changed in a way that legitimately requires its
## retransmission to any connected clients.

proc get_bam_modified*(this: TypedWritable): UpdateSeq {.importcpp: "#.get_bam_modified()".} ## \
## Returns the current bam_modified counter.  This counter is normally
## incremented automatically whenever the object is modified.

proc get_class_type*(_: typedesc[TypedWritable]): TypeHandle {.importcpp: "TypedWritable::get_class_type()", header: "typedWritable.h".}

converter upcast_to_TypedWritable*(this: TypedWritableReferenceCount): TypedWritable {.importcpp: "((TypedWritable *)(#.p()))".}

converter upcast_to_ReferenceCount*(this: TypedWritableReferenceCount): ReferenceCount {.importcpp: "(PT(ReferenceCount)(#))".}

proc get_class_type*(_: typedesc[TypedWritableReferenceCount]): TypeHandle {.importcpp: "TypedWritableReferenceCount::get_class_type()", header: "typedWritableReferenceCount.h".}

converter upcast_to_TypedWritableReferenceCount*(this: BamCacheRecord): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

proc make_copy*(this: BamCacheRecord): BamCacheRecord {.importcpp: "#->make_copy()".} ## \
## Returns a duplicate of the BamCacheRecord.  The duplicate will not have a
## data pointer set, even though one may have been assigned to the original
## via set_data().

proc `==`*(this: BamCacheRecord, other: BamCacheRecord): bool {.importcpp: "#->operator ==(#)".}

proc get_source_pathname*(this: BamCacheRecord): Filename {.importcpp: "#->get_source_pathname()".} ## \
## Returns the full pathname to the source file that originally generated this
## cache request.  In some cases, for instance in the case of a of a multipage
## texture like "cube_#.png", this may not not a true filename on disk.

proc get_cache_filename*(this: BamCacheRecord): Filename {.importcpp: "#->get_cache_filename()".} ## \
## Returns the name of the cache file as hashed from the source_pathname.
## This will be relative to the root of the cache directory, and it will not
## include any suffixes that may be appended to resolve hash conflicts.

proc get_source_timestamp*(this: BamCacheRecord): int {.importcpp: "#->get_source_timestamp()".} ## \
## Returns the file timestamp of the original source file that generated this
## cache record, if available.  In some cases the original file timestamp is
## not available, and this will return 0.

proc get_recorded_time*(this: BamCacheRecord): int {.importcpp: "#->get_recorded_time()".} ## \
## Returns the time at which this particular record was recorded or updated.

proc get_num_dependent_files*(this: BamCacheRecord): int {.importcpp: "#->get_num_dependent_files()".} ## \
## Returns the number of source files that contribute to the cache.

proc get_dependent_pathname*(this: BamCacheRecord, n: int): Filename {.importcpp: "#->get_dependent_pathname(#)".} ## \
## Returns the full pathname of the nth source files that contributes to the
## cache.

proc dependents_unchanged*(this: BamCacheRecord): bool {.importcpp: "#->dependents_unchanged()".} ## \
## Returns true if all of the dependent files are still the same as when the
## cache was recorded, false otherwise.

proc clear_dependent_files*(this: BamCacheRecord) {.importcpp: "#->clear_dependent_files()".} ## \
## Empties the list of files that contribute to the data in this record.

proc add_dependent_file*(this: BamCacheRecord, pathname: Filename) {.importcpp: "#->add_dependent_file(#)".} ## \
## Adds the indicated file to the list of files that will be loaded to
## generate the data in this record.  This should be called once for the
## primary source file, and again for each secondary source file, if any.

proc add_dependent_file*(this: BamCacheRecord, file: VirtualFile) {.importcpp: "#->add_dependent_file(#)".} ## \
## Variant of add_dependent_file that takes an already opened VirtualFile.

proc has_data*(this: BamCacheRecord): bool {.importcpp: "#->has_data()".} ## \
## Returns true if this cache record has an in-memory data object associated--
## that is, the object stored in the cache.

proc clear_data*(this: BamCacheRecord) {.importcpp: "#->clear_data()".} ## \
## Removes the in-memory data object associated with this record, if any.
## This does not affect the on-disk representation of the record.

proc get_data*(this: BamCacheRecord): TypedWritable {.importcpp: "#->get_data()".} ## \
## Returns a pointer to the data stored in the record, or NULL if there is no
## data.  The pointer is not removed from the record.

proc set_data*(this: BamCacheRecord, `ptr`: TypedWritable) {.importcpp: "#->set_data(#)".} ## \
## This variant on set_data() is provided to easily pass objects deriving from
## TypedWritable.

proc set_data*(this: BamCacheRecord, `ptr`: TypedWritable, ref_ptr: ReferenceCount) {.importcpp: "#->set_data(#, #)".} ## \
## Stores a new data object on the record.  You should pass the same pointer
## twice, to both parameters; this allows the C++ typecasting to automatically
## convert the pointer into both a TypedWritable and a ReferenceCount pointer,
## so that the BamCacheRecord object can reliably manage the reference counts.
##
## You may pass 0 or NULL as the second parameter.  If you do this, the
## BamCacheRecord will not manage the object's reference count; it will be up
## to you to ensure the object is not deleted during the lifetime of the
## BamCacheRecord object.

proc set_data*(this: BamCacheRecord, `ptr`: TypedWritable, dummy: int) {.importcpp: "#->set_data(#, #)".} ## \
## This variant on set_data() is provided just to allow Python code to pass a
## 0 as the second parameter.

proc set_data*(this: BamCacheRecord, `ptr`: TypedWritableReferenceCount) {.importcpp: "#->set_data(#)".} ## \
## This variant on set_data() is provided to easily pass objects deriving from
## TypedWritableReferenceCount.

proc output*(this: BamCacheRecord, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: BamCacheRecord, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: BamCacheRecord, `out`: ostream) {.importcpp: "#->write(#)".}

proc get_class_type*(_: typedesc[BamCacheRecord]): TypeHandle {.importcpp: "BamCacheRecord::get_class_type()", header: "bamCacheRecord.h".}

proc initBamCache*(): BamCache {.importcpp: "BamCache()".}

proc set_active*(this: BamCache, flag: bool) {.importcpp: "#.set_active(#)".} ## \
## Changes the state of the active flag.  "active" means that the cache should
## be consulted automatically on loads, "not active" means that objects should
## be loaded directly without consulting the cache.
##
## This represents the global flag.  Also see the individual cache_models,
## cache_textures, cache_compressed_textures flags.

proc get_active*(this: BamCache): bool {.importcpp: "#.get_active()".} ## \
## Returns true if the BamCache is currently active, false if it is not.
## "active" means that the cache should be consulted automatically on loads,
## "not active" means that objects should be loaded directly without
## consulting the cache.
##
## This represents the global flag.  Also see the individual cache_models,
## cache_textures, cache_compressed_textures flags.

proc set_cache_models*(this: BamCache, flag: bool) {.importcpp: "#.set_cache_models(#)".} ## \
## Indicates whether model files (e.g.  egg files and bam files) will be
## stored in the cache, as bam files.

proc get_cache_models*(this: BamCache): bool {.importcpp: "#.get_cache_models()".} ## \
## Returns whether model files (e.g.  egg files and bam files) will be stored
## in the cache, as bam files.
##
## This also returns false if get_active() is false.

proc set_cache_textures*(this: BamCache, flag: bool) {.importcpp: "#.set_cache_textures(#)".} ## \
## Indicates whether texture files will be stored in the cache, as
## uncompressed txo files.

proc get_cache_textures*(this: BamCache): bool {.importcpp: "#.get_cache_textures()".} ## \
## Returns whether texture files (e.g.  egg files and bam files) will be
## stored in the cache, as txo files.
##
## This also returns false if get_active() is false.

proc set_cache_compressed_textures*(this: BamCache, flag: bool) {.importcpp: "#.set_cache_compressed_textures(#)".} ## \
## Indicates whether compressed texture files will be stored in the cache, as
## compressed txo files.  The compressed data may either be generated in-CPU,
## via the squish library, or it may be extracted from the GSG after the
## texture has been loaded.
##
## This may be set in conjunction with set_cache_textures(), or independently
## of it.  If set_cache_textures() is true and this is false, all textures
## will be cached in their uncompressed form.  If set_cache_textures() is
## false and this is true, only compressed textures will be cached, and they
## will be cached in their compressed form.  If both are true, all textures
## will be cached, in their uncompressed or compressed form appropriately.

proc get_cache_compressed_textures*(this: BamCache): bool {.importcpp: "#.get_cache_compressed_textures()".} ## \
## Returns whether compressed texture files will be stored in the cache, as
## compressed txo files.  See set_cache_compressed_textures().
##
## This also returns false if get_active() is false.

proc set_cache_compiled_shaders*(this: BamCache, flag: bool) {.importcpp: "#.set_cache_compiled_shaders(#)".} ## \
## Indicates whether compiled shader programs will be stored in the cache, as
## binary .sho files.  This may not be supported by all shader languages or
## graphics renderers.

proc get_cache_compiled_shaders*(this: BamCache): bool {.importcpp: "#.get_cache_compiled_shaders()".} ## \
## Returns whether compiled shader programs will be stored in the cache, as
## binary .txo files.  See set_cache_compiled_shaders().
##
## This also returns false if get_active() is false.

proc set_root*(this: BamCache, root: Filename) {.importcpp: "#.set_root(#)".} ## \
## Changes the current root pathname of the cache.  This specifies where the
## cache files are stored on disk.  This should name a directory that is on a
## disk local to the machine (not on a network-mounted disk), for instance,
## tmp/panda-cache or /c/panda-cache.
##
## If the directory does not already exist, it will be created as a result of
## this call.

proc get_root*(this: BamCache): Filename {.importcpp: "#.get_root()".} ## \
## Returns the current root pathname of the cache.  See set_root().

proc set_flush_time*(this: BamCache, flush_time: int) {.importcpp: "#.set_flush_time(#)".} ## \
## Specifies the time in seconds between automatic flushes of the cache index.

proc get_flush_time*(this: BamCache): int {.importcpp: "#.get_flush_time()".} ## \
## Returns the time in seconds between automatic flushes of the cache index.

proc set_cache_max_kbytes*(this: BamCache, max_kbytes: int) {.importcpp: "#.set_cache_max_kbytes(#)".} ## \
## Specifies the maximum size, in kilobytes, which the cache is allowed to
## grow to.  If a newly cached file would exceed this size, an older file is
## removed from the cache.
##
## Note that in the case of multiple different processes simultaneously
## operating on the same cache directory, the actual cache size may slightly
## exceed this value from time to time due to latency in checking between the
## processes.

proc get_cache_max_kbytes*(this: BamCache): int {.importcpp: "#.get_cache_max_kbytes()".} ## \
## Returns the maximum size, in kilobytes, which the cache is allowed to grow
## to.  See set_cache_max_kbytes().

proc set_read_only*(this: BamCache, ro: bool) {.importcpp: "#.set_read_only(#)".} ## \
## Can be used to put the cache in read-only mode, or take it out of read-only
## mode.  Note that if you put it into read-write mode, and it discovers that
## it does not have write access, it will put itself right back into read-only
## mode.

proc get_read_only*(this: BamCache): bool {.importcpp: "#.get_read_only()".} ## \
## Returns true if the cache is in read-only mode.  Normally, the cache starts
## in read-write mode.  It can put itself into read-only mode automatically if
## it discovers that it does not have write access to the cache.

proc lookup*(this: BamCache, source_filename: Filename, cache_extension: string): BamCacheRecord {.importcpp: "#.lookup(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Looks up a file in the cache.
##
## If the file is cacheable, then regardless of whether the file is found in
## the cache or not, this returns a BamCacheRecord.  On the other hand, if the
## file cannot be cached, returns NULL.
##
## If record->has_data() returns true, then the file was found in the cache,
## and you may call record->extract_data() to get the object.  If
## record->has_data() returns false, then the file was not found in the cache
## or the cache was stale; and you should reload the source file (calling
## record->add_dependent_file() for each file loaded, including the original
## source file), and then call record->set_data() to record the resulting
## loaded object; and finally, you should call store() to write the cached
## record to disk.

proc store*(this: BamCache, record: BamCacheRecord): bool {.importcpp: "#.store(#)".} ## \
## Flushes a cache entry to disk.  You must have retrieved the cache record
## via a prior call to lookup(), and then stored the data via
## record->set_data().  Returns true on success, false on failure.

proc consider_flush_index*(this: BamCache) {.importcpp: "#.consider_flush_index()".} ## \
## Flushes the index if enough time has elapsed since the index was last
## flushed.

proc flush_index*(this: BamCache) {.importcpp: "#.flush_index()".} ## \
## Ensures the index is written to disk.

proc list_index*(this: BamCache, `out`: ostream, indent_level: int) {.importcpp: "#.list_index(#, #)".} ## \
## Writes the contents of the index to standard output.

proc list_index*(this: BamCache, `out`: ostream) {.importcpp: "#.list_index(#)".} ## \
## Writes the contents of the index to standard output.

proc get_global_ptr*(_: typedesc[BamCache]): BamCache {.importcpp: "BamCache::get_global_ptr()", header: "bamCache.h".} ## \
## Returns a pointer to the global BamCache object, which is used
## automatically by the ModelPool and TexturePool.

proc consider_flush_global_index*(_: typedesc[BamCache]) {.importcpp: "BamCache::consider_flush_global_index()", header: "bamCache.h".} ## \
## If there is a global BamCache object, calls consider_flush_index() on it.

proc flush_global_index*(_: typedesc[BamCache]) {.importcpp: "BamCache::flush_global_index()", header: "bamCache.h".} ## \
## If there is a global BamCache object, calls flush_index() on it.

proc initBamEnums*(): BamEnums {.importcpp: "BamEnums()".}

proc initBamEnums*(param0: BamEnums): BamEnums {.importcpp: "BamEnums(#)".}

proc initLoaderOptions*(param0: LoaderOptions): LoaderOptions {.importcpp: "LoaderOptions(#)".}

proc initLoaderOptions*(flags: int): LoaderOptions {.importcpp: "LoaderOptions(#)".}

proc initLoaderOptions*(): LoaderOptions {.importcpp: "LoaderOptions()".}

proc initLoaderOptions*(flags: int, texture_flags: int): LoaderOptions {.importcpp: "LoaderOptions(#, #)".}

proc set_flags*(this: LoaderOptions, flags: int) {.importcpp: "#.set_flags(#)".}

proc get_flags*(this: LoaderOptions): int {.importcpp: "#.get_flags()".}

proc set_texture_flags*(this: LoaderOptions, flags: int) {.importcpp: "#.set_texture_flags(#)".}

proc get_texture_flags*(this: LoaderOptions): int {.importcpp: "#.get_texture_flags()".}

proc set_texture_num_views*(this: LoaderOptions, num_views: int) {.importcpp: "#.set_texture_num_views(#)".} ## \
## Specifies the expected number of views to load for the texture.  This is
## ignored unless TF_multiview is included in texture_flags.  This must be
## specified when loading a 3-d multiview texture or 2-d texture array, in
## which case it is used to differentiate z levels from separate views; it
## may be zero in the case of 2-d textures or cube maps, in which case the
## number of views can be inferred from the number of images found on disk.

proc get_texture_num_views*(this: LoaderOptions): int {.importcpp: "#.get_texture_num_views()".} ## \
## See set_texture_num_views().

proc set_auto_texture_scale*(this: LoaderOptions, scale: AutoTextureScale) {.importcpp: "#.set_auto_texture_scale(#)".} ## \
## Set this flag to ATS_none, ATS_up, ATS_down, or ATS_pad to control how a
## texture is scaled from disk when it is subsequently loaded.  Set it to
## ATS_unspecified to restore the default behavior.

proc get_auto_texture_scale*(this: LoaderOptions): AutoTextureScale {.importcpp: "#.get_auto_texture_scale()".} ## \
## See set_auto_texture_scale().

proc output*(this: LoaderOptions, `out`: ostream) {.importcpp: "#.output(#)".}

proc initBamReader*(source: DatagramGenerator): BamReader {.importcpp: "BamReader(#)".} ## \
## The primary interface for a caller.

proc initBamReader*(): BamReader {.importcpp: "BamReader()".} ## \
## The primary interface for a caller.

proc set_source*(this: BamReader, source: DatagramGenerator) {.importcpp: "#.set_source(#)".} ## \
## Changes the source of future datagrams for this BamReader.  This also
## implicitly calls init() if it has not already been called.

proc get_source*(this: BamReader): DatagramGenerator {.importcpp: "#.get_source()".} ## \
## Returns the current source of the BamReader as set by set_source() or the
## constructor.

proc init*(this: BamReader): bool {.importcpp: "#.init()".} ## \
## Initializes the BamReader prior to reading any objects from its source.
## This includes reading the Bam header.
##
## This returns true if the BamReader successfully initialized, false
## otherwise.

proc get_filename*(this: BamReader): Filename {.importcpp: "#.get_filename()".} ## \
## If a BAM is a file, then the BamReader should contain the name of the file.
## This enables the reader to interpret pathnames in the BAM as relative to
## the directory containing the BAM.

proc get_loader_options*(this: BamReader): LoaderOptions {.importcpp: "#.get_loader_options()".} ## \
## Returns the LoaderOptions passed to the loader when the model was
## requested, if any.

proc set_loader_options*(this: BamReader, options: LoaderOptions) {.importcpp: "#.set_loader_options(#)".} ## \
## Specifies the LoaderOptions for this BamReader.

proc read_object*(this: BamReader): TypedWritable {.importcpp: "#.read_object()".} ## \
## Reads a single object from the Bam file.  If the object type is known, a
## new object of the appropriate type is created and returned; otherwise, NULL
## is returned.  NULL is also returned when the end of the file is reached.
## is_eof() may be called to differentiate between these two cases.
##
## This may be called repeatedly to extract out all the objects in the Bam
## file, but typically (especially for scene graph files, indicated with the
## .bam extension), only one object is retrieved directly from the Bam file:
## the root of the scene graph.  The remaining objects will all be retrieved
## recursively by the first object.
##
## Note that the object returned may not yet be complete.  In particular, some
## of its pointers may not be filled in; you must call resolve() to fill in
## all the available pointers before you can safely use any objects returned
## by read_object().
##
## This flavor of read_object() requires the caller to know what type of
## object it has received in order to properly manage the reference counts.

proc is_eof*(this: BamReader): bool {.importcpp: "#.is_eof()".} ## \
## Returns true if the reader has reached end-of-file, false otherwise.  This
## call is only valid after a call to read_object().

proc resolve*(this: BamReader): bool {.importcpp: "#.resolve()".} ## \
## This may be called at any time during processing of the Bam file to resolve
## all the known pointers so far.  It is usually called at the end of the
## processing, after all objects have been read, which is generally the best
## time to call it.
##
## This must be called at least once after reading a particular object via
## get_object() in order to validate that object.
##
## The return value is true if all objects have been resolved, or false if
## some objects are still outstanding (in which case you will need to call
## resolve() again later).

proc change_pointer*(this: BamReader, orig_pointer: TypedWritable, new_pointer: TypedWritable): bool {.importcpp: "#.change_pointer(#, #)".} ## \
## Indicates that an object recently read from the bam stream should be
## replaced with a new object.  Any future occurrences of the original object
## in the stream will henceforth return the new object instead.
##
## The return value is true if the replacement was successfully made, or false
## if the object was not read from the stream (or if change_pointer had
## already been called on it).

proc get_file_major_ver*(this: BamReader): int {.importcpp: "#.get_file_major_ver()".} ## \
## Returns the major version number of the Bam file currently being read.

proc get_file_minor_ver*(this: BamReader): int {.importcpp: "#.get_file_minor_ver()".} ## \
## Returns the minor version number of the Bam file currently being read.

proc get_file_stdfloat_double*(this: BamReader): bool {.importcpp: "#.get_file_stdfloat_double()".} ## \
## Returns true if the file stores all "standard" floats as 64-bit doubles, or
## false if they are 32-bit floats.  This is determined by the compilation
## flags of the version of Panda that generated this file.

proc get_current_major_ver*(this: BamReader): int {.importcpp: "#.get_current_major_ver()".} ## \
## Returns the major version number of Bam files supported by the current code
## base.  This must match get_file_major_ver() in order to successfully read a
## file.

proc get_current_minor_ver*(this: BamReader): int {.importcpp: "#.get_current_minor_ver()".} ## \
## Returns the minor version number of Bam files supported by the current code
## base.  This must match or exceed get_file_minor_ver() in order to
## successfully read a file.

proc initBamWriter*(param0: BamWriter): BamWriter {.importcpp: "BamWriter(#)".}

proc initBamWriter*(target: DatagramSink): BamWriter {.importcpp: "BamWriter(#)".}

proc initBamWriter*(): BamWriter {.importcpp: "BamWriter()".}

proc set_target*(this: BamWriter, target: DatagramSink) {.importcpp: "#.set_target(#)".} ## \
## Changes the destination of future datagrams written by the BamWriter.  This
## also implicitly calls init() if it has not already been called.

proc get_target*(this: BamWriter): DatagramSink {.importcpp: "#.get_target()".} ## \
## Returns the current target of the BamWriter as set by set_target() or the
## constructor.

proc init*(this: BamWriter): bool {.importcpp: "#.init()".} ## \
## Initializes the BamWriter prior to writing any objects to its output
## stream.  This includes writing out the Bam header.
##
## This returns true if the BamWriter successfully initialized, false
## otherwise.

proc get_filename*(this: BamWriter): Filename {.importcpp: "#.get_filename()".} ## \
## If a BAM is a file, then the BamWriter should contain the name of the file.
## This enables the writer to convert pathnames in the BAM to relative to the
## directory containing the BAM.

proc write_object*(this: BamWriter, obj: TypedWritable): bool {.importcpp: "#.write_object(#)".} ## \
## Writes a single object to the Bam file, so that the
## BamReader::read_object() can later correctly restore the object and all its
## pointers.
##
## This implicitly also writes any additional objects this object references
## (if they haven't already been written), so that pointers may be fully
## resolved.
##
## This may be called repeatedly to write a sequence of objects to the Bam
## file, but typically (especially for scene graph files, indicated with the
## .bam extension), only one object is written directly from the Bam file: the
## root of the scene graph.  The remaining objects will all be written
## recursively by the first object.
##
## Returns true if the object is successfully written, false otherwise.

proc has_object*(this: BamWriter, obj: TypedWritable): bool {.importcpp: "#.has_object(#)".} ## \
## Returns true if the object has previously been written (or at least
## requested to be written) to the bam file, or false if we've never heard of
## it before.

proc flush*(this: BamWriter) {.importcpp: "#.flush()".} ## \
## Ensures that all data written thus far is manifested on the output stream.

proc get_file_major_ver*(this: BamWriter): int {.importcpp: "#.get_file_major_ver()".} ## \
## Returns the major version number of the Bam file currently being written.

proc get_file_minor_ver*(this: BamWriter): int {.importcpp: "#.get_file_minor_ver()".} ## \
## Returns the minor version number of the Bam file currently being written.

proc set_file_minor_ver*(this: BamWriter, minor_ver: int) {.importcpp: "#.set_file_minor_ver(#)".} ## \
## Changes the minor .bam version to write.  This should be called before
## init().  Each Panda version has only a fairly narrow range of versions it
## is able to write; consult the .bam documentation for more information.

proc get_file_stdfloat_double*(this: BamWriter): bool {.importcpp: "#.get_file_stdfloat_double()".} ## \
## Returns true if the file will store all "standard" floats as 64-bit
## doubles, or false if they are 32-bit floats.  This isn't runtime settable;
## it's based on the compilation flags of the version of Panda that generated
## this file.

proc get_root_node*(this: BamWriter): TypedWritable {.importcpp: "#.get_root_node()".} ## \
## Returns the root node of the part of the scene graph we are currently
## writing out.  This is used for determining what to make NodePaths relative
## to.

proc set_root_node*(this: BamWriter, root_node: TypedWritable) {.importcpp: "#.set_root_node(#)".} ## \
## Sets the root node of the part of the scene graph we are currently writing
## out.  NodePaths written to this bam file will be relative to this node.

proc initBitArray*(): BitArray {.importcpp: "BitArray()".}

proc initBitArray*(param0: BitArray): BitArray {.importcpp: "BitArray(#)".}

proc initBitArray*(init_value: clonglong): BitArray {.importcpp: "BitArray(#)".}

proc initBitArray*(`from`: SparseArray): BitArray {.importcpp: "BitArray(#)".}

proc all_on*(_: typedesc[BitArray]): BitArray {.importcpp: "BitArray::all_on()", header: "bitArray.h".} ## \
## Returns a BitArray with an infinite array of bits, all on.

proc all_off*(_: typedesc[BitArray]): BitArray {.importcpp: "BitArray::all_off()", header: "bitArray.h".} ## \
## Returns a BitArray whose bits are all off.

proc lower_on*(_: typedesc[BitArray], on_bits: int): BitArray {.importcpp: "BitArray::lower_on(#)", header: "bitArray.h".} ## \
## Returns a BitArray whose lower on_bits bits are on.

proc bit*(_: typedesc[BitArray], index: int): BitArray {.importcpp: "BitArray::bit(#)", header: "bitArray.h".} ## \
## Returns a BitArray with only the indicated bit on.

proc range*(_: typedesc[BitArray], low_bit: int, size: int): BitArray {.importcpp: "BitArray::range(#, #)", header: "bitArray.h".} ## \
## Returns a BitArray whose size bits, beginning at low_bit, are on.

proc has_max_num_bits*(_: typedesc[BitArray]): bool {.importcpp: "BitArray::has_max_num_bits()", header: "bitArray.h".}

proc get_max_num_bits*(_: typedesc[BitArray]): int {.importcpp: "BitArray::get_max_num_bits()", header: "bitArray.h".}

proc get_num_bits_per_word*(_: typedesc[BitArray]): int {.importcpp: "BitArray::get_num_bits_per_word()", header: "bitArray.h".}

proc get_num_bits*(this: BitArray): clonglong {.importcpp: "#.get_num_bits()".} ## \
## Returns the current number of possibly different bits in this array.  There
## are actually an infinite number of bits, but every bit higher than this bit
## will have the same value, either 0 or 1 (see get_highest_bits()).
##
## This number may grow and/or shrink automatically as needed.

proc get_bit*(this: BitArray, index: int): bool {.importcpp: "#.get_bit(#)".} ## \
## Returns true if the nth bit is set, false if it is cleared.  It is valid
## for n to increase beyond get_num_bits(), but the return value
## get_num_bits() will always be the same.

proc set_bit*(this: BitArray, index: int) {.importcpp: "#.set_bit(#)".} ## \
## Sets the nth bit on.  If n >= get_num_bits(), this automatically extends
## the array.

proc clear_bit*(this: BitArray, index: int) {.importcpp: "#.clear_bit(#)".} ## \
## Sets the nth bit off.  If n >= get_num_bits(), this automatically extends
## the array.

proc set_bit_to*(this: BitArray, index: int, value: bool) {.importcpp: "#.set_bit_to(#, #)".} ## \
## Sets the nth bit either on or off, according to the indicated bool value.

proc get_highest_bits*(this: BitArray): bool {.importcpp: "#.get_highest_bits()".} ## \
## Returns true if the infinite set of bits beyond get_num_bits() are all on,
## or false of they are all off.

proc is_zero*(this: BitArray): bool {.importcpp: "#.is_zero()".} ## \
## Returns true if the entire bitmask is zero, false otherwise.

proc is_all_on*(this: BitArray): bool {.importcpp: "#.is_all_on()".} ## \
## Returns true if the entire bitmask is one, false otherwise.

proc extract*(this: BitArray, low_bit: int, size: int): clonglong {.importcpp: "#.extract(#, #)".} ## \
## Returns a word that represents only the indicated range of bits within this
## BitArray, shifted to the least-significant position.  size must be <=
## get_num_bits_per_word().

proc store*(this: BitArray, value: clonglong, low_bit: int, size: int) {.importcpp: "#.store(#, #, #)".} ## \
## Stores the indicated word into the indicated range of bits with this
## BitArray.

proc has_any_of*(this: BitArray, low_bit: int, size: int): bool {.importcpp: "#.has_any_of(#, #)".} ## \
## Returns true if any bit in the indicated range is set, false otherwise.

proc has_all_of*(this: BitArray, low_bit: int, size: int): bool {.importcpp: "#.has_all_of(#, #)".} ## \
## Returns true if all bits in the indicated range are set, false otherwise.

proc set_range*(this: BitArray, low_bit: int, size: int) {.importcpp: "#.set_range(#, #)".} ## \
## Sets the indicated range of bits on.

proc clear_range*(this: BitArray, low_bit: int, size: int) {.importcpp: "#.clear_range(#, #)".} ## \
## Sets the indicated range of bits off.

proc set_range_to*(this: BitArray, value: bool, low_bit: int, size: int) {.importcpp: "#.set_range_to(#, #, #)".} ## \
## Sets the indicated range of bits to either on or off.

proc get_num_on_bits*(this: BitArray): int {.importcpp: "#.get_num_on_bits()".} ## \
## Returns the number of bits that are set to 1 in the array.  Returns -1 if
## there are an infinite number of 1 bits.

proc get_num_off_bits*(this: BitArray): int {.importcpp: "#.get_num_off_bits()".} ## \
## Returns the number of bits that are set to 0 in the array.  Returns -1 if
## there are an infinite number of 0 bits.

proc get_lowest_on_bit*(this: BitArray): int {.importcpp: "#.get_lowest_on_bit()".} ## \
## Returns the index of the lowest 1 bit in the array.  Returns -1 if there
## are no 1 bits.

proc get_lowest_off_bit*(this: BitArray): int {.importcpp: "#.get_lowest_off_bit()".} ## \
## Returns the index of the lowest 0 bit in the array.  Returns -1 if there
## are no 0 bits.

proc get_highest_on_bit*(this: BitArray): int {.importcpp: "#.get_highest_on_bit()".} ## \
## Returns the index of the highest 1 bit in the array.  Returns -1 if there
## are no 1 bits or if there an infinite number of 1 bits.

proc get_highest_off_bit*(this: BitArray): int {.importcpp: "#.get_highest_off_bit()".} ## \
## Returns the index of the highest 0 bit in the array.  Returns -1 if there
## are no 0 bits or if there an infinite number of 1 bits.

proc get_next_higher_different_bit*(this: BitArray, low_bit: int): int {.importcpp: "#.get_next_higher_different_bit(#)".} ## \
## Returns the index of the next bit in the array, above low_bit, whose value
## is different that the value of low_bit.  Returns low_bit again if all bits
## higher than low_bit have the same value.
##
## This can be used to quickly iterate through all of the bits in the array.

proc get_num_words*(this: BitArray): clonglong {.importcpp: "#.get_num_words()".} ## \
## Returns the number of possibly-unique words stored in the array.

proc get_word*(this: BitArray, n: clonglong): BitMaskNative {.importcpp: "#.get_word(#)".} ## \
## Returns the nth word in the array.  It is valid for n to be greater than
## get_num_words(), but the return value beyond get_num_words() will always be
## the same.

proc set_word*(this: BitArray, n: clonglong, value: clonglong) {.importcpp: "#.set_word(#, #)".} ## \
## Replaces the nth word in the array.  If n >= get_num_words(), this
## automatically extends the array.

proc invert_in_place*(this: BitArray) {.importcpp: "#.invert_in_place()".} ## \
## Inverts all the bits in the BitArray.  This is equivalent to array =
## ~array.

proc has_bits_in_common*(this: BitArray, other: BitArray): bool {.importcpp: "#.has_bits_in_common(#)".} ## \
## Returns true if this BitArray has any "one" bits in common with the other
## one, false otherwise.
##
## This is equivalent to (array & other) != 0, but may be faster.

proc clear*(this: BitArray) {.importcpp: "#.clear()".} ## \
## Sets all the bits in the BitArray off.

proc output*(this: BitArray, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes the BitArray out as a hex number.  For a BitArray, this is always
## the same as output_hex(); it's too confusing for the output format to
## change back and forth at runtime.

proc output_binary*(this: BitArray, `out`: ostream, spaces_every: int) {.importcpp: "#.output_binary(#, #)".} ## \
## Writes the BitArray out as a binary number, with spaces every four bits.

proc output_binary*(this: BitArray, `out`: ostream) {.importcpp: "#.output_binary(#)".} ## \
## Writes the BitArray out as a binary number, with spaces every four bits.

proc output_hex*(this: BitArray, `out`: ostream, spaces_every: int) {.importcpp: "#.output_hex(#, #)".} ## \
## Writes the BitArray out as a hexadecimal number, with spaces every four
## digits.

proc output_hex*(this: BitArray, `out`: ostream) {.importcpp: "#.output_hex(#)".} ## \
## Writes the BitArray out as a hexadecimal number, with spaces every four
## digits.

proc write*(this: BitArray, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes the BitArray out as a binary or a hex number, according to the
## number of bits.

proc write*(this: BitArray, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes the BitArray out as a binary or a hex number, according to the
## number of bits.

proc `==`*(this: BitArray, other: BitArray): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: BitArray, other: BitArray): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: BitArray, other: BitArray): bool {.importcpp: "#.operator <(#)".}

proc compare_to*(this: BitArray, other: BitArray): int {.importcpp: "#.compare_to(#)".} ## \
## Returns a number less than zero if this BitArray sorts before the indicated
## other BitArray, greater than zero if it sorts after, or 0 if they are
## equivalent.  This is based on the same ordering defined by operator <.

proc `&`*(this: BitArray, other: BitArray): BitArray {.importcpp: "#.operator &(#)".}

proc `|`*(this: BitArray, other: BitArray): BitArray {.importcpp: "#.operator |(#)".}

proc `^`*(this: BitArray, other: BitArray): BitArray {.importcpp: "#.operator ^(#)".}

proc `~`*(this: BitArray): BitArray {.importcpp: "#.operator ~()".}

proc `<<`*(this: BitArray, shift: int): BitArray {.importcpp: "#.operator <<(#)".}

proc `>>`*(this: BitArray, shift: int): BitArray {.importcpp: "#.operator >>(#)".}

proc `&=`*(this: BitArray, other: BitArray): BitArray {.importcpp: "#.operator &=(#)".}

proc `|=`*(this: BitArray, other: BitArray): BitArray {.importcpp: "#.operator |=(#)".}

proc `^=`*(this: BitArray, other: BitArray): BitArray {.importcpp: "#.operator ^=(#)".}

proc `<<=`*(this: BitArray, shift: int): BitArray {.importcpp: "#.operator <<=(#)".}

proc `>>=`*(this: BitArray, shift: int): BitArray {.importcpp: "#.operator >>=(#)".}

proc get_class_type*(_: typedesc[BitArray]): TypeHandle {.importcpp: "BitArray::get_class_type()", header: "bitArray.h".}

proc initButtonHandle*(): ButtonHandle {.importcpp: "ButtonHandle()".} ## \
## The default constructor must do nothing, because we can't guarantee
## ordering of static initializers.  If the constructor tried to initialize
## its value, it  might happen after the value had already been set
## previously by another static initializer!

proc initButtonHandle*(param0: ButtonHandle): ButtonHandle {.importcpp: "ButtonHandle(#)".}

proc initButtonHandle*(index: int): ButtonHandle {.importcpp: "ButtonHandle(#)".} ## \
## Constructs a ButtonHandle with the corresponding index number, which may
## have been returned by an earlier call to ButtonHandle::get_index().

proc initButtonHandle*(name: string): ButtonHandle {.importcpp: "ButtonHandle(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Constructs a ButtonHandle with the corresponding name, which is looked up
## in the ButtonRegistry.  This exists for the purpose of being able to
## automatically coerce a string into a ButtonHandle; for most purposes, you
## should use either the static KeyboardButton/MouseButton getters or
## ButtonRegistry::register_button().

proc `==`*(this: ButtonHandle, other: ButtonHandle): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: ButtonHandle, other: ButtonHandle): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: ButtonHandle, other: ButtonHandle): bool {.importcpp: "#.operator <(#)".}

proc `<=`*(this: ButtonHandle, other: ButtonHandle): bool {.importcpp: "#.operator <=(#)".}

proc `>`*(this: ButtonHandle, other: ButtonHandle): bool {.importcpp: "#.operator >(#)".}

proc `>=`*(this: ButtonHandle, other: ButtonHandle): bool {.importcpp: "#.operator >=(#)".}

proc compare_to*(this: ButtonHandle, other: ButtonHandle): int {.importcpp: "#.compare_to(#)".} ## \
## Sorts ButtonHandles arbitrarily (according to <, >, etc.).  Returns a
## number less than 0 if this type sorts before the other one, greater than
## zero if it sorts after, 0 if they are equivalent.

proc get_hash*(this: ButtonHandle): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a hash code suitable for phash_map.

proc get_name*(this: ButtonHandle): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the button.

proc has_ascii_equivalent*(this: ButtonHandle): bool {.importcpp: "#.has_ascii_equivalent()".} ## \
## Returns true if the button was created with an ASCII equivalent code (e.g.
## for a standard keyboard button).

proc get_ascii_equivalent*(this: ButtonHandle): char {.importcpp: "#.get_ascii_equivalent()".} ## \
## Returns the character code associated with the button, or '\0' if no ASCII
## code was associated.

proc get_alias*(this: ButtonHandle): ButtonHandle {.importcpp: "#.get_alias()".} ## \
## Returns the alias (alternate name) associated with the button, if any, or
## ButtonHandle::none() if the button has no alias.
##
## Each button is allowed to have one alias, and multiple different buttons
## can refer to the same alias.  The alias should be the more general name for
## the button, for instance, shift is an alias for lshift, but not vice-versa.

proc matches*(this: ButtonHandle, other: ButtonHandle): bool {.importcpp: "#.matches(#)".} ## \
## Returns true if this ButtonHandle is the same as the other one, or if the
## other one is an alias for this one.  (Does not return true if this button
## is an alias for the other one, however.)
##
## This is a more general comparison than operator ==.

proc get_index*(this: ButtonHandle): int {.importcpp: "#.get_index()".} ## \
## Returns the integer index associated with this ButtonHandle.  Each
## different ButtonHandle will have a different index.  However, you probably
## shouldn't be using this method; you should just treat the ButtonHandles as
## opaque classes.  This is provided for the convenience of non-C++ scripting
## languages to build a hashtable of ButtonHandles.

proc output*(this: ButtonHandle, `out`: ostream) {.importcpp: "#.output(#)".}

proc none*(_: typedesc[ButtonHandle]): ButtonHandle {.importcpp: "ButtonHandle::none()", header: "buttonHandle.h".}

proc `typecast bool`*(this: ButtonHandle): bool {.importcpp: "#.operator typecast bool()".}

proc get_class_type*(_: typedesc[ButtonHandle]): TypeHandle {.importcpp: "ButtonHandle::get_class_type()", header: "buttonHandle.h".}

proc get_button*(this: ButtonRegistry, name: string): ButtonHandle {.importcpp: "#.get_button(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Finds a ButtonHandle in the registry matching the indicated name.  If there
## is no such ButtonHandle, registers a new one and returns it.

proc find_button*(this: ButtonRegistry, name: string): ButtonHandle {.importcpp: "#.find_button(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Finds a ButtonHandle in the registry matching the indicated name.  If there
## is no such ButtonHandle, returns ButtonHandle::none().

proc find_ascii_button*(this: ButtonRegistry, ascii_equivalent: char): ButtonHandle {.importcpp: "#.find_ascii_button(#)".} ## \
## Finds a ButtonHandle in the registry matching the indicated ASCII
## equivalent character.  If there is no such ButtonHandle, returns
## ButtonHandle::none().

proc write*(this: ButtonRegistry, `out`: ostream) {.importcpp: "#.write(#)".}

proc initButtonRegistry*(param0: ButtonRegistry): ButtonRegistry {.importcpp: "ButtonRegistry(#)".}

proc get_num_buttons*(this: ButtonMap): clonglong {.importcpp: "#->get_num_buttons()".} ## \
## Returns the number of buttons that this button mapping specifies.

proc get_raw_button*(this: ButtonMap, i: clonglong): ButtonHandle {.importcpp: "#->get_raw_button(#)".} ## \
## Returns the underlying raw button associated with the nth button.

proc get_mapped_button*(this: ButtonMap, raw: ButtonHandle): ButtonHandle {.importcpp: "#->get_mapped_button(#)".} ## \
## Returns the button that the given button is mapped to, or
## ButtonHandle::none() if this map does not specify a mapped button for the
## given raw button.

proc get_mapped_button*(this: ButtonMap, i: clonglong): ButtonHandle {.importcpp: "#->get_mapped_button(#)".} ## \
## Returns the nth mapped button, meaning the button that the nth raw button
## is mapped to.

proc get_mapped_button*(this: ButtonMap, raw_name: string): ButtonHandle {.importcpp: "#->get_mapped_button(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the button that the given button is mapped to, or
## ButtonHandle::none() if this map does not specify a mapped button for the
## given raw button.

proc get_mapped_button_label*(this: ButtonMap, raw: ButtonHandle): string {.importcpp: "nimStringFromStdString(#->get_mapped_button_label(#))", header: stringConversionCode.} ## \
## If the button map specifies a special name for the button (eg.  if the
## operating system or keyboard device has a localized name describing the
## key), returns it, or the empty string otherwise.
##
## Note that this is not the same as get_mapped_button().get_name(), which
## returns the name of the Panda event associated with the button.

proc get_mapped_button_label*(this: ButtonMap, i: clonglong): string {.importcpp: "nimStringFromStdString(#->get_mapped_button_label(#))", header: stringConversionCode.} ## \
## Returns the label associated with the nth mapped button, meaning the button
## that the nth raw button is mapped to.

proc get_mapped_button_label*(this: ButtonMap, raw_name: string): string {.importcpp: "nimStringFromStdString(#->get_mapped_button_label(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## If the button map specifies a special name for the button (eg.  if the
## operating system or keyboard device has a localized name describing the
## key), returns it, or the empty string otherwise.
##
## Note that this is not the same as get_mapped_button().get_name(), which
## returns the name of the Panda event associated with the button.

proc output*(this: ButtonMap, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: ButtonMap, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: ButtonMap, `out`: ostream) {.importcpp: "#->write(#)".}

proc get_class_type*(_: typedesc[ButtonMap]): TypeHandle {.importcpp: "ButtonMap::get_class_type()", header: "buttonMap.h".}

proc newButtonMap*(): ButtonMap {.importcpp: "new ButtonMap()".}

proc newButtonMap*(param0: ButtonMap): ButtonMap {.importcpp: "new ButtonMap(#)".}

proc output*(this: CallbackObject, `out`: ostream) {.importcpp: "#->output(#)".}

proc get_class_type*(_: typedesc[CallbackObject]): TypeHandle {.importcpp: "CallbackObject::get_class_type()", header: "callbackObject.h".}

proc newCallbackObject*(param0: CallbackObject): CallbackObject {.importcpp: "new CallbackObject(#)".}

proc get_cache_ref_count*(this: CachedTypedWritableReferenceCount): int {.importcpp: "#->get_cache_ref_count()".} ## \
## Returns the current reference count.

proc cache_ref*(this: CachedTypedWritableReferenceCount) {.importcpp: "#->cache_ref()".} ## \
## Explicitly increments the cache reference count and the normal reference
## count simultaneously.

proc cache_unref*(this: CachedTypedWritableReferenceCount): bool {.importcpp: "#->cache_unref()".} ## \
## Explicitly decrements the cache reference count and the normal reference
## count simultaneously.
##
## The return value is true if the new reference count is nonzero, false if it
## is zero.

proc test_ref_count_integrity*(this: CachedTypedWritableReferenceCount): bool {.importcpp: "#->test_ref_count_integrity()".} ## \
## Does some easy checks to make sure that the reference count isn't
## completely bogus.

proc get_class_type*(_: typedesc[CachedTypedWritableReferenceCount]): TypeHandle {.importcpp: "CachedTypedWritableReferenceCount::get_class_type()", header: "cachedTypedWritableReferenceCount.h".}

proc output*(this: CallbackData, `out`: ostream) {.importcpp: "#.output(#)".}

proc upcall*(this: CallbackData) {.importcpp: "#.upcall()".} ## \
## You should make this call during the callback if you want to continue the
## normal function that would have been done in the absence of a callback.

proc get_class_type*(_: typedesc[CallbackData]): TypeHandle {.importcpp: "CallbackData::get_class_type()", header: "callbackData.h".}

proc newPythonCallbackObject*(): PythonCallbackObject {.importcpp: "new PythonCallbackObject()".}

proc newPythonCallbackObject*(param0: PythonCallbackObject): PythonCallbackObject {.importcpp: "new PythonCallbackObject(#)".}

proc get_class_type*(_: typedesc[PythonCallbackObject]): TypeHandle {.importcpp: "PythonCallbackObject::get_class_type()", header: "pythonCallbackObject.h".}

proc initTimeVal*(): TimeVal {.importcpp: "TimeVal()".}

proc initTimeVal*(param0: TimeVal): TimeVal {.importcpp: "TimeVal(#)".}

proc get_sec*(this: TimeVal): int {.importcpp: "#.get_sec()".}

proc get_usec*(this: TimeVal): int {.importcpp: "#.get_usec()".}

proc newClockObject*(copy: ClockObject): ClockObject {.importcpp: "new ClockObject(#)".}

proc newClockObject*(): ClockObject {.importcpp: "new ClockObject()".}

proc get_frame_time*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->get_frame_time(#)".} ## \
## Returns the time in seconds as of the last time tick() was called
## (typically, this will be as of the start of the current frame).
##
## This is generally the kind of time you want to ask for in most rendering
## and animation contexts, since it's important that all of the animation for
## a given frame remains in sync with each other.

proc get_frame_time*(this: ClockObject): float64 {.importcpp: "#->get_frame_time()".} ## \
## Returns the time in seconds as of the last time tick() was called
## (typically, this will be as of the start of the current frame).
##
## This is generally the kind of time you want to ask for in most rendering
## and animation contexts, since it's important that all of the animation for
## a given frame remains in sync with each other.

proc get_real_time*(this: ClockObject): float64 {.importcpp: "#->get_real_time()".} ## \
## Returns the actual number of seconds elapsed since the ClockObject was
## created, or since it was last reset.  This is useful for doing real timing
## measurements, e.g.  for performance statistics.
##
## This returns the most precise timer we have for short time intervals, but
## it may tend to drift over the long haul.  If more accurate timekeeping is
## needed over a long period of time, use get_long_time() instead.

proc get_long_time*(this: ClockObject): float64 {.importcpp: "#->get_long_time()".} ## \
## Returns the actual number of seconds elapsed since the ClockObject was
## created, or since it was last reset.
##
## This is similar to get_real_time(), except that it uses the most accurate
## counter we have over a long period of time, and so it is less likely to
## drift.  However, it may not be very precise for measuring short intervals.
## On Windows, for instace, this is only accurate to within about 55
## milliseconds.

proc reset*(this: ClockObject) {.importcpp: "#->reset()".} ## \
## Simultaneously resets both the time and the frame count to zero.

proc set_real_time*(this: ClockObject, time: float64) {.importcpp: "#->set_real_time(#)".} ## \
## Resets the clock to the indicated time.  This changes only the real time of
## the clock as reported by get_real_time(), but does not immediately change
## the time reported by get_frame_time()--that will change after the next call
## to tick().  Also see reset(), set_frame_time(), and set_frame_count().

proc set_frame_time*(this: ClockObject, time: float64, current_thread: Thread) {.importcpp: "#->set_frame_time(#, #)".} ## \
## Changes the time as reported for the current frame to the indicated time.
## Normally, the way to adjust the frame time is via tick(); this function is
## provided only for occasional special adjustments.

proc set_frame_time*(this: ClockObject, time: float64) {.importcpp: "#->set_frame_time(#)".} ## \
## Changes the time as reported for the current frame to the indicated time.
## Normally, the way to adjust the frame time is via tick(); this function is
## provided only for occasional special adjustments.

proc set_frame_count*(this: ClockObject, frame_count: int, current_thread: Thread) {.importcpp: "#->set_frame_count(#, #)".} ## \
## Resets the number of frames counted to the indicated number.  Also see
## reset(), set_real_time(), and set_frame_time().

proc set_frame_count*(this: ClockObject, frame_count: int) {.importcpp: "#->set_frame_count(#)".} ## \
## Resets the number of frames counted to the indicated number.  Also see
## reset(), set_real_time(), and set_frame_time().

proc get_frame_count*(this: ClockObject, current_thread: Thread): int {.importcpp: "#->get_frame_count(#)".} ## \
## Returns the number of times tick() has been called since the ClockObject
## was created, or since it was last reset.  This is generally the number of
## frames that have been rendered.

proc get_frame_count*(this: ClockObject): int {.importcpp: "#->get_frame_count()".} ## \
## Returns the number of times tick() has been called since the ClockObject
## was created, or since it was last reset.  This is generally the number of
## frames that have been rendered.

proc get_net_frame_rate*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->get_net_frame_rate(#)".} ## \
## Returns the average frame rate since the last reset.  This is simply the
## total number of frames divided by the total elapsed time.  This reports the
## virtual frame rate if the clock is in (or has been in) M_non_real_time
## mode.

proc get_net_frame_rate*(this: ClockObject): float64 {.importcpp: "#->get_net_frame_rate()".} ## \
## Returns the average frame rate since the last reset.  This is simply the
## total number of frames divided by the total elapsed time.  This reports the
## virtual frame rate if the clock is in (or has been in) M_non_real_time
## mode.

proc get_dt*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->get_dt(#)".} ## \
## Returns the elapsed time for the previous frame: the number of seconds
## elapsed between the last two calls to tick().

proc get_dt*(this: ClockObject): float64 {.importcpp: "#->get_dt()".} ## \
## Returns the elapsed time for the previous frame: the number of seconds
## elapsed between the last two calls to tick().

proc set_dt*(this: ClockObject, dt: float64) {.importcpp: "#->set_dt(#)".} ## \
## In non-real-time mode, sets the number of seconds that should appear to
## elapse between frames.  In forced mode or limited mode, sets our target dt.
## In normal mode, this has no effect.
##
## Also see set_frame_rate(), which is a different way to specify the same
## quantity.

proc set_frame_rate*(this: ClockObject, frame_rate: float64) {.importcpp: "#->set_frame_rate(#)".} ## \
## In non-real-time mode, sets the number of frames per second that we should
## appear to be running.  In forced mode or limited mode, sets our target
## frame rate.  In normal mode, this has no effect.
##
## Also see set_dt(), which is a different way to specify the same quantity.

proc get_max_dt*(this: ClockObject): float64 {.importcpp: "#->get_max_dt()".} ## \
## Returns the current maximum allowable time elapsed between any two frames.
## See set_max_dt().

proc set_max_dt*(this: ClockObject, max_dt: float64) {.importcpp: "#->set_max_dt(#)".} ## \
## Sets a limit on the value returned by get_dt().  If this value is less than
## zero, no limit is imposed; otherwise, this is the maximum value that will
## ever be returned by get_dt(), regardless of how much time has actually
## elapsed between frames.
##
## This limit is only imposed in real-time mode; in non-real-time mode, the dt
## is fixed anyway and max_dt is ignored.
##
## This is generally used to guarantee reasonable behavior even in the
## presence of a very slow or chuggy frame rame.

proc get_degrade_factor*(this: ClockObject): float64 {.importcpp: "#->get_degrade_factor()".} ## \
## In degrade mode, returns the ratio by which the performance is degraded.  A
## value of 2.0 causes the clock to be slowed down by a factor of two
## (reducing performance to 1/2 what would be otherwise).
##
## This has no effect if mode is not M_degrade.

proc set_degrade_factor*(this: ClockObject, degrade_factor: float64) {.importcpp: "#->set_degrade_factor(#)".} ## \
## In degrade mode, sets the ratio by which the performance is degraded.  A
## value of 2.0 causes the clock to be slowed down by a factor of two
## (reducing performance to 1/2 what would be otherwise).
##
## This has no effect if mode is not M_degrade.

proc set_average_frame_rate_interval*(this: ClockObject, time: float64) {.importcpp: "#->set_average_frame_rate_interval(#)".} ## \
## Specifies the interval of time (in seconds) over which
## get_average_frame_rate() averages the number of frames per second to
## compute the frame rate.  Changing this does not necessarily immediately
## change the result of get_average_frame_rate(), until this interval of time
## has elapsed again.
##
## Setting this to zero disables the computation of get_average_frame_rate().

proc get_average_frame_rate_interval*(this: ClockObject): float64 {.importcpp: "#->get_average_frame_rate_interval()".} ## \
## Returns the interval of time (in seconds) over which
## get_average_frame_rate() averages the number of frames per second to
## compute the frame rate.

proc get_average_frame_rate*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->get_average_frame_rate(#)".} ## \
## Returns the average frame rate in number of frames per second over the last
## get_average_frame_rate_interval() seconds.  This measures the virtual frame
## rate if the clock is in M_non_real_time mode.

proc get_average_frame_rate*(this: ClockObject): float64 {.importcpp: "#->get_average_frame_rate()".} ## \
## Returns the average frame rate in number of frames per second over the last
## get_average_frame_rate_interval() seconds.  This measures the virtual frame
## rate if the clock is in M_non_real_time mode.

proc get_max_frame_duration*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->get_max_frame_duration(#)".} ## \
## Returns the maximum frame duration over the last
## get_average_frame_rate_interval() seconds.

proc get_max_frame_duration*(this: ClockObject): float64 {.importcpp: "#->get_max_frame_duration()".} ## \
## Returns the maximum frame duration over the last
## get_average_frame_rate_interval() seconds.

proc calc_frame_rate_deviation*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->calc_frame_rate_deviation(#)".} ## \
## Returns the standard deviation of the frame times of the frames rendered
## over the past get_average_frame_rate_interval() seconds.  This number gives
## an estimate of the chugginess of the frame rate; if it is large, there is a
## large variation in the frame rate; if is small, all of the frames are
## consistent in length.
##
## A large value might also represent just a recent change in frame rate, for
## instance, because the camera has just rotated from looking at a simple
## scene to looking at a more complex scene.

proc calc_frame_rate_deviation*(this: ClockObject): float64 {.importcpp: "#->calc_frame_rate_deviation()".} ## \
## Returns the standard deviation of the frame times of the frames rendered
## over the past get_average_frame_rate_interval() seconds.  This number gives
## an estimate of the chugginess of the frame rate; if it is large, there is a
## large variation in the frame rate; if is small, all of the frames are
## consistent in length.
##
## A large value might also represent just a recent change in frame rate, for
## instance, because the camera has just rotated from looking at a simple
## scene to looking at a more complex scene.

proc tick*(this: ClockObject, current_thread: Thread) {.importcpp: "#->tick(#)".} ## \
## Instructs the clock that a new frame has just begun.  In normal, real-time
## mode, get_frame_time() will henceforth report the time as of this instant
## as the current start-of-frame time.  In non-real-time mode,
## get_frame_time() will be incremented by the value of dt.

proc tick*(this: ClockObject) {.importcpp: "#->tick()".} ## \
## Instructs the clock that a new frame has just begun.  In normal, real-time
## mode, get_frame_time() will henceforth report the time as of this instant
## as the current start-of-frame time.  In non-real-time mode,
## get_frame_time() will be incremented by the value of dt.

proc sync_frame_time*(this: ClockObject, current_thread: Thread) {.importcpp: "#->sync_frame_time(#)".} ## \
## Resets the frame time to the current real time.  This is similar to tick(),
## except that it does not advance the frame counter and does not affect dt.
## This is intended to be used in the middle of a particularly long frame to
## compensate for the time that has already elapsed.
##
## In non-real-time mode, this function has no effect (because in this mode
## all frames take the same length of time).

proc sync_frame_time*(this: ClockObject) {.importcpp: "#->sync_frame_time()".} ## \
## Resets the frame time to the current real time.  This is similar to tick(),
## except that it does not advance the frame counter and does not affect dt.
## This is intended to be used in the middle of a particularly long frame to
## compensate for the time that has already elapsed.
##
## In non-real-time mode, this function has no effect (because in this mode
## all frames take the same length of time).

proc check_errors*(this: ClockObject, current_thread: Thread): bool {.importcpp: "#->check_errors(#)".} ## \
## Returns true if a clock error was detected since the last time
## check_errors() was called.  A clock error means that something happened, an
## OS or BIOS bug, for instance, that makes the current value of the clock
## somewhat suspect, and an application may wish to resynchronize with any
## external clocks.

proc get_global_clock*(_: typedesc[ClockObject]): ClockObject {.importcpp: "ClockObject::get_global_clock()", header: "clockObject.h".} ## \
## Returns a pointer to the global ClockObject.  This is the ClockObject that
## most code should use for handling scene graph rendering and animation.

proc get_class_type*(_: typedesc[ClockObject]): TypeHandle {.importcpp: "ClockObject::get_class_type()", header: "clockObject.h".}

proc parse_color_space_string*(str: string): ColorSpace {.importcpp: "parse_color_space_string(nimStringToStdString(#))", header: stringConversionCode.}

proc format_color_space*(cs: ColorSpace): string {.importcpp: "nimStringFromStdString(format_color_space(#))", header: stringConversionCode.}

proc get_model_path*(): ConfigVariableSearchPath {.importcpp: "get_model_path()".}

proc get_plugin_path*(): ConfigVariableSearchPath {.importcpp: "get_plugin_path()".}

proc cache_ref*(this: CopyOnWriteObject) {.importcpp: "#->cache_ref()".} ## \
## @see CachedTypedWritableReferenceCount::cache_ref()

proc cache_unref*(this: CopyOnWriteObject): bool {.importcpp: "#->cache_unref()".} ## \
## @see CachedTypedWritableReferenceCount::cache_unref()

proc get_class_type*(_: typedesc[CopyOnWriteObject]): TypeHandle {.importcpp: "CopyOnWriteObject::get_class_type()", header: "copyOnWriteObject.h".}

converter upcast_to_DatagramSink*(this: DatagramBuffer): DatagramSink {.importcpp: "#.upcast_to_DatagramSink()".}

converter upcast_to_DatagramGenerator*(this: DatagramBuffer): DatagramGenerator {.importcpp: "#.upcast_to_DatagramGenerator()".}

proc initDatagramBuffer*(): DatagramBuffer {.importcpp: "DatagramBuffer()".} ## \
## Initializes an empty datagram buffer.

proc clear*(this: DatagramBuffer) {.importcpp: "#.clear()".} ## \
## Clears the internal buffer.

proc initDatagramInputFile*(): DatagramInputFile {.importcpp: "DatagramInputFile()".}

proc open*(this: DatagramInputFile, file: FileReference): bool {.importcpp: "#.open(#)".} ## \
## Opens the indicated filename for reading.  Returns true on success, false
## on failure.

proc open*(this: DatagramInputFile, filename: Filename): bool {.importcpp: "#.open(#)".} ## \
## Opens the indicated filename for reading.  Returns true on success, false
## on failure.

proc open*(this: DatagramInputFile, `in`: istream, filename: Filename): bool {.importcpp: "#.open(#, #)".} ## \
## Starts reading from the indicated stream.  Returns true on success, false
## on failure.  The DatagramInputFile does not take ownership of the stream;
## you are responsible for closing or deleting it when you are done.

proc open*(this: DatagramInputFile, `in`: istream): bool {.importcpp: "#.open(#)".} ## \
## Starts reading from the indicated stream.  Returns true on success, false
## on failure.  The DatagramInputFile does not take ownership of the stream;
## you are responsible for closing or deleting it when you are done.

proc get_stream*(this: DatagramInputFile): istream {.importcpp: "#.get_stream()".} ## \
## Returns the istream represented by the input file.

proc close*(this: DatagramInputFile) {.importcpp: "#.close()".} ## \
## Closes the file.  This is also implicitly done when the DatagramInputFile
## destructs.

proc initDatagramOutputFile*(): DatagramOutputFile {.importcpp: "DatagramOutputFile()".}

proc open*(this: DatagramOutputFile, file: FileReference): bool {.importcpp: "#.open(#)".} ## \
## Opens the indicated filename for writing.  Returns true if successful,
## false on failure.

proc open*(this: DatagramOutputFile, filename: Filename): bool {.importcpp: "#.open(#)".} ## \
## Opens the indicated filename for writing.  Returns true on success, false
## on failure.

proc open*(this: DatagramOutputFile, `out`: ostream, filename: Filename): bool {.importcpp: "#.open(#, #)".} ## \
## Starts writing to the indicated stream.  Returns true on success, false on
## failure.  The DatagramOutputFile does not take ownership of the stream; you
## are responsible for closing or deleting it when you are done.

proc open*(this: DatagramOutputFile, `out`: ostream): bool {.importcpp: "#.open(#)".} ## \
## Starts writing to the indicated stream.  Returns true on success, false on
## failure.  The DatagramOutputFile does not take ownership of the stream; you
## are responsible for closing or deleting it when you are done.

proc close*(this: DatagramOutputFile) {.importcpp: "#.close()".} ## \
## Closes the file.  This is also implicitly done when the DatagramOutputFile
## destructs.

proc write_header*(this: DatagramOutputFile, header: string): bool {.importcpp: "#.write_header(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Writes a sequence of bytes to the beginning of the datagram file.  This may
## be called any number of times after the file has been opened and before the
## first datagram is written.  It may not be called once the first datagram is
## written.

proc lstick*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::lstick()", header: "gamepadButton.h".}

proc rstick*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::rstick()", header: "gamepadButton.h".}

proc lshoulder*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::lshoulder()", header: "gamepadButton.h".}

proc rshoulder*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::rshoulder()", header: "gamepadButton.h".}

proc ltrigger*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::ltrigger()", header: "gamepadButton.h".}

proc rtrigger*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::rtrigger()", header: "gamepadButton.h".}

proc lgrip*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::lgrip()", header: "gamepadButton.h".}

proc rgrip*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::rgrip()", header: "gamepadButton.h".}

proc dpad_left*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::dpad_left()", header: "gamepadButton.h".}

proc dpad_right*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::dpad_right()", header: "gamepadButton.h".}

proc dpad_up*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::dpad_up()", header: "gamepadButton.h".}

proc dpad_down*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::dpad_down()", header: "gamepadButton.h".}

proc back*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::back()", header: "gamepadButton.h".}

proc guide*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::guide()", header: "gamepadButton.h".}

proc start*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::start()", header: "gamepadButton.h".}

proc next*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::next()", header: "gamepadButton.h".}

proc previous*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::previous()", header: "gamepadButton.h".}

proc face_a*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::face_a()", header: "gamepadButton.h".}

proc face_b*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::face_b()", header: "gamepadButton.h".}

proc face_c*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::face_c()", header: "gamepadButton.h".}

proc face_x*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::face_x()", header: "gamepadButton.h".}

proc face_y*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::face_y()", header: "gamepadButton.h".}

proc face_z*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::face_z()", header: "gamepadButton.h".}

proc face_1*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::face_1()", header: "gamepadButton.h".}

proc face_2*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::face_2()", header: "gamepadButton.h".}

proc trigger*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::trigger()", header: "gamepadButton.h".} ## \
## Flight stick buttons, takes zero-based index.  First is always trigger.

proc joystick*(_: typedesc[GamepadButton], button_number: int): ButtonHandle {.importcpp: "GamepadButton::joystick(#)", header: "gamepadButton.h".} ## \
## Returns the ButtonHandle associated with the particular numbered joystick
## button (zero-based), if there is one, or ButtonHandle::none() if there is
## not.

proc hat_up*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::hat_up()", header: "gamepadButton.h".}

proc hat_down*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::hat_down()", header: "gamepadButton.h".}

proc hat_left*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::hat_left()", header: "gamepadButton.h".}

proc hat_right*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::hat_right()", header: "gamepadButton.h".}

proc initGamepadButton*(): GamepadButton {.importcpp: "GamepadButton()".}

proc initGamepadButton*(param0: GamepadButton): GamepadButton {.importcpp: "GamepadButton(#)".}

proc ascii_key*(_: typedesc[KeyboardButton], ascii_equivalent: char): ButtonHandle {.importcpp: "KeyboardButton::ascii_key(#)", header: "keyboardButton.h".} ## \
## Returns the ButtonHandle associated with the particular ASCII character, if
## there is one, or ButtonHandle::none() if there is not.

proc space*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::space()", header: "keyboardButton.h".}

proc backspace*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::backspace()", header: "keyboardButton.h".}

proc tab*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::tab()", header: "keyboardButton.h".}

proc enter*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::enter()", header: "keyboardButton.h".}

proc escape*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::escape()", header: "keyboardButton.h".}

proc f1*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f1()", header: "keyboardButton.h".}

proc f2*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f2()", header: "keyboardButton.h".}

proc f3*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f3()", header: "keyboardButton.h".}

proc f4*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f4()", header: "keyboardButton.h".}

proc f5*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f5()", header: "keyboardButton.h".}

proc f6*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f6()", header: "keyboardButton.h".}

proc f7*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f7()", header: "keyboardButton.h".}

proc f8*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f8()", header: "keyboardButton.h".}

proc f9*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f9()", header: "keyboardButton.h".}

proc f10*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f10()", header: "keyboardButton.h".}

proc f11*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f11()", header: "keyboardButton.h".}

proc f12*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f12()", header: "keyboardButton.h".}

proc f13*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f13()", header: "keyboardButton.h".} ## \
## PC keyboards don't have these four buttons, but Macs do.

proc f14*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f14()", header: "keyboardButton.h".}

proc f15*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f15()", header: "keyboardButton.h".}

proc f16*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f16()", header: "keyboardButton.h".}

proc left*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::left()", header: "keyboardButton.h".}

proc right*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::right()", header: "keyboardButton.h".}

proc up*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::up()", header: "keyboardButton.h".}

proc down*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::down()", header: "keyboardButton.h".}

proc page_up*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::page_up()", header: "keyboardButton.h".}

proc page_down*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::page_down()", header: "keyboardButton.h".}

proc home*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::home()", header: "keyboardButton.h".}

proc insert*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::insert()", header: "keyboardButton.h".}

proc del*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::del()", header: "keyboardButton.h".} ## \
## delete is a C++ keyword.

proc help*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::help()", header: "keyboardButton.h".} ## \
## delete is a C++ keyword.

proc menu*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::menu()", header: "keyboardButton.h".}

proc shift*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::shift()", header: "keyboardButton.h".}

proc control*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::control()", header: "keyboardButton.h".}

proc alt*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::alt()", header: "keyboardButton.h".}

proc meta*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::meta()", header: "keyboardButton.h".}

proc caps_lock*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::caps_lock()", header: "keyboardButton.h".}

proc shift_lock*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::shift_lock()", header: "keyboardButton.h".}

proc num_lock*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::num_lock()", header: "keyboardButton.h".}

proc scroll_lock*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::scroll_lock()", header: "keyboardButton.h".}

proc print_screen*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::print_screen()", header: "keyboardButton.h".}

proc pause*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::pause()", header: "keyboardButton.h".}

proc lshift*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::lshift()", header: "keyboardButton.h".}

proc rshift*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::rshift()", header: "keyboardButton.h".}

proc lcontrol*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::lcontrol()", header: "keyboardButton.h".}

proc rcontrol*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::rcontrol()", header: "keyboardButton.h".}

proc lalt*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::lalt()", header: "keyboardButton.h".}

proc ralt*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::ralt()", header: "keyboardButton.h".}

proc lmeta*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::lmeta()", header: "keyboardButton.h".}

proc rmeta*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::rmeta()", header: "keyboardButton.h".}

proc initKeyboardButton*(): KeyboardButton {.importcpp: "KeyboardButton()".}

proc initKeyboardButton*(param0: KeyboardButton): KeyboardButton {.importcpp: "KeyboardButton(#)".}

proc load_prc_file*(filename: Filename): ConfigPage {.importcpp: "load_prc_file(#)".} ## \
## A convenience function for loading explicit prc files from a disk file or
## from within a multifile (via the virtual file system).  Save the return
## value and pass it to unload_prc_file() if you ever want to unload this file
## later.
##
## The filename is first searched along the default prc search path, and then
## also along the model path, for convenience.
##
## This function is defined in putil instead of in dtool with the read of the
## prc stuff, so that it can take advantage of the virtual file system (which
## is defined in express), and the model path (which is in putil).

proc load_prc_file_data*(name: string, data: string): ConfigPage {.importcpp: "load_prc_file_data(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Another convenience function to load a prc file from an explicit string,
## which represents the contents of the prc file.
##
## The first parameter is an arbitrary name to assign to this in-memory prc
## file.  Supply a filename if the data was read from a file, or use any other
## name that is meaningful to you.  The name is only used when the set of
## loaded prc files is listed.

proc unload_prc_file*(page: ConfigPage): bool {.importcpp: "unload_prc_file(#)".}

proc hash_prc_variables*(hash: HashVal) {.importcpp: "hash_prc_variables(#)".}

proc initModifierButtons*(): ModifierButtons {.importcpp: "ModifierButtons()".}

proc initModifierButtons*(copy: ModifierButtons): ModifierButtons {.importcpp: "ModifierButtons(#)".}

proc `==`*(this: ModifierButtons, other: ModifierButtons): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: ModifierButtons, other: ModifierButtons): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: ModifierButtons, other: ModifierButtons): bool {.importcpp: "#.operator <(#)".}

proc `&`*(this: ModifierButtons, other: ModifierButtons): ModifierButtons {.importcpp: "#.operator &(#)".}

proc `|`*(this: ModifierButtons, other: ModifierButtons): ModifierButtons {.importcpp: "#.operator |(#)".}

proc `&=`*(this: ModifierButtons, other: ModifierButtons): ModifierButtons {.importcpp: "#.operator &=(#)".}

proc `|=`*(this: ModifierButtons, other: ModifierButtons): ModifierButtons {.importcpp: "#.operator |=(#)".}

proc set_button_list*(this: ModifierButtons, other: ModifierButtons) {.importcpp: "#.set_button_list(#)".} ## \
## Sets the list of buttons to watch to be the same as that of the other
## ModifierButtons object.  This makes the lists pointer equivalent (until one
## or the other is later modified).
##
## This will preserve the state of any button that was on the original list
## and is also on the new lists.  Any other buttons will get reset to the
## default state of "up".

proc matches*(this: ModifierButtons, other: ModifierButtons): bool {.importcpp: "#.matches(#)".} ## \
## Returns true if the set of buttons indicated as down by this
## ModifierButtons object is the same set of buttons indicated as down by the
## other ModifierButtons object.  The buttons indicated as up are not
## relevant.

proc add_button*(this: ModifierButtons, button: ButtonHandle): bool {.importcpp: "#.add_button(#)".} ## \
## Adds the indicated button to the set of buttons that will be monitored for
## upness and downness.  Returns true if the button was added, false if it was
## already being monitored or if too many buttons are currently being
## monitored.

proc has_button*(this: ModifierButtons, button: ButtonHandle): bool {.importcpp: "#.has_button(#)".} ## \
## Returns true if the indicated button is in the set of buttons being
## monitored, false otherwise.

proc remove_button*(this: ModifierButtons, button: ButtonHandle): bool {.importcpp: "#.remove_button(#)".} ## \
## Removes the indicated button from the set of buttons being monitored.
## Returns true if the button was removed, false if it was not being monitored
## in the first place.
##
## Unlike the other methods, you cannot remove a button by removing its alias;
## you have to remove exactly the button itself.

proc get_num_buttons*(this: ModifierButtons): int {.importcpp: "#.get_num_buttons()".} ## \
## Returns the number of buttons that the ModifierButtons object is monitoring
## (e.g.  the number of buttons passed to add_button()).

proc get_button*(this: ModifierButtons, index: int): ButtonHandle {.importcpp: "#.get_button(#)".} ## \
## Returns the nth button that the ModifierButtons object is monitoring (the
## nth button passed to add_button()).  This must be in the range 0 <= index <
## get_num_buttons().

proc button_down*(this: ModifierButtons, button: ButtonHandle): bool {.importcpp: "#.button_down(#)".} ## \
## Records that a particular button has been pressed.  If the given button is
## one of the buttons that is currently being monitored, this will update the
## internal state appropriately; otherwise, it will do nothing.  Returns true
## if the button is one that was monitored, or false otherwise.

proc button_up*(this: ModifierButtons, button: ButtonHandle): bool {.importcpp: "#.button_up(#)".} ## \
## Records that a particular button has been released.  If the given button is
## one of the buttons that is currently being monitored, this will update the
## internal state appropriately; otherwise, it will do nothing.  Returns true
## if the button is one that was monitored, or false otherwise.

proc all_buttons_up*(this: ModifierButtons) {.importcpp: "#.all_buttons_up()".} ## \
## Marks all monitored buttons as being in the "up" state.

proc is_down*(this: ModifierButtons, button: ButtonHandle): bool {.importcpp: "#.is_down(#)".} ## \
## Returns true if the indicated button is known to be down, or false if it is
## known to be up or if it is not in the set of buttons being tracked.

proc is_down*(this: ModifierButtons, index: int): bool {.importcpp: "#.is_down(#)".} ## \
## Returns true if the indicated button is known to be down, or false if it is
## known to be up.

proc is_any_down*(this: ModifierButtons): bool {.importcpp: "#.is_any_down()".} ## \
## Returns true if any of the tracked button are known to be down, or false if
## all of them are up.

proc get_prefix*(this: ModifierButtons): string {.importcpp: "nimStringFromStdString(#.get_prefix())", header: stringConversionCode.} ## \
## Returns a string which can be used to prefix any button name or event name
## with the unique set of modifier buttons currently being held.

proc output*(this: ModifierButtons, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes a one-line summary of the buttons known to be down.

proc write*(this: ModifierButtons, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a multi-line summary including all of the buttons being monitored
## and which ones are known to be down.

proc button*(_: typedesc[MouseButton], button_number: int): ButtonHandle {.importcpp: "MouseButton::button(#)", header: "mouseButton.h".} ## \
## Returns the ButtonHandle associated with the particular numbered mouse
## button (zero-based), if there is one, or ButtonHandle::none() if there is
## not.

proc one*(_: typedesc[MouseButton]): ButtonHandle {.importcpp: "MouseButton::one()", header: "mouseButton.h".} ## \
## Returns the ButtonHandle associated with the first mouse button.

proc two*(_: typedesc[MouseButton]): ButtonHandle {.importcpp: "MouseButton::two()", header: "mouseButton.h".} ## \
## Returns the ButtonHandle associated with the second mouse button.

proc three*(_: typedesc[MouseButton]): ButtonHandle {.importcpp: "MouseButton::three()", header: "mouseButton.h".} ## \
## Returns the ButtonHandle associated with the third mouse button.

proc four*(_: typedesc[MouseButton]): ButtonHandle {.importcpp: "MouseButton::four()", header: "mouseButton.h".} ## \
## Returns the ButtonHandle associated with the fourth mouse button.

proc five*(_: typedesc[MouseButton]): ButtonHandle {.importcpp: "MouseButton::five()", header: "mouseButton.h".} ## \
## Returns the ButtonHandle associated with the fifth mouse button.

proc wheel_up*(_: typedesc[MouseButton]): ButtonHandle {.importcpp: "MouseButton::wheel_up()", header: "mouseButton.h".} ## \
## Returns the ButtonHandle generated when the mouse wheel is rolled one notch
## upwards.

proc wheel_down*(_: typedesc[MouseButton]): ButtonHandle {.importcpp: "MouseButton::wheel_down()", header: "mouseButton.h".} ## \
## Returns the ButtonHandle generated when the mouse wheel is rolled one notch
## downwards.

proc wheel_left*(_: typedesc[MouseButton]): ButtonHandle {.importcpp: "MouseButton::wheel_left()", header: "mouseButton.h".} ## \
## Returns the ButtonHandle generated when the mouse is scrolled to the left.
## Usually, you'll only find the horizontal scroll on laptops.

proc wheel_right*(_: typedesc[MouseButton]): ButtonHandle {.importcpp: "MouseButton::wheel_right()", header: "mouseButton.h".} ## \
## Returns the ButtonHandle generated when the mouse is scrolled to the right.
## Usually, you'll only find the horizontal scroll on laptops.

proc is_mouse_button*(_: typedesc[MouseButton], button: ButtonHandle): bool {.importcpp: "MouseButton::is_mouse_button(#)", header: "mouseButton.h".} ## \
## Returns true if the indicated ButtonHandle is a mouse button, false if it
## is some other kind of button.

proc initMouseButton*(): MouseButton {.importcpp: "MouseButton()".}

proc initMouseButton*(param0: MouseButton): MouseButton {.importcpp: "MouseButton(#)".}

proc get_x*(this: PointerData): float64 {.importcpp: "#.get_x()".}

proc get_y*(this: PointerData): float64 {.importcpp: "#.get_y()".}

proc get_in_window*(this: PointerData): bool {.importcpp: "#.get_in_window()".} ## \
## If this returns false, the pointer is not currently present in the window
## and the values returned by get_x() and get_y() may not be meaningful.

proc initPointerData*(): PointerData {.importcpp: "PointerData()".}

proc initPointerData*(param0: PointerData): PointerData {.importcpp: "PointerData(#)".}

proc get_node_ref_count*(this: NodeCachedReferenceCount): int {.importcpp: "#->get_node_ref_count()".} ## \
## Returns the current reference count.

proc node_ref*(this: NodeCachedReferenceCount) {.importcpp: "#->node_ref()".} ## \
## Explicitly increments the reference count.
##
## This function is const, even though it changes the object, because
## generally fiddling with an object's reference count isn't considered part
## of fiddling with the object.  An object might be const in other ways, but
## we still need to accurately count the number of references to it.

proc node_unref*(this: NodeCachedReferenceCount): bool {.importcpp: "#->node_unref()".} ## \
## Explicitly decrements the node reference count and the normal reference
## count simultaneously.
##
## The return value is true if the new reference count is nonzero, false if it
## is zero.

proc test_ref_count_integrity*(this: NodeCachedReferenceCount): bool {.importcpp: "#->test_ref_count_integrity()".} ## \
## Does some easy checks to make sure that the reference count isn't
## completely bogus.

proc get_referenced_bits*(this: NodeCachedReferenceCount): int {.importcpp: "#->get_referenced_bits()".} ## \
## Returns the union of the values defined in the Referenced enum that
## represents the various things that appear to be holding a pointer to this
## object.
##
## If R_node is included, at least one node is holding a pointer; if R_cache
## is included, at least one cache element is.

proc get_class_type*(_: typedesc[NodeCachedReferenceCount]): TypeHandle {.importcpp: "NodeCachedReferenceCount::get_class_type()", header: "nodeCachedReferenceCount.h".}

proc initSparseArray*(): SparseArray {.importcpp: "SparseArray()".}

proc initSparseArray*(`from`: BitArray): SparseArray {.importcpp: "SparseArray(#)".}

proc initSparseArray*(param0: SparseArray): SparseArray {.importcpp: "SparseArray(#)".}

proc all_on*(_: typedesc[SparseArray]): SparseArray {.importcpp: "SparseArray::all_on()", header: "sparseArray.h".} ## \
## Returns a SparseArray with an infinite array of bits, all on.

proc all_off*(_: typedesc[SparseArray]): SparseArray {.importcpp: "SparseArray::all_off()", header: "sparseArray.h".} ## \
## Returns a SparseArray whose bits are all off.

proc lower_on*(_: typedesc[SparseArray], on_bits: int): SparseArray {.importcpp: "SparseArray::lower_on(#)", header: "sparseArray.h".} ## \
## Returns a SparseArray whose lower on_bits bits are on.

proc bit*(_: typedesc[SparseArray], index: int): SparseArray {.importcpp: "SparseArray::bit(#)", header: "sparseArray.h".} ## \
## Returns a SparseArray with only the indicated bit on.

proc range*(_: typedesc[SparseArray], low_bit: int, size: int): SparseArray {.importcpp: "SparseArray::range(#, #)", header: "sparseArray.h".} ## \
## Returns a SparseArray whose size bits, beginning at low_bit, are on.

proc has_max_num_bits*(_: typedesc[SparseArray]): bool {.importcpp: "SparseArray::has_max_num_bits()", header: "sparseArray.h".} ## \
## Returns true if there is a maximum number of bits that may be stored in
## this structure, false otherwise.  If this returns true, the number may be
## queried in get_max_num_bits().
##
## This method always returns false.  The SparseArray has no maximum number of
## bits.  This method is defined so generic programming algorithms can use
## BitMask or SparseArray interchangeably.

proc get_max_num_bits*(_: typedesc[SparseArray]): int {.importcpp: "SparseArray::get_max_num_bits()", header: "sparseArray.h".} ## \
## If get_max_num_bits() returned true, this method may be called to return
## the maximum number of bits that may be stored in this structure.  It is an
## error to call this if get_max_num_bits() return false.
##
## It is always an error to call this method.  The SparseArray has no maximum
## number of bits.  This method is defined so generic programming algorithms
## can use BitMask or SparseArray interchangeably.

proc get_num_bits*(this: SparseArray): int {.importcpp: "#.get_num_bits()".} ## \
## Returns the current number of possibly different bits in this array.  There
## are actually an infinite number of bits, but every bit higher than this bit
## will have the same value, either 0 or 1 (see get_highest_bits()).
##
## This number may grow and/or shrink automatically as needed.

proc get_bit*(this: SparseArray, index: int): bool {.importcpp: "#.get_bit(#)".} ## \
## Returns true if the nth bit is set, false if it is cleared.  It is valid
## for n to increase beyond get_num_bits(), but the return value
## get_num_bits() will always be the same.

proc set_bit*(this: SparseArray, index: int) {.importcpp: "#.set_bit(#)".} ## \
## Sets the nth bit on.  If n >= get_num_bits(), this automatically extends
## the array.

proc clear_bit*(this: SparseArray, index: int) {.importcpp: "#.clear_bit(#)".} ## \
## Sets the nth bit off.  If n >= get_num_bits(), this automatically extends
## the array.

proc set_bit_to*(this: SparseArray, index: int, value: bool) {.importcpp: "#.set_bit_to(#, #)".} ## \
## Sets the nth bit either on or off, according to the indicated bool value.

proc get_highest_bits*(this: SparseArray): bool {.importcpp: "#.get_highest_bits()".} ## \
## Returns true if the infinite set of bits beyond get_num_bits() are all on,
## or false of they are all off.

proc is_zero*(this: SparseArray): bool {.importcpp: "#.is_zero()".} ## \
## Returns true if the entire bitmask is zero, false otherwise.

proc is_all_on*(this: SparseArray): bool {.importcpp: "#.is_all_on()".} ## \
## Returns true if the entire bitmask is one, false otherwise.

proc has_any_of*(this: SparseArray, low_bit: int, size: int): bool {.importcpp: "#.has_any_of(#, #)".} ## \
## Returns true if any bit in the indicated range is set, false otherwise.

proc has_all_of*(this: SparseArray, low_bit: int, size: int): bool {.importcpp: "#.has_all_of(#, #)".} ## \
## Returns true if all bits in the indicated range are set, false otherwise.

proc set_range*(this: SparseArray, low_bit: int, size: int) {.importcpp: "#.set_range(#, #)".} ## \
## Sets the indicated range of bits on.

proc clear_range*(this: SparseArray, low_bit: int, size: int) {.importcpp: "#.clear_range(#, #)".} ## \
## Sets the indicated range of bits off.

proc set_range_to*(this: SparseArray, value: bool, low_bit: int, size: int) {.importcpp: "#.set_range_to(#, #, #)".} ## \
## Sets the indicated range of bits to either on or off.

proc get_num_on_bits*(this: SparseArray): int {.importcpp: "#.get_num_on_bits()".} ## \
## Returns the number of bits that are set to 1 in the array.  Returns -1 if
## there are an infinite number of 1 bits.

proc get_num_off_bits*(this: SparseArray): int {.importcpp: "#.get_num_off_bits()".} ## \
## Returns the number of bits that are set to 0 in the array.  Returns -1 if
## there are an infinite number of 0 bits.

proc get_lowest_on_bit*(this: SparseArray): int {.importcpp: "#.get_lowest_on_bit()".} ## \
## Returns the index of the lowest 1 bit in the array.  Returns -1 if there
## are no 1 bits or if there are an infinite number of 1 bits.

proc get_lowest_off_bit*(this: SparseArray): int {.importcpp: "#.get_lowest_off_bit()".} ## \
## Returns the index of the lowest 0 bit in the array.  Returns -1 if there
## are no 0 bits or if there are an infinite number of 1 bits.

proc get_highest_on_bit*(this: SparseArray): int {.importcpp: "#.get_highest_on_bit()".} ## \
## Returns the index of the highest 1 bit in the array.  Returns -1 if there
## are no 1 bits or if there an infinite number of 1 bits.

proc get_highest_off_bit*(this: SparseArray): int {.importcpp: "#.get_highest_off_bit()".} ## \
## Returns the index of the highest 0 bit in the array.  Returns -1 if there
## are no 0 bits or if there an infinite number of 1 bits.

proc get_next_higher_different_bit*(this: SparseArray, low_bit: int): int {.importcpp: "#.get_next_higher_different_bit(#)".} ## \
## Returns the index of the next bit in the array, above low_bit, whose value
## is different that the value of low_bit.  Returns low_bit again if all bits
## higher than low_bit have the same value.
##
## This can be used to quickly iterate through all of the bits in the array.

proc invert_in_place*(this: SparseArray) {.importcpp: "#.invert_in_place()".} ## \
## Inverts all the bits in the SparseArray.  This is equivalent to array =
## ~array.

proc has_bits_in_common*(this: SparseArray, other: SparseArray): bool {.importcpp: "#.has_bits_in_common(#)".} ## \
## Returns true if this SparseArray has any "one" bits in common with the
## other one, false otherwise.
##
## This is equivalent to (array & other) != 0, but may be faster.

proc clear*(this: SparseArray) {.importcpp: "#.clear()".} ## \
## Sets all the bits in the SparseArray off.

proc output*(this: SparseArray, `out`: ostream) {.importcpp: "#.output(#)".}

proc `==`*(this: SparseArray, other: SparseArray): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: SparseArray, other: SparseArray): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: SparseArray, other: SparseArray): bool {.importcpp: "#.operator <(#)".}

proc compare_to*(this: SparseArray, other: SparseArray): int {.importcpp: "#.compare_to(#)".} ## \
## Returns a number less than zero if this SparseArray sorts before the
## indicated other SparseArray, greater than zero if it sorts after, or 0 if
## they are equivalent.  This is based on the same ordering defined by
## operator <.

proc `&`*(this: SparseArray, other: SparseArray): SparseArray {.importcpp: "#.operator &(#)".}

proc `|`*(this: SparseArray, other: SparseArray): SparseArray {.importcpp: "#.operator |(#)".}

proc `^`*(this: SparseArray, other: SparseArray): SparseArray {.importcpp: "#.operator ^(#)".}

proc `~`*(this: SparseArray): SparseArray {.importcpp: "#.operator ~()".}

proc `<<`*(this: SparseArray, shift: int): SparseArray {.importcpp: "#.operator <<(#)".}

proc `>>`*(this: SparseArray, shift: int): SparseArray {.importcpp: "#.operator >>(#)".}

proc `&=`*(this: SparseArray, other: SparseArray): SparseArray {.importcpp: "#.operator &=(#)".}

proc `|=`*(this: SparseArray, other: SparseArray): SparseArray {.importcpp: "#.operator |=(#)".}

proc `^=`*(this: SparseArray, other: SparseArray): SparseArray {.importcpp: "#.operator ^=(#)".}

proc `<<=`*(this: SparseArray, shift: int): SparseArray {.importcpp: "#.operator <<=(#)".}

proc `>>=`*(this: SparseArray, shift: int): SparseArray {.importcpp: "#.operator >>=(#)".}

proc is_inverse*(this: SparseArray): bool {.importcpp: "#.is_inverse()".} ## \
## If this is true, the SparseArray is actually defined as a list of subranges
## of integers that are *not* in the set.  If this is false (the default),
## then the subranges define the integers that *are* in the set.  This affects
## the interpretation of the values returned by iterating through
## get_num_subranges().

proc get_num_subranges*(this: SparseArray): clonglong {.importcpp: "#.get_num_subranges()".} ## \
## Returns the number of separate subranges stored in the SparseArray.  You
## can use this limit to iterate through the subranges, calling
## get_subrange_begin() and get_subrange_end() for each one.
##
## Also see is_inverse().

proc get_subrange_begin*(this: SparseArray, n: clonglong): int {.importcpp: "#.get_subrange_begin(#)".} ## \
## Returns the first numeric element in the nth subrange.
##
## Also see is_inverse().

proc get_subrange_end*(this: SparseArray, n: clonglong): int {.importcpp: "#.get_subrange_end(#)".} ## \
## Returns the last numeric element, plus one, in the nth subrange.
##
## Also see is_inverse().

proc get_class_type*(_: typedesc[SparseArray]): TypeHandle {.importcpp: "SparseArray::get_class_type()", header: "sparseArray.h".}

proc get_value_type*(this: ParamValueBase): TypeHandle {.importcpp: "#->get_value_type()".} ## \
## Returns the type of the underlying value.

proc output*(this: ParamValueBase, `out`: ostream) {.importcpp: "#->output(#)".}

proc get_class_type*(_: typedesc[ParamValueBase]): TypeHandle {.importcpp: "ParamValueBase::get_class_type()", header: "paramValueBase.h".}

proc newParamTypedRefCount*(value: TypedReferenceCount): ParamTypedRefCount {.importcpp: "new ParamTypedRefCount(#)".}

proc get_value*(this: ParamTypedRefCount): TypedReferenceCount {.importcpp: "#->get_value()".} ## \
## Retrieves the value stored in the parameter.

proc get_class_type*(_: typedesc[ParamTypedRefCount]): TypeHandle {.importcpp: "ParamTypedRefCount::get_class_type()", header: "paramTypedRefCount.h".}

proc get_class_type*(_: typedesc[WritableConfigurable]): TypeHandle {.importcpp: "WritableConfigurable::get_class_type()", header: "writableConfigurable.h".}

proc initUniqueIdAllocator*(param0: UniqueIdAllocator): UniqueIdAllocator {.importcpp: "UniqueIdAllocator(#)".}

proc initUniqueIdAllocator*(min: int, max: int): UniqueIdAllocator {.importcpp: "UniqueIdAllocator(#, #)".} ## \
## Create a free id pool in the range [min:max].

proc initUniqueIdAllocator*(min: int): UniqueIdAllocator {.importcpp: "UniqueIdAllocator(#)".} ## \
## Create a free id pool in the range [min:max].

proc initUniqueIdAllocator*(): UniqueIdAllocator {.importcpp: "UniqueIdAllocator()".} ## \
## Create a free id pool in the range [min:max].

proc allocate*(this: UniqueIdAllocator): int {.importcpp: "#.allocate()".} ## \
## Returns an id between _min and _max (that were passed to the constructor).
## IndexEnd is returned if no ids are available.

proc initial_reserve_id*(this: UniqueIdAllocator, id: int) {.importcpp: "#.initial_reserve_id(#)".} ## \
## This may be called to mark a particular id as having already been allocated
## (for instance, by a prior pass).  The specified id is removed from the
## available pool.
##
## Because of the limitations of this algorithm, this is most efficient when
## it is called before the first call to allocate(), and when all the calls to
## initial_reserve_id() are made in descending order by id.  However, this is
## a performance warning only; if performance is not an issue, any id may be
## reserved at any time.

proc free*(this: UniqueIdAllocator, index: int) {.importcpp: "#.free(#)".} ## \
## Free an allocated index (index must be between _min and _max that were
## passed to the constructor).

proc fraction_used*(this: UniqueIdAllocator): float32 {.importcpp: "#.fraction_used()".} ## \
## return the decimal fraction of the pool that is used.  The range is 0 to
## 1.0 (e.g.  75% would be 0.75).

proc output*(this: UniqueIdAllocator, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## ...intended for debugging only.

proc write*(this: UniqueIdAllocator, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## ...intended for debugging only.

proc newFilterProperties*(): FilterProperties {.importcpp: "new FilterProperties()".}

proc newFilterProperties*(param0: FilterProperties): FilterProperties {.importcpp: "new FilterProperties(#)".}

proc clear*(this: FilterProperties) {.importcpp: "#->clear()".} ## \
## Removes all DSP postprocessing.

proc add_lowpass*(this: FilterProperties, cutoff_freq: float32, resonance_q: float32) {.importcpp: "#->add_lowpass(#, #)".} ## \
## Add a lowpass filter to the end of the DSP chain.

proc add_highpass*(this: FilterProperties, cutoff_freq: float32, resonance_q: float32) {.importcpp: "#->add_highpass(#, #)".} ## \
## Add a highpass filter to the end of the DSP chain.

proc add_echo*(this: FilterProperties, drymix: float32, wetmix: float32, delay: float32, decayratio: float32) {.importcpp: "#->add_echo(#, #, #, #)".} ## \
## Add a echo filter to the end of the DSP chain.

proc add_flange*(this: FilterProperties, drymix: float32, wetmix: float32, depth: float32, rate: float32) {.importcpp: "#->add_flange(#, #, #, #)".} ## \
## Add a flange filter to the end of the DSP chain.

proc add_distort*(this: FilterProperties, level: float32) {.importcpp: "#->add_distort(#)".} ## \
## Add a distort filter to the end of the DSP chain.

proc add_normalize*(this: FilterProperties, fadetime: float32, threshold: float32, maxamp: float32) {.importcpp: "#->add_normalize(#, #, #)".} ## \
## Add a normalize filter to the end of the DSP chain.

proc add_parameq*(this: FilterProperties, center_freq: float32, bandwidth: float32, gain: float32) {.importcpp: "#->add_parameq(#, #, #)".} ## \
## Add a parameq filter to the end of the DSP chain.

proc add_pitchshift*(this: FilterProperties, pitch: float32, fftsize: float32, overlap: float32) {.importcpp: "#->add_pitchshift(#, #, #)".} ## \
## Add a pitchshift filter to the end of the DSP chain.

proc add_chorus*(this: FilterProperties, drymix: float32, wet1: float32, wet2: float32, wet3: float32, delay: float32, rate: float32, depth: float32) {.importcpp: "#->add_chorus(#, #, #, #, #, #, #)".} ## \
## Add a chorus filter to the end of the DSP chain.

proc add_sfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32, reflectionslevel: float32, reflectionsdelay: float32, reverblevel: float32, reverbdelay: float32, diffusion: float32, density: float32, hfreference: float32, roomlf: float32, lfreference: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #, #, #, #, #, #, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc add_sfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32, reflectionslevel: float32, reflectionsdelay: float32, reverblevel: float32, reverbdelay: float32, diffusion: float32, density: float32, hfreference: float32, roomlf: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #, #, #, #, #, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc add_sfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32, reflectionslevel: float32, reflectionsdelay: float32, reverblevel: float32, reverbdelay: float32, diffusion: float32, density: float32, hfreference: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #, #, #, #, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc add_sfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32, reflectionslevel: float32, reflectionsdelay: float32, reverblevel: float32, reverbdelay: float32, diffusion: float32, density: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #, #, #, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc add_sfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32, reflectionslevel: float32, reflectionsdelay: float32, reverblevel: float32, reverbdelay: float32, diffusion: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #, #, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc add_sfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32, reflectionslevel: float32, reflectionsdelay: float32, reverblevel: float32, reverbdelay: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc add_sfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32, reflectionslevel: float32, reflectionsdelay: float32, reverblevel: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc add_sfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32, reflectionslevel: float32, reflectionsdelay: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc add_sfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32, reflectionslevel: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc add_sfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc add_sfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc add_sfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32) {.importcpp: "#->add_sfxreverb(#, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc add_sfxreverb*(this: FilterProperties, drylevel: float32, room: float32) {.importcpp: "#->add_sfxreverb(#, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc add_sfxreverb*(this: FilterProperties, drylevel: float32) {.importcpp: "#->add_sfxreverb(#)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc add_sfxreverb*(this: FilterProperties) {.importcpp: "#->add_sfxreverb()".} ## \
## Add a reverb filter to the end of the DSP chain.

proc add_compress*(this: FilterProperties, threshold: float32, attack: float32, release: float32, gainmakeup: float32) {.importcpp: "#->add_compress(#, #, #, #)".} ## \
## Add a compress filter to the end of the DSP chain.

proc get_class_type*(_: typedesc[FilterProperties]): TypeHandle {.importcpp: "FilterProperties::get_class_type()", header: "filterProperties.h".}

proc play*(this: AudioSound) {.importcpp: "#->play()".} ## \
## For best compatibility, set the loop_count, volume, and balance, prior to
## calling play().  You may set them while they're playing, but it's
## implementation specific whether you get the results.  - Calling play() a
## second time on the same sound before it is finished will start the sound
## again (creating a skipping or stuttering effect).

proc stop*(this: AudioSound) {.importcpp: "#->stop()".}

proc set_loop*(this: AudioSound, loop: bool) {.importcpp: "#->set_loop(#)".} ## \
## loop: false = play once; true = play forever.  inits to false.

proc set_loop*(this: AudioSound) {.importcpp: "#->set_loop()".} ## \
## loop: false = play once; true = play forever.  inits to false.

proc get_loop*(this: AudioSound): bool {.importcpp: "#->get_loop()".}

proc set_loop_count*(this: AudioSound, loop_count: int) {.importcpp: "#->set_loop_count(#)".} ## \
## loop_count: 0 = forever; 1 = play once; n = play n times.  inits to 1.

proc set_loop_count*(this: AudioSound) {.importcpp: "#->set_loop_count()".} ## \
## loop_count: 0 = forever; 1 = play once; n = play n times.  inits to 1.

proc get_loop_count*(this: AudioSound): int {.importcpp: "#->get_loop_count()".}

proc set_time*(this: AudioSound, start_time: float32) {.importcpp: "#->set_time(#)".} ## \
## Control time position within the sound, in seconds.  This is similar (in
## concept) to the seek position within a file.  The value starts at 0.0 (the
## default) and ends at the value given by the length() method.
##
## The current time position will not change while the sound is playing; you
## must call play() again to effect the change.  To play the same sound from
## a time offset a second time, explicitly set the time position again.  When
## looping, the second and later loops will start from the beginning of the
## sound.
##
## If a sound is playing, calling get_time() repeatedly will return different
## results over time.  e.g.
## @code
## PN_stdfloat percent_complete = s.get_time() / s.length();
## @endcode

proc set_time*(this: AudioSound) {.importcpp: "#->set_time()".} ## \
## Control time position within the sound, in seconds.  This is similar (in
## concept) to the seek position within a file.  The value starts at 0.0 (the
## default) and ends at the value given by the length() method.
##
## The current time position will not change while the sound is playing; you
## must call play() again to effect the change.  To play the same sound from
## a time offset a second time, explicitly set the time position again.  When
## looping, the second and later loops will start from the beginning of the
## sound.
##
## If a sound is playing, calling get_time() repeatedly will return different
## results over time.  e.g.
## @code
## PN_stdfloat percent_complete = s.get_time() / s.length();
## @endcode

proc get_time*(this: AudioSound): float32 {.importcpp: "#->get_time()".}

proc set_volume*(this: AudioSound, volume: float32) {.importcpp: "#->set_volume(#)".} ## \
## 0 = minimum; 1.0 = maximum.  inits to 1.0.

proc set_volume*(this: AudioSound) {.importcpp: "#->set_volume()".} ## \
## 0 = minimum; 1.0 = maximum.  inits to 1.0.

proc get_volume*(this: AudioSound): float32 {.importcpp: "#->get_volume()".}

proc set_balance*(this: AudioSound, balance_right: float32) {.importcpp: "#->set_balance(#)".} ## \
## -1.0 is hard left 0.0 is centered 1.0 is hard right inits to 0.0.

proc set_balance*(this: AudioSound) {.importcpp: "#->set_balance()".} ## \
## -1.0 is hard left 0.0 is centered 1.0 is hard right inits to 0.0.

proc get_balance*(this: AudioSound): float32 {.importcpp: "#->get_balance()".}

proc set_play_rate*(this: AudioSound, play_rate: float32) {.importcpp: "#->set_play_rate(#)".} ## \
## play_rate is any positive PN_stdfloat value.  inits to 1.0.

proc set_play_rate*(this: AudioSound) {.importcpp: "#->set_play_rate()".} ## \
## play_rate is any positive PN_stdfloat value.  inits to 1.0.

proc get_play_rate*(this: AudioSound): float32 {.importcpp: "#->get_play_rate()".}

proc set_active*(this: AudioSound, flag: bool) {.importcpp: "#->set_active(#)".} ## \
## inits to manager's state.

proc set_active*(this: AudioSound) {.importcpp: "#->set_active()".} ## \
## inits to manager's state.

proc get_active*(this: AudioSound): bool {.importcpp: "#->get_active()".}

proc set_finished_event*(this: AudioSound, event: string) {.importcpp: "#->set_finished_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Set (or clear) the event that will be thrown when the sound finishes
## playing.  To clear the event, pass an empty string.

proc get_finished_event*(this: AudioSound): string {.importcpp: "nimStringFromStdString(#->get_finished_event())", header: stringConversionCode.}

proc get_name*(this: AudioSound): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## There is no set_name(), this is intentional.

proc length*(this: AudioSound): float32 {.importcpp: "#->length()".} ## \
## return: playing time in seconds.

proc set_3d_attributes*(this: AudioSound, px: float32, py: float32, pz: float32, vx: float32, vy: float32, vz: float32) {.importcpp: "#->set_3d_attributes(#, #, #, #, #, #)".} ## \
## Controls the position of this sound's emitter.  px, py and pz are the
## emitter's position.  vx, vy and vz are the emitter's velocity in UNITS
## PER SECOND (default: meters).

proc set_3d_min_distance*(this: AudioSound, dist: float32) {.importcpp: "#->set_3d_min_distance(#)".} ## \
## Controls the distance (in units) that this sound begins to fall off.
## Also affects the rate it falls off.  Default is 1.0 CloserFaster, <1.0
## FartherSlower, >1.0

proc get_3d_min_distance*(this: AudioSound): float32 {.importcpp: "#->get_3d_min_distance()".}

proc set_3d_max_distance*(this: AudioSound, dist: float32) {.importcpp: "#->set_3d_max_distance(#)".} ## \
## Controls the maximum distance (in units) that this sound stops falling
## off.  The sound does not stop at that point, it just doesn't get any
## quieter.  You should rarely need to adjust this.  Default is 1000000000.0

proc get_3d_max_distance*(this: AudioSound): float32 {.importcpp: "#->get_3d_max_distance()".}

proc get_speaker_mix*(this: AudioSound, speaker: int): float32 {.importcpp: "#->get_speaker_mix(#)".} ## \
## speaker_mix and speaker_level(s) serve the same purpose.
## speaker_mix is for use with FMOD. speaker_level(s) is for use with
## Miles.  Both interfaces exist because of a significant difference in the
## two APIs.  Hopefully the difference can be reconciled into a single
## interface at some point.

proc set_speaker_mix*(this: AudioSound, frontleft: float32, frontright: float32, center: float32, sub: float32, backleft: float32, backright: float32, sideleft: float32, sideright: float32) {.importcpp: "#->set_speaker_mix(#, #, #, #, #, #, #, #)".}

proc get_speaker_level*(this: AudioSound, index: int): float32 {.importcpp: "#->get_speaker_level(#)".}

proc set_speaker_levels*(this: AudioSound, level1: float32, level2: float32, level3: float32, level4: float32, level5: float32, level6: float32, level7: float32, level8: float32, level9: float32) {.importcpp: "#->set_speaker_levels(#, #, #, #, #, #, #, #, #)".}

proc set_speaker_levels*(this: AudioSound, level1: float32, level2: float32, level3: float32, level4: float32, level5: float32, level6: float32, level7: float32, level8: float32) {.importcpp: "#->set_speaker_levels(#, #, #, #, #, #, #, #)".}

proc set_speaker_levels*(this: AudioSound, level1: float32, level2: float32, level3: float32, level4: float32, level5: float32, level6: float32, level7: float32) {.importcpp: "#->set_speaker_levels(#, #, #, #, #, #, #)".}

proc set_speaker_levels*(this: AudioSound, level1: float32, level2: float32, level3: float32, level4: float32, level5: float32, level6: float32) {.importcpp: "#->set_speaker_levels(#, #, #, #, #, #)".}

proc set_speaker_levels*(this: AudioSound, level1: float32, level2: float32, level3: float32, level4: float32, level5: float32) {.importcpp: "#->set_speaker_levels(#, #, #, #, #)".}

proc set_speaker_levels*(this: AudioSound, level1: float32, level2: float32, level3: float32, level4: float32) {.importcpp: "#->set_speaker_levels(#, #, #, #)".}

proc set_speaker_levels*(this: AudioSound, level1: float32, level2: float32, level3: float32) {.importcpp: "#->set_speaker_levels(#, #, #)".}

proc set_speaker_levels*(this: AudioSound, level1: float32, level2: float32) {.importcpp: "#->set_speaker_levels(#, #)".}

proc set_speaker_levels*(this: AudioSound, level1: float32) {.importcpp: "#->set_speaker_levels(#)".}

proc get_priority*(this: AudioSound): int {.importcpp: "#->get_priority()".}

proc set_priority*(this: AudioSound, priority: int) {.importcpp: "#->set_priority(#)".}

proc configure_filters*(this: AudioSound, config: FilterProperties): bool {.importcpp: "#->configure_filters(#)".}

proc output*(this: AudioSound, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: AudioSound, `out`: ostream) {.importcpp: "#->write(#)".}

proc get_class_type*(_: typedesc[AudioSound]): TypeHandle {.importcpp: "AudioSound::get_class_type()", header: "audioSound.h".}

proc get_speaker_setup*(this: AudioManager): int {.importcpp: "#->get_speaker_setup()".}

proc configure_filters*(this: AudioManager, config: FilterProperties): bool {.importcpp: "#->configure_filters(#)".}

proc create_AudioManager*(_: typedesc[AudioManager]): AudioManager {.importcpp: "AudioManager::create_AudioManager()", header: "audioManager.h".}

proc shutdown*(this: AudioManager) {.importcpp: "#->shutdown()".}

proc is_valid*(this: AudioManager): bool {.importcpp: "#->is_valid()".} ## \
## If you're interested in knowing whether this audio manager is valid,
## here's the call to do it.  It is not necessary to check whether the audio
## manager is valid before making other calls.  You are free to use an
## invalid sound manager, you may get silent sounds from it though.  The
## sound manager and the sounds it creates should not crash the application
## even when the objects are not valid.

proc get_sound*(this: AudioManager, file_name: Filename, positional: bool, mode: int): AudioSound {.importcpp: "#->get_sound(#, #, #)".} ## \
## Get a sound:

proc get_sound*(this: AudioManager, file_name: Filename, positional: bool): AudioSound {.importcpp: "#->get_sound(#, #)".} ## \
## Get a sound:

proc get_sound*(this: AudioManager, file_name: Filename): AudioSound {.importcpp: "#->get_sound(#)".} ## \
## Get a sound:

proc get_sound*(this: AudioManager, source: MovieAudio, positional: bool, mode: int): AudioSound {.importcpp: "#->get_sound(#, #, #)".}

proc get_sound*(this: AudioManager, source: MovieAudio, positional: bool): AudioSound {.importcpp: "#->get_sound(#, #)".}

proc get_sound*(this: AudioManager, source: MovieAudio): AudioSound {.importcpp: "#->get_sound(#)".}

proc get_null_sound*(this: AudioManager): AudioSound {.importcpp: "#->get_null_sound()".}

proc uncache_sound*(this: AudioManager, file_name: Filename) {.importcpp: "#->uncache_sound(#)".} ## \
## Tell the AudioManager there is no need to keep this one cached.  This
## doesn't break any connection between AudioSounds that have already given
## by get_sound() from this manager.  It's only affecting whether the
## AudioManager keeps a copy of the sound in its poolcache.

proc clear_cache*(this: AudioManager) {.importcpp: "#->clear_cache()".}

proc set_cache_limit*(this: AudioManager, count: int) {.importcpp: "#->set_cache_limit(#)".}

proc get_cache_limit*(this: AudioManager): int {.importcpp: "#->get_cache_limit()".}

proc set_volume*(this: AudioManager, volume: float32) {.importcpp: "#->set_volume(#)".} ## \
## Control volume: FYI: If you start a sound with the volume off and turn
## the volume up later, you'll hear the sound playing at that late point.  0
## = minimum; 1.0 = maximum.  inits to 1.0.

proc get_volume*(this: AudioManager): float32 {.importcpp: "#->get_volume()".}

proc set_active*(this: AudioManager, flag: bool) {.importcpp: "#->set_active(#)".} ## \
## Turn the manager on or off.  If you play a sound while the manager is
## inactive, it won't start.  If you deactivate the manager while sounds are
## playing, they'll stop.  If you activate the manager while looping sounds
## are playing (those that have a loop_count of zero), they will start
## playing from the beginning of their loop.  Defaults to true.

proc get_active*(this: AudioManager): bool {.importcpp: "#->get_active()".}

proc set_concurrent_sound_limit*(this: AudioManager, limit: int) {.importcpp: "#->set_concurrent_sound_limit(#)".} ## \
## This controls the number of sounds that you allow at once.  This is more
## of a user choice -- it avoids talk over and the creation of a cacophony.
## It can also be used to help performance.  0 == unlimited.  1 == mutually
## exclusive (one sound at a time).  Which is an example of: n == allow n
## sounds to be playing at the same time.

proc set_concurrent_sound_limit*(this: AudioManager) {.importcpp: "#->set_concurrent_sound_limit()".} ## \
## This controls the number of sounds that you allow at once.  This is more
## of a user choice -- it avoids talk over and the creation of a cacophony.
## It can also be used to help performance.  0 == unlimited.  1 == mutually
## exclusive (one sound at a time).  Which is an example of: n == allow n
## sounds to be playing at the same time.

proc get_concurrent_sound_limit*(this: AudioManager): int {.importcpp: "#->get_concurrent_sound_limit()".}

proc reduce_sounds_playing_to*(this: AudioManager, count: int) {.importcpp: "#->reduce_sounds_playing_to(#)".} ## \
## This is likely to be a utility function for the concurrent_sound_limit
## options.  It is exposed as an API, because it's reasonable that it may be
## useful to be here.  It reduces the number of concurrently playing sounds
## to count by some implementation specific means.  If the number of sounds
## currently playing is at or below count then there is no effect.

proc stop_all_sounds*(this: AudioManager) {.importcpp: "#->stop_all_sounds()".} ## \
## Stop playback on all sounds managed by this manager.  This is effectively
## the same as reduce_sounds_playing_to(0), but this call may be for
## efficient on some implementations.

proc update*(this: AudioManager) {.importcpp: "#->update()".} ## \
## This should be called every frame.  Failure to call could cause problems.

proc audio_3d_set_listener_attributes*(this: AudioManager, px: float32, py: float32, pz: float32, vx: float32, vy: float32, vz: float32, fx: float32, fy: float32, fz: float32, ux: float32, uy: float32, uz: float32) {.importcpp: "#->audio_3d_set_listener_attributes(#, #, #, #, #, #, #, #, #, #, #, #)".} ## \
## This controls the "set of ears" that listens to 3D spacialized sound px,
## py, pz are position coordinates.  vx, vy, vz are a velocity vector in
## UNITS PER SECOND (default: meters). fx, fy and fz are the respective
## components of a unit forward-vector ux, uy and uz are the respective
## components of a unit up-vector

proc audio_3d_set_distance_factor*(this: AudioManager, factor: float32) {.importcpp: "#->audio_3d_set_distance_factor(#)".} ## \
## Control the "relative scale that sets the distance factor" units for 3D
## spacialized audio. This is a float in units-per-meter. Default value is
## 1.0, which means that Panda units are understood as meters; for e.g.
## feet, set 3.28. This factor is applied only to Fmod and OpenAL at the
## moment.

proc audio_3d_get_distance_factor*(this: AudioManager): float32 {.importcpp: "#->audio_3d_get_distance_factor()".}

proc audio_3d_set_doppler_factor*(this: AudioManager, factor: float32) {.importcpp: "#->audio_3d_set_doppler_factor(#)".} ## \
## Control the presence of the Doppler effect.  Default is 1.0 Exaggerated
## Doppler, use >1.0 Diminshed Doppler, use <1.0

proc audio_3d_get_doppler_factor*(this: AudioManager): float32 {.importcpp: "#->audio_3d_get_doppler_factor()".}

proc audio_3d_set_drop_off_factor*(this: AudioManager, factor: float32) {.importcpp: "#->audio_3d_set_drop_off_factor(#)".} ## \
## Exaggerate or diminish the effect of distance on sound.  Default is 1.0
## Valid range is 0 to 10 Faster drop off, use >1.0 Slower drop off, use
## <1.0

proc audio_3d_get_drop_off_factor*(this: AudioManager): float32 {.importcpp: "#->audio_3d_get_drop_off_factor()".}

proc get_dls_pathname*(_: typedesc[AudioManager]): Filename {.importcpp: "AudioManager::get_dls_pathname()", header: "audioManager.h".}

proc output*(this: AudioManager, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: AudioManager, `out`: ostream) {.importcpp: "#->write(#)".}

proc set_speaker_configuration*(this: AudioManager, speaker1: LVecBase3, speaker2: LVecBase3, speaker3: LVecBase3, speaker4: LVecBase3, speaker5: LVecBase3, speaker6: LVecBase3, speaker7: LVecBase3, speaker8: LVecBase3, speaker9: LVecBase3) {.importcpp: "#->set_speaker_configuration(#, #, #, #, #, #, #, #, #)".} ## \
## set_speaker_configuration is a Miles only method.

proc set_speaker_configuration*(this: AudioManager, speaker1: LVecBase3, speaker2: LVecBase3, speaker3: LVecBase3, speaker4: LVecBase3, speaker5: LVecBase3, speaker6: LVecBase3, speaker7: LVecBase3, speaker8: LVecBase3) {.importcpp: "#->set_speaker_configuration(#, #, #, #, #, #, #, #)".} ## \
## set_speaker_configuration is a Miles only method.

proc set_speaker_configuration*(this: AudioManager, speaker1: LVecBase3, speaker2: LVecBase3, speaker3: LVecBase3, speaker4: LVecBase3, speaker5: LVecBase3, speaker6: LVecBase3, speaker7: LVecBase3) {.importcpp: "#->set_speaker_configuration(#, #, #, #, #, #, #)".} ## \
## set_speaker_configuration is a Miles only method.

proc set_speaker_configuration*(this: AudioManager, speaker1: LVecBase3, speaker2: LVecBase3, speaker3: LVecBase3, speaker4: LVecBase3, speaker5: LVecBase3, speaker6: LVecBase3) {.importcpp: "#->set_speaker_configuration(#, #, #, #, #, #)".} ## \
## set_speaker_configuration is a Miles only method.

proc set_speaker_configuration*(this: AudioManager, speaker1: LVecBase3, speaker2: LVecBase3, speaker3: LVecBase3, speaker4: LVecBase3, speaker5: LVecBase3) {.importcpp: "#->set_speaker_configuration(#, #, #, #, #)".} ## \
## set_speaker_configuration is a Miles only method.

proc set_speaker_configuration*(this: AudioManager, speaker1: LVecBase3, speaker2: LVecBase3, speaker3: LVecBase3, speaker4: LVecBase3) {.importcpp: "#->set_speaker_configuration(#, #, #, #)".} ## \
## set_speaker_configuration is a Miles only method.

proc set_speaker_configuration*(this: AudioManager, speaker1: LVecBase3, speaker2: LVecBase3, speaker3: LVecBase3) {.importcpp: "#->set_speaker_configuration(#, #, #)".} ## \
## set_speaker_configuration is a Miles only method.

proc set_speaker_configuration*(this: AudioManager, speaker1: LVecBase3, speaker2: LVecBase3) {.importcpp: "#->set_speaker_configuration(#, #)".} ## \
## set_speaker_configuration is a Miles only method.

proc set_speaker_configuration*(this: AudioManager, speaker1: LVecBase3) {.importcpp: "#->set_speaker_configuration(#)".} ## \
## set_speaker_configuration is a Miles only method.

proc get_class_type*(_: typedesc[AudioManager]): TypeHandle {.importcpp: "AudioManager::get_class_type()", header: "audioManager.h".}

proc newAudioLoadRequest*(param0: AudioLoadRequest): AudioLoadRequest {.importcpp: "new AudioLoadRequest(#)".}

proc newAudioLoadRequest*(audio_manager: AudioManager, filename: string, positional: bool): AudioLoadRequest {.importcpp: "new AudioLoadRequest(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Create a new AudioLoadRequest, and add it to the loader via load_async(),
## to begin an asynchronous load.

proc get_audio_manager*(this: AudioLoadRequest): AudioManager {.importcpp: "#->get_audio_manager()".} ## \
## Returns the AudioManager that will serve this asynchronous
## AudioLoadRequest.

proc get_filename*(this: AudioLoadRequest): string {.importcpp: "nimStringFromStdString(#->get_filename())", header: stringConversionCode.} ## \
## Returns the filename associated with this asynchronous AudioLoadRequest.

proc get_positional*(this: AudioLoadRequest): bool {.importcpp: "#->get_positional()".} ## \
## Returns the positional flag associated with this asynchronous
## AudioLoadRequest.

proc is_ready*(this: AudioLoadRequest): bool {.importcpp: "#->is_ready()".} ## \
## Returns true if this request has completed, false if it is still pending.
## When this returns true, you may retrieve the sound loaded by calling
## get_sound().
## Equivalent to `req.done() and not req.cancelled()`.
## @see done()

proc get_sound*(this: AudioLoadRequest): AudioSound {.importcpp: "#->get_sound()".} ## \
## Returns the sound that was loaded asynchronously, if any, or nullptr if
## there was an error.  It is an error to call this unless done() returns
## true.
## @deprecated Use result() instead.

proc get_class_type*(_: typedesc[AudioLoadRequest]): TypeHandle {.importcpp: "AudioLoadRequest::get_class_type()", header: "audioLoadRequest.h".}

proc initPGFrameStyle*(): PGFrameStyle {.importcpp: "PGFrameStyle()".}

proc initPGFrameStyle*(copy: PGFrameStyle): PGFrameStyle {.importcpp: "PGFrameStyle(#)".}

proc set_color*(this: PGFrameStyle, color: LColor) {.importcpp: "#.set_color(#)".} ## \
## Sets the dominant color of the frame.

proc set_color*(this: PGFrameStyle, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_color(#, #, #, #)".} ## \
## Sets the dominant color of the frame.

proc get_color*(this: PGFrameStyle): LColor {.importcpp: "#.get_color()".} ## \
## Returns the dominant color of the frame.

proc set_texture*(this: PGFrameStyle, texture: Texture) {.importcpp: "#.set_texture(#)".} ## \
## Specifies a texture that should be applied to the frame.

proc has_texture*(this: PGFrameStyle): bool {.importcpp: "#.has_texture()".} ## \
## Returns true if a texture has been applied to the frame.

proc get_texture*(this: PGFrameStyle): Texture {.importcpp: "#.get_texture()".} ## \
## Returns the texture that has been applied to the frame, or NULL if no
## texture has been applied.

proc clear_texture*(this: PGFrameStyle) {.importcpp: "#.clear_texture()".} ## \
## Removes the texture from the frame.

proc set_width*(this: PGFrameStyle, width: LVecBase2) {.importcpp: "#.set_width(#)".} ## \
## Sets the width parameter, which has meaning only for certain frame types.
## For instance, this is the width of the bevel for T_bevel_in or T_bevel_out.
## The units are in screen units.

proc set_width*(this: PGFrameStyle, x: float32, y: float32) {.importcpp: "#.set_width(#, #)".} ## \
## Sets the width parameter, which has meaning only for certain frame types.
## For instance, this is the width of the bevel for T_bevel_in or T_bevel_out.
## The units are in screen units.

proc get_width*(this: PGFrameStyle): LVecBase2 {.importcpp: "#.get_width()".} ## \
## Returns the width parameter, which has meaning only for certain frame
## types.  For instance, this is the width of the bevel for T_bevel_in or
## T_bevel_out.  The units are in screen units.

proc set_uv_width*(this: PGFrameStyle, uv_width: LVecBase2) {.importcpp: "#.set_uv_width(#)".} ## \
## Sets the uv_width parameter, which indicates the amount of the texture that
## is consumed by the inner bevel--the width in texture space of the amount
## indicated by set_width.

proc set_uv_width*(this: PGFrameStyle, u: float32, v: float32) {.importcpp: "#.set_uv_width(#, #)".} ## \
## Sets the uv_width parameter, which indicates the amount of the texture that
## is consumed by the inner bevel--the width in texture space of the amount
## indicated by set_width.

proc get_uv_width*(this: PGFrameStyle): LVecBase2 {.importcpp: "#.get_uv_width()".} ## \
## See set_uv_width().

proc set_visible_scale*(this: PGFrameStyle, visible_scale: LVecBase2) {.importcpp: "#.set_visible_scale(#)".} ## \
## Sets a scale factor on the visible representation of the frame, in the X
## and Y directions.  If this scale factor is other than 1, it will affect the
## size of the visible frame representation within the actual frame border.

proc set_visible_scale*(this: PGFrameStyle, x: float32, y: float32) {.importcpp: "#.set_visible_scale(#, #)".} ## \
## Sets a scale factor on the visible representation of the frame, in the X
## and Y directions.  If this scale factor is other than 1, it will affect the
## size of the visible frame representation within the actual frame border.

proc get_visible_scale*(this: PGFrameStyle): LVecBase2 {.importcpp: "#.get_visible_scale()".} ## \
## Returns the scale factor on the visible representation of the frame, in the
## X and Y directions.  If this scale factor is other than 1, it will affect
## the size of the visible frame representation within the actual frame
## border.

proc get_internal_frame*(this: PGFrameStyle, frame: LVecBase4): LVecBase4 {.importcpp: "#.get_internal_frame(#)".} ## \
## Computes the size of the internal frame, given the indicated external
## frame, appropriate for this kind of frame style.  This simply subtracts the
## border width for those frame styles that include a border.

proc output*(this: PGFrameStyle, `out`: ostream) {.importcpp: "#.output(#)".}

proc newPGItem*(name: string): PGItem {.importcpp: "new PGItem(nimStringToStdString(#))", header: stringConversionCode.}

proc set_name*(this: PGItem, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.}

proc set_frame*(this: PGItem, frame: LVecBase4) {.importcpp: "#->set_frame(#)".} ## \
## Sets the bounding rectangle of the item, in local coordinates.  This is the
## region on screen within which the mouse will be considered to be within the
## item.  Normally, it should correspond to the bounding rectangle of the
## visible geometry of the item.

proc set_frame*(this: PGItem, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_frame(#, #, #, #)".} ## \
## Sets the bounding rectangle of the item, in local coordinates.  This is the
## region on screen within which the mouse will be considered to be within the
## item.  Normally, it should correspond to the bounding rectangle of the
## visible geometry of the item.

proc get_frame*(this: PGItem): LVecBase4 {.importcpp: "#->get_frame()".} ## \
## Returns the bounding rectangle of the item.  See set_frame().  It is an
## error to call this if has_frame() returns false.

proc has_frame*(this: PGItem): bool {.importcpp: "#->has_frame()".} ## \
## Returns true if the item has a bounding rectangle; see set_frame().

proc clear_frame*(this: PGItem) {.importcpp: "#->clear_frame()".} ## \
## Removes the bounding rectangle from the item.  It will no longer be
## possible to position the mouse within the item; see set_frame().

proc set_state*(this: PGItem, state: int) {.importcpp: "#->set_state(#)".} ## \
## Sets the "state" of this particular PGItem.
##
## The PGItem node will render as if it were the subgraph assigned to the
## corresponding index via set_state_def().

proc get_state*(this: PGItem): int {.importcpp: "#->get_state()".} ## \
## Returns the "state" of this particular PGItem.  See set_state().

proc set_active*(this: PGItem, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets whether the PGItem is active for mouse watching.  This is not
## necessarily related to the active/inactive appearance of the item, which is
## controlled by set_state(), but it does affect whether it responds to mouse
## events.

proc get_active*(this: PGItem): bool {.importcpp: "#->get_active()".} ## \
## Returns whether the PGItem is currently active for mouse events.  See
## set_active().

proc set_focus*(this: PGItem, focus: bool) {.importcpp: "#->set_focus(#)".} ## \
## Sets whether the PGItem currently has keyboard focus.  This simply means
## that the item may respond to keyboard events as well as to mouse events;
## precisely what this means is up to the individual item.
##
## Only one PGItem in the world is allowed to have focus at any given time.
## Setting the focus on any other item automatically disables the focus from
## the previous item.

proc get_focus*(this: PGItem): bool {.importcpp: "#->get_focus()".} ## \
## Returns whether the PGItem currently has focus for keyboard events.  See
## set_focus().

proc set_background_focus*(this: PGItem, focus: bool) {.importcpp: "#->set_background_focus(#)".} ## \
## Sets the background_focus flag for this item.  When background_focus is
## enabled, the item will receive keypress events even if it is not in focus;
## in fact, even if it is not onscreen.  Unlike normal focus, many items may
## have background_focus simultaneously.

proc get_background_focus*(this: PGItem): bool {.importcpp: "#->get_background_focus()".} ## \
## Returns whether background_focus is currently enabled.  See
## set_background_focus().

proc set_suppress_flags*(this: PGItem, suppress_flags: int) {.importcpp: "#->set_suppress_flags(#)".} ## \
## This is just an interface to set the suppress flags on the underlying
## MouseWatcherRegion.  See MouseWatcherRegion::set_suppress_flags().

proc get_suppress_flags*(this: PGItem): int {.importcpp: "#->get_suppress_flags()".} ## \
## This is just an interface to get the suppress flags on the underlying
## MouseWatcherRegion.  See MouseWatcherRegion::get_suppress_flags().

proc get_num_state_defs*(this: PGItem): int {.importcpp: "#->get_num_state_defs()".} ## \
## Returns one more than the highest-numbered state def that was ever assigned
## to the PGItem.  The complete set of state defs assigned may then be
## retrieved by indexing from 0 to (get_num_state_defs() - 1).
##
## This is only an upper limit on the actual number of state defs, since there
## may be holes in the list.

proc clear_state_def*(this: PGItem, state: int) {.importcpp: "#->clear_state_def(#)".} ## \
## Resets the NodePath assigned to the indicated state to its initial default,
## with only a frame representation if appropriate.

proc has_state_def*(this: PGItem, state: int): bool {.importcpp: "#->has_state_def(#)".} ## \
## Returns true if get_state_def() has ever been called for the indicated
## state (thus defining a render subgraph for this state index), false
## otherwise.

proc get_state_def*(this: PGItem, state: int): NodePath {.importcpp: "#->get_state_def(#)".} ## \
## Returns the Node that is the root of the subgraph that will be drawn when
## the PGItem is in the indicated state.  The first time this is called for a
## particular state index, it may create the Node.

proc instance_to_state_def*(this: PGItem, state: int, path: NodePath): NodePath {.importcpp: "#->instance_to_state_def(#, #)".} ## \
## Parents an instance of the bottom node of the indicated NodePath to the
## indicated state index.

proc get_frame_style*(this: PGItem, state: int): PGFrameStyle {.importcpp: "#->get_frame_style(#)".} ## \
## Returns the kind of frame that will be drawn behind the item when it is in
## the indicated state.

proc set_frame_style*(this: PGItem, state: int, style: PGFrameStyle) {.importcpp: "#->set_frame_style(#, #)".} ## \
## Changes the kind of frame that will be drawn behind the item when it is in
## the indicated state.

proc get_id*(this: PGItem): string {.importcpp: "nimStringFromStdString(#->get_id())", header: stringConversionCode.} ## \
## Returns the unique ID assigned to this PGItem.  This will be assigned to
## the region created with the MouseWatcher, and will thus be used to generate
## event names.

proc set_id*(this: PGItem, id: string) {.importcpp: "#->set_id(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Set the unique ID assigned to this PGItem.  It is the user's responsibility
## to ensure that this ID is unique.
##
## Normally, this should not need to be called, as the PGItem will assign
## itself an ID when it is created, but this function allows the user to
## decide to redefine the ID to be something possibly more meaningful.

proc get_enter_prefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_enter_prefix())", header: "pGItem.h".} ## \
## Returns the prefix that is used to define the enter event for all PGItems.
## The enter event is the concatenation of this string followed by get_id().

proc get_exit_prefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_exit_prefix())", header: "pGItem.h".} ## \
## Returns the prefix that is used to define the exit event for all PGItems.
## The exit event is the concatenation of this string followed by get_id().

proc get_within_prefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_within_prefix())", header: "pGItem.h".} ## \
## Returns the prefix that is used to define the within event for all PGItems.
## The within event is the concatenation of this string followed by get_id().

proc get_without_prefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_without_prefix())", header: "pGItem.h".} ## \
## Returns the prefix that is used to define the without event for all
## PGItems.  The without event is the concatenation of this string followed by
## get_id().

proc get_focus_in_prefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_focus_in_prefix())", header: "pGItem.h".} ## \
## Returns the prefix that is used to define the focus_in event for all
## PGItems.  The focus_in event is the concatenation of this string followed
## by get_id().
##
## Unlike most item events, this event is thrown with no parameters.

proc get_focus_out_prefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_focus_out_prefix())", header: "pGItem.h".} ## \
## Returns the prefix that is used to define the focus_out event for all
## PGItems.  The focus_out event is the concatenation of this string followed
## by get_id().
##
## Unlike most item events, this event is thrown with no parameters.

proc get_press_prefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_press_prefix())", header: "pGItem.h".} ## \
## Returns the prefix that is used to define the press event for all PGItems.
## The press event is the concatenation of this string followed by a button
## name, followed by a hyphen and get_id().

proc get_repeat_prefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_repeat_prefix())", header: "pGItem.h".} ## \
## Returns the prefix that is used to define the repeat event for all PGItems.
## The repeat event is the concatenation of this string followed by a button
## name, followed by a hyphen and get_id().

proc get_release_prefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_release_prefix())", header: "pGItem.h".} ## \
## Returns the prefix that is used to define the release event for all
## PGItems.  The release event is the concatenation of this string followed by
## a button name, followed by a hyphen and get_id().

proc get_keystroke_prefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_keystroke_prefix())", header: "pGItem.h".} ## \
## Returns the prefix that is used to define the keystroke event for all
## PGItems.  The keystroke event is the concatenation of this string followed
## by a hyphen and get_id().

proc get_enter_event*(this: PGItem): string {.importcpp: "nimStringFromStdString(#->get_enter_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item is active and the
## mouse enters its frame, but not any nested frames.

proc get_exit_event*(this: PGItem): string {.importcpp: "nimStringFromStdString(#->get_exit_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item is active and the
## mouse exits its frame, or enters a nested frame.

proc get_within_event*(this: PGItem): string {.importcpp: "nimStringFromStdString(#->get_within_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item is active and the
## mouse moves within the boundaries of the frame.  This is different from the
## enter_event in that the mouse is considered within the frame even if it is
## also within a nested frame.

proc get_without_event*(this: PGItem): string {.importcpp: "nimStringFromStdString(#->get_without_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item is active and the
## mouse moves completely outside the boundaries of the frame.  This is
## different from the exit_event in that the mouse is considered within the
## frame even if it is also within a nested frame.

proc get_focus_in_event*(this: PGItem): string {.importcpp: "nimStringFromStdString(#->get_focus_in_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item gets the keyboard
## focus.

proc get_focus_out_event*(this: PGItem): string {.importcpp: "nimStringFromStdString(#->get_focus_out_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item loses the keyboard
## focus.

proc get_press_event*(this: PGItem, button: ButtonHandle): string {.importcpp: "nimStringFromStdString(#->get_press_event(#))", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item is active and the
## indicated mouse or keyboard button is depressed while the mouse is within
## the frame.

proc get_repeat_event*(this: PGItem, button: ButtonHandle): string {.importcpp: "nimStringFromStdString(#->get_repeat_event(#))", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item is active and the
## indicated mouse or keyboard button is continuously held down while the
## mouse is within the frame.

proc get_release_event*(this: PGItem, button: ButtonHandle): string {.importcpp: "nimStringFromStdString(#->get_release_event(#))", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item is active and the
## indicated mouse or keyboard button, formerly clicked down is within the
## frame, is released.

proc get_keystroke_event*(this: PGItem): string {.importcpp: "nimStringFromStdString(#->get_keystroke_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item is active and any
## key is pressed by the user.

proc get_frame_inv_xform*(this: PGItem): LMatrix4 {.importcpp: "#->get_frame_inv_xform()".} ## \
## Returns the inverse of the frame transform matrix

proc set_sound*(this: PGItem, event: string, sound: AudioSound) {.importcpp: "#->set_sound(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Sets the sound that will be played whenever the indicated event occurs.

proc clear_sound*(this: PGItem, event: string) {.importcpp: "#->clear_sound(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the sound associated with the indicated event.

proc get_sound*(this: PGItem, event: string): AudioSound {.importcpp: "#->get_sound(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the sound associated with the indicated event, or NULL if there is
## no associated sound.

proc has_sound*(this: PGItem, event: string): bool {.importcpp: "#->has_sound(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if there is a sound associated with the indicated event, or
## false otherwise.

proc get_text_node*(_: typedesc[PGItem]): TextNode {.importcpp: "PGItem::get_text_node()", header: "pGItem.h".} ## \
## Returns the TextNode object that will be used by all PGItems to generate
## default labels given a string.  This can be loaded with the default font,
## etc.

proc set_text_node*(_: typedesc[PGItem], node: TextNode) {.importcpp: "PGItem::set_text_node(#)", header: "pGItem.h".} ## \
## Changes the TextNode object that will be used by all PGItems to generate
## default labels given a string.  This can be loaded with the default font,
## etc.

proc get_focus_item*(_: typedesc[PGItem]): PGItem {.importcpp: "PGItem::get_focus_item()", header: "pGItem.h".} ## \
## Returns the one PGItem in the world that currently has keyboard focus, if
## any, or NULL if no item has keyboard focus.  Use PGItem::set_focus() to
## activate or deactivate keyboard focus on a particular item.

proc get_class_type*(_: typedesc[PGItem]): TypeHandle {.importcpp: "PGItem::get_class_type()", header: "pGItem.h".}

proc newPGButton*(name: string): PGButton {.importcpp: "new PGButton(nimStringToStdString(#))", header: stringConversionCode.}

proc setup*(this: PGButton, ready: NodePath) {.importcpp: "#->setup(#)".} ## \
## Sets up the button using the indicated NodePath as arbitrary geometry.

proc setup*(this: PGButton, ready: NodePath, depressed: NodePath) {.importcpp: "#->setup(#, #)".} ## \
## Sets up the button using the indicated NodePath as arbitrary geometry.

proc setup*(this: PGButton, ready: NodePath, depressed: NodePath, rollover: NodePath) {.importcpp: "#->setup(#, #, #)".} ## \
## Sets up the button using the indicated NodePath as arbitrary geometry.

proc setup*(this: PGButton, ready: NodePath, depressed: NodePath, rollover: NodePath, inactive: NodePath) {.importcpp: "#->setup(#, #, #, #)".} ## \
## Sets up the button using the indicated NodePath as arbitrary geometry.

proc setup*(this: PGButton, label: string, bevel: float32) {.importcpp: "#->setup(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Sets up the button as a default text button using the indicated label
## string.  The TextNode defined by PGItem::get_text_node() will be used to
## create the label geometry.  This automatically sets up the frame according
## to the size of the text.

proc setup*(this: PGButton, label: string) {.importcpp: "#->setup(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets up the button as a default text button using the indicated label
## string.  The TextNode defined by PGItem::get_text_node() will be used to
## create the label geometry.  This automatically sets up the frame according
## to the size of the text.

proc add_click_button*(this: PGButton, button: ButtonHandle): bool {.importcpp: "#->add_click_button(#)".} ## \
## Adds the indicated button to the set of buttons that can effectively
## "click" the PGButton.  Normally, this is just MouseButton::one().  Returns
## true if the button was added, or false if it was already there.

proc remove_click_button*(this: PGButton, button: ButtonHandle): bool {.importcpp: "#->remove_click_button(#)".} ## \
## Removes the indicated button from the set of buttons that can effectively
## "click" the PGButton.  Normally, this is just MouseButton::one().  Returns
## true if the button was removed, or false if it was not in the set.

proc has_click_button*(this: PGButton, button: ButtonHandle): bool {.importcpp: "#->has_click_button(#)".} ## \
## Returns true if the indicated button is on the set of buttons that can
## effectively "click" the PGButton.  Normally, this is just
## MouseButton::one().

proc is_button_down*(this: PGButton): bool {.importcpp: "#->is_button_down()".} ## \
## Returns true if the user is currently holding the mouse button down on the
## button, false otherwise.

proc get_click_prefix*(_: typedesc[PGButton]): string {.importcpp: "nimStringFromStdString(PGButton::get_click_prefix())", header: stringConversionCode.} ## \
## Returns the prefix that is used to define the click event for all
## PGButtons.  The click event is the concatenation of this string followed by
## get_id().

proc get_click_event*(this: PGButton, button: ButtonHandle): string {.importcpp: "nimStringFromStdString(#->get_click_event(#))", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the button is clicked
## normally.

proc get_class_type*(_: typedesc[PGButton]): TypeHandle {.importcpp: "PGButton::get_class_type()", header: "pGButton.h".}

proc newPGTop*(name: string): PGTop {.importcpp: "new PGTop(nimStringToStdString(#))", header: stringConversionCode.}

proc set_mouse_watcher*(this: PGTop, watcher: MouseWatcher) {.importcpp: "#->set_mouse_watcher(#)".} ## \
## Sets the MouseWatcher pointer that the PGTop object registers its PG items
## with.  This must be set before the PG items are active.

proc get_mouse_watcher*(this: PGTop): MouseWatcher {.importcpp: "#->get_mouse_watcher()".} ## \
## Returns the MouseWatcher pointer that the PGTop object registers its PG
## items with, or NULL if the MouseWatcher has not yet been set.

proc get_group*(this: PGTop): MouseWatcherGroup {.importcpp: "#->get_group()".} ## \
## Returns the MouseWatcherGroup pointer that the PGTop object registers its
## PG items with, or NULL if the MouseWatcher has not yet been set.

proc set_start_sort*(this: PGTop, start_sort: int) {.importcpp: "#->set_start_sort(#)".} ## \
## Specifies the sort index that is assigned during the traversal to the first
## PGItem that is discovered during traversal.  Subsequent PGItems will be
## assigned consecutively higher sort indexes.
##
## This number is used by the MouseWatcher system to rank the clickable mouse
## regions in the same order in which the items are rendered, so that items on
## top will receive mouse priority.
##
## Normally, it makes the most sense to leave this initial value at its
## default value of 0, unless you need the PGItems to have a particular sort
## value with respect to some other objects in the scene (particularly with a
## second PGTop node).

proc get_start_sort*(this: PGTop): int {.importcpp: "#->get_start_sort()".} ## \
## Returns the sort index that is assigned during the traversal to the first
## PGItem that is discovered during traversal.  See set_start_sort().

proc get_class_type*(_: typedesc[PGTop]): TypeHandle {.importcpp: "PGTop::get_class_type()", header: "pGTop.h".}

proc newPGEntry*(name: string): PGEntry {.importcpp: "new PGEntry(nimStringToStdString(#))", header: stringConversionCode.}

proc setup*(this: PGEntry, width: float32, num_lines: int) {.importcpp: "#->setup(#, #)".} ## \
## Sets up the entry for normal use.  The width is the maximum width of
## characters that will be typed, and num_lines is the integer number of lines
## of text of the entry.  Both of these together determine the size of the
## entry, based on the TextNode in effect.

proc setup_minimal*(this: PGEntry, width: float32, num_lines: int) {.importcpp: "#->setup_minimal(#, #)".} ## \
## Sets up the entry without creating any frame or other decoration.

proc set_text*(this: PGEntry, text: string): bool {.importcpp: "#->set_text(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the text currently displayed within the entry.  This uses the
## Unicode encoding currently specified for the "focus" TextNode; therefore,
## the TextNode must exist before calling set_text().
##
## The return value is true if all the text is accepted, or false if some was
## truncated (see set_max_width(), etc.).

proc get_plain_text*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_plain_text())", header: stringConversionCode.} ## \
## Returns the text currently displayed within the entry, without any embedded
## properties characters.
##
## This uses the Unicode encoding currently specified for the "focus"
## TextNode; therefore, the TextNode must exist before calling get_text().

proc get_text*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_text())", header: stringConversionCode.} ## \
## Returns the text currently displayed within the entry.  This uses the
## Unicode encoding currently specified for the "focus" TextNode; therefore,
## the TextNode must exist before calling get_text().

proc get_num_characters*(this: PGEntry): int {.importcpp: "#->get_num_characters()".} ## \
## Returns the number of characters of text in the entry.  This is the actual
## number of visible characters, not counting implicit newlines due to
## wordwrapping, or formatted characters for text properties changes.  If
## there is an embedded TextGraphic object, it counts as one character.
##
## This is also the length of the string returned by get_plain_text().

proc get_character*(this: PGEntry, n: int): int {.importcpp: "#->get_character(#)".} ## \
## Returns the character at the indicated position in the entry.  If the
## object at this position is a graphic object instead of a character, returns
## 0.

proc get_graphic*(this: PGEntry, n: int): TextGraphic {.importcpp: "#->get_graphic(#)".} ## \
## Returns the graphic object at the indicated position in the pre-wordwrapped
## string.  If the object at this position is a character instead of a graphic
## object, returns NULL.

proc get_properties*(this: PGEntry, n: int): TextProperties {.importcpp: "#->get_properties(#)".} ## \
## Returns the TextProperties in effect for the object at the indicated
## position in the pre-wordwrapped string.

proc set_cursor_position*(this: PGEntry, position: int) {.importcpp: "#->set_cursor_position(#)".} ## \
## Sets the current position of the cursor.  This is the position within the
## text at which the next letter typed by the user will be inserted; normally
## it is the same as the length of the text.

proc get_cursor_position*(this: PGEntry): int {.importcpp: "#->get_cursor_position()".} ## \
## Returns the current position of the cursor.

proc get_cursor_X*(this: PGEntry): float32 {.importcpp: "#->get_cursor_X()".}

proc get_cursor_Y*(this: PGEntry): float32 {.importcpp: "#->get_cursor_Y()".}

proc set_max_chars*(this: PGEntry, max_chars: int) {.importcpp: "#->set_max_chars(#)".} ## \
## Sets the maximum number of characters that may be typed into the entry.
## This is a limit on the number of characters, as opposed to the width of the
## entry; see also set_max_width().
##
## If this is 0, there is no limit.

proc get_max_chars*(this: PGEntry): int {.importcpp: "#->get_max_chars()".} ## \
## Returns the current maximum number of characters that may be typed into the
## entry, or 0 if there is no limit.  See set_max_chars().

proc set_max_width*(this: PGEntry, max_width: float32) {.importcpp: "#->set_max_width(#)".} ## \
## Sets the maximum width of all characters that may be typed into the entry.
## This is a limit on the width of the formatted text, not a fixed limit on
## the number of characters; also set_max_chars().
##
## If this is 0, there is no limit.
##
## If _num_lines is more than 1, rather than being a fixed width on the whole
## entry, this becomes instead the wordwrap width (and the width limit on the
## entry is essentially _max_width * _num_lines).

proc get_max_width*(this: PGEntry): float32 {.importcpp: "#->get_max_width()".} ## \
## Returns the current maximum width of the characters that may be typed into
## the entry, or 0 if there is no limit.  See set_max_width().

proc set_num_lines*(this: PGEntry, num_lines: int) {.importcpp: "#->set_num_lines(#)".} ## \
## Sets the number of lines of text the PGEntry will use.  This only has
## meaning if _max_width is not 0; _max_width indicates the wordwrap width of
## each line.

proc get_num_lines*(this: PGEntry): int {.importcpp: "#->get_num_lines()".} ## \
## Returns the number of lines of text the PGEntry will use, if _max_width is
## not 0.  See set_num_lines().

proc set_blink_rate*(this: PGEntry, blink_rate: float32) {.importcpp: "#->set_blink_rate(#)".} ## \
## Sets the number of times per second the cursor will blink while the entry
## has keyboard focus.
##
## If this is 0, the cursor does not blink, but is held steady.

proc get_blink_rate*(this: PGEntry): float32 {.importcpp: "#->get_blink_rate()".} ## \
## Returns the number of times per second the cursor will blink, or 0 if the
## cursor is not to blink.

proc get_cursor_def*(this: PGEntry): NodePath {.importcpp: "#->get_cursor_def()".} ## \
## Returns the Node that will be rendered to represent the cursor.  You can
## attach suitable cursor geometry to this node.

proc clear_cursor_def*(this: PGEntry) {.importcpp: "#->clear_cursor_def()".} ## \
## Removes all the children from the cursor_def node, in preparation for
## adding a new definition.

proc set_cursor_keys_active*(this: PGEntry, flag: bool) {.importcpp: "#->set_cursor_keys_active(#)".} ## \
## Sets whether the arrow keys (and home/end) control movement of the cursor.
## If true, they are active; if false, they are ignored.

proc get_cursor_keys_active*(this: PGEntry): bool {.importcpp: "#->get_cursor_keys_active()".} ## \
## Returns whether the arrow keys are currently set to control movement of the
## cursor; see set_cursor_keys_active().

proc set_obscure_mode*(this: PGEntry, flag: bool) {.importcpp: "#->set_obscure_mode(#)".} ## \
## Specifies whether obscure mode should be enabled.  In obscure mode, a
## string of asterisks is displayed instead of the literal text, e.g.  for
## entering passwords.
##
## In obscure mode, the width of the text is computed based on the width of
## the string of asterisks, not on the width of the actual text.  This has
## implications on the maximum length of text that may be entered if max_width
## is in effect.

proc get_obscure_mode*(this: PGEntry): bool {.importcpp: "#->get_obscure_mode()".} ## \
## Specifies whether obscure mode is enabled.  See set_obscure_mode().

proc set_overflow_mode*(this: PGEntry, flag: bool) {.importcpp: "#->set_overflow_mode(#)".} ## \
## Specifies whether overflow mode should be enabled.  In overflow mode, text
## can overflow the boundaries of the Entry element horizontally.
##
## Overflow mode only works when the number of lines is 1.

proc get_overflow_mode*(this: PGEntry): bool {.importcpp: "#->get_overflow_mode()".} ## \
## Specifies whether overflow mode is enabled.  See set_overflow_mode().

proc set_candidate_active*(this: PGEntry, candidate_active: string) {.importcpp: "#->set_candidate_active(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the name of the TextProperties structure added to the
## TextPropertiesManager that will be used to render candidate strings from
## the IME, used for typing characters in east Asian languages.  Each
## candidate string represents one possible way to interpret the sequence of
## keys the user has just entered; it should not be considered typed yet, but
## it is important for the user to be able to see what he is considering
## entering.
##
## This particular method sets the properties for the subset of the current
## candidate string that the user can actively scroll through.

proc get_candidate_active*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_candidate_active())", header: stringConversionCode.} ## \
## See set_candidate_active().

proc set_candidate_inactive*(this: PGEntry, candidate_inactive: string) {.importcpp: "#->set_candidate_inactive(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the name of the TextProperties structure added to the
## TextPropertiesManager that will be used to render candidate strings from
## the IME, used for typing characters in east Asian languages.  Each
## candidate string represents one possible way to interpret the sequence of
## keys the user has just entered; it should not be considered typed yet, but
## it is important for the user to be able to see what he is considering
## entering.
##
## This particular method sets the properties for the subset of the current
## candidate string that the user is not actively scrolling through.

proc get_candidate_inactive*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_candidate_inactive())", header: stringConversionCode.} ## \
## See set_candidate_inactive().

proc set_text_def*(this: PGEntry, state: int, node: TextNode) {.importcpp: "#->set_text_def(#, #)".} ## \
## Changes the TextNode that will be used to render the text within the entry
## when the entry is in the indicated state.  The default if nothing is
## specified is the same TextNode returned by PGItem::get_text_node().

proc get_text_def*(this: PGEntry, state: int): TextNode {.importcpp: "#->get_text_def(#)".} ## \
## Returns the TextNode that will be used to render the text within the entry
## when the entry is in the indicated state.  See set_text_def().

proc get_accept_prefix*(_: typedesc[PGEntry]): string {.importcpp: "nimStringFromStdString(PGEntry::get_accept_prefix())", header: "pGEntry.h".} ## \
## Returns the prefix that is used to define the accept event for all
## PGEntries.  The accept event is the concatenation of this string followed
## by get_id().

proc get_accept_failed_prefix*(_: typedesc[PGEntry]): string {.importcpp: "nimStringFromStdString(PGEntry::get_accept_failed_prefix())", header: "pGEntry.h".} ## \
## Returns the prefix that is used to define the accept failed event for all
## PGEntries.  This event is the concatenation of this string followed by
## get_id().

proc get_overflow_prefix*(_: typedesc[PGEntry]): string {.importcpp: "nimStringFromStdString(PGEntry::get_overflow_prefix())", header: "pGEntry.h".} ## \
## Returns the prefix that is used to define the overflow event for all
## PGEntries.  The overflow event is the concatenation of this string followed
## by get_id().

proc get_type_prefix*(_: typedesc[PGEntry]): string {.importcpp: "nimStringFromStdString(PGEntry::get_type_prefix())", header: "pGEntry.h".} ## \
## Returns the prefix that is used to define the type event for all PGEntries.
## The type event is the concatenation of this string followed by get_id().

proc get_erase_prefix*(_: typedesc[PGEntry]): string {.importcpp: "nimStringFromStdString(PGEntry::get_erase_prefix())", header: "pGEntry.h".} ## \
## Returns the prefix that is used to define the erase event for all
## PGEntries.  The erase event is the concatenation of this string followed by
## get_id().

proc get_cursormove_prefix*(_: typedesc[PGEntry]): string {.importcpp: "nimStringFromStdString(PGEntry::get_cursormove_prefix())", header: "pGEntry.h".} ## \
## Returns the prefix that is used to define the cursor event for all
## PGEntries.  The cursor event is the concatenation of this string followed
## by get_id().

proc get_accept_event*(this: PGEntry, button: ButtonHandle): string {.importcpp: "nimStringFromStdString(#->get_accept_event(#))", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the entry is accepted
## normally.

proc get_accept_failed_event*(this: PGEntry, button: ButtonHandle): string {.importcpp: "nimStringFromStdString(#->get_accept_failed_event(#))", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the entry cannot accept an
## input

proc get_overflow_event*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_overflow_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when too much text is attempted
## to be entered into the PGEntry, exceeding either the limit set via
## set_max_chars() or via set_max_width().

proc get_type_event*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_type_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown whenever the user extends the
## text by typing.

proc get_erase_event*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_erase_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown whenever the user erases
## characters in the text.

proc get_cursormove_event*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_cursormove_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown whenever the cursor moves

proc set_wtext*(this: PGEntry, wtext: string): bool {.importcpp: "#->set_wtext(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the text currently displayed within the entry.
##
## The return value is true if all the text is accepted, or false if some was
## truncated (see set_max_width(), etc.).

proc get_plain_wtext*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_plain_wtext())", header: stringConversionCode.} ## \
## Returns the text currently displayed within the entry, without any embedded
## properties characters.

proc get_wtext*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_wtext())", header: stringConversionCode.} ## \
## Returns the text currently displayed within the entry.

proc set_accept_enabled*(this: PGEntry, enabled: bool) {.importcpp: "#->set_accept_enabled(#)".} ## \
## Sets whether the input may be accepted--use to disable submission by the
## user

proc is_wtext*(this: PGEntry): bool {.importcpp: "#->is_wtext()".} ## \
## Returns true if any of the characters in the string returned by get_wtext()
## are out of the range of an ASCII character (and, therefore, get_wtext()
## should be called in preference to get_text()).

proc get_class_type*(_: typedesc[PGEntry]): TypeHandle {.importcpp: "PGEntry::get_class_type()", header: "pGEntry.h".}

converter upcast_to_TypedWritableReferenceCount*(this: PGMouseWatcherParameter): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcast_to_MouseWatcherParameter*(this: PGMouseWatcherParameter): MouseWatcherParameter {.importcpp: "((MouseWatcherParameter *)(#.p()))".}

proc output*(this: PGMouseWatcherParameter, `out`: ostream) {.importcpp: "#->output(#)".}

proc get_class_type*(_: typedesc[PGMouseWatcherParameter]): TypeHandle {.importcpp: "PGMouseWatcherParameter::get_class_type()", header: "pGMouseWatcherParameter.h".}

proc newPGMouseWatcherParameter*(param0: PGMouseWatcherParameter): PGMouseWatcherParameter {.importcpp: "new PGMouseWatcherParameter(#)".}

proc newPGMouseWatcherBackground*(): PGMouseWatcherBackground {.importcpp: "new PGMouseWatcherBackground()".}

proc newPGMouseWatcherBackground*(param0: PGMouseWatcherBackground): PGMouseWatcherBackground {.importcpp: "new PGMouseWatcherBackground(#)".}

proc get_class_type*(_: typedesc[PGMouseWatcherBackground]): TypeHandle {.importcpp: "PGMouseWatcherBackground::get_class_type()", header: "pGMouseWatcherBackground.h".}

proc newPGVirtualFrame*(name: string): PGVirtualFrame {.importcpp: "new PGVirtualFrame(nimStringToStdString(#))", header: stringConversionCode.}

proc newPGVirtualFrame*(): PGVirtualFrame {.importcpp: "new PGVirtualFrame()".}

proc setup*(this: PGVirtualFrame, width: float32, height: float32) {.importcpp: "#->setup(#, #)".} ## \
## Creates a PGVirtualFrame with the indicated dimensions.

proc set_clip_frame*(this: PGVirtualFrame, clip_frame: LVecBase4) {.importcpp: "#->set_clip_frame(#)".} ## \
## Sets the bounding rectangle of the clip frame.  This is the size of the
## small window through which we can see the virtual canvas.  Normally, this
## is the same size as the actual frame or smaller (typically it is smaller by
## the size of the bevel, or to make room for scroll bars).

proc set_clip_frame*(this: PGVirtualFrame, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_clip_frame(#, #, #, #)".} ## \
## Sets the bounding rectangle of the clip frame.  This is the size of the
## small window through which we can see the virtual canvas.  Normally, this
## is the same size as the actual frame or smaller (typically it is smaller by
## the size of the bevel, or to make room for scroll bars).

proc get_clip_frame*(this: PGVirtualFrame): LVecBase4 {.importcpp: "#->get_clip_frame()".} ## \
## Returns the bounding rectangle of the clip frame.  See set_clip_frame().
## If has_clip_frame() is false, this returns the item's actual frame.

proc has_clip_frame*(this: PGVirtualFrame): bool {.importcpp: "#->has_clip_frame()".} ## \
## Returns true if the clip frame has been set; see set_clip_frame().  If it
## has not been set, objects in the virtual frame will not be clipped.

proc clear_clip_frame*(this: PGVirtualFrame) {.importcpp: "#->clear_clip_frame()".} ## \
## Removes the clip frame from the item.  This disables clipping.

proc set_canvas_transform*(this: PGVirtualFrame, transform: TransformState) {.importcpp: "#->set_canvas_transform(#)".} ## \
## Changes the transform of the virtual canvas.  This transform is applied to
## all child nodes of the canvas_node.

proc get_canvas_transform*(this: PGVirtualFrame): TransformState {.importcpp: "#->get_canvas_transform()".} ## \
## Returns the transform of the virtual canvas.  This transform is applied to
## all child nodes of the canvas_node.

proc get_canvas_node*(this: PGVirtualFrame): PandaNode {.importcpp: "#->get_canvas_node()".} ## \
## Returns the special node that holds all of the children that appear in the
## virtual canvas.

proc get_canvas_parent*(this: PGVirtualFrame): PandaNode {.importcpp: "#->get_canvas_parent()".} ## \
## Returns the parent node of the canvas_node.

proc get_class_type*(_: typedesc[PGVirtualFrame]): TypeHandle {.importcpp: "PGVirtualFrame::get_class_type()", header: "pGVirtualFrame.h".}

converter upcast_to_PGItem*(this: PGSliderBar): PGItem {.importcpp: "(PT(PGItem)(#))".}

proc newPGSliderBar*(name: string): PGSliderBar {.importcpp: "new PGSliderBar(nimStringToStdString(#))", header: stringConversionCode.}

proc newPGSliderBar*(): PGSliderBar {.importcpp: "new PGSliderBar()".}

proc setup_scroll_bar*(this: PGSliderBar, vertical: bool, length: float32, width: float32, bevel: float32) {.importcpp: "#->setup_scroll_bar(#, #, #, #)".} ## \
## Creates PGSliderBar that represents a vertical or horizontal scroll bar (if
## vertical is true or false, respectively), with additional buttons for
## scrolling, and a range of 0 .. 1.
##
## length here is the measurement along the scroll bar, and width is the
## measurement across the scroll bar, whether it is vertical or horizontal (so
## for a horizontal scroll bar, the length is actually the x dimension, and
## the width is the y dimension).

proc setup_slider*(this: PGSliderBar, vertical: bool, length: float32, width: float32, bevel: float32) {.importcpp: "#->setup_slider(#, #, #, #)".} ## \
## Creates PGSliderBar that represents a slider that the user can use to
## control an analog quantity.
##
## This is functionally the same as a scroll bar, but it has a distinctive
## look.

proc set_axis*(this: PGSliderBar, axis: LVector3) {.importcpp: "#->set_axis(#)".} ## \
## Specifies the axis of the slider bar's motion.  This should be only one of
## four vectors: (1, 0, 0), (0, 0, 1), (-1, 0, 0), or (0, 0, -1).
##
## This specifies the vector in which the thumb moves when it is moving from
## the minimum to the maximum value.
##
## The axis must be parallel to one of the screen axes, and it must be
## normalized.  Hence, it may only be one of the above four possibilities;
## anything else is an error and will result in indeterminate behavior.
##
## Normally, you should not try to set the axis directly.

proc get_axis*(this: PGSliderBar): LVector3 {.importcpp: "#->get_axis()".} ## \
## Returns the axis of the slider bar's motion.  See set_axis().

proc set_range*(this: PGSliderBar, min_value: float32, max_value: float32) {.importcpp: "#->set_range(#, #)".} ## \
## Sets the minimum and maxmimum value for the slider.

proc get_min_value*(this: PGSliderBar): float32 {.importcpp: "#->get_min_value()".} ## \
## Returns the value when the slider is all the way to the left.

proc get_max_value*(this: PGSliderBar): float32 {.importcpp: "#->get_max_value()".} ## \
## Returns the value when the slider is all the way to the right.

proc set_scroll_size*(this: PGSliderBar, scroll_size: float32) {.importcpp: "#->set_scroll_size(#)".} ## \
## Specifies the amount the slider will move when the user clicks on the left
## or right buttons.

proc get_scroll_size*(this: PGSliderBar): float32 {.importcpp: "#->get_scroll_size()".} ## \
## Returns the value last set by set_scroll_size().

proc set_page_size*(this: PGSliderBar, page_size: float32) {.importcpp: "#->set_page_size(#)".} ## \
## Specifies the amount of data contained in a single page.  This indicates
## how much the thumb will jump when the trough is directly clicked; and if
## resize_thumb is true, it also controls the visible size of the thumb
## button.

proc get_page_size*(this: PGSliderBar): float32 {.importcpp: "#->get_page_size()".} ## \
## Returns the value last set by set_page_size().

proc set_value*(this: PGSliderBar, value: float32) {.importcpp: "#->set_value(#)".} ## \
## Sets the current value of the slider programmatically.  This should range
## between get_min_value() and get_max_value().

proc get_value*(this: PGSliderBar): float32 {.importcpp: "#->get_value()".} ## \
## Returns the current value of the slider.

proc set_ratio*(this: PGSliderBar, ratio: float32) {.importcpp: "#->set_ratio(#)".} ## \
## Sets the current value of the slider, expressed in the range 0 .. 1.

proc get_ratio*(this: PGSliderBar): float32 {.importcpp: "#->get_ratio()".} ## \
## Returns the current value of the slider, expressed in the range 0 .. 1.

proc is_button_down*(this: PGSliderBar): bool {.importcpp: "#->is_button_down()".} ## \
## Returns true if the user is currently holding down the mouse button to
## manipulate the slider.  When true, calls to set_ratio() or set_value() will
## have no effect.

proc set_resize_thumb*(this: PGSliderBar, resize_thumb: bool) {.importcpp: "#->set_resize_thumb(#)".} ## \
## Sets the resize_thumb flag.  When this is true, the thumb button's frame
## will be adjusted so that its width visually represents the page size.  When
## this is false, the thumb button will be left alone.

proc get_resize_thumb*(this: PGSliderBar): bool {.importcpp: "#->get_resize_thumb()".} ## \
## Returns the resize_thumb flag.  See set_resize_thumb().

proc set_manage_pieces*(this: PGSliderBar, manage_pieces: bool) {.importcpp: "#->set_manage_pieces(#)".} ## \
## Sets the manage_pieces flag.  When this is true, the sub-pieces of the
## slider bar--that is, the thumb, and the left and right scroll buttons--are
## automatically positioned and/or resized when the slider bar's overall frame
## is changed.

proc get_manage_pieces*(this: PGSliderBar): bool {.importcpp: "#->get_manage_pieces()".} ## \
## Returns the manage_pieces flag.  See set_manage_pieces().

proc set_thumb_button*(this: PGSliderBar, thumb_button: PGButton) {.importcpp: "#->set_thumb_button(#)".} ## \
## Sets the PGButton object that will serve as the thumb for this slider.
## This button visually represents the position of the slider, and can be
## dragged left and right by the user.
##
## It is the responsibility of the caller to ensure that the button object is
## parented to the PGSliderBar node.

proc clear_thumb_button*(this: PGSliderBar) {.importcpp: "#->clear_thumb_button()".} ## \
## Removes the thumb button object from control of the frame.  It is your
## responsibility to actually remove or hide the button itself.

proc get_thumb_button*(this: PGSliderBar): PGButton {.importcpp: "#->get_thumb_button()".} ## \
## Returns the PGButton that serves as the thumb for this slider, or NULL if
## it is not set.

proc set_left_button*(this: PGSliderBar, left_button: PGButton) {.importcpp: "#->set_left_button(#)".} ## \
## Sets the PGButton object that will serve as the left scroll button for this
## slider.  This button is optional; if present, the user can click on it to
## move scroll_size units at a time to the left.
##
## It is the responsibility of the caller to ensure that the button object is
## parented to the PGSliderBar node.

proc clear_left_button*(this: PGSliderBar) {.importcpp: "#->clear_left_button()".} ## \
## Removes the left button object from control of the frame.  It is your
## responsibility to actually remove or hide the button itself.

proc get_left_button*(this: PGSliderBar): PGButton {.importcpp: "#->get_left_button()".} ## \
## Returns the PGButton that serves as the left scroll button for this slider,
## if any, or NULL if it is not set.

proc set_right_button*(this: PGSliderBar, right_button: PGButton) {.importcpp: "#->set_right_button(#)".} ## \
## Sets the PGButton object that will serve as the right scroll button for
## this slider.  This button is optional; if present, the user can click on it
## to move scroll_size units at a time to the right.
##
## It is the responsibility of the caller to ensure that the button object is
## parented to the PGSliderBar node.

proc clear_right_button*(this: PGSliderBar) {.importcpp: "#->clear_right_button()".} ## \
## Removes the right button object from control of the frame.  It is your
## responsibility to actually remove or hide the button itself.

proc get_right_button*(this: PGSliderBar): PGButton {.importcpp: "#->get_right_button()".} ## \
## Returns the PGButton that serves as the right scroll button for this
## slider, if any, or NULL if it is not set.

proc get_adjust_prefix*(_: typedesc[PGSliderBar]): string {.importcpp: "nimStringFromStdString(PGSliderBar::get_adjust_prefix())", header: stringConversionCode.} ## \
## Returns the prefix that is used to define the adjust event for all
## PGSliderBars.  The adjust event is the concatenation of this string
## followed by get_id().

proc get_adjust_event*(this: PGSliderBar): string {.importcpp: "nimStringFromStdString(#->get_adjust_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the slider bar value is
## adjusted by the user or programmatically.

proc set_active*(this: PGSliderBar, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets whether the PGItem is active for mouse watching.  This is not
## necessarily related to the active/inactive appearance of the item, which is
## controlled by set_state(), but it does affect whether it responds to mouse
## events.

proc remanage*(this: PGSliderBar) {.importcpp: "#->remanage()".} ## \
## Manages the position and size of the scroll bars and the thumb.  Normally
## this should not need to be called directly.

proc recompute*(this: PGSliderBar) {.importcpp: "#->recompute()".} ## \
## Recomputes the position and size of the thumb.  Normally this should not
## need to be called directly.

proc get_class_type*(_: typedesc[PGSliderBar]): TypeHandle {.importcpp: "PGSliderBar::get_class_type()", header: "pGSliderBar.h".}

converter upcast_to_PGVirtualFrame*(this: PGScrollFrame): PGVirtualFrame {.importcpp: "(PT(PGVirtualFrame)(#))".}

proc newPGScrollFrame*(name: string): PGScrollFrame {.importcpp: "new PGScrollFrame(nimStringToStdString(#))", header: stringConversionCode.}

proc newPGScrollFrame*(): PGScrollFrame {.importcpp: "new PGScrollFrame()".}

proc setup*(this: PGScrollFrame, width: float32, height: float32, left: float32, right: float32, bottom: float32, top: float32, slider_width: float32, bevel: float32) {.importcpp: "#->setup(#, #, #, #, #, #, #, #)".} ## \
## Creates a PGScrollFrame with the indicated dimensions, and the indicated
## virtual frame.

proc set_virtual_frame*(this: PGScrollFrame, virtual_frame: LVecBase4) {.importcpp: "#->set_virtual_frame(#)".} ## \
## Sets the bounding rectangle of the virtual frame.  This is the size of the
## large, virtual canvas which we can see only a portion of at any given time.

proc set_virtual_frame*(this: PGScrollFrame, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_virtual_frame(#, #, #, #)".} ## \
## Sets the bounding rectangle of the virtual frame.  This is the size of the
## large, virtual canvas which we can see only a portion of at any given time.

proc get_virtual_frame*(this: PGScrollFrame): LVecBase4 {.importcpp: "#->get_virtual_frame()".} ## \
## Returns the bounding rectangle of the virtual frame.  See
## set_virtual_frame().  If has_virtual_frame() is false, this returns the
## item's clip frame.

proc has_virtual_frame*(this: PGScrollFrame): bool {.importcpp: "#->has_virtual_frame()".} ## \
## Returns true if the virtual frame has a bounding rectangle; see
## set_virtual_frame().  Most PGScrollFrame objects will have a virtual frame.

proc clear_virtual_frame*(this: PGScrollFrame) {.importcpp: "#->clear_virtual_frame()".} ## \
## Removes the virtual frame from the item.  This effectively sets the virtual
## frame to the same size as the clip frame.  Scrolling will no longer be
## possible.

proc set_manage_pieces*(this: PGScrollFrame, manage_pieces: bool) {.importcpp: "#->set_manage_pieces(#)".} ## \
## Sets the manage_pieces flag.  When this is true, the sub-pieces of the
## scroll frame--that is, the two scroll bars--are automatically positioned
## and/or resized when the scroll frame's overall frame is changed.  They are
## also automatically resized to fill in the gap when one or the other is
## hidden.

proc get_manage_pieces*(this: PGScrollFrame): bool {.importcpp: "#->get_manage_pieces()".} ## \
## Returns the manage_pieces flag.  See set_manage_pieces().

proc set_auto_hide*(this: PGScrollFrame, auto_hide: bool) {.importcpp: "#->set_auto_hide(#)".} ## \
## Sets the auto_hide flag.  When this is true, the two scroll bars are
## automatically hidden if they are not needed (that is, if the virtual frame
## would fit within the clip frame without them), and they are automatically
## shown when they are needed.
##
## Setting this flag true forces the manage_pieces flag to also be set true.

proc get_auto_hide*(this: PGScrollFrame): bool {.importcpp: "#->get_auto_hide()".} ## \
## Returns the auto_hide flag.  See set_auto_hide().

proc set_horizontal_slider*(this: PGScrollFrame, horizontal_slider: PGSliderBar) {.importcpp: "#->set_horizontal_slider(#)".} ## \
## Sets the PGSliderBar object that will serve as the horizontal scroll bar
## for this frame.  It is your responsibility to parent this slider bar to the
## frame and move it to the appropriate place.

proc clear_horizontal_slider*(this: PGScrollFrame) {.importcpp: "#->clear_horizontal_slider()".} ## \
## Removes the horizontal scroll bar from control of the frame.  It is your
## responsibility to actually remove or hide the object itself.

proc get_horizontal_slider*(this: PGScrollFrame): PGSliderBar {.importcpp: "#->get_horizontal_slider()".} ## \
## Returns the PGSliderBar that serves as the horizontal scroll bar for this
## frame, if any, or NULL if it is not set.

proc set_vertical_slider*(this: PGScrollFrame, vertical_slider: PGSliderBar) {.importcpp: "#->set_vertical_slider(#)".} ## \
## Sets the PGSliderBar object that will serve as the vertical scroll bar for
## this frame.  It is your responsibility to parent this slider bar to the
## frame and move it to the appropriate place.

proc clear_vertical_slider*(this: PGScrollFrame) {.importcpp: "#->clear_vertical_slider()".} ## \
## Removes the vertical scroll bar from control of the frame.  It is your
## responsibility to actually remove or hide the object itself.

proc get_vertical_slider*(this: PGScrollFrame): PGSliderBar {.importcpp: "#->get_vertical_slider()".} ## \
## Returns the PGSliderBar that serves as the vertical scroll bar for this
## frame, if any, or NULL if it is not set.

proc remanage*(this: PGScrollFrame) {.importcpp: "#->remanage()".} ## \
## Manages the position and size of the scroll bars.  Normally this should not
## need to be called directly.

proc recompute*(this: PGScrollFrame) {.importcpp: "#->recompute()".} ## \
## Forces the PGScrollFrame to recompute itself right now.  Normally this
## should not be required.

proc get_class_type*(_: typedesc[PGScrollFrame]): TypeHandle {.importcpp: "PGScrollFrame::get_class_type()", header: "pGScrollFrame.h".}

proc newPGWaitBar*(name: string): PGWaitBar {.importcpp: "new PGWaitBar(nimStringToStdString(#))", header: stringConversionCode.}

proc newPGWaitBar*(): PGWaitBar {.importcpp: "new PGWaitBar()".}

proc setup*(this: PGWaitBar, width: float32, height: float32, range: float32) {.importcpp: "#->setup(#, #, #)".} ## \
## Creates a PGWaitBar with the indicated dimensions, with the indicated
## maximum range.

proc set_range*(this: PGWaitBar, range: float32) {.importcpp: "#->set_range(#)".} ## \
## Sets the value at which the WaitBar indicates 100%.

proc get_range*(this: PGWaitBar): float32 {.importcpp: "#->get_range()".} ## \
## Returns the value at which the WaitBar indicates 100%.

proc set_value*(this: PGWaitBar, value: float32) {.importcpp: "#->set_value(#)".} ## \
## Sets the current value of the bar.  This should range between 0 and
## get_range().

proc get_value*(this: PGWaitBar): float32 {.importcpp: "#->get_value()".} ## \
## Returns the current value of the bar.

proc get_percent*(this: PGWaitBar): float32 {.importcpp: "#->get_percent()".} ## \
## Returns the percentage complete.

proc set_bar_style*(this: PGWaitBar, style: PGFrameStyle) {.importcpp: "#->set_bar_style(#)".} ## \
## Sets the kind of frame that is drawn on top of the WaitBar to represent the
## amount completed.

proc get_bar_style*(this: PGWaitBar): PGFrameStyle {.importcpp: "#->get_bar_style()".} ## \
## Returns the kind of frame that is drawn on top of the WaitBar to represent
## the amount completed.

proc get_class_type*(_: typedesc[PGWaitBar]): TypeHandle {.importcpp: "PGWaitBar::get_class_type()", header: "pGWaitBar.h".}

proc initNetAddress*(): NetAddress {.importcpp: "NetAddress()".} ## \
## Constructs an unspecified address.

proc initNetAddress*(param0: NetAddress): NetAddress {.importcpp: "NetAddress(#)".}

proc initNetAddress*(`addr`: Socket_Address): NetAddress {.importcpp: "NetAddress(#)".} ## \
## Constructs an address from a given Socket_Address.  Normally, this
## constructor should not be used by user code; instead, create a default
## NetAddress and use one of the set_*() functions to set up an address.

proc set_any*(this: NetAddress, port: int): bool {.importcpp: "#.set_any(#)".} ## \
## Sets the address up to refer to a particular port, but not to any
## particular IP.  Returns true if successful, false otherwise (currently,
## this only returns true).

proc set_localhost*(this: NetAddress, port: int): bool {.importcpp: "#.set_localhost(#)".} ## \
## Sets the address up to refer to a particular port, on this host.

proc set_broadcast*(this: NetAddress, port: int): bool {.importcpp: "#.set_broadcast(#)".} ## \
## Sets the address to the broadcast address.

proc set_host*(this: NetAddress, hostname: string, port: int): bool {.importcpp: "#.set_host(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Sets the address up to refer to a particular port on a particular host.
## Returns true if the hostname is known, false otherwise.

proc clear*(this: NetAddress) {.importcpp: "#.clear()".} ## \
## Resets the NetAddress to its initial state.

proc get_port*(this: NetAddress): int {.importcpp: "#.get_port()".} ## \
## Returns the port number to which this address refers.

proc set_port*(this: NetAddress, port: int) {.importcpp: "#.set_port(#)".} ## \
## Resets the port number without otherwise changing the address.

proc get_ip_string*(this: NetAddress): string {.importcpp: "nimStringFromStdString(#.get_ip_string())", header: stringConversionCode.} ## \
## Returns the IP address to which this address refers, formatted as a string.

proc is_any*(this: NetAddress): bool {.importcpp: "#.is_any()".} ## \
## Returns true if the IP address has only zeroes.

proc get_ip*(this: NetAddress): int {.importcpp: "#.get_ip()".} ## \
## Returns the IP address to which this address refers, as a 32-bit integer,
## in host byte order.
## @deprecated  Does not work with IPv6 addresses.

proc get_ip_component*(this: NetAddress, n: int): char {.importcpp: "#.get_ip_component(#)".} ## \
## Returns the nth 8-bit component of the IP address.  An IP address has four
## components; component 0 is the first (leftmost), and component 3 is the
## last (rightmost) in the dotted number convention.

proc get_addr*(this: NetAddress): Socket_Address {.importcpp: "#.get_addr()".} ## \
## Returns the Socket_Address for this address.

proc output*(this: NetAddress, `out`: ostream) {.importcpp: "#.output(#)".}

proc get_hash*(this: NetAddress): clonglong {.importcpp: "#.get_hash()".}

proc `==`*(this: NetAddress, other: NetAddress): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: NetAddress, other: NetAddress): bool {.importcpp: "#.operator !=(#)".}

proc newConnection*(manager: ConnectionManager, socket: Socket_IP): Connection {.importcpp: "new Connection(#, #)".} ## \
## Creates a connection.  Normally this constructor should not be used
## directly by user code; use one of the methods in ConnectionManager to make
## a new connection.

proc get_address*(this: Connection): NetAddress {.importcpp: "#->get_address()".} ## \
## Returns the address bound to this connection, if it is a TCP connection.

proc get_manager*(this: Connection): ConnectionManager {.importcpp: "#->get_manager()".} ## \
## Returns a pointer to the ConnectionManager object that serves this
## connection.

proc get_socket*(this: Connection): Socket_IP {.importcpp: "#->get_socket()".} ## \
## Returns the internal Socket_IP that defines the connection.

proc set_collect_tcp*(this: Connection, collect_tcp: bool) {.importcpp: "#->set_collect_tcp(#)".} ## \
## Enables or disables "collect-tcp" mode.  In this mode, individual TCP
## packets are not sent immediately, but rather they are collected together
## and accumulated to be sent periodically as one larger TCP packet.  This
## cuts down on overhead from the TCP/IP protocol, especially if many small
## packets need to be sent on the same connection, but it introduces
## additional latency (since packets must be held before they can be sent).
##
## See set_collect_tcp_interval() to specify the interval of time for which to
## hold packets before sending them.
##
## If you enable this mode, you may also need to periodically call
## consider_flush() to flush the queue if no packets have been sent recently.

proc get_collect_tcp*(this: Connection): bool {.importcpp: "#->get_collect_tcp()".} ## \
## Returns the current setting of "collect-tcp" mode.  See set_collect_tcp().

proc set_collect_tcp_interval*(this: Connection, interval: float64) {.importcpp: "#->set_collect_tcp_interval(#)".} ## \
## Specifies the interval in time, in seconds, for which to hold TCP packets
## before sending all of the recently received packets at once.  This only has
## meaning if "collect-tcp" mode is enabled; see set_collect_tcp().

proc get_collect_tcp_interval*(this: Connection): float64 {.importcpp: "#->get_collect_tcp_interval()".} ## \
## Returns the interval in time, in seconds, for which to hold TCP packets
## before sending all of the recently received packets at once.  This only has
## meaning if "collect-tcp" mode is enabled; see set_collect_tcp().

proc consider_flush*(this: Connection): bool {.importcpp: "#->consider_flush()".} ## \
## Sends the most recently queued TCP datagram(s) if enough time has elapsed.
## This only has meaning if set_collect_tcp() has been set to true.

proc flush*(this: Connection): bool {.importcpp: "#->flush()".} ## \
## Sends the most recently queued TCP datagram(s) now.  This only has meaning
## if set_collect_tcp() has been set to true.

proc set_linger*(this: Connection, flag: bool, time: float64) {.importcpp: "#->set_linger(#, #)".} ## \
## Sets the time to linger on close if data is present.  If flag is false,
## when you close a socket with data available the system attempts to deliver
## the data to the peer (the default behavior).  If flag is false but time is
## zero, the system discards any undelivered data when you close the socket.
## If flag is false but time is nonzero, the system waits up to time seconds
## to deliver the data.

proc set_reuse_addr*(this: Connection, flag: bool) {.importcpp: "#->set_reuse_addr(#)".} ## \
## Sets whether local address reuse is allowed.

proc set_keep_alive*(this: Connection, flag: bool) {.importcpp: "#->set_keep_alive(#)".} ## \
## Sets whether the connection is periodically tested to see if it is still
## alive.

proc set_recv_buffer_size*(this: Connection, size: int) {.importcpp: "#->set_recv_buffer_size(#)".} ## \
## Sets the size of the receive buffer, in bytes.

proc set_send_buffer_size*(this: Connection, size: int) {.importcpp: "#->set_send_buffer_size(#)".} ## \
## Sets the size of the send buffer, in bytes.

proc set_ip_time_to_live*(this: Connection, ttl: int) {.importcpp: "#->set_ip_time_to_live(#)".} ## \
## Sets IP time-to-live.

proc set_ip_type_of_service*(this: Connection, tos: int) {.importcpp: "#->set_ip_type_of_service(#)".} ## \
## Sets IP type-of-service and precedence.

proc set_no_delay*(this: Connection, flag: bool) {.importcpp: "#->set_no_delay(#)".} ## \
## If flag is true, this disables the Nagle algorithm, and prevents delaying
## of send to coalesce packets.

proc set_max_segment*(this: Connection, size: int) {.importcpp: "#->set_max_segment(#)".} ## \
## Sets the maximum segment size.

proc add_connection*(this: ConnectionReader, connection: Connection): bool {.importcpp: "#.add_connection(#)".} ## \
## Adds a new socket to the list of sockets the ConnectionReader will monitor.
## A datagram that comes in on any of the monitored sockets will be reported.
## In the case of a ConnectionListener, this adds a new rendezvous socket; any
## activity on any of the monitored sockets will cause a connection to be
## accepted.
##
## The return value is true if the connection was added, false if it was
## already there.
##
## add_connection() is thread-safe, and may be called at will by any thread.

proc remove_connection*(this: ConnectionReader, connection: Connection): bool {.importcpp: "#.remove_connection(#)".} ## \
## Removes a socket from the list of sockets being monitored.  Returns true if
## the socket was correctly removed, false if it was not on the list in the
## first place.
##
## remove_connection() is thread-safe, and may be called at will by any
## thread.

proc is_connection_ok*(this: ConnectionReader, connection: Connection): bool {.importcpp: "#.is_connection_ok(#)".} ## \
## Returns true if the indicated connection has been added to the
## ConnectionReader and is being monitored properly, false if it is not known,
## or if there was some error condition detected on the connection.  (If there
## was an error condition, normally the ConnectionManager would have been
## informed and closed the connection.)

proc poll*(this: ConnectionReader) {.importcpp: "#.poll()".} ## \
## Explicitly polls the available sockets to see if any of them have any
## noise.  This function does nothing unless this is a polling-type
## ConnectionReader, i.e.  it was created with zero threads (and is_polling()
## will return true).
##
## It is not necessary to call this explicitly for a QueuedConnectionReader.

proc get_manager*(this: ConnectionReader): ConnectionManager {.importcpp: "#.get_manager()".} ## \
## Returns a pointer to the ConnectionManager object that serves this
## ConnectionReader.

proc is_polling*(this: ConnectionReader): bool {.importcpp: "#.is_polling()".} ## \
## Returns true if the reader is a polling reader, i.e.  it has no threads.

proc get_num_threads*(this: ConnectionReader): int {.importcpp: "#.get_num_threads()".} ## \
## Returns the number of threads the ConnectionReader has been created with.

proc set_raw_mode*(this: ConnectionReader, mode: bool) {.importcpp: "#.set_raw_mode(#)".} ## \
## Sets the ConnectionReader into raw mode (or turns off raw mode).  In raw
## mode, datagram headers are not expected; instead, all the data available on
## the pipe is treated as a single datagram.
##
## This is similar to set_tcp_header_size(0), except that it also turns off
## headers for UDP packets.

proc get_raw_mode*(this: ConnectionReader): bool {.importcpp: "#.get_raw_mode()".} ## \
## Returns the current setting of the raw mode flag.  See set_raw_mode().

proc set_tcp_header_size*(this: ConnectionReader, tcp_header_size: int) {.importcpp: "#.set_tcp_header_size(#)".} ## \
## Sets the header size of TCP packets.  At the present, legal values for this
## are 0, 2, or 4; this specifies the number of bytes to use encode the
## datagram length at the start of each TCP datagram.  Sender and receiver
## must independently agree on this.

proc get_tcp_header_size*(this: ConnectionReader): int {.importcpp: "#.get_tcp_header_size()".} ## \
## Returns the current setting of TCP header size.  See set_tcp_header_size().

proc shutdown*(this: ConnectionReader) {.importcpp: "#.shutdown()".} ## \
## Terminates all threads cleanly.  Normally this is only called by the
## destructor, but it may be called explicitly before destruction.

proc initNetDatagram*(): NetDatagram {.importcpp: "NetDatagram()".} ## \
## Constructs an empty datagram.

proc initNetDatagram*(copy: Datagram): NetDatagram {.importcpp: "NetDatagram(#)".}

proc initNetDatagram*(copy: NetDatagram): NetDatagram {.importcpp: "NetDatagram(#)".}

proc set_connection*(this: NetDatagram, connection: Connection) {.importcpp: "#.set_connection(#)".} ## \
## Specifies the socket to which the datagram should be written.

proc get_connection*(this: NetDatagram): Connection {.importcpp: "#.get_connection()".} ## \
## Retrieves the socket from which the datagram was read, or to which it is
## scheduled to be written.

proc set_address*(this: NetDatagram, address: NetAddress) {.importcpp: "#.set_address(#)".} ## \
## Specifies the host to which the datagram should be sent.

proc get_address*(this: NetDatagram): NetAddress {.importcpp: "#.get_address()".} ## \
## Retrieves the host from which the datagram was read, or to which it is
## scheduled to be sent.

proc get_class_type*(_: typedesc[NetDatagram]): TypeHandle {.importcpp: "NetDatagram::get_class_type()", header: "netDatagram.h".}

proc initConnectionManager*(): ConnectionManager {.importcpp: "ConnectionManager()".}

proc open_UDP_connection*(this: ConnectionManager, hostname: string, port: int, for_broadcast: bool): Connection {.importcpp: "#.open_UDP_connection(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Opens a socket for sending and/or receiving UDP packets.  If the port
## number is greater than zero, the UDP connection will be opened for
## listening on the indicated port; otherwise, it will be useful only for
## sending.
##
## This variant accepts both a hostname and port to listen on a particular
## interface; if the hostname is empty, all interfaces will be available,
## both IPv4 and IPv6.
##
## If for_broadcast is true, this UDP connection will be configured to send
## and/or receive messages on the broadcast address (255.255.255.255);
## otherwise, these messages may be automatically filtered by the OS.
##
## Use a ConnectionReader and ConnectionWriter to handle the actual
## communication.

proc open_UDP_connection*(this: ConnectionManager, hostname: string, port: int): Connection {.importcpp: "#.open_UDP_connection(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Opens a socket for sending and/or receiving UDP packets.  If the port
## number is greater than zero, the UDP connection will be opened for
## listening on the indicated port; otherwise, it will be useful only for
## sending.
##
## This variant accepts both a hostname and port to listen on a particular
## interface; if the hostname is empty, all interfaces will be available,
## both IPv4 and IPv6.
##
## If for_broadcast is true, this UDP connection will be configured to send
## and/or receive messages on the broadcast address (255.255.255.255);
## otherwise, these messages may be automatically filtered by the OS.
##
## Use a ConnectionReader and ConnectionWriter to handle the actual
## communication.

proc open_UDP_connection*(this: ConnectionManager, port: int): Connection {.importcpp: "#.open_UDP_connection(#)".} ## \
## Opens a socket for sending and/or receiving UDP packets.  If the port
## number is greater than zero, the UDP connection will be opened for
## listening on the indicated port; otherwise, it will be useful only for
## sending.
##
## Use a ConnectionReader and ConnectionWriter to handle the actual
## communication.

proc open_UDP_connection*(this: ConnectionManager): Connection {.importcpp: "#.open_UDP_connection()".} ## \
## Opens a socket for sending and/or receiving UDP packets.  If the port
## number is greater than zero, the UDP connection will be opened for
## listening on the indicated port; otherwise, it will be useful only for
## sending.
##
## Use a ConnectionReader and ConnectionWriter to handle the actual
## communication.

proc open_TCP_server_rendezvous*(this: ConnectionManager, address: NetAddress, backlog: int): Connection {.importcpp: "#.open_TCP_server_rendezvous(#, #)".} ## \
## Creates a socket to be used as a rendezvous socket for a server to listen
## for TCP connections.  The socket returned by this call should only be added
## to a ConnectionListener (not to a generic ConnectionReader).
##
## This variant of this method accepts a NetAddress, which allows you to
## specify a specific interface to listen to.
##
## backlog is the maximum length of the queue of pending connections.

proc open_TCP_server_rendezvous*(this: ConnectionManager, hostname: string, port: int, backlog: int): Connection {.importcpp: "#.open_TCP_server_rendezvous(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Creates a socket to be used as a rendezvous socket for a server to listen
## for TCP connections.  The socket returned by this call should only be added
## to a ConnectionListener (not to a generic ConnectionReader).
##
## This variant of this method accepts a "hostname", which is usually just an
## IP address in dotted notation, and a port number.  It will listen on the
## interface indicated by the IP address.  If the IP address is empty string,
## it will listen on all interfaces.
##
## backlog is the maximum length of the queue of pending connections.

proc open_TCP_server_rendezvous*(this: ConnectionManager, port: int, backlog: int): Connection {.importcpp: "#.open_TCP_server_rendezvous(#, #)".} ## \
## Creates a socket to be used as a rendezvous socket for a server to listen
## for TCP connections.  The socket returned by this call should only be added
## to a ConnectionListener (not to a generic ConnectionReader).
##
## This variant of this method accepts a single port, and will listen to that
## port on all available interfaces, both IPv4 and IPv6.
##
## backlog is the maximum length of the queue of pending connections.

proc open_TCP_client_connection*(this: ConnectionManager, address: NetAddress, timeout_ms: int): Connection {.importcpp: "#.open_TCP_client_connection(#, #)".} ## \
## Attempts to establish a TCP client connection to a server at the indicated
## address.  If the connection is not established within timeout_ms
## milliseconds, a null connection is returned.

proc open_TCP_client_connection*(this: ConnectionManager, hostname: string, port: int, timeout_ms: int): Connection {.importcpp: "#.open_TCP_client_connection(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## This is a shorthand version of the function to directly establish
## communications to a named host and port.

proc close_connection*(this: ConnectionManager, connection: Connection): bool {.importcpp: "#.close_connection(#)".} ## \
## Terminates a UDP or TCP socket previously opened.  This also removes it
## from any associated ConnectionReader or ConnectionListeners.
##
## The socket itself may not be immediately closed--it will not be closed
## until all outstanding pointers to it are cleared, including any pointers
## remaining in NetDatagrams recently received from the socket.
##
## The return value is true if the connection was marked to be closed, or
## false if close_connection() had already been called (or the connection did
## not belong to this ConnectionManager).  In neither case can you infer
## anything about whether the connection has *actually* been closed yet based
## on the return value.

proc wait_for_readers*(this: ConnectionManager, timeout: float64): bool {.importcpp: "#.wait_for_readers(#)".} ## \
## Blocks the process for timeout number of seconds, or until any data is
## available on any of the non-threaded ConnectionReaders or
## ConnectionListeners, whichever comes first.  The return value is true if
## there is data available (but you have to iterate through all readers to
## find it), or false if the timeout occurred without any data.
##
## If the timeout value is negative, this will block forever or until data is
## available.
##
## This only works if all ConnectionReaders and ConnectionListeners are non-
## threaded.  If any threaded ConnectionReaders are part of the
## ConnectionManager, the timeout value is implicitly treated as 0.

proc get_host_name*(_: typedesc[ConnectionManager]): string {.importcpp: "nimStringFromStdString(ConnectionManager::get_host_name())", header: "connectionManager.h".} ## \
## Returns the name of this particular machine on the network, if available,
## or the empty string if the hostname cannot be determined.

proc scan_interfaces*(this: ConnectionManager) {.importcpp: "#.scan_interfaces()".} ## \
## Repopulates the list reported by get_num_interface()/get_interface().  It
## is not necessary to call this explicitly, unless you want to re-determine
## the connected interfaces (for instance, if you suspect the hardware has
## recently changed).

proc get_num_interfaces*(this: ConnectionManager): clonglong {.importcpp: "#.get_num_interfaces()".} ## \
## This returns the number of usable network interfaces detected on this
## machine.  See scan_interfaces() to repopulate this list.

proc initConnectionWriter*(manager: ConnectionManager, num_threads: int, thread_name: string): ConnectionWriter {.importcpp: "ConnectionWriter(#, #, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates a new ConnectionWriter with the indicated number of threads to
## handle output.
##
## If num_threads is 0, all datagrams will be sent immediately instead of
## queueing for later transmission by a thread.

proc initConnectionWriter*(manager: ConnectionManager, num_threads: int): ConnectionWriter {.importcpp: "ConnectionWriter(#, #)".} ## \
## Creates a new ConnectionWriter with the indicated number of threads to
## handle output.
##
## If num_threads is 0, all datagrams will be sent immediately instead of
## queueing for later transmission by a thread.

proc set_max_queue_size*(this: ConnectionWriter, max_size: int) {.importcpp: "#.set_max_queue_size(#)".} ## \
## Limits the number of packets that may be pending on the outbound queue.
## This only has an effect when using threads; if num_threads is 0, then all
## packets are sent immediately.

proc get_max_queue_size*(this: ConnectionWriter): int {.importcpp: "#.get_max_queue_size()".} ## \
## Returns the maximum size the queue is allowed to grow to.  See
## set_max_queue_size().

proc get_current_queue_size*(this: ConnectionWriter): int {.importcpp: "#.get_current_queue_size()".} ## \
## Returns the current number of things in the queue.

proc send*(this: ConnectionWriter, datagram: Datagram, connection: Connection, address: NetAddress, `block`: bool): bool {.importcpp: "#.send(#, #, #, #)".} ## \
## Enqueues a datagram for transmittal on the indicated socket.  This form of
## the function allows the specification of a destination host address, and so
## is appropriate for UDP packets.  Use the other send() method for sending
## TCP packets.
##
## Returns true if successful, false if there was an error.  In the normal,
## threaded case, this function only returns false if the send queue is
## filled; it's impossible to detect a transmission error at this point.
##
## If block is true, this will not return false if the send queue is filled;
## instead, it will wait until there is space available.

proc send*(this: ConnectionWriter, datagram: Datagram, connection: Connection, address: NetAddress): bool {.importcpp: "#.send(#, #, #)".} ## \
## Enqueues a datagram for transmittal on the indicated socket.  This form of
## the function allows the specification of a destination host address, and so
## is appropriate for UDP packets.  Use the other send() method for sending
## TCP packets.
##
## Returns true if successful, false if there was an error.  In the normal,
## threaded case, this function only returns false if the send queue is
## filled; it's impossible to detect a transmission error at this point.
##
## If block is true, this will not return false if the send queue is filled;
## instead, it will wait until there is space available.

proc send*(this: ConnectionWriter, datagram: Datagram, connection: Connection, `block`: bool): bool {.importcpp: "#.send(#, #, #)".} ## \
## Enqueues a datagram for transmittal on the indicated socket.  Since the
## host address is not specified with this form, this function should only be
## used for sending TCP packets.  Use the other send() method for sending UDP
## packets.
##
## Returns true if successful, false if there was an error.  In the normal,
## threaded case, this function only returns false if the send queue is
## filled; it's impossible to detect a transmission error at this point.
##
## If block is true, this will not return false if the send queue is filled;
## instead, it will wait until there is space available.

proc send*(this: ConnectionWriter, datagram: Datagram, connection: Connection): bool {.importcpp: "#.send(#, #)".} ## \
## Enqueues a datagram for transmittal on the indicated socket.  Since the
## host address is not specified with this form, this function should only be
## used for sending TCP packets.  Use the other send() method for sending UDP
## packets.
##
## Returns true if successful, false if there was an error.  In the normal,
## threaded case, this function only returns false if the send queue is
## filled; it's impossible to detect a transmission error at this point.
##
## If block is true, this will not return false if the send queue is filled;
## instead, it will wait until there is space available.

proc is_valid_for_udp*(this: ConnectionWriter, datagram: Datagram): bool {.importcpp: "#.is_valid_for_udp(#)".} ## \
## Returns true if the datagram is small enough to be sent over a UDP packet,
## false otherwise.

proc get_manager*(this: ConnectionWriter): ConnectionManager {.importcpp: "#.get_manager()".} ## \
## Returns a pointer to the ConnectionManager object that serves this
## ConnectionWriter.

proc is_immediate*(this: ConnectionWriter): bool {.importcpp: "#.is_immediate()".} ## \
## Returns true if the writer is an immediate writer, i.e.  it has no threads.

proc get_num_threads*(this: ConnectionWriter): int {.importcpp: "#.get_num_threads()".} ## \
## Returns the number of threads the ConnectionWriter has been created with.

proc set_raw_mode*(this: ConnectionWriter, mode: bool) {.importcpp: "#.set_raw_mode(#)".} ## \
## Sets the ConnectionWriter into raw mode (or turns off raw mode).  In raw
## mode, datagrams are not sent along with their headers; the bytes in the
## datagram are simply sent down the pipe.
##
## Setting the ConnectionWriter to raw mode must be done with care.  This can
## only be done when the matching ConnectionReader is also set to raw mode, or
## when the ConnectionWriter is communicating to a process that does not
## expect datagrams.

proc get_raw_mode*(this: ConnectionWriter): bool {.importcpp: "#.get_raw_mode()".} ## \
## Returns the current setting of the raw mode flag.  See set_raw_mode().

proc set_tcp_header_size*(this: ConnectionWriter, tcp_header_size: int) {.importcpp: "#.set_tcp_header_size(#)".} ## \
## Sets the header size of TCP packets.  At the present, legal values for this
## are 0, 2, or 4; this specifies the number of bytes to use encode the
## datagram length at the start of each TCP datagram.  Sender and receiver
## must independently agree on this.

proc get_tcp_header_size*(this: ConnectionWriter): int {.importcpp: "#.get_tcp_header_size()".} ## \
## Returns the current setting of TCP header size.  See set_tcp_header_size().

proc shutdown*(this: ConnectionWriter) {.importcpp: "#.shutdown()".} ## \
## Stops all the threads and cleans them up.  This is called automatically by
## the destructor, but it may be called explicitly before destruction.

converter upcast_to_DatagramGenerator*(this: DatagramGeneratorNet): DatagramGenerator {.importcpp: "#.upcast_to_DatagramGenerator()".}

converter upcast_to_ConnectionReader*(this: DatagramGeneratorNet): ConnectionReader {.importcpp: "#.upcast_to_ConnectionReader()".}

proc initDatagramGeneratorNet*(manager: ConnectionManager, num_threads: int): DatagramGeneratorNet {.importcpp: "DatagramGeneratorNet(#, #)".} ## \
## Creates a new DatagramGeneratorNet with the indicated number of threads to
## handle requests.  Normally num_threads should be either 0 or 1 to guarantee
## that datagrams are generated in the same order in which they were received.

proc get_datagram*(this: DatagramGeneratorNet, data: Datagram): bool {.importcpp: "#.get_datagram(#)".} ## \
## Reads the next datagram from the stream.  Blocks until a datagram is
## available.  Returns true on success, false on stream closed or error.

proc is_eof*(this: DatagramGeneratorNet): bool {.importcpp: "#.is_eof()".} ## \
## Returns true if the stream has been closed normally.  This test may only be
## made after a call to get_datagram() has failed.

proc is_error*(this: DatagramGeneratorNet): bool {.importcpp: "#.is_error()".} ## \
## Returns true if the stream has an error condition.

converter upcast_to_DatagramSink*(this: DatagramSinkNet): DatagramSink {.importcpp: "#.upcast_to_DatagramSink()".}

converter upcast_to_ConnectionWriter*(this: DatagramSinkNet): ConnectionWriter {.importcpp: "#.upcast_to_ConnectionWriter()".}

proc initDatagramSinkNet*(manager: ConnectionManager, num_threads: int): DatagramSinkNet {.importcpp: "DatagramSinkNet(#, #)".} ## \
## Creates a new DatagramSinkNet with the indicated number of threads to
## handle writing.  Normally num_threads should be either 0 or 1 to guarantee
## that datagrams are delivered in the same order in which they were sent.

proc set_target*(this: DatagramSinkNet, connection: Connection) {.importcpp: "#.set_target(#)".} ## \
## Specifies the Connection that will receive all future Datagrams sent.

proc get_target*(this: DatagramSinkNet): Connection {.importcpp: "#.get_target()".} ## \
## Returns the current target Connection, or NULL if the target has not yet
## been set.  See set_target().

proc put_datagram*(this: DatagramSinkNet, data: Datagram): bool {.importcpp: "#.put_datagram(#)".} ## \
## Sends the given datagram to the target.  Returns true on success, false if
## there is an error.  Blocks if necessary until the target is ready.

proc is_error*(this: DatagramSinkNet): bool {.importcpp: "#.is_error()".} ## \
## Returns true if there is an error on the target connection, or if the
## target has never been set.

proc flush*(this: DatagramSinkNet) {.importcpp: "#.flush()".} ## \
## Ensures that all datagrams previously written will be visible on the
## stream.

converter upcast_to_ConnectionListener*(this: QueuedConnectionListener): ConnectionListener {.importcpp: "#.upcast_to_ConnectionListener()".}

proc initQueuedConnectionListener*(manager: ConnectionManager, num_threads: int): QueuedConnectionListener {.importcpp: "QueuedConnectionListener(#, #)".}

proc new_connection_available*(this: QueuedConnectionListener): bool {.importcpp: "#.new_connection_available()".} ## \
## Returns true if a new connection was recently established; the connection
## information may then be retrieved via get_new_connection().

converter upcast_to_ConnectionManager*(this: QueuedConnectionManager): ConnectionManager {.importcpp: "#.upcast_to_ConnectionManager()".}

proc initQueuedConnectionManager*(): QueuedConnectionManager {.importcpp: "QueuedConnectionManager()".}

proc reset_connection_available*(this: QueuedConnectionManager): bool {.importcpp: "#.reset_connection_available()".} ## \
## Returns true if one of the readers/writers/listeners reported a connection
## reset recently.  If so, the particular connection that has been reset can
## be extracted via get_reset_connection().
##
## Only connections which were externally reset are certain to appear in this
## list.  Those which were explicitly closed via a call to close_connection()
## may or may not be reported.  Furthermore, it is the responsibility of the
## caller to subsequently call close_connection() with any connection reported
## reset by this call.  (There is no harm in calling close_connection() more
## than once on a given socket.)

converter upcast_to_ConnectionReader*(this: QueuedConnectionReader): ConnectionReader {.importcpp: "#.upcast_to_ConnectionReader()".}

proc initQueuedConnectionReader*(manager: ConnectionManager, num_threads: int): QueuedConnectionReader {.importcpp: "QueuedConnectionReader(#, #)".}

proc data_available*(this: QueuedConnectionReader): bool {.importcpp: "#.data_available()".} ## \
## Returns true if a datagram is available on the queue; call get_data() to
## extract the datagram.

proc get_data*(this: QueuedConnectionReader, result: Datagram): bool {.importcpp: "#.get_data(#)".} ## \
## This flavor of QueuedConnectionReader::get_data(), works like the other,
## except that it only fills a Datagram object, not a NetDatagram object.
## This means that the Datagram cannot be queried for its source Connection
## and/or NetAddress, but it is useful in all other respects.

proc get_data*(this: QueuedConnectionReader, result: NetDatagram): bool {.importcpp: "#.get_data(#)".} ## \
## If a previous call to data_available() returned true, this function will
## return the datagram that has become available.
##
## The return value is true if a datagram was successfully returned, or false
## if there was, in fact, no datagram available.  (This may happen if there
## are multiple threads accessing the QueuedConnectionReader).

proc initRecentConnectionReader*(manager: ConnectionManager): RecentConnectionReader {.importcpp: "RecentConnectionReader(#)".}

proc data_available*(this: RecentConnectionReader): bool {.importcpp: "#.data_available()".} ## \
## Returns true if a datagram is available on the queue; call get_data() to
## extract the datagram.

proc get_data*(this: RecentConnectionReader, result: Datagram): bool {.importcpp: "#.get_data(#)".} ## \
## This flavor of RecentConnectionReader::get_data(), works like the other,
## except that it only fills a Datagram object, not a NetDatagram object.
## This means that the Datagram cannot be queried for its source Connection
## and/or NetAddress, but it is useful in all other respects.

proc get_data*(this: RecentConnectionReader, result: NetDatagram): bool {.importcpp: "#.get_data(#)".} ## \
## If a previous call to data_available() returned true, this function will
## return the datagram that has become available.
##
## The return value is true if a datagram was successfully returned, or false
## if there was, in fact, no datagram available.  (This may happen if there
## are multiple threads accessing the RecentConnectionReader).

proc initSocket_Address*(inaddr: Socket_Address): Socket_Address {.importcpp: "Socket_Address(#)".}

proc initSocket_Address*(port: int): Socket_Address {.importcpp: "Socket_Address(#)".} ## \
## Constructor that lets us set a port value

proc initSocket_Address*(): Socket_Address {.importcpp: "Socket_Address()".} ## \
## Constructor that lets us set a port value

proc set_any_IP*(this: Socket_Address, port: int): bool {.importcpp: "#.set_any_IP(#)".} ## \
## Set to any address and a specified port

proc set_any_IPv6*(this: Socket_Address, port: int): bool {.importcpp: "#.set_any_IPv6(#)".} ## \
## Set to any IPv6 address and a specified port.

proc set_port*(this: Socket_Address, port: int): bool {.importcpp: "#.set_port(#)".} ## \
## Set to a specified port

proc set_broadcast*(this: Socket_Address, port: int): bool {.importcpp: "#.set_broadcast(#)".} ## \
## Set to the broadcast address and a specified port

proc set_host*(this: Socket_Address, hostname: string): bool {.importcpp: "#.set_host(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Initializes the address from a string specifying both the address and port,
## separated by a colon.  An IPv6 address must be enclosed in brackets.

proc set_host*(this: Socket_Address, hostname: string, port: int): bool {.importcpp: "#.set_host(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## This function will take a port and string-based TCP address and initialize
## the address with this information.  Returns true on success; on failure, it
## returns false and the address may be undefined.

proc set_host*(this: Socket_Address, ip4addr: int, port: int): bool {.importcpp: "#.set_host(#, #)".}

proc clear*(this: Socket_Address) {.importcpp: "#.clear()".} ## \
## Set the internal values to a suitable known value

proc get_family*(this: Socket_Address): int {.importcpp: "#.get_family()".} ## \
## Returns AF_INET if this is an IPv4 address, or AF_INET6 if this is an IPv6
## address.

proc get_port*(this: Socket_Address): int {.importcpp: "#.get_port()".} ## \
## Get the port portion as an integer

proc get_ip*(this: Socket_Address): string {.importcpp: "nimStringFromStdString(#.get_ip())", header: stringConversionCode.} ## \
## Return the IP address portion in dot notation string.

proc get_ip_port*(this: Socket_Address): string {.importcpp: "nimStringFromStdString(#.get_ip_port())", header: stringConversionCode.} ## \
## Return the ip address/port in dot notation string.  If this is an IPv6
## address, it will be enclosed in square brackets.

proc GetIPAddressRaw*(this: Socket_Address): int {.importcpp: "#.GetIPAddressRaw()".} ## \
## Returns a raw 32-bit unsigned integer representing the IPv4 address.
## @deprecated  Does not work with IPv6 addresses.

proc `==`*(this: Socket_Address, `in`: Socket_Address): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: Socket_Address, `in`: Socket_Address): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: Socket_Address, `in`: Socket_Address): bool {.importcpp: "#.operator <(#)".}

proc is_any*(this: Socket_Address): bool {.importcpp: "#.is_any()".} ## \
## True if the address is zero.

proc is_mcast_range*(this: Socket_Address): bool {.importcpp: "#.is_mcast_range()".} ## \
## True if the address is in the multicast range.

proc initSocket_IP*(): Socket_IP {.importcpp: "Socket_IP()".} ## \
## Def Constructor

proc initSocket_IP*(`in`: int): Socket_IP {.importcpp: "Socket_IP(#)".} ## \
## Assigns an existing socket to this class

proc Close*(this: Socket_IP) {.importcpp: "#.Close()".} ## \
## Closes a socket if it is open (allocated).

proc GetLastError*(_: typedesc[Socket_IP]): int {.importcpp: "Socket_IP::GetLastError()", header: "socket_IP.h".} ## \
## Gets the last errcode from a socket operation.

proc SetNonBlocking*(this: Socket_IP): int {.importcpp: "#.SetNonBlocking()".} ## \
## this function will throw a socket into non-blocking mode

proc SetBlocking*(this: Socket_IP): int {.importcpp: "#.SetBlocking()".} ## \
## Set the socket to block on subsequent calls to socket functions that
## address this socket

proc SetReuseAddress*(this: Socket_IP, flag: bool): bool {.importcpp: "#.SetReuseAddress(#)".} ## \
## Informs a socket to reuse IP address as needed

proc SetReuseAddress*(this: Socket_IP): bool {.importcpp: "#.SetReuseAddress()".} ## \
## Informs a socket to reuse IP address as needed

proc SetV6Only*(this: Socket_IP, flag: bool): bool {.importcpp: "#.SetV6Only(#)".} ## \
## Sets a flag indicating whether this IPv6 socket should operate in
## dual-stack mode or not.

proc Active*(this: Socket_IP): bool {.importcpp: "#.Active()".} ## \
## Ask if the socket is open (allocated)

proc SetRecvBufferSize*(this: Socket_IP, size: int): int {.importcpp: "#.SetRecvBufferSize(#)".} ## \
## Ok it sets the recv buffer size for both tcp and UDP

proc SetSocket*(this: Socket_IP, ins: int) {.importcpp: "#.SetSocket(#)".} ## \
## Assigns an existing socket to this class

proc GetSocket*(this: Socket_IP): int {.importcpp: "#.GetSocket()".} ## \
## Gets the base socket type

proc GetPeerName*(this: Socket_IP): Socket_Address {.importcpp: "#.GetPeerName()".} ## \
## Wrapper on berkly getpeername...

proc InitNetworkDriver*(_: typedesc[Socket_IP]): int {.importcpp: "Socket_IP::InitNetworkDriver()", header: "socket_IP.h".}

proc get_class_type*(_: typedesc[Socket_IP]): TypeHandle {.importcpp: "Socket_IP::get_class_type()", header: "socket_IP.h".}

proc initSocket_TCP*(): Socket_TCP {.importcpp: "Socket_TCP()".}

proc initSocket_TCP*(param0: int): Socket_TCP {.importcpp: "Socket_TCP(#)".}

proc SetNoDelay*(this: Socket_TCP, flag: bool): int {.importcpp: "#.SetNoDelay(#)".} ## \
## Disable Nagle algorithm.  Don't delay send to coalesce packets

proc SetNoDelay*(this: Socket_TCP): int {.importcpp: "#.SetNoDelay()".} ## \
## Disable Nagle algorithm.  Don't delay send to coalesce packets

proc SetLinger*(this: Socket_TCP, interval_seconds: int): int {.importcpp: "#.SetLinger(#)".} ## \
## will control the behavior of SO_LINGER for a TCP socket

proc SetLinger*(this: Socket_TCP): int {.importcpp: "#.SetLinger()".} ## \
## will control the behavior of SO_LINGER for a TCP socket

proc DontLinger*(this: Socket_TCP): int {.importcpp: "#.DontLinger()".} ## \
## Turn off the linger flag.  The socket will quickly release buffered items
## and free up OS resources.  You may lose a stream if you use this flag and
## do not negotiate the close at the application layer.

proc SetSendBufferSize*(this: Socket_TCP, insize: int): int {.importcpp: "#.SetSendBufferSize(#)".} ## \
## Just like it sounds.  Sets a buffered socket recv buffer size.  This
## function does not refuse ranges outside hard-coded OS limits

proc ActiveOpen*(this: Socket_TCP, theaddress: Socket_Address, setdelay: bool): bool {.importcpp: "#.ActiveOpen(#, #)".} ## \
## This function will try and set the socket up for active open to a specified
## address and port provided by the input parameter

proc ActiveOpenNonBlocking*(this: Socket_TCP, theaddress: Socket_Address): bool {.importcpp: "#.ActiveOpenNonBlocking(#)".} ## \
## This function will try and set the socket up for active open to a specified
## address and port provided by the input parameter (non-blocking version)

proc ErrorIs_WouldBlocking*(this: Socket_TCP, err: int): bool {.importcpp: "#.ErrorIs_WouldBlocking(#)".}

proc ShutdownSend*(this: Socket_TCP): bool {.importcpp: "#.ShutdownSend()".}

proc SendData*(this: Socket_TCP, str: string): int {.importcpp: "#.SendData(nimStringToStdString(#))", header: stringConversionCode.}

proc RecvData*(this: Socket_TCP, max_len: int): string {.importcpp: "nimStringFromStdString(#.RecvData(#))", header: stringConversionCode.} ## \
## Read the data from the connection - if error 0 if socket closed for read or
## length is 0 + bytes read (May be smaller than requested)

proc get_class_type*(_: typedesc[Socket_TCP]): TypeHandle {.importcpp: "Socket_TCP::get_class_type()", header: "socket_TCP.h".}

proc initSocket_TCP_Listen*(): Socket_TCP_Listen {.importcpp: "Socket_TCP_Listen()".}

proc OpenForListen*(this: Socket_TCP_Listen, address: Socket_Address, backlog_size: int): bool {.importcpp: "#.OpenForListen(#, #)".} ## \
## This function will initialize a listening Socket

proc OpenForListen*(this: Socket_TCP_Listen, address: Socket_Address): bool {.importcpp: "#.OpenForListen(#)".} ## \
## This function will initialize a listening Socket

proc OpenForListen*(this: Socket_TCP_Listen, port: int, backlog_size: int): bool {.importcpp: "#.OpenForListen(#, #)".} ## \
## This function will initialize a listening Socket

proc OpenForListen*(this: Socket_TCP_Listen, port: int): bool {.importcpp: "#.OpenForListen(#)".} ## \
## This function will initialize a listening Socket

proc GetIncomingConnection*(this: Socket_TCP_Listen, newsession: Socket_TCP, address: Socket_Address): bool {.importcpp: "#.GetIncomingConnection(#, #)".}

proc get_class_type*(_: typedesc[Socket_TCP_Listen]): TypeHandle {.importcpp: "Socket_TCP_Listen::get_class_type()", header: "socket_TCP_Listen.h".}

proc initSocket_UDP_Incoming*(): Socket_UDP_Incoming {.importcpp: "Socket_UDP_Incoming()".}

proc OpenForInput*(this: Socket_UDP_Incoming, address: Socket_Address): bool {.importcpp: "#.OpenForInput(#)".} ## \
## Starts a UDP socket listening on a port

proc OpenForInput*(this: Socket_UDP_Incoming, port: int): bool {.importcpp: "#.OpenForInput(#)".} ## \
## Starts a UDP socket listening on a port

proc OpenForInputMCast*(this: Socket_UDP_Incoming, address: Socket_Address): bool {.importcpp: "#.OpenForInputMCast(#)".} ## \
## Starts a UDP socket listening on a port

proc SendTo*(this: Socket_UDP_Incoming, data: string, len: int, address: Socket_Address): bool {.importcpp: "#.SendTo(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Send data to specified address

proc InitNoAddress*(this: Socket_UDP_Incoming): bool {.importcpp: "#.InitNoAddress()".} ## \
## Set this socket to work without a bound external address.

proc SetToBroadCast*(this: Socket_UDP_Incoming): bool {.importcpp: "#.SetToBroadCast()".} ## \
## Flips the OS bits that allow for brodcast packets to come in on this port.

proc get_class_type*(_: typedesc[Socket_UDP_Incoming]): TypeHandle {.importcpp: "Socket_UDP_Incoming::get_class_type()", header: "socket_UDP_Incoming.h".}

proc initSocket_UDP_Outgoing*(): Socket_UDP_Outgoing {.importcpp: "Socket_UDP_Outgoing()".}

proc InitToAddress*(this: Socket_UDP_Outgoing, address: Socket_Address): bool {.importcpp: "#.InitToAddress(#)".} ## \
## Connects the Socket to a specified address

proc Send*(this: Socket_UDP_Outgoing, data: string): bool {.importcpp: "#.Send(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Send data to connected address

proc InitNoAddress*(this: Socket_UDP_Outgoing): bool {.importcpp: "#.InitNoAddress()".} ## \
## use this interface for a none tagreted UDP connection

proc SendTo*(this: Socket_UDP_Outgoing, data: string, address: Socket_Address): bool {.importcpp: "#.SendTo(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Send data to specified address

proc SetToBroadCast*(this: Socket_UDP_Outgoing): bool {.importcpp: "#.SetToBroadCast()".} ## \
## Ask the OS to let us receive broadcast packets on this port.

proc get_class_type*(_: typedesc[Socket_UDP_Outgoing]): TypeHandle {.importcpp: "Socket_UDP_Outgoing::get_class_type()", header: "socket_UDP_Outgoing.h".}

proc initSocket_fdset*(): Socket_fdset {.importcpp: "Socket_fdset()".} ## \
## The constructor

proc initSocket_fdset*(param0: Socket_fdset): Socket_fdset {.importcpp: "Socket_fdset(#)".}

proc setForSocket*(this: Socket_fdset, incon: Socket_IP) {.importcpp: "#.setForSocket(#)".}

proc IsSetFor*(this: Socket_fdset, incon: Socket_IP): bool {.importcpp: "#.IsSetFor(#)".} ## \
## check to see if a socket object has been marked for reading

proc WaitForRead*(this: Socket_fdset, zeroFds: bool, sleep_time: int): int {.importcpp: "#.WaitForRead(#, #)".}

proc WaitForRead*(this: Socket_fdset, zeroFds: bool): int {.importcpp: "#.WaitForRead(#)".}

proc WaitForWrite*(this: Socket_fdset, zeroFds: bool, sleep_time: int): int {.importcpp: "#.WaitForWrite(#, #)".} ## \
## This is the function that will wait till one of the sockets is ready for
## writing

proc WaitForWrite*(this: Socket_fdset, zeroFds: bool): int {.importcpp: "#.WaitForWrite(#)".} ## \
## This is the function that will wait till one of the sockets is ready for
## writing

proc WaitForError*(this: Socket_fdset, zeroFds: bool, sleep_time: int): int {.importcpp: "#.WaitForError(#, #)".} ## \
## This is the function that will wait till one of the sockets is in error
## state

proc WaitForError*(this: Socket_fdset, zeroFds: bool): int {.importcpp: "#.WaitForError(#)".} ## \
## This is the function that will wait till one of the sockets is in error
## state

proc clear*(this: Socket_fdset) {.importcpp: "#.clear()".} ## \
## Marks the content as empty

proc GetMessage*(this: Buffered_DatagramConnection, val: Datagram): bool {.importcpp: "#.GetMessage(#)".} ## \
## Reads a message.  Returns false on failure.

proc DoConnect*(this: Buffered_DatagramConnection): bool {.importcpp: "#.DoConnect()".} ## \
## all the real state magic is in here

proc IsConnected*(this: Buffered_DatagramConnection): bool {.importcpp: "#.IsConnected()".} ## \
## all the real state magic is in here

proc initBuffered_DatagramConnection*(rbufsize: int, wbufsize: int, write_flush_point: int): Buffered_DatagramConnection {.importcpp: "Buffered_DatagramConnection(#, #, #)".}

proc SendMessage*(this: Buffered_DatagramConnection, msg: Datagram): bool {.importcpp: "#.SendMessage(#)".} ## \
## the reason thsi all exists

proc Flush*(this: Buffered_DatagramConnection): bool {.importcpp: "#.Flush()".} ## \
## Flush all writes.

proc Reset*(this: Buffered_DatagramConnection) {.importcpp: "#.Reset()".} ## \
## Reset

proc WaitForNetworkReadEvent*(this: Buffered_DatagramConnection, MaxTime: float32) {.importcpp: "#.WaitForNetworkReadEvent(#)".}

proc AddressQueueSize*(this: Buffered_DatagramConnection): clonglong {.importcpp: "#.AddressQueueSize()".} ## \
## address queue stuff

proc AddAddress*(this: Buffered_DatagramConnection, inadr: Socket_Address) {.importcpp: "#.AddAddress(#)".} ## \
## must be called to set value to the server

proc ClearAddresses*(this: Buffered_DatagramConnection) {.importcpp: "#.ClearAddresses()".}

proc get_class_type*(_: typedesc[Buffered_DatagramConnection]): TypeHandle {.importcpp: "Buffered_DatagramConnection::get_class_type()", header: "buffered_DatagramConnection.h".}

proc initSocket_UDP*(): Socket_UDP {.importcpp: "Socket_UDP()".}

proc InitToAddress*(this: Socket_UDP, address: Socket_Address): bool {.importcpp: "#.InitToAddress(#)".} ## \
## Connects the socket to a Specified address

proc Send*(this: Socket_UDP, data: string): bool {.importcpp: "#.Send(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Send data to connected address

proc SendTo*(this: Socket_UDP, data: string, address: Socket_Address): bool {.importcpp: "#.SendTo(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Send data to specified address

proc SetToBroadCast*(this: Socket_UDP): bool {.importcpp: "#.SetToBroadCast()".} ## \
## Ask the OS to let us receive broadcast packets on this port.

proc get_class_type*(_: typedesc[Socket_UDP]): TypeHandle {.importcpp: "Socket_UDP::get_class_type()", header: "socket_UDP.h".}

proc SetCondenseWhiteSpace*(_: typedesc[TiXmlBase], condense: bool) {.importcpp: "TiXmlBase::SetCondenseWhiteSpace(#)", header: "tiXmlBase.h".} ## \
## The world does not agree on whether white space should be kept or
## not. In order to make everyone happy, these global, static functions
## are provided to set whether or not TinyXml will condense all white space
## into a single space or not. The default is to condense. Note changing this
## value is not thread safe.

proc IsWhiteSpaceCondensed*(_: typedesc[TiXmlBase]): bool {.importcpp: "TiXmlBase::IsWhiteSpaceCondensed()", header: "tiXmlBase.h".} ## \
## Return the current white space setting.

proc Row*(this: TiXmlBase): int {.importcpp: "#.Row()".} ## \
## Return the position, in the original source file, of this node or attribute.
## The row and column are 1-based. (That is the first row and first column is
## 1,1). If the returns values are 0 or less, then the parser does not have
## a row and column value.
##
## Generally, the row and column value will be set when the TiXmlDocument::Load(),
## TiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set
## when the DOM was created from operator>>.
##
## The values reflect the initial load. Once the DOM is modified programmatically
## (by adding or changing nodes and attributes) the new values will NOT update to
## reflect changes in the document.
##
## There is a minor performance cost to computing the row and column. Computation
## can be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.
##
## @sa TiXmlDocument::SetTabSize()

proc Column*(this: TiXmlBase): int {.importcpp: "#.Column()".} ## \
## < See Row()

proc GetUserData*(this: TiXmlBase) {.importcpp: "#.GetUserData()".} ## \
## < Get a pointer to arbitrary user data.

proc Value*(this: TiXmlNode): string {.importcpp: "nimStringFromStdString(#.Value())", header: stringConversionCode.} ## \
## The meaning of 'value' changes for the specific type of
## TiXmlNode.
## @verbatim
## Document:   filename of the xml file
## Element:    name of the element
## Comment:    the comment text
## Unknown:    the tag contents
## Text:       the text string
## @endverbatim
##
## The subclasses will wrap this function.

proc ValueStr*(this: TiXmlNode): string {.importcpp: "nimStringFromStdString(#.ValueStr())", header: stringConversionCode.} ## \
## Return Value() as a std::string. If you only use STL,
## this is more efficient than calling Value().
## Only available in STL mode.

proc ValueTStr*(this: TiXmlNode): string {.importcpp: "nimStringFromStdString(#.ValueTStr())", header: stringConversionCode.}

proc Clear*(this: TiXmlNode) {.importcpp: "#.Clear()".} ## \
## Delete all the children of this node. Does not affect 'this'.

proc Parent*(this: TiXmlNode): TiXmlNode {.importcpp: "#.Parent()".} ## \
## One step up the DOM.

proc FirstChild*(this: TiXmlNode): TiXmlNode {.importcpp: "#.FirstChild()".} ## \
## < The first child of this node. Will be null if there are no children.

proc LastChild*(this: TiXmlNode): TiXmlNode {.importcpp: "#.LastChild()".} ## \
## The last child of this node. Will be null if there are no children.

proc IterateChildren*(this: TiXmlNode, previous: TiXmlNode): TiXmlNode {.importcpp: "#.IterateChildren(#)".}

proc InsertEndChild*(this: TiXmlNode, addThis: TiXmlNode): TiXmlNode {.importcpp: "#.InsertEndChild(#)".} ## \
## Add a new node related to this. Adds a child past the LastChild.
## Returns a pointer to the new object or NULL if an error occured.

proc InsertBeforeChild*(this: TiXmlNode, beforeThis: TiXmlNode, addThis: TiXmlNode): TiXmlNode {.importcpp: "#.InsertBeforeChild(#, #)".} ## \
## Add a new node related to this. Adds a child before the specified child.
## Returns a pointer to the new object or NULL if an error occured.

proc InsertAfterChild*(this: TiXmlNode, afterThis: TiXmlNode, addThis: TiXmlNode): TiXmlNode {.importcpp: "#.InsertAfterChild(#, #)".} ## \
## Add a new node related to this. Adds a child after the specified child.
## Returns a pointer to the new object or NULL if an error occured.

proc ReplaceChild*(this: TiXmlNode, replaceThis: TiXmlNode, withThis: TiXmlNode): TiXmlNode {.importcpp: "#.ReplaceChild(#, #)".} ## \
## Replace a child of this node.
## Returns a pointer to the new object or NULL if an error occured.

proc RemoveChild*(this: TiXmlNode, removeThis: TiXmlNode): bool {.importcpp: "#.RemoveChild(#)".} ## \
## Delete a child of this node.

proc PreviousSibling*(this: TiXmlNode): TiXmlNode {.importcpp: "#.PreviousSibling()".}

proc NextSibling*(this: TiXmlNode): TiXmlNode {.importcpp: "#.NextSibling()".}

proc NextSiblingElement*(this: TiXmlNode): TiXmlElement {.importcpp: "#.NextSiblingElement()".}

proc FirstChildElement*(this: TiXmlNode): TiXmlElement {.importcpp: "#.FirstChildElement()".}

proc Type*(this: TiXmlNode): int {.importcpp: "#.Type()".} ## \
## Query the type (as an enumerated value, above) of this node.
## The possible types are: DOCUMENT, ELEMENT, COMMENT,
## UNKNOWN, TEXT, and DECLARATION.

proc GetDocument*(this: TiXmlNode): TiXmlDocument {.importcpp: "#.GetDocument()".}

proc NoChildren*(this: TiXmlNode): bool {.importcpp: "#.NoChildren()".} ## \
## Returns true if this node has no children.

proc ToDocument*(this: TiXmlNode): TiXmlDocument {.importcpp: "#.ToDocument()".} ## \
## < Cast to a more defined type. Will return null if not of the requested type.

proc ToElement*(this: TiXmlNode): TiXmlElement {.importcpp: "#.ToElement()".} ## \
## < Cast to a more defined type. Will return null if not of the requested type.

proc ToComment*(this: TiXmlNode): TiXmlComment {.importcpp: "#.ToComment()".} ## \
## < Cast to a more defined type. Will return null if not of the requested type.

proc ToUnknown*(this: TiXmlNode): TiXmlUnknown {.importcpp: "#.ToUnknown()".} ## \
## < Cast to a more defined type. Will return null if not of the requested type.

proc ToText*(this: TiXmlNode): TiXmlText {.importcpp: "#.ToText()".} ## \
## < Cast to a more defined type. Will return null if not of the requested type.

proc ToDeclaration*(this: TiXmlNode): TiXmlDeclaration {.importcpp: "#.ToDeclaration()".} ## \
## < Cast to a more defined type. Will return null if not of the requested type.

proc Clone*(this: TiXmlNode): TiXmlNode {.importcpp: "#.Clone()".} ## \
## Create an exact duplicate of this node and return it. The memory must be deleted
## by the caller.

proc Accept*(this: TiXmlNode, visitor: TiXmlVisitor): bool {.importcpp: "#.Accept(#)".} ## \
## Accept a hierchical visit the nodes in the TinyXML DOM. Every node in the
## XML tree will be conditionally visited and the host will be called back
## via the TiXmlVisitor interface.
##
## This is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse
## the XML for the callbacks, so the performance of TinyXML is unchanged by using this
## interface versus any other.)
##
## The interface has been based on ideas from:
##
## - http://www.saxproject.org/
## - http://c2.com/cgi/wiki?HierarchicalVisitorPattern
##
## Which are both good references for "visiting".
##
## An example of using Accept():
## @verbatim
## TiXmlPrinter printer;
## tinyxmlDoc.Accept( &printer );
## const char* xmlcstr = printer.CStr();
## @endverbatim

proc initTiXmlDeclaration*(): TiXmlDeclaration {.importcpp: "TiXmlDeclaration()".} ## \
## Construct an empty declaration.

proc initTiXmlDeclaration*(copy: TiXmlDeclaration): TiXmlDeclaration {.importcpp: "TiXmlDeclaration(#)".}

proc Version*(this: TiXmlDeclaration): string {.importcpp: "nimStringFromStdString(#.Version())", header: stringConversionCode.} ## \
## Version. Will return an empty string if none was found.

proc Encoding*(this: TiXmlDeclaration): string {.importcpp: "nimStringFromStdString(#.Encoding())", header: stringConversionCode.} ## \
## Encoding. Will return an empty string if none was found.

proc Standalone*(this: TiXmlDeclaration): string {.importcpp: "nimStringFromStdString(#.Standalone())", header: stringConversionCode.} ## \
## Is this a standalone document?

proc initTiXmlDocument*(): TiXmlDocument {.importcpp: "TiXmlDocument()".} ## \
## Create an empty document, that has no name.

proc initTiXmlDocument*(copy: TiXmlDocument): TiXmlDocument {.importcpp: "TiXmlDocument(#)".}

proc initTiXmlDocument*(documentName: string): TiXmlDocument {.importcpp: "TiXmlDocument(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Create a document with a name. The name of the document is also the filename of the xml.

proc LoadFile*(this: TiXmlDocument, encoding: TiXmlEncoding): bool {.importcpp: "#.LoadFile(#)".} ## \
## Load a file using the current document value.
## Returns true if successful. Will delete any existing
## document data before loading.

proc LoadFile*(this: TiXmlDocument): bool {.importcpp: "#.LoadFile()".} ## \
## Load a file using the current document value.
## Returns true if successful. Will delete any existing
## document data before loading.

proc LoadFile*(this: TiXmlDocument, filename: string, encoding: TiXmlEncoding): bool {.importcpp: "#.LoadFile(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Load a file using the given filename. Returns true if successful.

proc LoadFile*(this: TiXmlDocument, filename: string): bool {.importcpp: "#.LoadFile(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Load a file using the given filename. Returns true if successful.

proc SaveFile*(this: TiXmlDocument): bool {.importcpp: "#.SaveFile()".} ## \
## Save a file using the current document value. Returns true if successful.

proc SaveFile*(this: TiXmlDocument, filename: string): bool {.importcpp: "#.SaveFile(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Save a file using the given filename. Returns true if successful.

proc RootElement*(this: TiXmlDocument): TiXmlElement {.importcpp: "#.RootElement()".}

proc Error*(this: TiXmlDocument): bool {.importcpp: "#.Error()".} ## \
## If an error occurs, Error will be set to true. Also,
## - The ErrorId() will contain the integer identifier of the error (not generally useful)
## - The ErrorDesc() method will return the name of the error. (very useful)
## - The ErrorRow() and ErrorCol() will return the location of the error (if known)

proc ErrorDesc*(this: TiXmlDocument): string {.importcpp: "nimStringFromStdString(#.ErrorDesc())", header: stringConversionCode.} ## \
## Contains a textual (english) description of the error if one occurs.

proc ErrorId*(this: TiXmlDocument): int {.importcpp: "#.ErrorId()".} ## \
## Generally, you probably want the error string ( ErrorDesc() ). But if you
## prefer the ErrorId, this function will fetch it.

proc ErrorRow*(this: TiXmlDocument): int {.importcpp: "#.ErrorRow()".} ## \
## Returns the location (if known) of the error. The first column is column 1,
## and the first row is row 1. A value of 0 means the row and column wasn't applicable
## (memory errors, for example, have no row/column) or the parser lost the error. (An
## error in the error reporting, in that case.)
##
## @sa SetTabSize, Row, Column

proc ErrorCol*(this: TiXmlDocument): int {.importcpp: "#.ErrorCol()".} ## \
## < The column where the error occured. See ErrorRow()

proc TabSize*(this: TiXmlDocument): int {.importcpp: "#.TabSize()".}

proc ClearError*(this: TiXmlDocument) {.importcpp: "#.ClearError()".} ## \
## If you have handled the error, it can be reset with this call. The error
## state is automatically cleared if you Parse a new XML block.

proc Print*(this: TiXmlDocument) {.importcpp: "#.Print()".} ## \
## Write the document to standard out using formatted printing ("pretty print"). */

proc initTiXmlElement*(param0: TiXmlElement): TiXmlElement {.importcpp: "TiXmlElement(#)".}

proc initTiXmlElement*(in_value: string): TiXmlElement {.importcpp: "TiXmlElement(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Construct an element.

proc Attribute*(this: TiXmlElement, name: string): string {.importcpp: "nimStringFromStdString(#.Attribute(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Given an attribute name, Attribute() returns the value
## for the attribute of that name, or null if none exists.

proc SetAttribute*(this: TiXmlElement, name: string, value: int) {.importcpp: "#.SetAttribute(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Sets an attribute of name to a given value. The attribute
## will be created if it does not exist, or changed if it does.

proc SetDoubleAttribute*(this: TiXmlElement, name: string, value: float64) {.importcpp: "#.SetDoubleAttribute(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Sets an attribute of name to a given value. The attribute
## will be created if it does not exist, or changed if it does.

proc RemoveAttribute*(this: TiXmlElement, name: string) {.importcpp: "#.RemoveAttribute(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Deletes an attribute with the given name.

proc FirstAttribute*(this: TiXmlElement): TiXmlAttribute {.importcpp: "#.FirstAttribute()".} ## \
## < Access the first attribute in this element.

proc LastAttribute*(this: TiXmlElement): TiXmlAttribute {.importcpp: "#.LastAttribute()".} ## \
## < Access the last attribute in this element.

proc GetText*(this: TiXmlElement): string {.importcpp: "nimStringFromStdString(#.GetText())", header: stringConversionCode.} ## \
## Convenience function for easy access to the text inside an element. Although easy
## and concise, GetText() is limited compared to getting the TiXmlText child
## and accessing it directly.
##
## If the first child of 'this' is a TiXmlText, the GetText()
## returns the character string of the Text node, else null is returned.
##
## This is a convenient method for getting the text of simple contained text:
## @verbatim
## <foo>This is text</foo>
## const char* str = fooElement->GetText();
## @endverbatim
##
## 'str' will be a pointer to "This is text".
##
## Note that this function can be misleading. If the element foo was created from
## this XML:
## @verbatim
## <foo><b>This is text</b></foo>
## @endverbatim
##
## then the value of str would be null. The first child node isn't a text node, it is
## another element. From this XML:
## @verbatim
## <foo>This is <b>text</b></foo>
## @endverbatim
## GetText() will return "This is ".
##
## WARNING: GetText() accesses a child node - don't become confused with the
## similarly named TiXmlHandle::Text() and TiXmlNode::ToText() which are
## safe type casts on the referenced node.

proc read_xml_stream*(`in`: istream): TiXmlDocument {.importcpp: "read_xml_stream(#)".} ## \
## Reads an XML document from the indicated stream.
## @returns the document, or NULL on error.

proc write_xml_stream*(`out`: ostream, doc: TiXmlDocument) {.importcpp: "write_xml_stream(#, #)".}

proc print_xml*(xnode: TiXmlNode) {.importcpp: "print_xml(#)".}

proc print_xml_to_file*(filename: Filename, xnode: TiXmlNode) {.importcpp: "print_xml_to_file(#, #)".}

proc get_TIXML_MAJOR_VERSION*(): int {.importcpp: "get_TIXML_MAJOR_VERSION()".}

proc get_TIXML_MINOR_VERSION*(): int {.importcpp: "get_TIXML_MINOR_VERSION()".}

proc get_TIXML_PATCH_VERSION*(): int {.importcpp: "get_TIXML_PATCH_VERSION()".}

proc initTiXmlCursor*(param0: TiXmlCursor): TiXmlCursor {.importcpp: "TiXmlCursor(#)".}

proc VisitEnter*(this: TiXmlVisitor, param0: TiXmlDocument): bool {.importcpp: "#.VisitEnter(#)".} ## \
## doc*/

proc VisitEnter*(this: TiXmlVisitor, param0: TiXmlElement, param1: TiXmlAttribute): bool {.importcpp: "#.VisitEnter(#, #)".} ## \
## firstAttribute*/

proc VisitExit*(this: TiXmlVisitor, param0: TiXmlDocument): bool {.importcpp: "#.VisitExit(#)".} ## \
## doc*/

proc VisitExit*(this: TiXmlVisitor, param0: TiXmlElement): bool {.importcpp: "#.VisitExit(#)".} ## \
## element*/

proc Visit*(this: TiXmlVisitor, param0: TiXmlComment): bool {.importcpp: "#.Visit(#)".} ## \
## comment*/

proc Visit*(this: TiXmlVisitor, param0: TiXmlDeclaration): bool {.importcpp: "#.Visit(#)".} ## \
## declaration*/

proc Visit*(this: TiXmlVisitor, param0: TiXmlText): bool {.importcpp: "#.Visit(#)".} ## \
## text*/

proc Visit*(this: TiXmlVisitor, param0: TiXmlUnknown): bool {.importcpp: "#.Visit(#)".} ## \
## unknown*/

proc initTiXmlVisitor*(): TiXmlVisitor {.importcpp: "TiXmlVisitor()".}

proc initTiXmlVisitor*(param0: TiXmlVisitor): TiXmlVisitor {.importcpp: "TiXmlVisitor(#)".}

proc get_TIXML_DEFAULT_ENCODING*(): TiXmlEncoding {.importcpp: "get_TIXML_DEFAULT_ENCODING()".}

proc initTiXmlAttribute*(): TiXmlAttribute {.importcpp: "TiXmlAttribute()".} ## \
## Construct an empty attribute.

proc Name*(this: TiXmlAttribute): string {.importcpp: "nimStringFromStdString(#.Name())", header: stringConversionCode.} ## \
## < Return the name of this attribute.

proc Value*(this: TiXmlAttribute): string {.importcpp: "nimStringFromStdString(#.Value())", header: stringConversionCode.} ## \
## < Return the value of this attribute.

proc ValueStr*(this: TiXmlAttribute): string {.importcpp: "nimStringFromStdString(#.ValueStr())", header: stringConversionCode.} ## \
## < Return the value of this attribute.

proc IntValue*(this: TiXmlAttribute): int {.importcpp: "#.IntValue()".} ## \
## < Return the value of this attribute, converted to an integer.

proc DoubleValue*(this: TiXmlAttribute): float64 {.importcpp: "#.DoubleValue()".} ## \
## < Return the value of this attribute, converted to a double.

proc NameTStr*(this: TiXmlAttribute): string {.importcpp: "nimStringFromStdString(#.NameTStr())", header: stringConversionCode.} ## \
## Get the tinyxml string representation

proc Next*(this: TiXmlAttribute): TiXmlAttribute {.importcpp: "#.Next()".}

proc Previous*(this: TiXmlAttribute): TiXmlAttribute {.importcpp: "#.Previous()".}

proc `==`*(this: TiXmlAttribute, rhs: TiXmlAttribute): bool {.importcpp: "#.operator ==(#)".}

proc `<`*(this: TiXmlAttribute, rhs: TiXmlAttribute): bool {.importcpp: "#.operator <(#)".}

proc `>`*(this: TiXmlAttribute, rhs: TiXmlAttribute): bool {.importcpp: "#.operator >(#)".}

proc SetDocument*(this: TiXmlAttribute, doc: TiXmlDocument) {.importcpp: "#.SetDocument(#)".} ## \
## [internal use]
## Set the document pointer so the attribute can report errors.

proc initTiXmlAttributeSet*(): TiXmlAttributeSet {.importcpp: "TiXmlAttributeSet()".}

proc Add*(this: TiXmlAttributeSet, attribute: TiXmlAttribute) {.importcpp: "#.Add(#)".}

proc Remove*(this: TiXmlAttributeSet, attribute: TiXmlAttribute) {.importcpp: "#.Remove(#)".}

proc First*(this: TiXmlAttributeSet): TiXmlAttribute {.importcpp: "#.First()".}

proc Last*(this: TiXmlAttributeSet): TiXmlAttribute {.importcpp: "#.Last()".}

proc initTiXmlComment*(): TiXmlComment {.importcpp: "TiXmlComment()".} ## \
## Constructs an empty comment.

proc initTiXmlComment*(param0: TiXmlComment): TiXmlComment {.importcpp: "TiXmlComment(#)".}

proc initTiXmlText*(copy: TiXmlText): TiXmlText {.importcpp: "TiXmlText(#)".}

proc initTiXmlText*(initValue: string): TiXmlText {.importcpp: "TiXmlText(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Constructor for text element. By default, it is treated as
## normal, encoded text. If you want it be output as a CDATA text
## element, set the parameter _cdata to 'true'

proc CDATA*(this: TiXmlText): bool {.importcpp: "#.CDATA()".} ## \
## Queries whether this represents text using a CDATA section.

proc initTiXmlUnknown*(): TiXmlUnknown {.importcpp: "TiXmlUnknown()".}

proc initTiXmlUnknown*(copy: TiXmlUnknown): TiXmlUnknown {.importcpp: "TiXmlUnknown(#)".}

proc initTiXmlHandle*(`ref`: TiXmlHandle): TiXmlHandle {.importcpp: "TiXmlHandle(#)".} ## \
## Copy constructor

proc FirstChild*(this: TiXmlHandle): TiXmlHandle {.importcpp: "#.FirstChild()".} ## \
## Return a handle to the first child node.

proc FirstChild*(this: TiXmlHandle, value: string): TiXmlHandle {.importcpp: "#.FirstChild(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Return a handle to the first child node with the given name.

proc FirstChildElement*(this: TiXmlHandle): TiXmlHandle {.importcpp: "#.FirstChildElement()".} ## \
## Return a handle to the first child element.

proc FirstChildElement*(this: TiXmlHandle, value: string): TiXmlHandle {.importcpp: "#.FirstChildElement(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Return a handle to the first child element with the given name.

proc Child*(this: TiXmlHandle, value: string, index: int): TiXmlHandle {.importcpp: "#.Child(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Return a handle to the "index" child with the given name.
## The first child is 0, the second 1, etc.

proc Child*(this: TiXmlHandle, index: int): TiXmlHandle {.importcpp: "#.Child(#)".} ## \
## Return a handle to the "index" child.
## The first child is 0, the second 1, etc.

proc ChildElement*(this: TiXmlHandle, value: string, index: int): TiXmlHandle {.importcpp: "#.ChildElement(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Return a handle to the "index" child element with the given name.
## The first child element is 0, the second 1, etc. Note that only TiXmlElements
## are indexed: other types are not counted.

proc ChildElement*(this: TiXmlHandle, index: int): TiXmlHandle {.importcpp: "#.ChildElement(#)".} ## \
## Return a handle to the "index" child element.
## The first child element is 0, the second 1, etc. Note that only TiXmlElements
## are indexed: other types are not counted.

proc ToNode*(this: TiXmlHandle): TiXmlNode {.importcpp: "#.ToNode()".} ## \
## Return the handle as a TiXmlNode. This may return null.

proc ToElement*(this: TiXmlHandle): TiXmlElement {.importcpp: "#.ToElement()".} ## \
## Return the handle as a TiXmlElement. This may return null.

proc ToText*(this: TiXmlHandle): TiXmlText {.importcpp: "#.ToText()".} ## \
## Return the handle as a TiXmlText. This may return null.

proc ToUnknown*(this: TiXmlHandle): TiXmlUnknown {.importcpp: "#.ToUnknown()".} ## \
## Return the handle as a TiXmlUnknown. This may return null.

proc Node*(this: TiXmlHandle): TiXmlNode {.importcpp: "#.Node()".} ## \
## @deprecated use ToNode.
## Return the handle as a TiXmlNode. This may return null.

proc Element*(this: TiXmlHandle): TiXmlElement {.importcpp: "#.Element()".} ## \
## @deprecated use ToElement.
## Return the handle as a TiXmlElement. This may return null.

proc Text*(this: TiXmlHandle): TiXmlText {.importcpp: "#.Text()".} ## \
## @deprecated use ToText()
## Return the handle as a TiXmlText. This may return null.

proc Unknown*(this: TiXmlHandle): TiXmlUnknown {.importcpp: "#.Unknown()".} ## \
## @deprecated use ToUnknown()
## Return the handle as a TiXmlUnknown. This may return null.

proc initTiXmlPrinter*(): TiXmlPrinter {.importcpp: "TiXmlPrinter()".}

proc initTiXmlPrinter*(param0: TiXmlPrinter): TiXmlPrinter {.importcpp: "TiXmlPrinter(#)".}

proc Indent*(this: TiXmlPrinter): string {.importcpp: "nimStringFromStdString(#.Indent())", header: stringConversionCode.} ## \
## Query the indention string.

proc LineBreak*(this: TiXmlPrinter): string {.importcpp: "nimStringFromStdString(#.LineBreak())", header: stringConversionCode.} ## \
## Query the current line breaking string.

proc SetStreamPrinting*(this: TiXmlPrinter) {.importcpp: "#.SetStreamPrinting()".} ## \
## Switch over to "stream printing" which is the most dense formatting without
## linebreaks. Common when the XML is needed for network transmission.

proc CStr*(this: TiXmlPrinter): string {.importcpp: "nimStringFromStdString(#.CStr())", header: stringConversionCode.} ## \
## Return the result.

proc Size*(this: TiXmlPrinter): clonglong {.importcpp: "#.Size()".} ## \
## Return the length of the result string.

proc Str*(this: TiXmlPrinter): string {.importcpp: "nimStringFromStdString(#.Str())", header: stringConversionCode.} ## \
## Return the result.

proc set_point_size*(this: FreetypeFont, point_size: float32): bool {.importcpp: "#.set_point_size(#)".} ## \
## Sets the point size of the font.  This controls the apparent size of the
## font onscreen.  By convention, a 10 point font is about 1 screen unit high.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

proc get_point_size*(this: FreetypeFont): float32 {.importcpp: "#.get_point_size()".} ## \
## Returns the point size of the font.

proc set_pixels_per_unit*(this: FreetypeFont, pixels_per_unit: float32): bool {.importcpp: "#.set_pixels_per_unit(#)".} ## \
## Set the resolution of the texture map, and hence the clarity of the
## resulting font.  This sets the number of pixels in the texture map that are
## used for each onscreen unit.
##
## Setting this number larger results in an easier to read font, but at the
## cost of more texture memory.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

proc get_pixels_per_unit*(this: FreetypeFont): float32 {.importcpp: "#.get_pixels_per_unit()".} ## \
## Returns the resolution of the texture map.  See set_pixels_per_unit().

proc set_pixel_size*(this: FreetypeFont, pixel_size: float32): bool {.importcpp: "#.set_pixel_size(#)".} ## \
## Computes the appropriate pixels_per_unit value to set the size of the font
## in the texture to the indicated number of pixels.  This is just another way
## to specify pixels_per_unit().

proc get_pixel_size*(this: FreetypeFont): float32 {.importcpp: "#.get_pixel_size()".} ## \
## Returns the size of the font in pixels, as it appears in the texture.

proc set_scale_factor*(this: FreetypeFont, scale_factor: float32): bool {.importcpp: "#.set_scale_factor(#)".} ## \
## Sets the factor by which the font is rendered larger by the FreeType
## library before being filtered down to its actual size in the texture as
## specified by set_pixels_per_unit().  This may be set to a number larger
## than 1.0 to improve the font's antialiasing (since FreeType doesn't really
## do a swell job of antialiasing by itself).  There is some performance
## implication for setting this different than 1.0.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

proc get_scale_factor*(this: FreetypeFont): float32 {.importcpp: "#.get_scale_factor()".} ## \
## Returns the antialiasing scale factor.  See set_scale_factor().

proc set_native_antialias*(this: FreetypeFont, native_antialias: bool) {.importcpp: "#.set_native_antialias(#)".} ## \
## Sets whether the Freetype library's built-in antialias mode is enabled.
## There are two unrelated ways to achieve antialiasing: with Freetype's
## native antialias mode, and with the use of a scale_factor greater than one.
## By default, both modes are enabled.
##
## At low resolutions, some fonts may do better with one mode or the other.
## In general, Freetype's native antialiasing will produce less blurry
## results, but may introduce more artifacts.

proc get_native_antialias*(this: FreetypeFont): bool {.importcpp: "#.get_native_antialias()".} ## \
## Returns whether Freetype's built-in antialias mode is enabled.  See
## set_native_antialias().

proc get_font_pixel_size*(this: FreetypeFont): int {.importcpp: "#.get_font_pixel_size()".} ## \
## This is used to report whether the requested pixel size is being only
## approximated by a fixed-pixel-size font.  This returns 0 in the normal
## case, in which a scalable font is used, or the fixed-pixel-size font has
## exactly the requested pixel size.
##
## If this returns non-zero, it is the pixel size of the font that we are
## using to approximate our desired size.

proc get_line_height*(this: FreetypeFont): float32 {.importcpp: "#.get_line_height()".} ## \
## Returns the number of units high each line of text is.

proc get_space_advance*(this: FreetypeFont): float32 {.importcpp: "#.get_space_advance()".} ## \
## Returns the number of units wide a space is.

proc get_points_per_unit*(_: typedesc[FreetypeFont]): float32 {.importcpp: "FreetypeFont::get_points_per_unit()", header: "freetypeFont.h".} ## \
## Returns the point size of the font that is one Panda unit high.  This is an
## arbitrary Panda convention for text, and is set to 10.0.

proc get_points_per_inch*(_: typedesc[FreetypeFont]): float32 {.importcpp: "FreetypeFont::get_points_per_inch()", header: "freetypeFont.h".} ## \
## Returns the number of points in one inch.  This is a universal typographic
## convention.

proc initPNMTextGlyph*(param0: PNMTextGlyph): PNMTextGlyph {.importcpp: "PNMTextGlyph(#)".}

proc initPNMTextGlyph*(advance: float64): PNMTextGlyph {.importcpp: "PNMTextGlyph(#)".}

proc get_advance*(this: PNMTextGlyph): int {.importcpp: "#.get_advance()".} ## \
## Returns the number of pixels by which the pen should be advanced after
## rendering this glyph.

proc place*(this: PNMTextGlyph, dest_image: PNMImage, xp: int, yp: int, fg: LColor) {.importcpp: "#.place(#, #, #, #)".} ## \
## Copies the glyph to the indicated destination image at the indicated
## origin.  It colors the glyph pixels the indicated foreground color, blends
## antialiased pixels with the appropriate amount of the foreground color and
## the existing background color, and leaves other pixels alone.

proc place*(this: PNMTextGlyph, dest_image: PNMImage, xp: int, yp: int, fg: LColor, interior: LColor) {.importcpp: "#.place(#, #, #, #, #)".} ## \
## This flavor of place() also fills in the interior color.  This requires
## that determine_interior was called earlier.

proc get_left*(this: PNMTextGlyph): int {.importcpp: "#.get_left()".} ## \
## Returns the x coordinate of the leftmost pixel in the glyph.

proc get_right*(this: PNMTextGlyph): int {.importcpp: "#.get_right()".} ## \
## Returns the x coordinate of the rightmost pixel in the glyph.

proc get_bottom*(this: PNMTextGlyph): int {.importcpp: "#.get_bottom()".} ## \
## Returns the y coordinate of the bottommost pixel in the glyph.

proc get_top*(this: PNMTextGlyph): int {.importcpp: "#.get_top()".} ## \
## Returns the y coordinate of the topmost pixel in the glyph.

proc get_height*(this: PNMTextGlyph): int {.importcpp: "#.get_height()".} ## \
## Returns the height of the glyph in pixels.

proc get_width*(this: PNMTextGlyph): int {.importcpp: "#.get_width()".} ## \
## Returns the width of the glyph in pixels.

proc get_value*(this: PNMTextGlyph, x: int, y: int): float64 {.importcpp: "#.get_value(#, #)".} ## \
## Returns the value of the indicated pixel of the glyph.  The result is in
## the range [0, 1], where 0 indicates the pixel is not part of the glyph, and
## 1 indicates it is.  Intermediate values are used to represent antialiasing.

proc get_interior_flag*(this: PNMTextGlyph, x: int, y: int): bool {.importcpp: "#.get_interior_flag(#, #)".} ## \
## Returns true if the indicated pixel represents a pixel in the interior of a
## hollow font, false otherwise.

proc initPNMTextMaker*(font_filename: Filename, face_index: int): PNMTextMaker {.importcpp: "PNMTextMaker(#, #)".} ## \
## The constructor expects the name of some font file that FreeType can read,
## along with face_index, indicating which font within the file to load
## (usually 0).

proc initPNMTextMaker*(copy: FreetypeFont): PNMTextMaker {.importcpp: "PNMTextMaker(#)".}

proc initPNMTextMaker*(copy: PNMTextMaker): PNMTextMaker {.importcpp: "PNMTextMaker(#)".}

proc initPNMTextMaker*(font_data: string, data_length: int, face_index: int): PNMTextMaker {.importcpp: "PNMTextMaker(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## This constructor works as above, but it takes the font data from an in-
## memory buffer instead of from a named file.

proc is_valid*(this: PNMTextMaker): bool {.importcpp: "#.is_valid()".} ## \
## Returns true if the PNMTextMaker is valid and ready to generate text, false
## otherwise.

proc set_interior_flag*(this: PNMTextMaker, interior_flag: bool) {.importcpp: "#.set_interior_flag(#)".} ## \
## Sets the flag that indicates whether the interior of hollow fonts is
## identified as a preprocess as each glyph is loaded.  If this flag is true,
## you may specify an interior color along with a fg and bg color when you
## place text; if the flag is false, the interior color is ignored.
##
## It is generally best to set_native_antialias(0) when using this feature.
## Also, this works best when the pixel size is not very small.

proc get_interior_flag*(this: PNMTextMaker): bool {.importcpp: "#.get_interior_flag()".}

proc set_fg*(this: PNMTextMaker, fg: LColor) {.importcpp: "#.set_fg(#)".} ## \
## Sets the foreground color of text that will be generated by future calls to
## generate_into().  This is the color that all of the "on" pixels in the font
## will show as.

proc get_fg*(this: PNMTextMaker): LColor {.importcpp: "#.get_fg()".} ## \
## Returns the foreground color of text that will be generated by future calls
## to generate_into().

proc set_interior*(this: PNMTextMaker, interior: LColor) {.importcpp: "#.set_interior(#)".} ## \
## Sets the color that will be used to render the interior portions of hollow
## fonts in future calls to generate_into().  This is respected only if
## interior_flag is true.

proc get_interior*(this: PNMTextMaker): LColor {.importcpp: "#.get_interior()".} ## \
## Returns the color that will be used to render the interior portions of
## hollow fonts.

proc set_distance_field_radius*(this: PNMTextMaker, radius: int) {.importcpp: "#.set_distance_field_radius(#)".} ## \
## If this is set to something other than 0, Panda will generate a signed
## distance field with the given radius.

proc get_distance_field_radius*(this: PNMTextMaker): int {.importcpp: "#.get_distance_field_radius()".} ## \
## Returns the radius previously set with set_distance_field_radius, or 0
## otherwise.

proc generate_into*(this: PNMTextMaker, text: string, dest_image: PNMImage, x: int, y: int): int {.importcpp: "#.generate_into(nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Generates a single line of text into the indicated image at the indicated
## position; the return value is the total width in pixels.

proc calc_width*(this: PNMTextMaker, text: string): int {.importcpp: "#.calc_width(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the width in pixels of the indicated line of text.

proc get_glyph*(this: PNMTextMaker, character: int): PNMTextGlyph {.importcpp: "#.get_glyph(#)".} ## \
## Returns the glyph for the indicated index, or NULL if it is not defined in
## the font.


converter initFilename*(fn: string): Filename {.importcpp: "Filename(([](NimStringDesc *desc) {return std::string(desc->data, desc->len);})(#))".}

func time*(this: AsyncTask): float {.importcpp: "#->get_elapsed_time()".}
